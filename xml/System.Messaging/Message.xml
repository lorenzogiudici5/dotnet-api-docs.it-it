<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="452b72d229254f13a5d2827bfeca0ec97c6f6675" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30461095" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce accesso alle proprietà necessarie per definire un messaggio di Accodamento messaggi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la <xref:System.Messaging.Message> classe per leggere o ricevere messaggi da una coda o di un controllo accurato le proprietà del messaggio quando si invia un messaggio a una coda.  
  
 <xref:System.Messaging.MessageQueue> Usa il <xref:System.Messaging.Message> classe quando legge o riceve messaggi dalle code, perché sia il <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> e <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> metodi creano una nuova istanza del <xref:System.Messaging.Message> e impostare le proprietà dell'istanza. Il <xref:System.Messaging.Message> si applicano le proprietà di sola lettura della classe per il recupero di messaggi da una coda, mentre le proprietà di lettura/scrittura si applicano all'invio e recupero dei messaggi. Quando <xref:System.Messaging.MessageQueue> legge o riceve un messaggio da una coda, il relativo <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> proprietà determina quale proprietà del messaggio vengono recuperati.  
  
 Il <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Send%2A> metodo consente di specificare un tipo di oggetto per un messaggio inviato alla coda. È possibile utilizzare il <xref:System.Messaging.MessageQueue> dell'istanza <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà per specificare le impostazioni per i messaggi generici inviati alla coda. I tipi di impostazioni includono formattatore, etichetta, la crittografia e autenticazione. È inoltre possibile specificare valori per l'oggetto appropriato <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membri quando si coordina l'applicazione di messaggistica per rispondere a messaggi di riconoscimento e di report. Utilizzando un <xref:System.Messaging.Message> istanza l'invio di un messaggio alla coda offre la flessibilità necessaria per accedere e modificare molte di queste proprietà, per un singolo messaggio o in una base di messaggio per ogni messaggio. <xref:System.Messaging.Message> proprietà hanno la precedenza su <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 Messaggio vengono memorizzati nel <xref:System.Messaging.Message.Body%2A> proprietà e in misura minore, il <xref:System.Messaging.Message.AppSpecific%2A> e <xref:System.Messaging.Message.Extension%2A> proprietà. Quando dati del messaggio sono crittografati, serializzati o deserializzati, solo il contenuto del <xref:System.Messaging.Message.Body%2A> proprietà sono interessati.  
  
 Il contenuto del <xref:System.Messaging.Message.Body%2A> proprietà vengono serializzati quando viene inviato il messaggio, mediante il <xref:System.Messaging.Message.Formatter%2A> proprietà specificato. Il contenuto serializzato si trova nel <xref:System.Messaging.Message.BodyStream%2A> proprietà. È inoltre possibile impostare il <xref:System.Messaging.Message.BodyStream%2A> proprietà direttamente, ad esempio, per inviare un file come il contenuto dei dati di un messaggio. È possibile modificare il <xref:System.Messaging.Message.Body%2A> o <xref:System.Messaging.Message.Formatter%2A> proprietà in qualsiasi momento prima dell'invio del messaggio e i dati saranno serializzate in modo appropriato quando si chiama <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 Le proprietà definite per il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> proprietà si applica solo ai messaggi che non sono di tipo <xref:System.Messaging.Message>. Se si specifica il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà per un <xref:System.Messaging.MessageQueue>, lo stesso nome proprietà in un <xref:System.Messaging.Message> istanza ha inviato a tale coda prevalgono queste proprietà predefinite da ignorare.  
  
 Per un elenco di valori di proprietà iniziali per un'istanza di <xref:System.Messaging.Message>, vedere il <xref:System.Messaging.Message.%23ctor%2A> costruttore.  
  
   
  
## Examples  
 Esempio di codice seguente illustra la formattazione di un corpo del messaggio tramite <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Esempio di codice seguente illustra la formattazione di un corpo del messaggio tramite <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.Message" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.Message" /> con un corpo vuoto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare una nuova istanza di <xref:System.Messaging.Message> classe che ha un corpo vuoto.  
  
 Specificare il <xref:System.Messaging.Message.Body%2A> proprietà o <xref:System.Messaging.Message.BodyStream%2A> proprietà prima di inviare il <xref:System.Messaging.Message> oggetto. Il <xref:System.Messaging.Message.Body%2A> proprietà può essere qualsiasi oggetto che può essere serializzato, ad esempio una stringa di testo, un oggetto della struttura, un'istanza della classe o un oggetto incorporato.  
  
 A meno che non si scrive il contenuto del messaggio direttamente il <xref:System.Messaging.Message.BodyStream%2A> impostata, il <xref:System.Messaging.Message.Formatter%2A> proprietà prima di inviare il messaggio. Il corpo viene serializzato utilizzando il <xref:System.Messaging.Message.Formatter%2A> il valore della proprietà al momento il <xref:System.Messaging.MessageQueue.Send%2A> metodo viene chiamato sul <xref:System.Messaging.MessageQueue> istanza.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> ad accoppiamento ridotto, pertanto non è necessario avere lo stesso oggetto di tipo per il mittente e destinatario, quando si utilizza questo formato. Il <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializzare i dati in una rappresentazione binaria. Il <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato durante l'invio o la ricezione di componenti COM.  
  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Messaging.Message>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Enhanced Cryptographic Provider versione 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Esempio di codice seguente invia due messaggi con priorità diversa per la coda e successivamente recuperati.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Oggetto da serializzare nel corpo del messaggio.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.Message" /> utilizzando <see cref="T:System.Messaging.XmlMessageFormatter" /> per serializzare l'oggetto specificato nel corpo del messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare una nuova istanza del <xref:System.Messaging.Message> classe che contiene il <xref:System.Messaging.Message.Body%2A> specificato per il `body` parametro. Il `body` parametro può essere qualsiasi oggetto che può essere serializzato, ad esempio una stringa di testo, un oggetto della struttura, un'istanza della classe o un oggetto incorporato. Il corpo viene serializzato utilizzando il <xref:System.Messaging.XmlMessageFormatter> a meno che non si modifica il <xref:System.Messaging.Message.Formatter%2A> proprietà prima di <xref:System.Messaging.Message> viene inviato. Se si modifica il <xref:System.Messaging.Message.Body%2A> o <xref:System.Messaging.Message.Formatter%2A> proprietà in qualsiasi momento prima di chiamare <xref:System.Messaging.MessageQueue.Send%2A>, verrà serializzato il messaggio in base al nuovo valore della proprietà.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> ad accoppiamento ridotto, pertanto non è necessario avere lo stesso oggetto di tipo per il mittente e destinatario, quando si utilizza questo formato. Il <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializzare i dati in una rappresentazione binaria. Il <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato durante l'invio o la ricezione di componenti COM.  
  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Messaging.Message>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Enhanced Cryptographic Provider versione 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Parametro `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Esempio di codice seguente crea una nuova coda, invia un messaggio contenente un ordine e in seguito viene recuperato.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Oggetto da serializzare nel corpo del messaggio.</param>
        <param name="formatter">Oggetto <see cref="T:System.Messaging.IMessageFormatter" /> che specifica il formattatore da utilizzare per la serializzazione del corpo del messaggio.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.Message" /> utilizzando il formattatore specificato per serializzare l'oggetto specificato nel corpo del messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare una nuova istanza del <xref:System.Messaging.Message> classe che contiene il <xref:System.Messaging.Message.Body%2A> specificato da di `body` parametro e che utilizza un formattatore valido per serializzare il corpo. Il `body` parametro è un oggetto che può essere serializzato, ad esempio una stringa di testo, un oggetto della struttura, un'istanza della classe o un oggetto incorporato. Se si modifica il <xref:System.Messaging.Message.Body%2A> o <xref:System.Messaging.Message.Formatter%2A> proprietà in qualsiasi momento prima di chiamare <xref:System.Messaging.MessageQueue.Send%2A>, verrà serializzato il messaggio in base al nuovo valore della proprietà.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> ad accoppiamento ridotto, pertanto non è necessario avere lo stesso oggetto di tipo per il mittente e destinatario, quando si utilizza questo formato. Il <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializzare i dati in una rappresentazione binaria. Il <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato durante l'invio o la ricezione di componenti COM.  
  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Messaging.Message>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Enhanced Cryptographic Provider versione 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Parametro `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.Formatter%2A>|Parametro `formatter`.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo di messaggio di acknowledgment da restituire all'applicazione che esegue l'invio.</summary>
        <value>Uno dei valori <see cref="T:System.Messaging.AcknowledgeTypes" />, che rappresenta entrambi i tipi di messaggi di acknowledgment che il sistema invia alla coda amministrazione e le condizioni in cui tali messaggi vengono restituiti all'applicazione mittente. Il valore predefinito è <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà specifica il tipo di messaggi di riconoscimento richiesto dall'applicazione mittente. Impostare il <xref:System.Messaging.Message.AcknowledgeType%2A> prima di inviare il messaggio per richiedere la notifica di alcuni eventi, ad esempio, un messaggio ha raggiunto la coda di destinazione, il recupero di un messaggio o un timeout che impedisce che un messaggio di raggiungimento o il recupero da la coda di destinazione.  
  
 Accodamento messaggi restituisce notifica inviando messaggi di riconoscimento per il <xref:System.Messaging.Message.AdministrationQueue%2A> proprietà specificata dal messaggio originale. Un messaggio di riconoscimento <xref:System.Messaging.Message.Acknowledgment%2A> proprietà indica il tipo di riconoscimento che rappresenta. Ad esempio, se è stato inviato un messaggio di riconoscimento perché un messaggio non ha raggiunto la destinazione prima di <xref:System.Messaging.Message.TimeToReachQueue%2A> intervallo scaduto, il <xref:System.Messaging.Message.Acknowledgment%2A> può contenere il valore della proprietà del messaggio di riconoscimento `ReachQueueTimeout`.  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio contenente un ordine da e verso una coda. Richiede un riconoscimento positivo in particolare quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio viene filtrato in modo da ignorare la proprietà <see cref="P:System.Messaging.Message.AcknowledgeType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la classificazione dei messaggi di riconoscimento rappresentati da questo messaggio.</summary>
        <value>Uno dei valori dell'enumerazione <see cref="T:System.Messaging.Acknowledgment" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si riceve un messaggio da una coda di amministrazione, leggere la <xref:System.Messaging.Message.Acknowledgment%2A> proprietà per verificare lo stato del messaggio originale.  
  
 Quando un messaggio viene inviato alla coda di destinazione, Accodamento messaggi può essere richiesta per inviare un messaggio di riconoscimento. Tale messaggio può indicare, ad esempio, se il messaggio è arrivato ed è stato recuperato all'interno di timeout specificato, oppure può indicare la causa dell'errore nel caso di mancato recapito. La coda di destinazione restituisce messaggi di riconoscimento e li invia alla coda di amministrazione specificata del messaggio originale <xref:System.Messaging.Message.AdministrationQueue%2A> proprietà. Il <xref:System.Messaging.Message.Id%2A> proprietà di un messaggio di riconoscimento identifica il messaggio di riconoscimento, non l'originale. È possibile trovare l'identificatore del messaggio originale nel riconoscimento <xref:System.Messaging.Message> dell'istanza <xref:System.Messaging.Message.CorrelationId%2A> proprietà.  
  
 Se questo <xref:System.Messaging.Message> istanza rappresenta un messaggio di riconoscimento, di <xref:System.Messaging.Message.Acknowledgment%2A> proprietà specifica il tipo di riconoscimento. In caso contrario, il <xref:System.Messaging.Message.Acknowledgment%2A> proprietà contiene il valore `Normal`.  
  
 Utilizzare il <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà del messaggio originale per specificare le condizioni in cui verranno restituiti riconoscimenti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la coda che riceve i messaggi di riconoscimento generati da Accodamento messaggi.</summary>
        <value>La proprietà <see cref="T:System.Messaging.MessageQueue" /> che specifica la coda di amministrazione utilizzata per i messaggi di riconoscimento generati dal sistema. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La coda specificata nella <xref:System.Messaging.Message.AdministrationQueue%2A> proprietà può essere una coda non transazionale. I messaggi di riconoscimento inviati alla coda di amministrazione possono indicare se il messaggio originale ha raggiunto la coda di destinazione e se è stato rimosso dalla coda.  
  
 Quando il <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà ha un valore diverso da `None`, l'applicazione di invio è necessario specificare la coda da utilizzare come coda di amministrazione.  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio contenente un ordine da e verso una coda. Richiede un riconoscimento positivo in particolare quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.AdministrationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta informazioni aggiuntive specifiche di un'applicazione.</summary>
        <value>Informazioni specifiche dell'applicazione. Il valore predefinito è zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.AppSpecific%2A> proprietà contiene informazioni specifiche dell'applicazione che è possibile utilizzare per organizzare diversi tipi di messaggi. Ad esempio, è possibile utilizzare indici specifici dell'applicazione. È compito dell'applicazione per interpretare <xref:System.Messaging.Message.AppSpecific%2A> informazioni sulle proprietà.  
  
 Quando possibile, è necessario includere i dati del messaggio nel corpo del messaggio anziché <xref:System.Messaging.Message.AppSpecific%2A> proprietà.  
  
 Quando si utilizzano code esterne, utilizzare il <xref:System.Messaging.Message.Extension%2A> proprietà per specificare le proprietà di messaggio che non esistono in Accodamento messaggi. Come con la <xref:System.Messaging.Message.AppSpecific%2A> proprietà, è responsabilità dell'applicazione per comprendere il contenuto del <xref:System.Messaging.Message.Extension%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.AppSpecific" />.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'ora in cui il messaggio ha raggiunto la coda di destinazione.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> che rappresenta l'ora in cui il messaggio ha raggiunto la coda di destinazione. L'ora viene regolata da GMT sull'ora locale del computer sul quale si trova la coda di destinazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il messaggio <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà indica la velocità deve ricevere il messaggio dalla coda di destinazione. Il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà timer viene avviato quando viene inviato il messaggio, non quando il messaggio arriva nella coda.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.ArrivedTime%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.ArrivedTime" />.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'ID del mittente deve essere allegato al messaggio.</summary>
        <value>
          <see langword="true" /> se <see cref="P:System.Messaging.Message.SenderId" /> deve essere allegato al messaggio; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.SenderId%2A> proprietà è una matrice di byte che rappresenta l'identificatore del mittente. L'ID del mittente è impostata da Accodamento messaggi e viene utilizzato dal gestore code di destinazione per verificare se il mittente dispone dei diritti di accesso a una coda.  
  
 L'assenza dell'ID mittente un'indicazione dall'applicazione mittente che Accodamento messaggi deve convalidare il mittente del messaggio non verificare l'accesso del mittente diritti alla coda di ricezione. Il <xref:System.Messaging.Message.SenderId%2A> sia attendibile solo se il messaggio è stato autenticato quando ha raggiunto la coda di destinazione. Il messaggio viene rifiutato quando raggiunge la coda di destinazione se la coda accetta solo messaggi autenticati e il <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> o <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> proprietà `false`.  
  
> [!CAUTION]
>  Se un messaggio viene rifiutato, viene inviato alla coda di messaggi non recapitabili (se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è `true`), o viene ignorata. Quando un messaggio non riesce a raggiungere la coda, è possibile richiedere i riconoscimenti. In caso contrario, quando <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è `false` il messaggio potrebbe andare perso senza alcun avviso.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.AttachSenderId%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.AttachSenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il messaggio è stato autenticato.</summary>
        <value>
          <see langword="true" /> se era richiesta autenticazione del messaggio all'arrivo nella coda; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.Authenticated%2A> proprietà viene utilizzata solo dall'applicazione durante l'interazione con il messaggio e il tentativo di determinare se è stata richiesta l'autenticazione. Se il messaggio nella coda, il messaggio è stato autenticato. Viceversa, se il <xref:System.Messaging.Message.Authenticated%2A> proprietà `true`, il gestore delle code ricevente autenticato il messaggio quando il messaggio ricevuto.  
  
 È possibile determinare se un messaggio di autenticazione non riuscita per visualizzare le relative proprietà. Accodamento messaggi Elimina messaggi non autenticati prima che vengano recapitati alla coda. Tuttavia, è possibile richiedere che un messaggio di riconoscimento verrà inviato se un errore di recapito impedisce che il messaggio arriva nella coda.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.Authenticated%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.Authenticated" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del provider di crittografia utilizzato per generare la firma digitale del messaggio.</summary>
        <value>Nome del provider di crittografia utilizzato per generare la firma digitale del messaggio. Il valore predefinito è Microsoft Base Cryptographic Provider version 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere si usa il <xref:System.Messaging.Message.AuthenticationProviderName%2A> quando si utilizzano code esterne. Accodamento messaggi richiede il nome del provider di autenticazione e il tipo di provider di autenticazione del provider di crittografia (provider di autenticazione) per convalidare la firma digitale dei messaggi inviati a una coda esterna sia messaggi passati al messaggio Accodamento messaggi da una coda esterna.  
  
 Quando si invia un messaggio, impostare sempre la <xref:System.Messaging.Message.AuthenticationProviderName%2A> e <xref:System.Messaging.Message.ConnectorType%2A> insieme di proprietà. Quando il messaggio viene inviato, Accodamento messaggi ignora il nome del provider di autenticazione se non viene impostato anche il tipo di connettore.  
  
 Il <xref:System.Messaging.Message.AuthenticationProviderName%2A> proprietà non può essere `null`, ma può essere una stringa vuota ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossibile impostare la proprietà <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> è stato impostato su <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo di provider di crittografia utilizzato per generare la firma digitale del messaggio.</summary>
        <value>Uno dei valori di <see cref="T:System.Messaging.CryptographicProviderType" />. Il valore predefinito è <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere si usa il <xref:System.Messaging.Message.AuthenticationProviderType%2A> proprietà quando si utilizzano code esterne per specificare il servizio di crittografia associato a un messaggio. Accodamento messaggi richiede il nome del provider di autenticazione e il tipo di provider di autenticazione del provider di crittografia (provider di autenticazione) per convalidare la firma digitale dei messaggi inviati a una coda esterna sia messaggi passati al messaggio Accodamento messaggi da una coda esterna.  
  
 Solo `RsaFull` deve essere utilizzata con la messaggistica.  
  
 Quando si invia un messaggio, impostare sempre la <xref:System.Messaging.Message.AuthenticationProviderType%2A> e <xref:System.Messaging.Message.ConnectorType%2A> insieme di proprietà. Quando il messaggio viene inviato, Accodamento messaggi ignora il tipo di provider di autenticazione se non viene impostato anche il tipo di connettore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossibile impostare la proprietà <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il contenuto del messaggio.</summary>
        <value>Oggetto che specifica il contenuto del messaggio. L'oggetto può essere una stringa, una data, una valuta, un numero, una matrice di byte o qualsiasi oggetto gestito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il messaggio <xref:System.Messaging.Message.Body%2A> proprietà contiene in genere i dati associati con il messaggio. Anche se è anche possibile inviare i dati specifici dell'applicazione <xref:System.Messaging.Message.AppSpecific%2A> e <xref:System.Messaging.Message.Extension%2A> proprietà, è necessario includere dati del messaggio nel <xref:System.Messaging.Message.Body%2A> del messaggio laddove possibile. Solo il <xref:System.Messaging.Message.Body%2A> del contenuto della proprietà viene serializzato o crittografato.  
  
 Il <xref:System.Messaging.Message.Body%2A> proprietà può contenere qualsiasi oggetto le cui dimensioni non superiori a 4 MB. Se si utilizza <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> per inviare un oggetto che non è di tipo <xref:System.Messaging.Message> per il <xref:System.Messaging.MessageQueue>, tale oggetto viene collocato nella <xref:System.Messaging.Message.Body%2A> proprietà del <xref:System.Messaging.Message> istanza restituita dalla <xref:System.Messaging.MessageQueue.Peek%2A> o <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 L'argomento stringa in `MessageQueue.Send("hello.")` è un esempio di tale oggetto generico.  
  
 Il <xref:System.Messaging.Message.BodyType%2A> proprietà indica il tipo di informazioni archiviate nel corpo del messaggio. Queste informazioni per identificare il tipo di Accodamento messaggi utilizza il <xref:System.Messaging.Message.Body%2A> del contenuto della proprietà.  
  
 Specificare il <xref:System.Messaging.Message.Body%2A> proprietà o <xref:System.Messaging.Message.BodyStream%2A> proprietà prima di inviare il <xref:System.Messaging.Message> oggetto. Il <xref:System.Messaging.Message.Body%2A> proprietà può essere qualsiasi oggetto serializzabile, ad esempio una stringa di testo, un oggetto della struttura, una istanza della classe o un oggetto incorporato.  
  
 A meno che non si scrive il contenuto del messaggio direttamente il <xref:System.Messaging.Message.BodyStream%2A> impostata, il <xref:System.Messaging.Message.Formatter%2A> proprietà prima di inviare il messaggio. Quando il <xref:System.Messaging.MessageQueue.Send%2A> metodo viene chiamato sul <xref:System.Messaging.MessageQueue> istanza, il corpo viene serializzato utilizzando il formattatore contenuto nella <xref:System.Messaging.Message.Formatter%2A> proprietà. Se si invia il messaggio senza specificare un valore per il <xref:System.Messaging.Message.Formatter%2A> , il formattatore valore predefinito di proprietà <xref:System.Messaging.XmlMessageFormatter>.  
  
> [!NOTE]
>  Il tentativo di impostare il corpo di un messaggio da <xref:System.Decimal.MaxValue> causerà un <xref:System.OverflowException> quando il `Send` metodo il <xref:System.Messaging.MessageQueue> classe viene denominata e <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato.  
  
   
  
## Examples  
 Esempio di codice seguente invia due messaggi con priorità diversa per la coda e successivamente recuperati.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Messaging.Message.Formatter" /> è <see langword="null" />.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le informazioni presenti nel corpo del messaggio.</summary>
        <value>Oggetto <see cref="T:System.IO.Stream" /> che contiene le informazioni serializzate contenute nel <see cref="P:System.Messaging.Message.Body" /> del messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il corpo di un messaggio può essere costituito da qualsiasi tipo di informazioni, ad esempio, una stringa, una data, valuta, un numero, una matrice di byte o qualsiasi oggetto gestito. Questa informazione viene serializzata in un <xref:System.IO.Stream> deve essere passato alla coda.  
  
 Specificare il <xref:System.Messaging.Message.Body%2A> proprietà o <xref:System.Messaging.Message.BodyStream%2A> proprietà prima di inviare il <xref:System.Messaging.Message> oggetto. Se si imposta la <xref:System.Messaging.Message.Body%2A> proprietà, il contenuto viene serializzato nel <xref:System.Messaging.Message.BodyStream%2A> proprietà. Tuttavia, è possibile scegliere di scrivere il <xref:System.Messaging.Message.BodyStream%2A> proprietà direttamente. Ciò è utile, ad esempio, quando si desidera aprire una connessione a un file e il contenuto del flusso come corpo del messaggio.  
  
 A meno che non si scrive il contenuto del messaggio direttamente il <xref:System.Messaging.Message.BodyStream%2A> impostata, il <xref:System.Messaging.Message.Formatter%2A> proprietà prima di inviare il messaggio. Quando il <xref:System.Messaging.MessageQueue.Send%2A> metodo viene chiamato sul <xref:System.Messaging.MessageQueue> istanza, il corpo viene serializzato utilizzando il formattatore contenuto nella <xref:System.Messaging.Message.Formatter%2A> proprietà. Se si invia il messaggio senza specificare un valore per il <xref:System.Messaging.Message.Formatter%2A> , il formattatore valore predefinito di proprietà <xref:System.Messaging.XmlMessageFormatter>.  
  
 Se si imposta la <xref:System.Messaging.Message.UseEncryption%2A> proprietà `true` per il corpo del messaggio, il messaggio verrà crittografato quando viene inviato, non quando si imposta la <xref:System.Messaging.Message.Body%2A> proprietà. Pertanto, il <xref:System.Messaging.Message.BodyStream%2A> proprietà non verrà mai crittografata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo di dati contenuti nel corpo del messaggio.</summary>
        <value>Tipo effettivo del corpo del messaggio, come una stringa, una data, una valuta o un numero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il servizio Accodamento messaggi riconosce il contenuto del corpo come un oggetto o un flusso serializzato. Il <xref:System.Messaging.Message.BodyType%2A> proprietà indica il tipo di oggetto all'interno di <xref:System.Messaging.Message.Body%2A> proprietà del messaggio.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> esegue l'associazione tra i tipi nativi e l'oggetto nel corpo del messaggio. Se si utilizza il <xref:System.Messaging.XmlMessageFormatter>, il formattatore imposterà automaticamente la <xref:System.Messaging.Message.BodyType%2A> proprietà per l'utente.  
  
 Altri formattatori possono fornire funzionalità di associazione anche, come illustrato nel codice c# seguente.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.BodyType%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica che alcune proprietà del messaggio normalmente impostate da Accodamento messaggi sono state impostate dall'applicazione mittente.</summary>
        <value>Oggetto <see cref="T:System.Guid" /> definito dall'applicazione e utilizzato in combinazione con le applicazioni di connessione o la crittografia dei messaggi. <see cref="T:System.Guid" /> consente a un'applicazione ricevente di interpretare le proprietà del messaggio che sono state impostate dall'applicazione mittente, ma che in genere vengono impostate da Accodamento messaggi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accodamento messaggi richiede la <xref:System.Messaging.Message.ConnectorType%2A> impostata ogni volta che un'applicazione imposta una proprietà del messaggio che viene in genere impostata da Accodamento messaggi. Un'applicazione utilizza in genere un <xref:System.Messaging.Message.ConnectorType%2A> in due casi seguenti:  
  
-   Ogni volta che un'applicazione di connessione passa un messaggio. Il <xref:System.Messaging.Message.ConnectorType%2A> indica le applicazioni di inviare e ricezione come interpretare le proprietà di sicurezza e conferma del messaggio.  
  
-   Ogni volta che l'applicazione mittente, piuttosto che Accodamento messaggi, consente di crittografare un messaggio. Il <xref:System.Messaging.Message.ConnectorType%2A> indica ad Accodamento messaggi consente di <xref:System.Messaging.Message.DestinationSymmetricKey%2A> per decrittografare il valore della proprietà.  
  
 È necessario impostare il <xref:System.Messaging.Message.ConnectorType%2A> proprietà se si impostano le proprietà seguenti (in caso contrario, la coda ignora tali proprietà quando il messaggio viene inviato):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.ConnectorType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'identificatore del messaggio utilizzato dai messaggi di riconoscimento, di rapporto e di risposta per fare riferimento al messaggio originale.</summary>
        <value>Identificatore del messaggio specificato dalla proprietà <see cref="P:System.Messaging.Message.Id" /> del messaggio originale. L'identificatore di correlazione viene utilizzato da Accodamento messaggi alla generazione di un messaggio di acknowledgment o di rapporto e da un'applicazione alla generazione di un messaggio di risposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il servizio Accodamento messaggi genera un messaggio di riconoscimento o di rapporto, utilizza la proprietà identificatore di correlazione per specificare l'identificatore del messaggio originale. In questo modo l'identificatore di correlazione unisce il rapporto o il messaggio di riconoscimento al messaggio originale.  
  
 L'applicazione mittente può quindi far corrispondere il riconoscimento o un report con il messaggio originale utilizzando il <xref:System.Messaging.Message.CorrelationId%2A> proprietà per identificare il messaggio originale <xref:System.Messaging.Message.Id%2A> proprietà.  
  
 Applicazioni di connessione devono inoltre impostare il <xref:System.Messaging.Message.CorrelationId%2A> proprietà dei messaggi di riconoscimento e di report per l'identificatore del messaggio del messaggio originale.  
  
 Quando l'applicazione invia un messaggio di risposta all'applicazione mittente, è possibile impostare il <xref:System.Messaging.Message.CorrelationId%2A> proprietà del messaggio di risposta per l'identificatore del messaggio del messaggio originale. L'applicazione mittente può quindi far corrispondere il messaggio di risposta al messaggio inviato.  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio che contiene un ordine da e verso una coda. Richiede un riconoscimento positivo in particolare quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.CorrelationId" />.</exception>
        <exception cref="T:System.ArgumentException">L'elemento <see cref="P:System.Messaging.Message.CorrelationId" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la coda di destinazione desiderata per un messaggio.</summary>
        <value>Oggetto <see cref="T:System.Messaging.MessageQueue" /> che specifica la coda di destinazione desiderata per il messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.DestinationQueue%2A> proprietà viene in genere utilizzata per determinare la destinazione originale di un messaggio che si trova in una coda journal o messaggi non recapitabili. In genere, non è necessario esaminare questa proprietà, perché in genere è recuperare il messaggio dalla coda di destinazione.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.DestinationQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.DestinationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la chiave simmetrica utilizzata per crittografare i messaggi crittografati dall'applicazione o i messaggi inviati alle code esterne.</summary>
        <value>Matrice di valori di byte che specifica la chiave simmetrica di destinazione utilizzata per crittografare il messaggio. L'impostazione predefinita è una matrice di lunghezza zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due scenari è necessario utilizzare il <xref:System.Messaging.Message.DestinationSymmetricKey%2A> proprietà. Il primo è quando l'applicazione, anziché da Accodamento messaggi, consente di crittografare un messaggio. Il secondo è quando si invia un messaggio crittografato a un sistema di accodamento diverso da Accodamento messaggi.  
  
 Prima di impostare questa proprietà, è necessario crittografare la chiave simmetrica con la chiave pubblica del gestore code di destinazione. Quando si invia un messaggio crittografato dall'applicazione, il gestore delle code ricevente utilizza la chiave simmetrica per decrittografare il messaggio prima dell'invio alla coda di destinazione.  
  
 Se si invia un messaggio a una coda esterna, il messaggio viene prima ricevuto dall'applicazione di connettore appropriato, che inoltra il messaggio crittografato con la chiave simmetrica associata all'applicazione ricevente. È responsabilità dell'applicazione ricevente per decrittografare il messaggio utilizzando la chiave simmetrica.  
  
 Quando si imposta la <xref:System.Messaging.Message.DestinationSymmetricKey%2A> proprietà, è necessario impostare anche la <xref:System.Messaging.Message.ConnectorType%2A> proprietà. Quando il messaggio viene inviato, Accodamento messaggi ignora il <xref:System.Messaging.Message.DestinationSymmetricKey%2A> proprietà se il <xref:System.Messaging.Message.ConnectorType%2A> non anche è impostata.  
  
 Il <xref:System.Messaging.Message.DestinationSymmetricKey%2A> proprietà ha una dimensione di matrice massima di 256 caratteri.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.DestinationSymmetricKey" />.</exception>
        <exception cref="T:System.ArgumentException">L'elemento <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la firma digitale utilizzata da Accodamento messaggi per autenticare il messaggio.</summary>
        <value>Matrice di valori di byte che specifica la firma digitale di Accodamento messaggi versione 1.0 utilizzata per autenticare il messaggio. L'impostazione predefinita è una matrice di lunghezza zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accodamento messaggi utilizza la firma digitale per autenticare i messaggi inviati dalla versione 1.0 di Accodamento messaggi. Nella maggior parte dei casi, il servizio Accodamento messaggi genera l'errore e imposta il <xref:System.Messaging.Message.DigitalSignature%2A> proprietà quando l'applicazione mittente richiede l'autenticazione. L'applicazione ricevente utilizza questa proprietà per recuperare la firma digitale allegata al messaggio.  
  
 È possibile utilizzare solo il <xref:System.Messaging.Message.DigitalSignature%2A> proprietà durante l'esecuzione di Accodamento messaggi versione 2.0. Quando richiede l'autenticazione, è necessario specificare le firme versione 1.0 di Accodamento messaggi all'applicazione mittente. Se l'applicazione mittente invia una firma versione 2.0 di accodamento, questa proprietà contiene un buffer di quattro byte, ciascuno contenente zero.  
  
 Il <xref:System.Messaging.Message.DigitalSignature%2A> proprietà, insieme con il <xref:System.Messaging.Message.SenderCertificate%2A> proprietà, viene inoltre utilizzata dalle applicazioni di connessione quando viene inviato un messaggio. In questo scenario, l'applicazione di connessione, anziché Accodamento messaggi, genera la firma digitale, basata sul certificato dell'utente che invia il messaggio.  
  
 Il <xref:System.Messaging.Message.DigitalSignature%2A> proprietà ha una dimensione di matrice massima di 256 caratteri.  
  
 Quando si imposta la <xref:System.Messaging.Message.DigitalSignature%2A> proprietà, è necessario impostare anche la <xref:System.Messaging.Message.ConnectorType%2A> proprietà. Quando viene inviato un messaggio, Accodamento messaggi ignora il <xref:System.Messaging.Message.DigitalSignature%2A> proprietà se il <xref:System.Messaging.Message.ConnectorType%2A> non anche è impostata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.DigitalSignature" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Messaging.Message.DigitalSignature" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'algoritmo di crittografia utilizzato per crittografare il corpo di un messaggio privato.</summary>
        <value>Uno dei valori dell'enumerazione <see cref="T:System.Messaging.EncryptionAlgorithm" />. Il valore predefinito è <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un messaggio è privato (crittografata), viene crittografato prima che venga inviato e decrittografato al momento della ricezione. Il <xref:System.Messaging.Message.EncryptionAlgorithm%2A> proprietà specifica l'algoritmo utilizzato per crittografare il corpo del messaggio di un messaggio privato.  
  
 Una coda può richiedere che in ingresso messaggi crittografati. Se un'applicazione invia un messaggio di (pubblici) non crittografato a una coda che accetta solo messaggi privati o se invia un messaggio privato a una coda che accetta solo messaggi non privati, la coda rifiuta il messaggio. L'applicazione mittente può richiedere che in tal caso essere restituito un messaggio di riconoscimento negativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.EncryptionAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta informazioni aggiuntive definite dall'applicazione, associate al messaggio.</summary>
        <value>Matrice di byte che fornisce informazioni aggiuntive, definite dall'applicazione e associate al messaggio. L'impostazione predefinita è una matrice di lunghezza zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.Extension%2A> proprietà fornisce informazioni aggiuntive definite dall'applicazione, come un oggetto binario di grandi dimensioni, che è associato il messaggio. È compito dell'applicazione ricevente per interpretare il contenuto del <xref:System.Messaging.Message.Extension%2A> proprietà.  
  
 Dove possibile, è necessario includere i dati del messaggio nel <xref:System.Messaging.Message.Body%2A> proprietà del messaggio anziché <xref:System.Messaging.Message.Extension%2A> proprietà.  
  
 Quando si utilizzano code esterne, utilizzare il <xref:System.Messaging.Message.Extension%2A> proprietà per specificare le proprietà di messaggio che non esistono in Accodamento messaggi.  
  
 Una coda esterna esiste in un sistema di accodamento diverso da Accodamento messaggi Microsoft. Il servizio Accodamento messaggi comunica con queste code tramite un'applicazione di connessione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.Extension" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Messaging.Message.Extension" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il formattatore utilizzato per serializzare o deserializzare un oggetto da e nel corpo del messaggio.</summary>
        <value>
          <see cref="T:System.Messaging.IMessageFormatter" /> che produce un flusso da scrivere o leggere dal corpo del messaggio. Il valore predefinito è <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Messaging.Message.Formatter%2A> proprietà durante la lettura e scrittura di un messaggio. Quando un messaggio viene inviato alla coda, il formattatore serializza i <xref:System.Messaging.Message.Body%2A> proprietà in un flusso che può essere inviato alla coda dei messaggi. Durante la lettura da una coda, il formattatore deserializza i dati del messaggio nel <xref:System.Messaging.Message.Body%2A> proprietà.  
  
 A meno che non si scrive il contenuto del messaggio direttamente il <xref:System.Messaging.Message.BodyStream%2A> impostata, il <xref:System.Messaging.Message.Formatter%2A> proprietà prima di inviare il messaggio. Quando il <xref:System.Messaging.MessageQueue.Send%2A> metodo viene chiamato sul <xref:System.Messaging.MessageQueue> istanza, il corpo viene serializzato utilizzando il formattatore contenuto nella <xref:System.Messaging.Message.Formatter%2A> proprietà. Se si invia il messaggio senza specificare un valore per il <xref:System.Messaging.Message.Formatter%2A> , il formattatore valore predefinito di proprietà <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> ad accoppiamento ridotto, pertanto non è necessario avere lo stesso oggetto di tipo per il mittente e destinatario, quando si utilizza questo formato. Il <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializzare i dati in una rappresentazione binaria. Il <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato durante l'invio o la ricezione di componenti COM.  
  
   
  
## Examples  
 Esempio di codice seguente illustra la formattazione di un corpo del messaggio tramite <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Esempio di codice seguente illustra la formattazione di un corpo del messaggio tramite <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Messaging.Message.Formatter" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'algoritmo hash utilizzato da Accodamento messaggi per autenticare un messaggio o creare una firma digitale per un messaggio.</summary>
        <value>Uno dei valori dell'enumerazione <see cref="T:System.Messaging.HashAlgorithm" />. Per Windows XP il valore predefinito è <see langword="SHA" />. In caso contrario, il valore predefinito è <see langword="MD5" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel computer di origine, Accodamento messaggi utilizza l'algoritmo hash durante la creazione di una firma digitale di un messaggio. Quindi, il gestore delle code di destinazione utilizza lo stesso algoritmo hash per autenticare il messaggio quando viene ricevuto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.HashAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identificatore del messaggio.</summary>
        <value>Identificatore univoco del messaggio, generato da Accodamento messaggi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accodamento messaggi genera un identificatore di messaggio quando viene inviato il messaggio. L'identificatore è composto da 20 byte e comprende due elementi: la macchina <xref:System.Guid> del computer mittente e un identificatore univoco per il messaggio nel computer. La combinazione dei due elementi genera un identificatore di messaggio univoco per la rete.  
  
 Accodamento messaggi genera identificatori di messaggio per tutti i messaggi, inclusi i messaggi di riconoscimento e di report. In genere, un messaggio di riconoscimento viene inviato da Accodamento messaggi in risposta all'arrivo o errore di un messaggio originale inviato. È possibile trovare il <xref:System.Messaging.Message.Id%2A> valore della proprietà del messaggio originale nel <xref:System.Messaging.Message.CorrelationId%2A> proprietà di un messaggio di riconoscimento.  
  
 È inoltre possibile utilizzare il <xref:System.Messaging.Message.Id%2A> proprietà quando si invia un messaggio di risposta a una coda di risposta. Per includere l'identificatore del messaggio originale in un messaggio di risposta, impostare il <xref:System.Messaging.Message.CorrelationId%2A> proprietà del messaggio di risposta per la <xref:System.Messaging.Message.Id%2A> proprietà del messaggio originale. L'applicazione che legge il messaggio di risposta può quindi utilizzare l'identificatore di correlazione del messaggio di risposta per identificare il messaggio originale.  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio contenente un ordine da e verso una coda. Richiede un riconoscimento positivo in particolare quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.Id" />.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che non è previsto un timeout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> e <xref:System.Messaging.Message.TimeToReachQueue%2A> richiedono un valore che specifica un timeout. Nel primo caso, il timeout è il tempo massimo consentito per un messaggio venga ricevuto dalla coda. Nel secondo caso, il timeout è il tempo consentito per un messaggio raggiungere la coda. In entrambi i casi, è possibile specificare il timeout come un numero di secondi o usare <xref:System.Messaging.Message.InfiniteTimeout> per indicare che è presente alcun timeout.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Messaging.Message.InfiniteTimeout> campo.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il messaggio è stato il primo messaggio inviato in una transazione.</summary>
        <value>
          <see langword="true" /> se il messaggio è stato il primo messaggio inviato in una transazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione ricevente utilizza il <xref:System.Messaging.Message.IsFirstInTransaction%2A> proprietà per verificare se un messaggio è il primo messaggio inviato in una singola transazione a una singola coda.  
  
 Questa proprietà è disponibile solo con Accodamento messaggi versione 2.0 e versioni successive.  
  
 Per verificare i limiti delle transazioni, è possibile utilizzare il <xref:System.Messaging.Message.IsFirstInTransaction%2A> proprietà, con altre due proprietà: <xref:System.Messaging.Message.IsLastInTransaction%2A> e <xref:System.Messaging.Message.TransactionId%2A>. Utilizzare la prima per verificare se un messaggio di stato l'ultimo messaggio inviato nella transazione e utilizzare quest'ultimo per recuperare l'ID della transazione.  
  
 Se viene inviato un messaggio in una transazione, solo il <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.IsLastInTransaction%2A> sono entrambe impostate su `true`.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.IsFirstInTransaction%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.IsFirstInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il messaggio è stato l'ultimo messaggio inviato in una transazione.</summary>
        <value>
          <see langword="true" /> se il messaggio è stato l'ultimo inviato in una transazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione ricevente utilizza il <xref:System.Messaging.Message.IsLastInTransaction%2A> proprietà per verificare se un messaggio è l'ultimo messaggio inviato in una singola transazione a una singola coda.  
  
 Questa proprietà è disponibile solo con Accodamento messaggi versione 2.0 e versioni successive.  
  
 Per verificare i limiti delle transazioni, è possibile utilizzare il <xref:System.Messaging.Message.IsLastInTransaction%2A> proprietà, con altre due proprietà: <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.TransactionId%2A>. Utilizzare la prima per verificare se un messaggio di stato il primo messaggio inviato nella transazione e utilizzare quest'ultimo per recuperare l'ID della transazione.  
  
 Se viene inviato un messaggio in una transazione, solo il <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.IsLastInTransaction%2A> sono entrambe impostate su `true`.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.IsLastInTransaction%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.IsLastInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una stringa Unicode definita dall'applicazione che descrive il messaggio.</summary>
        <value>L'etichetta del messaggio. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare un'etichetta di messaggio per diversi scopi. Un'etichetta di messaggio può essere utilizzata per scopi di visualizzazione o per elaborare in modo selettivo i messaggi sulla base del valore dell'etichetta. L'etichetta non devono essere univoci tra i messaggi.  
  
 La coda e le etichette di messaggio rappresentano un valore definito dall'applicazione in grado di identificare la coda o il messaggio in termini leggibili. È responsabilità dell'applicazione per interpretare il contenuto di etichetta, che non hanno alcun significato intrinseco per l'applicazione di Accodamento messaggi.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.Label%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.Label" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introdotto in MSMQ 3.0. Ottiene l'identificatore di ricerca del messaggio.</summary>
        <value>Identificatore di ricerca del messaggio, generato da Accodamento messaggi e univoco nella coda in cui si trova il messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà fornisce l'accesso in sola lettura all'identificatore di ricerca del messaggio. Identificatore di ricerca, introdotto in MSMQ 3.0, è un identificatore di a 64 bit che viene generato da Accodamento messaggi e assegnato a ogni messaggio quando il messaggio viene inserito nella coda. Identificatore di ricerca non corrisponde all'identificatore del messaggio che viene generato quando viene inviato il messaggio.  
  
 Accodamento messaggi genera un identificatore di ricerca per tutti i messaggi che vengono inseriti in una coda, tra cui generati dall'applicazione di destinazione, amministrazione e le code del report, nonché journal generato dal sistema, messaggi non recapitabili, connettore e in uscita. In altre parole, sono inclusi entrambi i messaggi inviati dalle applicazioni mittenti e da Accodamento messaggi. Identificatore di ricerca è univoca per la coda e non ha alcun significato all'esterno della coda.  
  
 Se un messaggio viene inviato a diverse code di destinazione oppure una copia di un messaggio viene archiviata in un journal del computer o della coda, ogni copia del messaggio avrà un proprio identificatore di ricerca quando viene inserito nella rispettiva coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà può essere letta solo messaggi recuperati da una coda.  
  
 Un identificatore di ricerca viene utilizzato per leggere un messaggio specifico nella coda. Dopo l'identificatore di ricerca di un messaggio è noto, l'applicazione ricevente può chiamare il <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> o <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> funzione per passare direttamente al messaggio e leggere o recuperarlo dalla coda, a differenza dei cursori che deve iniziare all'inizio della coda e Passare alla fine della coda,  
  
 Ottenere gli identificatori di ricerca dei messaggi nella coda è responsabilità dell'applicazione. Uno dei modi per ottenere gli identificatori di ricerca consiste nel creare un trigger per la coda di destinazione che richiama un componente che memorizza nella cache gli identificatori di ogni messaggio quando vengono inseriti nella coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.LookupId" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo di messaggio: <see langword="Normal" />, <see langword="Acknowledgment" /> o <see langword="Report" />.</summary>
        <value>Uno dei valori di <see cref="P:System.Messaging.Message.MessageType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accodamento messaggi in genere imposta questa proprietà quando invia il messaggio. Il tipo di un messaggio di accodamento messaggi può essere uno dei seguenti:  
  
-   `Normal`, quale un normale messaggio inviato da un'applicazione a una coda o un messaggio di risposta restituito all'applicazione mittente.  
  
-   `Acknowledgement`, che il servizio Accodamento messaggi genera ogni volta che l'applicazione mittente lo richiede. Accodamento messaggi, ad esempio, può generare messaggi positivi o negativi per comunicare l'arrivo o la lettura del messaggio originale. Accodamento messaggi restituisce il messaggio di conferma appropriato alla coda di amministrazione specificata dall'applicazione mittente.  
  
-   `Report`, che il servizio Accodamento messaggi genera ogni volta che viene definita una coda dei rapporti nel gestore code di origine. Quando la traccia è abilitata, l'accodamento messaggi invia un messaggio di rapporto alla coda di rapporti di accodamento messaggi ogni volta che il messaggio originale viene ricevuto o trasmesso da un server di accodamento messaggi.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.MessageType%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.MessageType" />.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la priorità del messaggio, che determina la posizione del messaggio nella coda.</summary>
        <value>Uno dei valori di <see cref="T:System.Messaging.MessagePriority" /> che rappresenta il livello di priorità di un messaggio non transazionale. Il valore predefinito è <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.Priority%2A> proprietà influisce sulla modalità Accodamento messaggi gestisce il messaggio sia durante l'indirizzamento e una volta raggiunta la destinazione. I messaggi con priorità superiore hanno la precedenza durante l'instradamento e vengono inseriti nella parte anteriore della coda. I messaggi con la stessa priorità vengono inseriti nella coda in base all'ora di arrivo.  
  
 È possibile impostare una priorità significativa solo per messaggi non transazionali. Accodamento messaggi imposta automaticamente la priorità per i messaggi transazionali per `Lowest`, che comporta la priorità verrà ignorato.  
  
   
  
## Examples  
 Esempio di codice seguente invia due messaggi con priorità diversa per la coda e successivamente recuperati.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.Priority" />.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica che il recapito del messaggio è garantito anche nel caso di un malfunzionamento del computer o di un problema di rete.</summary>
        <value>
          <see langword="true" /> se la consegna del messaggio è garantita mediante il salvataggio sul disco durante l'indirizzamento; <see langword="false" /> se la consegna non è garantita. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.Recoverable%2A> proprietà indica se è garantito il recapito di un messaggio, anche se il computer si blocca durante il messaggio di indirizzamento alla coda di destinazione.  
  
 Se è garantito il recapito di un messaggio, il messaggio viene archiviato in locale in ogni fase della route, fino a quando il messaggio viene inoltrato al computer successivo. L'impostazione di <xref:System.Messaging.Message.Recoverable%2A> proprietà `true` possono influire sulla velocità effettiva.  
  
 Se il messaggio è transazionale, Accodamento messaggi gestisce automaticamente il messaggio come recuperabile, indipendentemente dal valore della <xref:System.Messaging.Message.Recoverable%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.Recoverable%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.Recoverable" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la coda che riceve i messaggi di risposta generati dall'applicazione.</summary>
        <value>La proprietà <see cref="T:System.Messaging.MessageQueue" /> alla quale vengono restituiti i messaggi di risposta generati dall'applicazione. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.ResponseQueue%2A> proprietà identifica la coda che riceve i messaggi di risposta generati dall'applicazione, che restituisce l'applicazione ricevente all'applicazione mittente. Le code di risposta vengono specificate dall'applicazione mittente all'invio dei messaggi. È possibile specificare come coda di risposta qualsiasi coda disponibile.  
  
 I messaggi restituiti alla coda di risposta sono specifici dell'applicazione. È necessario che l'applicazione definisca il contenuto dei messaggi, nonché le operazioni da eseguire alla ricezione del messaggio.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.ResponseQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.ResponseQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il contesto per la sicurezza di un messaggio.</summary>
        <value>Oggetto <see cref="T:System.Messaging.SecurityContext" /> che contiene il contesto di sicurezza di un messaggio, se la proprietà è stata impostata in precedenza; in caso contrario, NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il certificato di sicurezza usato per autenticare i messaggi.</summary>
        <value>Una matrice di valori di byte che rappresenta un certificato di sicurezza, utilizzato da Accodamento messaggi per verificare il mittente del messaggio. L'impostazione predefinita è una matrice di lunghezza zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Applicazione di ricezione utilizza la <xref:System.Messaging.Message.SenderCertificate%2A> proprietà quando il messaggio include un certificato di protezione esterne.  
  
 Il servizio Accodamento messaggi può autenticare un messaggio utilizzando un certificato di sicurezza interni o esterni. Accodamento messaggi fornisce certificati interni, che vengono usati per verificare l'integrità del messaggio. Un'autorità di certificazione fornisce un certificato esterno che è possibile accedere tramite il <xref:System.Messaging.Message.SenderCertificate%2A> proprietà del messaggio. Oltre a consentire di Accodamento messaggi autenticare il messaggio, un certificato esterno consente all'applicazione ricevente verificare ulteriormente il mittente. Nessun valore utilizzabile da un'applicazione ricevente un certificato interno.  
  
 Un certificato esterno deve essere registrato con il servizio directory di sistema di Accodamento. Un certificato esterno contiene informazioni sull'autorità di certificazione, l'utente del certificato, il periodo di validità del certificato, la chiave pubblica dell'utente del certificato e la firma dell'autorità di certificazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.SenderCertificate" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identificatore del mittente.</summary>
        <value>Matrice di valori di byte che identifica il mittente. Il gestore della coda di destinazione utilizza l'identificatore quando autentica il messaggio per verificare il mittente del messaggio e i diritti di accesso alla coda del mittente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Messaging.Message.AttachSenderId%2A> proprietà `false`, l'identificatore del mittente specificato nella <xref:System.Messaging.Message.SenderId%2A> proprietà non è associata al messaggio quando viene inviato. Indica che il mittente non deve essere convalidato quando invia il messaggio alla coda di destinazione per Accodamento messaggi. Se il <xref:System.Messaging.Message.AttachSenderId%2A> proprietà `true`, <xref:System.Messaging.Message.SenderId%2A> valore della proprietà sia attendibile solo se il messaggio è stato autenticato. Utilizzare il <xref:System.Messaging.Message.Authenticated%2A> proprietà in combinazione con la <xref:System.Messaging.Message.SenderId%2A> proprietà per verificare i diritti di accesso del mittente.  
  
 Un'applicazione di connessione è un'applicazione che utilizza un server del connettore per la comunicazione tra il servizio Accodamento messaggi e altri sistemi di Accodamento. Accodamento messaggi richiede che le applicazioni di connessione per fornire l'identificazione del mittente. È necessario impostare il <xref:System.Messaging.Message.ConnectorType%2A> proprietà quando si invia un messaggio tramite un'applicazione di connessione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.SenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la versione di Accodamento messaggi utilizzata per inviare il messaggio.</summary>
        <value>Versione di Accodamento messaggi utilizzata per inviare il messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.SenderVersion%2A> proprietà è importante per determinate funzionalità. Ad esempio, l'elaborazione delle transazioni è supportato solo da Accodamento messaggi 2.0 e versioni successive e le firme digitali vengono utilizzate per autenticare i messaggi inviati da MSMQ 1.0.  
  
 I set di gestore code mittente la <xref:System.Messaging.Message.SenderVersion%2A> proprietà quando viene inviato il messaggio.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.SenderVersion%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.SenderVersion" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la data e l'ora sul computer mittente dell'invio del messaggio dal Gestore code di origine.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> che rappresenta l'ora di invio del messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.SentTime%2A> proprietà viene modificata in base all'ora locale del computer in cui l'istanza di <xref:System.Messaging.Message> classe è stata creata. In questo fuso orario può essere diverso da quelli delle code di origine e di destinazione.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.SentTime%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.SentTime" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene informazioni sul computer in cui il messaggio ha avuto origine.</summary>
        <value>Nome del computer dal quale è stato inviato il messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il formato del <xref:System.Messaging.Message.SourceMachine%2A> proprietà non includere barre rovesciate due (\\\\). Ad esempio, `myServer` valido <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.SourceMachine%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.SourceMachine" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Impossibile accedere alle informazioni sul computer o al servizio directory.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il limite di tempo massimo per la ricezione del messaggio dalla coda di destinazione.</summary>
        <value>Tempo totale per la ricezione di un messaggio inviato dalla coda di destinazione. Il valore predefinito è <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà specifica il tempo totale per un messaggio inviato venga ricevuto dalla coda di destinazione. Il limite di tempo include il tempo trascorso per raggiungere la coda di destinazione e il tempo di attesa nella coda prima che venga ricevuto il messaggio.  
  
> [!CAUTION]
>  Quando si utilizzano computer client dipendenti, assicurarsi che l'orologio del computer client è sincronizzato con l'orologio del server che esegue il servizio Accodamento messaggi. In caso contrario, risultati imprevisti quando si invia un messaggio il cui <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà non è <xref:System.Messaging.Message.InfiniteTimeout>.  
  
 Se l'intervallo specificato per il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà scade prima che il messaggio viene rimosso dalla coda, Accodamento messaggi Elimina il messaggio in uno dei due modi. Se la proprietà <xref:System.Messaging.Message.UseDeadLetterQueue%2A> del messaggio è `true`, il messaggio viene inviato alla coda inattiva. Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è `false`, il messaggio viene ignorato.  
  
 È possibile impostare il messaggio <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà per richiedere che il servizio Accodamento messaggi invia un messaggio di riconoscimento negativo nuovamente all'applicazione mittente se non viene recuperato il messaggio prima della scadenza del timer.  
  
 Se il valore specificato per il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà è minore del valore specificato per il <xref:System.Messaging.Message.TimeToReachQueue%2A> proprietà <xref:System.Messaging.Message.TimeToBeReceived%2A> ha la precedenza.  
  
 Quando più messaggi vengono inviati in una singola transazione, Accodamento messaggi utilizza il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà del primo messaggio.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.TimeToBeReceived" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per <see cref="P:System.Messaging.Message.TimeToBeReceived" /> non è valido.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il limite di tempo massimo impiegato dal messaggio per raggiungere la coda.</summary>
        <value>Il limite di tempo necessario a un messaggio, dal momento in cui viene inviato, per raggiungere la coda di destinazione. Il valore predefinito è <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'intervallo specificato per il <xref:System.Messaging.Message.TimeToReachQueue%2A> proprietà scade prima che il messaggio raggiunga la destinazione, Accodamento messaggi Elimina il messaggio in uno dei due modi. Se la proprietà <xref:System.Messaging.Message.UseDeadLetterQueue%2A> del messaggio è `true`, il messaggio viene inviato alla coda inattiva. Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è `false`, il messaggio viene ignorato  
  
 È possibile impostare del messaggio può <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà per richiedere che il servizio Accodamento messaggi invia un messaggio di riconoscimento negativo nuovamente all'applicazione mittente se il messaggio arriva prima della scadenza del timer.  
  
 Se il <xref:System.Messaging.Message.TimeToReachQueue%2A> è impostata su 0 secondi, di Accodamento messaggi esegue un tentativo di inviare il messaggio alla destinazione, se la coda è in attesa del messaggio. Se la coda è locale, il messaggio raggiunge sempre.  
  
 Se il valore specificato per il <xref:System.Messaging.Message.TimeToReachQueue%2A> è maggiore del valore specificato dalla proprietà di <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà <xref:System.Messaging.Message.TimeToBeReceived%2A> ha la precedenza.  
  
 Quando più messaggi vengono inviati in una singola transazione, Accodamento messaggi utilizza il <xref:System.Messaging.Message.TimeToReachQueue%2A> proprietà del primo messaggio.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.TimeToReachQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.TimeToReachQueue" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per <see cref="P:System.Messaging.Message.TimeToReachQueue" /> non è valido. Può rappresentare un numero negativo.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identificatore per la transazione di cui fa parte il messaggio.</summary>
        <value>Identificatore per la transazione associata al messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione ricevente utilizza il <xref:System.Messaging.Message.TransactionId%2A> proprietà per verificare che un messaggio è stato inviato come parte di una transazione specifica. L'identificatore di transazione contiene l'identificatore del computer di invio (primi 16 bit) seguito da un numero di sequenza della transazione a 4 byte.  
  
 Questa proprietà è disponibile solo per il servizio Accodamento messaggi versione 2.0 e versioni successive.  
  
 Identificatori della transazione non sono necessariamente essere univoco, perché i numeri di sequenza delle transazioni non sono persistenti e ripartono 2 <sup>20</sup>. Accodamento messaggi garantisce solo che le transazioni successive avranno diversi numeri di sequenza.  
  
 È possibile utilizzare il <xref:System.Messaging.Message.TransactionId%2A> proprietà con il <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.IsLastInTransaction%2A> per verificare i limiti delle transazioni.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.TransactionId%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.TransactionId" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la coda di stato della transazione sul computer di origine.</summary>
        <value>La coda di stato della transazione sul computer di origine, utilizzata per restituire messaggi di riconoscimento all'applicazione mittente. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.TransactionStatusQueue%2A> proprietà identifica la coda transazionale nel computer di origine che riceve messaggi di riconoscimento letti dalle applicazioni di connessione. Accodamento messaggi imposta la proprietà e le applicazioni di connettore usare la proprietà durante il recupero dei messaggi di transazione inviati alle code esterne.  
  
 Una coda esterna esiste in un sistema di accodamento diverso da Accodamento messaggi Microsoft. Il servizio Accodamento messaggi comunica con queste code tramite un'applicazione di connessione.  
  
 L'applicazione di connessione è possibile utilizzare la coda di stato di transazione per inviare messaggi di riconoscimento all'applicazione mittente. La coda di stato di transazione deve ricevere questi riconoscimenti anche se l'applicazione di invio non richiede altri.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.TransactionStatusQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il messaggio non è stato inviato. Questa proprietà può essere letta solamente da messaggi recuperati da una coda.  
  
 oppure  
  
 La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.TransactionStatusQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il messaggio è stato autenticato o deve esserlo prima del suo invio.</summary>
        <value>
          <see langword="true" /> se l'applicazione mittente richiede l'autenticazione del messaggio; <see langword="false" /> in caso contrario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.UseAuthentication%2A> proprietà specifica se il messaggio deve essere autenticato. Se l'applicazione mittente lo richiede l'autenticazione, Accodamento messaggi consente di creare una firma digitale e viene utilizzato per firmare il messaggio durante l'invio e autenticare il messaggio quando viene ricevuto.  
  
 Se <xref:System.Messaging.Message.UseAuthentication%2A> è `false` e un messaggio viene inviato a una coda che accetta solo messaggi autenticati, il messaggio verrà rifiutato quando raggiunge la coda.  
  
 È possibile determinare se un messaggio di autenticazione non riuscita per visualizzare le relative proprietà. Accodamento messaggi elimina tali messaggi prima che vengano recapitati alla coda. Tuttavia, è possibile richiedere di essere inviato un messaggio di conferma se un errore di recapito impedisce che un messaggio arriva nella coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.UseAuthentication" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una copia del messaggio non recapitato deve essere inviata a una coda dei messaggi non recapitabili.</summary>
        <value>
          <see langword="true" /> se la mancata consegna del messaggio deve risultare in una copia del messaggio inviato a una coda di messaggi non consegnati; <see langword="false" /> in caso contrario. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.UseJournalQueue%2A> e <xref:System.Messaging.Message.UseDeadLetterQueue%2A> specificano come il servizio Accodamento messaggi di traccia dei messaggi. Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è `true`, errore di recapito (di un messaggio non transazionale), fa sì che il messaggio da inviare alla coda di messaggi non recapitabili non transazionale nel computer che non ha potuto recapitare il messaggio. Errore di recapito può essere causato da un timer di messaggio che scade, ad esempio.  
  
 In caso di errore di recapito per un messaggio transazionale, Accodamento messaggi invia il messaggio nella coda di messaggi non recapitabili transazionale nel computer di origine in tutti i casi negativi e in dubbio.  
  
 Quando si archiviano i messaggi in una coda di messaggi non recapitabili, è necessario cancellare la coda periodicamente per rimuovere i messaggi che non sono più necessari. Messaggi memorizzati nelle code di messaggi non recapitabili diminuisce la quota di dimensioni per il computer in cui risiede la coda. La quota del computer è impostata dall'amministratore e fa riferimento alle dimensioni allocate per memorizzare messaggi sull'intero computer, non solo in una singola coda.  
  
 Non si crea un journal o una coda di messaggi non recapitabili. Sono entrambe code di sistema di Accodamento messaggi genera l'errore.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.UseDeadLetterQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.UseDeadLetterQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se rendere privato il messaggio.</summary>
        <value>
          <see langword="true" /> per richiedere ad Accodamento messaggi di crittografare il messaggio; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un messaggio è privato, il corpo viene crittografato prima che venga inviato e decrittografata quando vengono ricevuti. Per inviare un messaggio privato, l'applicazione di invio è necessario specificare la crittografia utilizzata e, facoltativamente, l'algoritmo di crittografia.  
  
 Quando si inviano messaggi privati, l'applicazione non è necessario eseguire la crittografia del messaggio. Il servizio Accodamento messaggi è possibile crittografare il corpo del messaggio per l'utente se l'applicazione invia messaggi all'interno di un'azienda di Microsoft Windows 2000, che dispone dell'accesso al servizio directory. Quando si ricevono messaggi privati, il gestore delle code ricevente sempre decrittografa il corpo del messaggio.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.UseEncryption%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.UseEncryption" />.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se è necessario inserire una copia del messaggio nel journal del computer di origine.</summary>
        <value>
          <see langword="true" /> per richiedere la memorizzazione di una copia di un messaggio nel journal del computer di origine dopo che il messaggio è stato correttamente trasmesso dal computer di origine al server successivo; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.UseJournalQueue%2A> e <xref:System.Messaging.Message.UseDeadLetterQueue%2A> specificano come il servizio Accodamento messaggi di traccia dei messaggi. Se <xref:System.Messaging.Message.UseJournalQueue%2A> è `true`, quindi una copia viene mantenuta nella coda journal di computer nel computer di origine a ogni passaggio che è stato trasmesso un messaggio.  
  
 Il messaggio inviato viene copiato nella coda journal solo se la coda di destinazione si trova in un computer remoto. Se la destinazione è il computer locale, il messaggio viene inviato direttamente alla coda. non sono passaggi intermedi in modo da richiedere l'inserimento nel journal.  
  
 Quando si archiviano i messaggi in una coda journal, cancellare la coda periodicamente per rimuovere i messaggi che non sono più necessari. Messaggi memorizzati nelle code diario rispetto alla quota per il computer in cui risiede la coda. (La quota del computer è impostata dall'amministratore).  
  
 Non si crea un journal o una coda di messaggi non recapitabili. Sono entrambe code di sistema di Accodamento messaggi genera l'errore.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.UseJournalQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.UseJournalQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se tenere traccia di un messaggio mentre procede verso la coda di destinazione.</summary>
        <value>
          <see langword="true" /> se ciascuna fase intermedia dello spostamento del messaggio originale alla coda di destinazione genera un rapporto da inviare alla coda dei rapporti di sistema; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.UseTracing%2A> proprietà specifica se tenere traccia della route di un messaggio mentre si sposta verso la coda di destinazione. Se `true`, un report (generati da Accodamento messaggi) viene inviato alla coda dei rapporti ogni volta che il messaggio passa attraverso un server di Accodamento. La coda del report viene specificata dal gestore code di origine. Le code del report non sono limitate ai messaggi di report generati da Accodamento messaggi; i messaggi generati dall'applicazione possono anche essere inviati alle code di report.  
  
 Utilizzo dell'analisi, è necessario configurare Active Directory e specificare una coda dei rapporti di Accodamento messaggi. L'amministratore configura le impostazioni.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.UseTracing%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La coda di messaggi viene filtrata in modo che venga ignorata la proprietà <see cref="P:System.Messaging.Message.UseTracing" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>