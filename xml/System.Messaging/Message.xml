<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="aca17eb5c1214cd7837f89c181242c98095e8144" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36477554" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides access to the properties needed to define a Message Queuing message.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la <xref:System.Messaging.Message> classe per leggere o ricevere messaggi da una coda o di un controllo accurato le proprietà del messaggio quando si invia un messaggio a una coda.  
  
 <xref:System.Messaging.MessageQueue> Usa il <xref:System.Messaging.Message> classe quando legge o riceve messaggi dalle code, perché sia il <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> e <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> metodi creano una nuova istanza della <xref:System.Messaging.Message> classe e impostare le proprietà dell'istanza. Il <xref:System.Messaging.Message> le proprietà di sola lettura della classe si applicano al recupero dei messaggi da una coda, mentre le proprietà di lettura/scrittura si applicano all'invio e recupero dei messaggi. Quando si <xref:System.Messaging.MessageQueue> legge o riceve un messaggio da una coda, il relativo <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> proprietà determina quale proprietà del messaggio vengono recuperati.  
  
 Il <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Send%2A> metodo consente di specificare un tipo di oggetto per un messaggio inviato alla coda. È possibile usare il <xref:System.Messaging.MessageQueue> dell'istanza <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà per specificare le impostazioni per i messaggi generici inviati alla coda. I tipi di impostazioni includono formattatore, etichetta, la crittografia e autenticazione. È inoltre possibile specificare valori per l'oggetto appropriato <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membri quando si coordina l'applicazione di messaggistica per rispondere ai messaggi di riconoscimento e di report. Utilizzando un <xref:System.Messaging.Message> istanza per inviare un messaggio alla coda offre la flessibilità necessaria per accedere e modificare numerose di queste proprietà, ovvero per un singolo messaggio o in base dal messaggio. <xref:System.Messaging.Message> proprietà hanno la precedenza su <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 I dati del messaggio viene archiviati nel <xref:System.Messaging.Message.Body%2A> proprietà e in misura minore, il <xref:System.Messaging.Message.AppSpecific%2A> e <xref:System.Messaging.Message.Extension%2A> proprietà. Quando i dati del messaggio sono crittografati, serializzati o deserializzati, solo il contenuto del <xref:System.Messaging.Message.Body%2A> proprietà sono interessate.  
  
 Il contenuto del <xref:System.Messaging.Message.Body%2A> proprietà vengono serializzati quando viene inviato il messaggio, mediante il <xref:System.Messaging.Message.Formatter%2A> proprietà specificato. Il contenuto serializzato è inclusi il <xref:System.Messaging.Message.BodyStream%2A> proprietà. È inoltre possibile impostare il <xref:System.Messaging.Message.BodyStream%2A> proprietà direttamente, ad esempio, per inviare un file come il contenuto dei dati di un messaggio. È possibile modificare il <xref:System.Messaging.Message.Body%2A> oppure <xref:System.Messaging.Message.Formatter%2A> proprietà in qualsiasi momento prima dell'invio del messaggio e i dati saranno serializzate in modo appropriato quando si chiama <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 Le proprietà definite per il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> proprietà si applica solo ai messaggi che non sono di tipo <xref:System.Messaging.Message>. Se si specifica il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà per un <xref:System.Messaging.MessageQueue>, lo stesso nome proprietà in un <xref:System.Messaging.Message> istanza ha inviato a tale coda prevalgono queste proprietà predefinite che verranno ignorati.  
  
 Per un elenco di valori di proprietà iniziali per un'istanza di <xref:System.Messaging.Message>, vedere il <xref:System.Messaging.Message.%23ctor%2A> costruttore.  
  
   
  
## Examples  
 Esempio di codice seguente illustra la formattazione di un corpo del messaggio tramite <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Esempio di codice seguente illustra la formattazione di un corpo del messaggio tramite <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.Message" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.Message" /> class with an empty body.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare una nuova istanza di <xref:System.Messaging.Message> classe che ha un corpo vuoto.  
  
 Specificare il <xref:System.Messaging.Message.Body%2A> proprietà o il <xref:System.Messaging.Message.BodyStream%2A> proprietà prima di inviare il <xref:System.Messaging.Message> oggetto. Il <xref:System.Messaging.Message.Body%2A> proprietà può essere qualsiasi oggetto che può essere serializzata, ad esempio una stringa di testo, un oggetto della struttura, un'istanza della classe o un oggetto incorporato.  
  
 A meno che non si scrive il contenuto del messaggio direttamente il <xref:System.Messaging.Message.BodyStream%2A> impostare la proprietà, il <xref:System.Messaging.Message.Formatter%2A> proprietà prima di inviare il messaggio. Il corpo viene serializzato utilizzando il <xref:System.Messaging.Message.Formatter%2A> il valore della proprietà al momento il <xref:System.Messaging.MessageQueue.Send%2A> metodo viene chiamato sul <xref:System.Messaging.MessageQueue> istanza.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> è regime, pertanto non è necessario avere lo stesso oggetto di tipo per il mittente e ricevitore quando si utilizza questo formato. Il <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializzare i dati in una rappresentazione binaria. Il <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato durante l'invio o la ricezione di componenti COM.  
  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Messaging.Message>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Enhanced Cryptographic Provider versione 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Esempio di codice seguente invia due messaggi con priorità diverse per la coda e successivamente recuperati.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">The object to be serialized into the body of the message.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.Message" /> class, using the <see cref="T:System.Messaging.XmlMessageFormatter" /> to serialize the specified object into the body of the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare una nuova istanza del <xref:System.Messaging.Message> classe che contiene il <xref:System.Messaging.Message.Body%2A> specificato per il `body` parametro. Il `body` parametro può essere qualsiasi oggetto che può essere serializzata, ad esempio una stringa di testo, un oggetto della struttura, un'istanza della classe o un oggetto incorporato. Il corpo viene serializzato utilizzando il <xref:System.Messaging.XmlMessageFormatter> a meno che non si modifica il <xref:System.Messaging.Message.Formatter%2A> proprietà prima di <xref:System.Messaging.Message> viene inviato. Se si modifica il <xref:System.Messaging.Message.Body%2A> oppure <xref:System.Messaging.Message.Formatter%2A> proprietà in qualsiasi momento prima di chiamare <xref:System.Messaging.MessageQueue.Send%2A>, verrà serializzato il messaggio in base al nuovo valore della proprietà.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> è regime, pertanto non è necessario avere lo stesso oggetto di tipo per il mittente e ricevitore quando si utilizza questo formato. Il <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializzare i dati in una rappresentazione binaria. Il <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato durante l'invio o la ricezione di componenti COM.  
  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Messaging.Message>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Enhanced Cryptographic Provider versione 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Il `body` parametro.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Esempio di codice seguente crea una nuova coda, invia un messaggio che contiene un ordine ad esso e quindi li recupera.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">The object to be serialized into the body of the message.</param>
        <param name="formatter">A <see cref="T:System.Messaging.IMessageFormatter" /> that specifies the formatter with which to serialize the message body.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.Message" /> class using the specified formatter to serialize the specified object into the body of the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare una nuova istanza della <xref:System.Messaging.Message> classe che contiene il <xref:System.Messaging.Message.Body%2A> specificato dal `body` parametro e che utilizza un formattatore valido per serializzare il corpo. Il `body` parametro è un oggetto che può essere serializzato, ad esempio una stringa di testo, un oggetto della struttura, un'istanza della classe o un oggetto incorporato. Se si modifica il <xref:System.Messaging.Message.Body%2A> oppure <xref:System.Messaging.Message.Formatter%2A> proprietà in qualsiasi momento prima di chiamare <xref:System.Messaging.MessageQueue.Send%2A>, verrà serializzato il messaggio in base al nuovo valore della proprietà.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> è regime, pertanto non è necessario avere lo stesso oggetto di tipo per il mittente e ricevitore quando si utilizza questo formato. Il <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializzare i dati in una rappresentazione binaria. Il <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato durante l'invio o la ricezione di componenti COM.  
  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Messaging.Message>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Enhanced Cryptographic Provider versione 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Il `body` parametro.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.Formatter%2A>|Il `formatter` parametro.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Una stringa vuota ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of acknowledgment message to be returned to the sending application.</summary>
        <value>Uno del <see cref="T:System.Messaging.AcknowledgeTypes" /> valori che rappresentano entrambi i tipi di messaggi di riconoscimento che il sistema invia alla coda di amministrazione e le condizioni in cui i riconoscimenti vengono restituiti all'applicazione mittente. Il valore predefinito è <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà specifica il tipo di messaggi di riconoscimento richiesto dall'applicazione mittente. Impostare il <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà prima di inviare il messaggio per richiedere la notifica di alcuni eventi, ad esempio, un messaggio ha raggiunto la coda di destinazione, il recupero di un messaggio o un timeout che impedisce che un messaggio di raggiungimento o il recupero da la coda di destinazione.  
  
 Accodamento messaggi restituisce notifica inviando messaggi di riconoscimento per il <xref:System.Messaging.Message.AdministrationQueue%2A> proprietà specificata dal messaggio originale. Un messaggio di riconoscimento <xref:System.Messaging.Message.Acknowledgment%2A> proprietà indica il tipo di riconoscimento da esso rappresentata. Ad esempio, se è stato inviato un messaggio di riconoscimento perché un messaggio non ha raggiunto la destinazione prima la <xref:System.Messaging.Message.TimeToReachQueue%2A> intervallo di scadenza, il <xref:System.Messaging.Message.Acknowledgment%2A> proprietà del messaggio di riconoscimento può contenere il valore `ReachQueueTimeout`.  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio contenente un ordine da e verso una coda. Richiede un riconoscimento positivo in particolare quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message is filtered to ignore the <see cref="P:System.Messaging.Message.AcknowledgeType" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the classification of acknowledgment that this message represents.</summary>
        <value>Uno dei valori dell'enumerazione <see cref="T:System.Messaging.Acknowledgment" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si riceve un messaggio da una coda di amministrazione, leggere la <xref:System.Messaging.Message.Acknowledgment%2A> proprietà per verificare lo stato del messaggio originale.  
  
 Quando un messaggio viene inviato alla coda di destinazione, Accodamento messaggi può essere richiesta per inviare un messaggio di riconoscimento. Tale messaggio può indicare, ad esempio, se il messaggio è arrivato ed è stato recuperato all'interno di timeout specificato, oppure può indicare la causa dell'errore nel caso di errore di recapito. La coda di destinazione restituisce messaggi di riconoscimento e li invia alla coda di amministrazione specificata del messaggio originale <xref:System.Messaging.Message.AdministrationQueue%2A> proprietà. Il <xref:System.Messaging.Message.Id%2A> proprietà di un messaggio di riconoscimento identifica il messaggio di riconoscimento, non l'originale. È possibile trovare l'identificatore del messaggio originale nel riconoscimento <xref:System.Messaging.Message> dell'istanza <xref:System.Messaging.Message.CorrelationId%2A> proprietà.  
  
 Se questa <xref:System.Messaging.Message> istanza rappresenta un messaggio di riconoscimento, la <xref:System.Messaging.Message.Acknowledgment%2A> proprietà specifica il tipo di riconoscimento. In caso contrario, il <xref:System.Messaging.Message.Acknowledgment%2A> proprietà contiene il valore `Normal`.  
  
 Utilizzare il <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà del messaggio originale per specificare le condizioni in cui verranno restituiti riconoscimenti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the queue that receives the acknowledgement messages that Message Queuing generates.</summary>
        <value>Il <see cref="T:System.Messaging.MessageQueue" /> che specifica la coda di amministrazione utilizzata per i messaggi di riconoscimento generati dal sistema. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La coda specificata nella <xref:System.Messaging.Message.AdministrationQueue%2A> proprietà può essere una coda non transazionale. I messaggi di riconoscimento inviati alla coda di amministrazione possono indicare se il messaggio originale ha raggiunto la coda di destinazione e se è stato rimosso dalla coda.  
  
 Quando il <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà ha un valore diverso da `None`, l'applicazione di invio deve specificare la coda da usare come coda di amministrazione.  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio contenente un ordine da e verso una coda. Richiede un riconoscimento positivo in particolare quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.AdministrationQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets additional, application-specific information.</summary>
        <value>Informazioni specifiche per l'applicazione. Il valore predefinito è zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.AppSpecific%2A> proprietà contiene informazioni specifiche dell'applicazione che è possibile utilizzare per organizzare diversi tipi di messaggi. Ad esempio, è possibile utilizzare indici specifici dell'applicazione. È compito dell'applicazione per interpretare <xref:System.Messaging.Message.AppSpecific%2A> informazioni sulle proprietà.  
  
 Laddove possibile, è necessario includere i dati del messaggio nel corpo del messaggio anziché il <xref:System.Messaging.Message.AppSpecific%2A> proprietà.  
  
 Quando si utilizzano code esterne, utilizzare il <xref:System.Messaging.Message.Extension%2A> proprietà per specificare le proprietà di messaggio che non esistono in Accodamento messaggi. Come con la <xref:System.Messaging.Message.AppSpecific%2A> proprietà, è compito dell'applicazione da riconoscere il contenuto del <xref:System.Messaging.Message.Extension%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.AppSpecific" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the message arrived in the destination queue.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> che rappresenta l'ora di arrivo del messaggio nella coda di destinazione. L'ora è aggiornata rispetto a GMT all'ora locale del computer in cui risiede la coda di destinazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il messaggio <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà indica con quale velocità deve ricevere il messaggio dalla coda di destinazione. Il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà timer viene avviato quando viene inviato il messaggio, non quando il messaggio arriva nella coda.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.ArrivedTime%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.ArrivedTime" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the sender ID should be attached to the message.</summary>
        <value>
          <see langword="true" /> Se il <see cref="P:System.Messaging.Message.SenderId" /> deve essere collegato al messaggio; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.SenderId%2A> proprietà è una matrice di byte che rappresenta l'identificatore del mittente. L'ID mittente impostata da Accodamento e viene utilizzato dal gestore delle code ricevente per verificare se il mittente disponga di diritti di accesso a una coda.  
  
 L'assenza dell'ID mittente un'indicazione dall'applicazione mittente che Accodamento messaggi deve convalidare il mittente del messaggio non verificare l'accesso del mittente diritti alla coda di ricezione. Il <xref:System.Messaging.Message.SenderId%2A> sia attendibile solo se il messaggio è stato autenticato quando ha raggiunto la coda di destinazione. Il messaggio viene rifiutato quando raggiunge la coda di destinazione se la coda accetta solo messaggi autenticati e il <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> o il <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> è di proprietà `false`.  
  
> [!CAUTION]
>  Se un messaggio viene rifiutato, viene inviato alla coda inattiva (se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è `true`), o viene ignorata. È possibile richiedere i riconoscimenti quando un messaggio non riesce a raggiungere la coda. In caso contrario, quando <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è `false` il messaggio potrebbe andare perso senza alcun avviso.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.AttachSenderId%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.AttachSenderId" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the message was authenticated.</summary>
        <value>
          <see langword="true" /> Se è stata richiesta l'autenticazione per il messaggio all'ingresso nella coda. in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.Authenticated%2A> proprietà viene utilizzata solo dall'applicazione durante l'interazione con il messaggio e il tentativo di determinare se è stata richiesta l'autenticazione. Se il messaggio nella coda, il messaggio è stato autenticato. Viceversa, se il <xref:System.Messaging.Message.Authenticated%2A> proprietà `true`, il gestore delle code ricevente autenticato il messaggio quando ricevuto il messaggio.  
  
 Non è possibile determinare se un messaggio di autenticazione non riuscita, esaminando le relative proprietà. Accodamento messaggi Elimina i messaggi che l'autenticazione non riesce prima che vengano recapitati alla coda. Tuttavia, è possibile richiedere che un messaggio di riconoscimento verrà inviato se un errore di recapito impedisce che il messaggio arriva nella coda.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.Authenticated%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Authenticated" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the cryptographic provider used to generate the digital signature of the message.</summary>
        <value>Il nome del provider di crittografia utilizzato per generare la firma digitale del messaggio. Il valore predefinito è Microsoft Enhanced Cryptographic Provider versione 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere si usa il <xref:System.Messaging.Message.AuthenticationProviderName%2A> quando si utilizzano code esterne. Accodamento messaggi richiede il nome del provider di autenticazione e il tipo di provider di autenticazione del provider di crittografia (provider di autenticazione) per convalidare le firme digitali dei messaggi inviati a una coda esterna sia messaggi passati al messaggio Accodamento messaggi da una coda esterna.  
  
 Quando si invia un messaggio, impostare sempre la <xref:System.Messaging.Message.AuthenticationProviderName%2A> e <xref:System.Messaging.Message.ConnectorType%2A> proprietà contemporaneamente. Quando il messaggio viene inviato, Accodamento messaggi ignora il nome del provider di autenticazione se il tipo di connettore non è impostato anche.  
  
 Il <xref:System.Messaging.Message.AuthenticationProviderName%2A> proprietà non può essere `null`, ma può essere una stringa vuota ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> property could not be set.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> property.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> was set to <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of cryptographic provider used to generate the digital signature of the message.</summary>
        <value>Uno dei valori di <see cref="T:System.Messaging.CryptographicProviderType" />. Il valore predefinito è <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere si usa il <xref:System.Messaging.Message.AuthenticationProviderType%2A> proprietà quando si lavora con le code esterne per specificare il servizio di crittografia associato a un messaggio. Accodamento messaggi richiede il nome del provider di autenticazione e il tipo di provider di autenticazione del provider di crittografia (provider di autenticazione) per convalidare le firme digitali dei messaggi inviati a una coda esterna sia messaggi passati al messaggio Accodamento messaggi da una coda esterna.  
  
 Solo `RsaFull` dovrà essere utilizzato con la messaggistica.  
  
 Quando si invia un messaggio, impostare sempre la <xref:System.Messaging.Message.AuthenticationProviderType%2A> e <xref:System.Messaging.Message.ConnectorType%2A> proprietà contemporaneamente. Quando il messaggio viene inviato, Accodamento messaggi ignora il tipo di provider di autenticazione se il tipo di connettore non è impostato anche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> property could not be set.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the content of the message.</summary>
        <value>Oggetto che specifica il contenuto del messaggio. L'oggetto può essere una stringa, una data, valuta, un numero, una matrice di byte o qualsiasi oggetto gestito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il messaggio <xref:System.Messaging.Message.Body%2A> proprietà contiene in genere i dati associati con il messaggio. Anche se è anche possibile inviare i dati specifici dell'applicazione <xref:System.Messaging.Message.AppSpecific%2A> e <xref:System.Messaging.Message.Extension%2A> delle proprietà, è necessario includere dati del messaggio nel <xref:System.Messaging.Message.Body%2A> del messaggio laddove possibile. Solo il <xref:System.Messaging.Message.Body%2A> del contenuto della proprietà è serializzato né crittografato.  
  
 Il <xref:System.Messaging.Message.Body%2A> proprietà può contenere qualsiasi oggetto le cui dimensioni non superiori a 4 MB. Se si utilizza <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> per inviare qualsiasi oggetto che non è di tipo <xref:System.Messaging.Message> per il <xref:System.Messaging.MessageQueue>, tale oggetto viene collocato nella <xref:System.Messaging.Message.Body%2A> proprietà del <xref:System.Messaging.Message> istanza restituita dalla <xref:System.Messaging.MessageQueue.Peek%2A> o <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 L'argomento stringa in `MessageQueue.Send("hello.")` è riportato un esempio di un oggetto di questo tipo generico.  
  
 Il <xref:System.Messaging.Message.BodyType%2A> proprietà indica il tipo di informazioni archiviate nel corpo del messaggio. Accodamento messaggi utilizza queste informazioni per identificare il tipo del <xref:System.Messaging.Message.Body%2A> del contenuto della proprietà.  
  
 Specificare il <xref:System.Messaging.Message.Body%2A> proprietà o il <xref:System.Messaging.Message.BodyStream%2A> proprietà prima di inviare il <xref:System.Messaging.Message> oggetto. Il <xref:System.Messaging.Message.Body%2A> proprietà può essere qualsiasi oggetto serializzabile, ad esempio una stringa di testo, oggetto della struttura, un'istanza di classe o oggetto incorporato.  
  
 A meno che non si scrive il contenuto del messaggio direttamente il <xref:System.Messaging.Message.BodyStream%2A> impostare la proprietà, il <xref:System.Messaging.Message.Formatter%2A> proprietà prima di inviare il messaggio. Quando il <xref:System.Messaging.MessageQueue.Send%2A> metodo viene chiamato sul <xref:System.Messaging.MessageQueue> istanza, il corpo viene serializzato utilizzando il formattatore contenuto nella <xref:System.Messaging.Message.Formatter%2A> proprietà. Se si invia il messaggio senza specificare un valore per il <xref:System.Messaging.Message.Formatter%2A> , il formattatore il valore predefinito proprietà <xref:System.Messaging.XmlMessageFormatter>.  
  
> [!NOTE]
>  Tentativo di impostare il corpo di un messaggio da <xref:System.Decimal.MaxValue> causerà un <xref:System.OverflowException> quando il `Send` metodo del <xref:System.Messaging.MessageQueue> classe è detta e <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato.  
  
   
  
## Examples  
 Esempio di codice seguente invia due messaggi con priorità diverse per la coda e successivamente recuperati.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Messaging.Message.Formatter" /> property is <see langword="null" />.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Body" /> property.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the information in the body of the message.</summary>
        <value>Un <see cref="T:System.IO.Stream" /> che contiene le informazioni serializzate incluso nel <see cref="P:System.Messaging.Message.Body" /> del messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il corpo di un messaggio può essere costituito da qualsiasi tipo di informazioni, ad esempio, una stringa, una data, valuta, un numero, una matrice di byte o qualsiasi oggetto gestito. Questa informazione viene serializzata in un <xref:System.IO.Stream> deve essere passato alla coda.  
  
 Specificare il <xref:System.Messaging.Message.Body%2A> proprietà o il <xref:System.Messaging.Message.BodyStream%2A> proprietà prima di inviare il <xref:System.Messaging.Message> oggetto. Se si imposta la <xref:System.Messaging.Message.Body%2A> proprietà, il contenuto viene serializzato nel <xref:System.Messaging.Message.BodyStream%2A> proprietà. Tuttavia, è possibile scegliere di scrivere il <xref:System.Messaging.Message.BodyStream%2A> proprietà direttamente. Ciò è utile, ad esempio, quando si desidera aprire una connessione a un file e il contenuto del flusso come corpo del messaggio.  
  
 A meno che non si scrive il contenuto del messaggio direttamente il <xref:System.Messaging.Message.BodyStream%2A> impostare la proprietà, il <xref:System.Messaging.Message.Formatter%2A> proprietà prima di inviare il messaggio. Quando il <xref:System.Messaging.MessageQueue.Send%2A> metodo viene chiamato sul <xref:System.Messaging.MessageQueue> istanza, il corpo viene serializzato utilizzando il formattatore contenuto nella <xref:System.Messaging.Message.Formatter%2A> proprietà. Se si invia il messaggio senza specificare un valore per il <xref:System.Messaging.Message.Formatter%2A> , il formattatore il valore predefinito proprietà <xref:System.Messaging.XmlMessageFormatter>.  
  
 Se si imposta la <xref:System.Messaging.Message.UseEncryption%2A> proprietà da `true` per il corpo del messaggio, il messaggio sarà crittografato quando viene inviato, non quando si imposta la <xref:System.Messaging.Message.Body%2A> proprietà. Pertanto, il <xref:System.Messaging.Message.BodyStream%2A> proprietà non verrà mai crittografata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Body" /> property.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of data that the message body contains.</summary>
        <value>Tipo true del corpo del messaggio, ad esempio una stringa, una data, valuta o un numero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il servizio Accodamento messaggi riconosce il contenuto del corpo come un oggetto o un flusso serializzato. Il <xref:System.Messaging.Message.BodyType%2A> proprietà indica il tipo di oggetto all'interno di <xref:System.Messaging.Message.Body%2A> proprietà del messaggio.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> esegue l'associazione tra i tipi nativi e l'oggetto nel corpo del messaggio. Se si utilizza il <xref:System.Messaging.XmlMessageFormatter>, il formattatore imposterà automaticamente la <xref:System.Messaging.Message.BodyType%2A> proprietà per l'utente.  
  
 Altri formattatori possono fornire funzionalità di associazione anche, come illustrato nel codice c# seguente.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.BodyType%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Body" /> property.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates that some message properties typically set by Message Queuing were set by the sending application.</summary>
        <value>Oggetto <see cref="T:System.Guid" /> definito dall'applicazione e utilizzato in combinazione con applicazioni di connessione o la crittografia dei messaggi. Ciò <see cref="T:System.Guid" /> consente a un'applicazione ricevente interpretare le proprietà del messaggio che sono state impostate dall'applicazione mittente ma che in genere vengono impostate da Accodamento messaggi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accodamento messaggi richiede la <xref:System.Messaging.Message.ConnectorType%2A> impostata ogni volta che un'applicazione imposta una proprietà del messaggio che viene in genere impostata da Accodamento messaggi. Un'applicazione utilizza in genere un <xref:System.Messaging.Message.ConnectorType%2A> in due casi seguenti:  
  
-   Ogni volta che un'applicazione di connessione passa un messaggio. Il <xref:System.Messaging.Message.ConnectorType%2A> indica le applicazioni di inviare e ricezione come interpretare le proprietà di sicurezza e conferma del messaggio.  
  
-   Ogni volta che l'applicazione mittente, piuttosto che Accodamento messaggi, consente di crittografare un messaggio. Il <xref:System.Messaging.Message.ConnectorType%2A> indica ad Accodamento messaggi da utilizzare il <xref:System.Messaging.Message.DestinationSymmetricKey%2A> valore della proprietà per decrittografare il messaggio.  
  
 È necessario impostare il <xref:System.Messaging.Message.ConnectorType%2A> proprietà se si impostano le proprietà seguenti (in caso contrario, la coda ignora queste proprietà quando il messaggio viene inviato):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.ConnectorType" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the message identifier used by acknowledgment, report, and response messages to reference the original message.</summary>
        <value>Identificatore del messaggio specificato per il <see cref="P:System.Messaging.Message.Id" /> proprietà del messaggio originale. L'identificatore di correlazione viene utilizzato da Accodamento durante la generazione di un messaggio di riconoscimento o un report e da un'applicazione quando genera un messaggio di risposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il servizio Accodamento messaggi genera un messaggio di riconoscimento o di rapporto, utilizza la proprietà identificatore di correlazione per specificare l'identificatore del messaggio originale. In questo modo l'identificatore di correlazione unisce il rapporto o il messaggio di riconoscimento al messaggio originale.  
  
 Applicazione mittente può quindi far corrispondere il riconoscimento o un report con il messaggio originale utilizzando il <xref:System.Messaging.Message.CorrelationId%2A> proprietà per identificare il messaggio originale <xref:System.Messaging.Message.Id%2A> proprietà.  
  
 Le applicazioni connettore devono inoltre impostare il <xref:System.Messaging.Message.CorrelationId%2A> proprietà dei messaggi di riconoscimento e report per l'identificatore del messaggio del messaggio originale.  
  
 Quando l'applicazione invia un messaggio di risposta all'applicazione mittente, è possibile impostare il <xref:System.Messaging.Message.CorrelationId%2A> proprietà del messaggio di risposta per l'identificatore del messaggio del messaggio originale. Applicazione mittente può quindi far corrispondere il messaggio di risposta al messaggio inviato.  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio che contiene un ordine da e verso una coda. Richiede un riconoscimento positivo in particolare quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.CorrelationId" /> property.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.CorrelationId" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the intended destination queue for a message.</summary>
        <value>Oggetto <see cref="T:System.Messaging.MessageQueue" /> che specifica la coda di destinazione specificata per il messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.DestinationQueue%2A> proprietà viene in genere utilizzata per determinare la destinazione originale di un messaggio che si trova in una coda journal o inattiva. In genere, non è necessario esaminare questa proprietà, perché in genere è recuperare il messaggio dalla coda di destinazione.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.DestinationQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.DestinationQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the symmetric key used to encrypt application-encrypted messages or messages sent to foreign queues.</summary>
        <value>Matrice di valori di byte che specifica la chiave simmetrica di destinazione utilizzata per crittografare il messaggio. Il valore predefinito è una matrice di lunghezza zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due scenari è necessario utilizzare il <xref:System.Messaging.Message.DestinationSymmetricKey%2A> proprietà. Il primo viene utilizzato quando l'applicazione, anziché con Accodamento messaggi, consente di crittografare un messaggio. Il secondo è quando si invia un messaggio crittografato a un sistema di accodamento diverso da Accodamento messaggi.  
  
 Prima di impostare questa proprietà, è necessario crittografare la chiave simmetrica con la chiave pubblica del gestore delle code ricevente. Quando si invia un messaggio crittografato dall'applicazione, il gestore delle code ricevente utilizza la chiave simmetrica per decrittografare il messaggio prima dell'invio alla coda di destinazione.  
  
 Se si invia un messaggio a una coda esterna, il messaggio viene prima ricevuto dall'applicazione di connettore appropriato, che inoltra il messaggio crittografato con la chiave simmetrica associata all'applicazione ricevente. È compito dell'applicazione ricevente per decrittografare il messaggio utilizzando la chiave simmetrica.  
  
 Quando si imposta la <xref:System.Messaging.Message.DestinationSymmetricKey%2A> , è necessario impostare anche la <xref:System.Messaging.Message.ConnectorType%2A> proprietà. Quando il messaggio viene inviato, Accodamento messaggi non viene fatta la <xref:System.Messaging.Message.DestinationSymmetricKey%2A> proprietà se il <xref:System.Messaging.Message.ConnectorType%2A> non proprietà è impostata.  
  
 Il <xref:System.Messaging.Message.DestinationSymmetricKey%2A> proprietà ha una dimensione di matrice massima pari a 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> property.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the digital signature that Message Queuing uses to authenticate the message.</summary>
        <value>Matrice di valori di byte che specifica la firma digitale di Accodamento messaggi 1.0 utilizzata per autenticare il messaggio. Il valore predefinito è una matrice di lunghezza zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accodamento messaggi utilizza la firma digitale per autenticare i messaggi che sono stati inviati dalla versione 1.0 di Accodamento messaggi. Nella maggior parte dei casi, il servizio Accodamento messaggi genera l'errore e imposta il <xref:System.Messaging.Message.DigitalSignature%2A> proprietà quando l'applicazione mittente lo richiede l'autenticazione. L'applicazione ricevente utilizza questa proprietà per recuperare la firma digitale allegata al messaggio.  
  
 È possibile utilizzare solo il <xref:System.Messaging.Message.DigitalSignature%2A> proprietà durante l'esecuzione di Accodamento messaggi versione 2.0. Quando richiede l'autenticazione, è necessario specificare le firme versione 1.0 di Accodamento messaggi all'applicazione mittente. Se l'applicazione mittente invia una firma di versione 2.0 accodamento, questa proprietà contiene un buffer di quattro byte, ciascuno contenente zero.  
  
 Il <xref:System.Messaging.Message.DigitalSignature%2A> proprietà, insieme con il <xref:System.Messaging.Message.SenderCertificate%2A> proprietà, viene inoltre utilizzata dalle applicazioni di connessione quando viene inviato un messaggio. In questo scenario, l'applicazione di connessione, invece di Accodamento messaggi, genera la firma digitale, basata sul certificato dell'utente che invia il messaggio.  
  
 Il <xref:System.Messaging.Message.DigitalSignature%2A> proprietà ha una dimensione di matrice massima pari a 256.  
  
 Quando si imposta la <xref:System.Messaging.Message.DigitalSignature%2A> , è necessario impostare anche la <xref:System.Messaging.Message.ConnectorType%2A> proprietà. Quando viene inviato un messaggio, Accodamento messaggi non viene fatta la <xref:System.Messaging.Message.DigitalSignature%2A> proprietà se il <xref:System.Messaging.Message.ConnectorType%2A> non proprietà è impostata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.DigitalSignature" /> property.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.DigitalSignature" /> property is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the encryption algorithm used to encrypt the body of a private message.</summary>
        <value>Uno dei valori dell'enumerazione <see cref="T:System.Messaging.EncryptionAlgorithm" />. Il valore predefinito è <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un messaggio è privato (crittografata) viene crittografato prima che venga inviato e decrittografato al momento della ricezione. Il <xref:System.Messaging.Message.EncryptionAlgorithm%2A> proprietà specifica l'algoritmo utilizzato per crittografare il corpo di un messaggio privato.  
  
 Una coda può richiedere che in ingresso dei messaggi crittografati. Se un'applicazione invia un messaggio di (pubblici) non crittografato a una coda che accetta solo messaggi privati o invia un messaggio privato a una coda che accetta solo messaggi non privati, la coda rifiuta il messaggio. Applicazione mittente può richiedere che in tal caso essere restituito un messaggio di riconoscimento negativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets additional, application-defined information associated with the message.</summary>
        <value>Matrice di valori byte che fornisce informazioni definite dall'applicazione associate al messaggio. Il valore predefinito è una matrice di lunghezza zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.Extension%2A> proprietà fornisce informazioni aggiuntive definite dall'applicazione, come un oggetto binario di grandi dimensioni, che è associato il messaggio. È compito dell'applicazione ricevente per interpretare il contenuto del <xref:System.Messaging.Message.Extension%2A> proprietà.  
  
 Dove possibile, è necessario includere dati del messaggio nel <xref:System.Messaging.Message.Body%2A> proprietà del messaggio anziché il <xref:System.Messaging.Message.Extension%2A> proprietà.  
  
 Quando si utilizzano code esterne, utilizzare il <xref:System.Messaging.Message.Extension%2A> proprietà per specificare le proprietà di messaggio che non esistono in Accodamento messaggi.  
  
 Esiste una coda esterna in un sistema di accodamento diverso da Accodamento messaggi Microsoft. Il servizio Accodamento messaggi comunica con queste code tramite un'applicazione di connessione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Extension" /> property.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.Extension" /> property is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the formatter used to serialize an object into or deserialize an object from the message body.</summary>
        <value>Il <see cref="T:System.Messaging.IMessageFormatter" /> che produce un flusso da scrivere o leggere dal corpo del messaggio. Il valore predefinito è <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Messaging.Message.Formatter%2A> proprietà durante la lettura e scrittura di un messaggio. Quando un messaggio viene inviato alla coda, il formattatore serializza i <xref:System.Messaging.Message.Body%2A> proprietà in un flusso che può essere inviato alla coda dei messaggi. Durante la lettura da una coda, il formattatore deserializza i dati del messaggio nel <xref:System.Messaging.Message.Body%2A> proprietà.  
  
 A meno che non si scrive il contenuto del messaggio direttamente il <xref:System.Messaging.Message.BodyStream%2A> impostare la proprietà, il <xref:System.Messaging.Message.Formatter%2A> proprietà prima di inviare il messaggio. Quando il <xref:System.Messaging.MessageQueue.Send%2A> metodo viene chiamato sul <xref:System.Messaging.MessageQueue> istanza, il corpo viene serializzato utilizzando il formattatore contenuto nella <xref:System.Messaging.Message.Formatter%2A> proprietà. Se si invia il messaggio senza specificare un valore per il <xref:System.Messaging.Message.Formatter%2A> , il formattatore il valore predefinito proprietà <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> è regime, pertanto non è necessario avere lo stesso oggetto di tipo per il mittente e ricevitore quando si utilizza questo formato. Il <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializzare i dati in una rappresentazione binaria. Il <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato durante l'invio o la ricezione di componenti COM.  
  
   
  
## Examples  
 Esempio di codice seguente illustra la formattazione di un corpo del messaggio tramite <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Esempio di codice seguente illustra la formattazione di un corpo del messaggio tramite <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.Formatter" /> property is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the hashing algorithm that Message Queuing uses when authenticating a message or creating a digital signature for a message.</summary>
        <value>Uno dei valori dell'enumerazione <see cref="T:System.Messaging.HashAlgorithm" />. Per Windows XP, il valore predefinito è <see langword="SHA" />. In caso contrario, il valore predefinito è <see langword="MD5" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel computer di origine, Accodamento messaggi utilizza l'algoritmo di hash durante la creazione di una firma digitale di un messaggio. Il gestore delle code di destinazione utilizza quindi lo stesso algoritmo hash per autenticare il messaggio quando viene ricevuto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.HashAlgorithm" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the message's identifier.</summary>
        <value>L'identificatore univoco del messaggio, che viene generato da Accodamento messaggi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accodamento messaggi genera un identificatore di messaggio quando viene inviato il messaggio. L'identificatore è composto da 20 byte e comprende due elementi: la macchina <xref:System.Guid> del computer mittente e un identificatore univoco per il messaggio nel computer. La combinazione dei due elementi genera un identificatore di messaggio univoco per la rete.  
  
 Accodamento messaggi genera identificatori di messaggio per tutti i messaggi, inclusi i messaggi di riconoscimento e di report. Un messaggio di riconoscimento viene in genere inviato dall'Accodamento messaggi in risposta all'arrivo o negativo di un messaggio originale inviato. È possibile trovare il <xref:System.Messaging.Message.Id%2A> valore della proprietà del messaggio originale nel <xref:System.Messaging.Message.CorrelationId%2A> proprietà di un messaggio di riconoscimento.  
  
 È anche possibile usare il <xref:System.Messaging.Message.Id%2A> proprietà quando si invia un messaggio di risposta a una coda di risposta. Per includere l'identificatore del messaggio originale in un messaggio di risposta, impostare il <xref:System.Messaging.Message.CorrelationId%2A> proprietà del messaggio di risposta per la <xref:System.Messaging.Message.Id%2A> proprietà del messaggio originale. L'applicazione che legge il messaggio di risposta può quindi utilizzare l'identificatore di correlazione del messaggio di risposta per identificare il messaggio originale.  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio contenente un ordine da e verso una coda. Richiede un riconoscimento positivo in particolare quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Id" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies that no time-out exists.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> e <xref:System.Messaging.Message.TimeToReachQueue%2A> richiedono un valore che specifica un timeout. Nel primo caso, il timeout è il tempo massimo consentito per un messaggio venga ricevuto dalla coda. Nel secondo caso, il timeout è il tempo consentito per un messaggio raggiungere la coda. In entrambi i casi, è possibile specificare il timeout come un numero di secondi o usare <xref:System.Messaging.Message.InfiniteTimeout> per indicare che è presente alcun timeout.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Messaging.Message.InfiniteTimeout> campo.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the message was the first message sent in a transaction.</summary>
        <value>
          <see langword="true" /> Se il messaggio è stato il primo messaggio inviato durante una transazione. in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione ricevente utilizza il <xref:System.Messaging.Message.IsFirstInTransaction%2A> per verificare se un messaggio è il primo messaggio inviato in una singola transazione a una singola coda.  
  
 Questa proprietà è disponibile solo con Accodamento messaggi versione 2.0 e versioni successive.  
  
 Per verificare i limiti delle transazioni, è possibile usare il <xref:System.Messaging.Message.IsFirstInTransaction%2A> proprietà, con altre due proprietà: <xref:System.Messaging.Message.IsLastInTransaction%2A> e <xref:System.Messaging.Message.TransactionId%2A>. Utilizzare il prima possibile per controllare se un messaggio è l'ultimo messaggio inviato nella transazione e utilizzare quest'ultimo per recuperare l'ID della transazione.  
  
 Se solo un messaggio viene inviato in una transazione, il <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.IsLastInTransaction%2A> sono entrambe impostate su `true`.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.IsFirstInTransaction%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.IsFirstInTransaction" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the message was the last message sent in a transaction.</summary>
        <value>
          <see langword="true" /> Se il messaggio è stato l'ultimo messaggio inviato in una singola transazione. in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione ricevente utilizza il <xref:System.Messaging.Message.IsLastInTransaction%2A> per verificare se un messaggio è l'ultimo messaggio inviato in una singola transazione a una singola coda.  
  
 Questa proprietà è disponibile solo con Accodamento messaggi versione 2.0 e versioni successive.  
  
 Per verificare i limiti delle transazioni, è possibile usare il <xref:System.Messaging.Message.IsLastInTransaction%2A> proprietà, con altre due proprietà: <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.TransactionId%2A>. Utilizzare il prima possibile per controllare se un messaggio è il primo messaggio inviato nella transazione e utilizzare quest'ultimo per recuperare l'ID della transazione.  
  
 Se solo un messaggio viene inviato in una transazione, il <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.IsLastInTransaction%2A> sono entrambe impostate su `true`.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.IsLastInTransaction%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.IsLastInTransaction" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an application-defined Unicode string that describes the message.</summary>
        <value>L'etichetta del messaggio. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare un'etichetta di messaggio per diversi scopi. Un'etichetta di messaggio può essere utilizzata per scopi di visualizzazione o per elaborare in modo selettivo i messaggi sulla base del valore dell'etichetta. L'etichetta non dovrà essere univoco all'interno dei messaggi.  
  
 La coda e le etichette di messaggio rappresentano un valore definito dall'applicazione in grado di identificare la coda o il messaggio in termini leggibili. È responsabilità dell'applicazione per interpretare il contenuto di etichetta, che non hanno alcun significato intrinseco per l'applicazione di Accodamento messaggi.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.Label%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Label" /> property.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introduced in MSMQ 3.0. Gets the message's lookup identifier.</summary>
        <value>Identificatore di ricerca del messaggio, che viene generato da Accodamento messaggi ed è univoco per la coda in cui si trova il messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà fornisce l'accesso di sola lettura all'identificatore di ricerca del messaggio. L'identificatore di ricerca, introdotto in MSMQ 3.0, è un identificatore a 64 bit che viene generato da Accodamento messaggi e assegnato a ogni messaggio quando il messaggio viene inserito nella coda. L'identificatore di ricerca non è uguale all'identificatore del messaggio che viene generato quando viene inviato il messaggio.  
  
 Accodamento messaggi genera un identificatore di ricerca per tutti i messaggi che vengono inseriti in una coda, tra cui generati dall'applicazione di destinazione, amministrazione, le code del report, nonché journal generati dal sistema, messaggi non recapitabili, connettore e in uscita. In altre parole, sono inclusi entrambi i messaggi inviati dalle applicazioni mittenti e da Accodamento messaggi. L'identificatore di ricerca è univoco per la coda e non ha significato all'esterno della coda.  
  
 Se un messaggio viene inviato a diverse code di destinazione oppure una copia di un messaggio viene archiviata in un journal del computer o della coda, ogni copia del messaggio avrà un proprio identificatore di ricerca quando viene inserito nella rispettiva coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà può essere letta solo messaggi recuperati da una coda.  
  
 Un identificatore di ricerca viene utilizzato per leggere un messaggio specifico nella coda. Una volta che è nota l'identificatore di ricerca di un messaggio, l'applicazione ricevente può chiamare la <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> o <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> (funzione) per passare direttamente al messaggio e leggere o recuperare dalla coda, a differenza dei cursori che deve iniziare all'inizio della coda e Spostarsi verso la fine della coda,  
  
 Ottenere gli identificatori di ricerca dei messaggi nella coda è responsabilità dell'applicazione. Uno dei modi per ottenere gli identificatori di ricerca consiste nel creare un trigger per la coda di destinazione che richiama un componente che memorizza nella cache gli identificatori di ogni messaggio quando vengono inseriti nella coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.LookupId" /> property.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the message type: <see langword="Normal" />, <see langword="Acknowledgment" />, or <see langword="Report" />.</summary>
        <value>Uno dei valori di <see cref="P:System.Messaging.Message.MessageType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accodamento messaggi in genere imposta questa proprietà quando invia il messaggio. Il tipo di un messaggio di accodamento messaggi può essere uno dei seguenti:  
  
-   `Normal`, quale un tipico messaggio inviato da un'applicazione a una coda o un messaggio di risposta restituito all'applicazione mittente.  
  
-   `Acknowledgement`, Accodamento messaggi generato ogni volta che l'applicazione mittente lo richiede. Accodamento messaggi, ad esempio, può generare messaggi positivi o negativi per comunicare l'arrivo o la lettura del messaggio originale. Accodamento messaggi restituisce il messaggio di conferma appropriato alla coda di amministrazione specificata dall'applicazione mittente.  
  
-   `Report`, Accodamento messaggi generato ogni volta che una coda dei rapporti è definita nel gestore delle code di origine. Quando la traccia è abilitata, l'accodamento messaggi invia un messaggio di rapporto alla coda di rapporti di accodamento messaggi ogni volta che il messaggio originale viene ricevuto o trasmesso da un server di accodamento messaggi.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.MessageType%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.MessageType" /> property.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the message priority, which determines where in the queue the message is placed.</summary>
        <value>Uno del <see cref="T:System.Messaging.MessagePriority" /> valori che rappresentano i livelli di priorità dei messaggi non transazionali. Il valore predefinito è <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.Priority%2A> proprietà influisce sul modo in cui il servizio Accodamento messaggi gestisce il messaggio sia durante l'indirizzamento e una volta raggiunta la destinazione. I messaggi con priorità superiore hanno la precedenza durante l'instradamento e vengono inseriti nella parte anteriore della coda. I messaggi con la stessa priorità vengono inseriti nella coda in base all'ora di arrivo.  
  
 È possibile impostare una priorità significativa solo per i messaggi non transazionali. Accodamento messaggi imposta automaticamente la priorità per i messaggi transazionali per `Lowest`, che comporta l'esecuzione priorità messaggio transazionale viene ignorata.  
  
   
  
## Examples  
 Esempio di codice seguente invia due messaggi con priorità diverse per la coda e successivamente recuperati.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Priority" /> property.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the message is guaranteed to be delivered in the event of a computer failure or network problem.</summary>
        <value>
          <see langword="true" /> Se è garantito il recapito del messaggio (tramite il salvataggio sul disco durante l'indirizzamento); <see langword="false" /> se per il recapito non è garantito. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.Recoverable%2A> proprietà indica se è garantito il recapito di un messaggio, anche se il computer si blocca durante il messaggio di indirizzamento alla coda di destinazione.  
  
 Se è garantito il recapito di un messaggio, il messaggio viene archiviato in locale in ogni fase della route, fino a quando il messaggio viene inoltrato al computer successivo. Impostazione di <xref:System.Messaging.Message.Recoverable%2A> proprietà `true` potrebbero avere effetto sulla velocità effettiva.  
  
 Se il messaggio è transazionale, Accodamento messaggi gestisce automaticamente il messaggio come recuperabile, indipendentemente dal valore della <xref:System.Messaging.Message.Recoverable%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.Recoverable%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Recoverable" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the queue that receives application-generated response messages.</summary>
        <value>Il <see cref="T:System.Messaging.MessageQueue" /> per la risposta generati dall'applicazione vengono restituiti i messaggi. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.ResponseQueue%2A> proprietà identifica la coda che riceve i messaggi di risposta generati dall'applicazione, che restituisce l'applicazione ricevente all'applicazione mittente. Le code di risposta vengono specificate dall'applicazione mittente all'invio dei messaggi. È possibile specificare come coda di risposta qualsiasi coda disponibile.  
  
 I messaggi restituiti alla coda di risposta sono specifici dell'applicazione. È necessario che l'applicazione definisca il contenuto dei messaggi, nonché le operazioni da eseguire alla ricezione del messaggio.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.ResponseQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.ResponseQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the security context for a message.</summary>
        <value>Oggetto <see cref="T:System.Messaging.SecurityContext" /> oggetto che contiene il contesto di sicurezza per un messaggio, se in precedenza è stata impostata la proprietà; in caso contrario NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the security certificate used to authenticate messages.</summary>
        <value>Matrice di valori di byte che rappresenta un certificato di sicurezza, Accodamento messaggi utilizza per verificare il mittente del messaggio. Il valore predefinito è una matrice di lunghezza zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Applicazione di ricezione utilizza la <xref:System.Messaging.Message.SenderCertificate%2A> proprietà quando il messaggio include un certificato di sicurezza esterno.  
  
 In Accodamento messaggi può autenticare un messaggio utilizzando un certificato di sicurezza interni o esterni. Accodamento messaggi fornisce certificati interni, che vengono usati per verificare l'integrità del messaggio. Un'autorità di certificazione fornisce un certificato esterno che è possibile accedere tramite il <xref:System.Messaging.Message.SenderCertificate%2A> proprietà del messaggio. Oltre a consentire di Accodamento per autenticare il messaggio, un certificato esterno consente all'applicazione ricevente verificare ulteriormente il mittente. Nessun valore utilizzabile da un'applicazione ricevente un certificato interno.  
  
 Un certificato esterno deve essere registrato con il servizio directory di sistema di Accodamento. Un certificato esterno contiene informazioni sull'autorità di certificazione, l'utente del certificato, il periodo di validità del certificato, la chiave pubblica dell'utente del certificato e la firma dell'autorità di certificazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.SenderCertificate" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the identifier of the sending user.</summary>
        <value>Matrice di valori di byte che identifica il mittente. Il gestore delle code ricevente utilizza l'identificatore quando si autentica il messaggio per verificare il mittente del messaggio e diritti di accesso del mittente per la coda.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Messaging.Message.AttachSenderId%2A> proprietà è `false`, l'identificatore del mittente specificato nella <xref:System.Messaging.Message.SenderId%2A> proprietà non è associata al messaggio durante l'invio. Indica che il mittente non deve essere convalidato quando invia il messaggio alla coda di destinazione per Accodamento messaggi. Se il <xref:System.Messaging.Message.AttachSenderId%2A> proprietà è `true`, il <xref:System.Messaging.Message.SenderId%2A> valore della proprietà sia attendibile solo se il messaggio è stato autenticato. Usare la <xref:System.Messaging.Message.Authenticated%2A> proprietà in combinazione con il <xref:System.Messaging.Message.SenderId%2A> per verificare i diritti di accesso del mittente.  
  
 Un'applicazione di connessione è un'applicazione che utilizza un server del connettore per consentire la comunicazione tra il servizio Accodamento messaggi e altri sistemi di Accodamento. Accodamento messaggi richiede alle applicazioni di connettore di fornire l'identificazione del mittente. È necessario impostare il <xref:System.Messaging.Message.ConnectorType%2A> proprietà quando si invia un messaggio tramite un'applicazione di connessione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.SenderId" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the version of Message Queuing used to send the message.</summary>
        <value>La versione di Accodamento messaggi consente di inviare il messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.SenderVersion%2A> proprietà è importante per determinate funzionalità. Ad esempio, l'elaborazione delle transazioni è supportato solo da Accodamento messaggi 2.0 e versioni successive e le firme digitali vengono utilizzate per autenticare i messaggi inviati da MSMQ 1.0.  
  
 I set di gestore delle code mittente la <xref:System.Messaging.Message.SenderVersion%2A> proprietà quando viene inviato il messaggio.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.SenderVersion%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.SenderVersion" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the date and time on the sending computer that the message was sent by the source queue manager.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> che rappresenta l'ora di invio del messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.SentTime%2A> proprietà viene aggiornata all'ora locale del computer in cui l'istanza di <xref:System.Messaging.Message> classe è stata creata. In questo fuso orario può essere diverso da quelli delle code di origine e di destinazione.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.SentTime%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.SentTime" /> property.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the computer from which the message originated.</summary>
        <value>Il nome del computer da cui è stato inviato il messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il formato del <xref:System.Messaging.Message.SourceMachine%2A> proprietà non includere barre rovesciate due (\\\\). Ad esempio `myServer` è un valore valido <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.SourceMachine%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.SourceMachine" /> property.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The computer information or directory service could not be accessed.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum amount of time for the message to be received from the destination queue.</summary>
        <value>Il tempo totale per un messaggio venga ricevuto dalla coda di destinazione. Il valore predefinito è <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà specifica il tempo totale per un messaggio venga ricevuto dalla coda di destinazione. Il limite di tempo include il tempo impiegato per ottenere la coda di destinazione e il tempo di attesa nella coda prima che venga ricevuto il messaggio.  
  
> [!CAUTION]
>  Quando si usano i computer client dipendenti, assicurarsi che l'orologio del computer client è sincronizzato con l'orologio del server che esegue il servizio Accodamento messaggi. In caso contrario, potrebbe causare un comportamento imprevisto quando si invia un messaggio il cui <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà non è <xref:System.Messaging.Message.InfiniteTimeout>.  
  
 Se l'intervallo specificato per il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà scade prima che il messaggio viene rimosso dalla coda, Accodamento messaggi Elimina il messaggio in uno dei due modi. Se la proprietà <xref:System.Messaging.Message.UseDeadLetterQueue%2A> del messaggio è `true`, il messaggio viene inviato alla coda inattiva. Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è `false`, il messaggio viene ignorato.  
  
 È possibile impostare il messaggio <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà per richiedere che il servizio Accodamento messaggi invia un messaggio di riconoscimento negativo nuovamente all'applicazione mittente se il messaggio non viene recuperato prima della scadenza del timer.  
  
 Se il valore specificato per il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà è minore del valore specificato per il <xref:System.Messaging.Message.TimeToReachQueue%2A> proprietà, <xref:System.Messaging.Message.TimeToBeReceived%2A> ha la precedenza.  
  
 Quando più messaggi vengono inviati in una singola transazione, Accodamento messaggi utilizza il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà del primo messaggio.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.TimeToBeReceived" /> property.</exception>
        <exception cref="T:System.ArgumentException">The value specified for <see cref="P:System.Messaging.Message.TimeToBeReceived" /> is invalid.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum amount of time for the message to reach the queue.</summary>
        <value>Il limite di tempo per il messaggio raggiunga la coda di destinazione, a partire dal momento in cui il messaggio viene inviato. Il valore predefinito è <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'intervallo specificato per il <xref:System.Messaging.Message.TimeToReachQueue%2A> proprietà scade prima che il messaggio raggiunga la destinazione, Accodamento messaggi Elimina il messaggio in uno dei due modi. Se la proprietà <xref:System.Messaging.Message.UseDeadLetterQueue%2A> del messaggio è `true`, il messaggio viene inviato alla coda inattiva. Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è `false`, il messaggio viene ignorato  
  
 È possibile impostare del messaggio può <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà per richiedere che il servizio Accodamento messaggi invia un messaggio di riconoscimento negativo nuovamente all'applicazione mittente se il messaggio non arrivano prima della scadenza del timer.  
  
 Se il <xref:System.Messaging.Message.TimeToReachQueue%2A> è impostata su 0 secondi, Accodamento messaggi esegue un tentativo di inviare il messaggio alla destinazione, ovvero se la coda è in attesa del messaggio. Se la coda è locale, il messaggio raggiunge sempre.  
  
 Se il valore specificato per il <xref:System.Messaging.Message.TimeToReachQueue%2A> proprietà è maggiore del valore specificato per il <xref:System.Messaging.Message.TimeToBeReceived%2A> proprietà, <xref:System.Messaging.Message.TimeToBeReceived%2A> ha la precedenza.  
  
 Quando più messaggi vengono inviati in una singola transazione, Accodamento messaggi utilizza il <xref:System.Messaging.Message.TimeToReachQueue%2A> proprietà del primo messaggio.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.TimeToReachQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.TimeToReachQueue" /> property.</exception>
        <exception cref="T:System.ArgumentException">The value specified for <see cref="P:System.Messaging.Message.TimeToReachQueue" /> is invalid. It might represent a negative number.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the identifier for the transaction of which the message was a part.</summary>
        <value>L'identificatore per la transazione associata al messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione ricevente utilizza il <xref:System.Messaging.Message.TransactionId%2A> per verificare che un messaggio è stato inviato come parte di una transazione specifica. L'identificatore di transazione contiene l'identificatore del computer di invio (primi 16 bit) seguito da un numero di sequenza della transazione a 4 byte.  
  
 Questa proprietà è disponibile solo per il servizio Accodamento messaggi versione 2.0 e versioni successive.  
  
 Gli identificatori delle transazioni non sono necessariamente essere univoco, perché i numeri di sequenza delle transazioni non sono persistenti e ripartono 2 <sup>20</sup>. Accodamento messaggi garantisce solo che le transazioni successive avranno diversi numeri di sequenza.  
  
 È possibile usare il <xref:System.Messaging.Message.TransactionId%2A> proprietà lungo con il <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.IsLastInTransaction%2A> per verificare i limiti delle transazioni.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.TransactionId%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.TransactionId" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the transaction status queue on the source computer.</summary>
        <value>Coda di stato transazioni sul computer di origine, viene utilizzato per l'invio di messaggi di acknowledgement restituito all'applicazione mittente. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.TransactionStatusQueue%2A> proprietà identifica la coda transazionale nel computer di origine che riceve i riconoscimenti di conferma di lettura da applicazioni di connessione. Accodamento messaggi imposta la proprietà e le applicazioni di connettore utilizzano la proprietà durante il recupero di messaggi di transazione inviati alle code esterne.  
  
 Esiste una coda esterna in un sistema di accodamento diverso da Accodamento messaggi Microsoft. Il servizio Accodamento messaggi comunica con queste code tramite un'applicazione di connessione.  
  
 L'applicazione di connessione possa utilizzare la coda di stato di transazione per inviare messaggi di riconoscimento all'applicazione mittente. La coda di stato di transazione deve ricevere questi riconoscimenti anche se l'applicazione di invio non richiede altri.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di un messaggio <xref:System.Messaging.Message.TransactionStatusQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.TransactionStatusQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the message was (or must be) authenticated before being sent.</summary>
        <value>
          <see langword="true" /> Se l'applicazione di invio ha richiesto l'autenticazione del messaggio; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.UseAuthentication%2A> proprietà specifica se il messaggio deve essere autenticato. Se l'applicazione mittente lo richiede l'autenticazione, Accodamento messaggi consente di creare una firma digitale e lo usa per firmare il messaggio durante l'invio e autenticare il messaggio quando viene ricevuto.  
  
 Se <xref:System.Messaging.Message.UseAuthentication%2A> è `false` e viene inviato un messaggio a una coda che accetta solo messaggi autenticati, il messaggio verrà rifiutato quando raggiunge la coda.  
  
 Non è possibile determinare se un messaggio di autenticazione non riuscita, esaminando le relative proprietà. Accodamento messaggi elimina tali messaggi prima che vengano recapitati alla coda. Tuttavia, è possibile richiedere che un messaggio di riconoscimento verrà inviato se un errore di recapito impedisce che un messaggio arriva nella coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.UseAuthentication" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a copy of the message that could not be delivered should be sent to a dead-letter queue.</summary>
        <value>
          <see langword="true" /> Se il recapito dei messaggi deve rispettate, una copia del messaggio inviato a una coda di messaggi non recapitabili; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.UseJournalQueue%2A> e <xref:System.Messaging.Message.UseDeadLetterQueue%2A> specificano come il servizio Accodamento messaggi di traccia dei messaggi. Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è `true`, errore di recapito (di un messaggio non transazionale), fa sì che il messaggio da inviare alla coda non transazionale recapitabili sul computer che non è stato possibile recapitare il messaggio. Errore di recapito può essere provocato da un timer di messaggio che scade, ad esempio.  
  
 Nel caso di errore di recapito per un messaggio transazionale, Accodamento messaggi invia il messaggio alla coda inattiva transazionale nel computer di origine in tutti i casi negativi e in dubbio.  
  
 Quando si archiviano i messaggi in una coda di messaggi non recapitabili, è necessario cancellare la coda periodicamente per rimuovere i messaggi che non sono più necessari. Messaggi memorizzati nel recapitabili conteggio ai fini della quota di dimensioni per il computer in cui risiede la coda. La quota del computer è impostata dall'amministratore e si riferisce alle dimensioni allocate per memorizzare messaggi sull'intero computer, non solo in una singola coda.  
  
 Non si crea una coda del diario o inattiva. Sono entrambe code di sistema di Accodamento messaggi genera l'errore.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.UseDeadLetterQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to make the message private.</summary>
        <value>
          <see langword="true" /> per richiedere di Accodamento per crittografare il messaggio; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un messaggio è privato, il corpo viene crittografato prima che venga inviato e decrittografata quando vengono ricevuti. Per inviare un messaggio privato, l'applicazione di invio deve specificare che la crittografia utilizzabile e, facoltativamente, l'algoritmo di crittografia.  
  
 Quando si inviano messaggi privati, l'applicazione non necessario eseguire la crittografia del messaggio. In Accodamento messaggi può crittografare il corpo del messaggio per l'utente se l'applicazione invia messaggi all'interno di un'azienda di Microsoft Windows 2000, che dispone dell'accesso al servizio directory. Quando si ricevono messaggi privati, il gestore delle code ricevente decrittografa sempre il corpo del messaggio.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.UseEncryption%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.UseEncryption" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a copy of the message should be kept in a machine journal on the originating computer.</summary>
        <value>
          <see langword="true" /> per richiedere di essere mantenuta una copia di un messaggio nel journal del computer di origine dopo che il messaggio è stato trasmesso (dal computer di origine con il server successivo); in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.UseJournalQueue%2A> e <xref:System.Messaging.Message.UseDeadLetterQueue%2A> specificano come il servizio Accodamento messaggi di traccia dei messaggi. Se <xref:System.Messaging.Message.UseJournalQueue%2A> è `true`, quindi una copia viene mantenuta nella coda journal di computer nel computer di origine a ogni passaggio che un messaggio viene trasmesso.  
  
 Il messaggio inviato viene copiato nella coda journal solo se la coda di destinazione si trova in un computer remoto. Se la destinazione è nel computer locale, il messaggio viene inviato direttamente alla coda. non sono passaggi intermedi in modo da richiedere l'inserimento nel journal.  
  
 Quando si archiviano i messaggi in una coda journal, deselezionare la periodicamente la coda per rimuovere i messaggi che non sono più necessari. Messaggi archiviati in code diario ai fini della quota per il computer in cui risiede la coda. (La quota del computer è impostata dall'amministratore).  
  
 Non si crea una coda del diario o inattiva. Sono entrambe code di sistema di Accodamento messaggi genera l'errore.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.UseJournalQueue%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.UseJournalQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to trace a message as it moves toward its destination queue.</summary>
        <value>
          <see langword="true" /> Se ogni fase intermedia dell'invio del messaggio originale alla coda di destinazione viene generato un report da inviare alla coda di rapporti del sistema; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.Message.UseTracing%2A> proprietà specifica se tenere traccia della route di un messaggio durante lo spostamento verso la coda di destinazione. Se `true`, un messaggio di rapporto (generato da Accodamento messaggi) viene inviato alla coda dei rapporti ogni volta che il messaggio passa attraverso un server di Accodamento. La coda del report viene specificata dal gestore code di origine. Le code del report non sono limitate per segnalare i messaggi generati da Accodamento messaggi; i messaggi generati dall'applicazione possono anche essere inviati alle code di report.  
  
 Utilizzo delle tracce, è necessario configurare Active Directory e specificare una coda dei rapporti di Accodamento messaggi. L'amministratore configura le impostazioni.  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di un messaggio <xref:System.Messaging.Message.UseTracing%2A> proprietà.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.UseTracing" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>