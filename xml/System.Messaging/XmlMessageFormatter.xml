<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="30c748e1b8131475a0816e44ef8493b13096829c" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39987441" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serializza e deserializza oggetti nel e dal corpo di un messaggio, utilizzando il formato XML basato sulla definizione di schema XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.XmlMessageFormatter> il formattatore predefinito che un'istanza di <xref:System.Messaging.MessageQueue> viene utilizzato per serializzare i messaggi scritti nella coda. Quando si crea un'istanza di <xref:System.Messaging.MessageQueue>, un'istanza di <xref:System.Messaging.XmlMessageFormatter> viene creato e associato il <xref:System.Messaging.MessageQueue>. È possibile specificare un formattatore diversi crearlo nel codice e assegnarlo al <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà del <xref:System.Messaging.MessageQueue>.  
  
 Impostazione predefinita della coda <xref:System.Messaging.XmlMessageFormatter> istanza può essere usata per scrivere nella coda, ma non può essere usato per leggere dalla coda, fino a quando non è impostata la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> proprietà sul formattatore. È possibile impostare uno o entrambi questi valori nell'istanza del formattatore predefinito, oppure è possibile creare una nuova istanza del formattatore e impostare i valori automaticamente passandoli come argomenti nel appropriato <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> costruttore.  
  
 Quando si specificano <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> anziché <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, tipo esistenza viene verificata in fase di compilazione anziché in fase di lettura, riducendo la probabilità di errore. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> richiede che ogni voce sia completo, che specifica il nome dell'assembly. Inoltre, quando si usano più versioni simultanee, il numero di versione deve essere inoltre aggiunto al nome del tipo di destinazione anche.  
  
 Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. In questo modo il formattatore interpretare il corpo del messaggio.  
  
 L'istanza serializzato nel corpo del messaggio deve essere conformi con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio usando la <xref:System.Messaging.MessageQueue.Receive%2A> metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 Solo una delle due proprietà deve essere impostato durante la lettura dalla coda, ma è possibile impostare entrambe. Il set di tipi è il set combinato delle due proprietà. La scelta della proprietà da utilizzare è specifica dell'applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un'eccezione quando il messaggio viene letto.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> è un componente fondamentale della messaggistica accoppiamento basato su XML. Usa l'utilità XSD.exe che il formato XML viene usato per generare lo schema XML, ad esempio quando si usa l'utilità per serializzare una classe utilizzata dall'applicazione. La classe deve disporre di un costruttore predefinito.  
  
 Il formato viene usato anche in questo caso nel processo di reverse quando l'utilità genera una classe basata allo schema distribuito per descrivere i dati di classe. L'uso dell'utilità e viene generato il XML schema consente di evitare ridistribuire i file ogni volta che viene ricompilata una classe dopo l'implementazione della classe è stato modificato. Purché lo schema non influisce sul client o server, altre modifiche su entrambi i lati non influiscano su altra.  
  
   
  
## Examples  
 L'esempio di codice seguente include tre parti di codice: un componente server, una classe order e codice client. La classe order è utilizzabile dall'utilità XSD.exe per generare lo schema che il server riconosca all'interno di messaggi in ingresso. Lo schema è un file XML formattato che descrive la "forma" della classe. Questo schema è quindi utilizzabile per generare una classe order specifiche del client che condivide lo stesso schema della classe server sul lato client.  
  
 Esempio di codice seguente rappresenta un componente server che riceve gli ordini tramite una coda di messaggi. Il corpo del messaggio deve essere un oggetto di ordini il cui schema corrisponde alla classe Order.cs riportata di seguito. Il processo del server o l'applicazione deserializza l'ordine.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 Il codice seguente rappresenta la classe order che fornisce uno schema per gli oggetti di ordine che riceve l'applicazione nel server e la deserializzazione.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Qualsiasi applicazione client che interagisce con l'applicazione nel server debba inviare messaggi al server dalle informazioni sulla serializzazione in una classe definita localmente ordine nel corpo del messaggio. La classe definita localmente order deve avere lo stesso schema della classe order definito dal server in cui l'applicazione nel server tenterà di deserializzare il corpo del messaggio. L'utilità XSD.exe consente la gestione dell'applicazione nel server di creare e distribuire lo schema che il client deve utilizzare per serializzare i messaggi inviati al server.  
  
 Quando il gestore dell'applicazione client riceve lo schema per la classe order, l'utilità XSD.exe viene utilizzato anche in questo caso per generare una classe client specifico ordine dallo schema. Si tratta della classe che viene usata nell'esempio di codice client seguente, non l'ordine della classe server (l'utilità XSD.exe fa sì che la classe di schema generato avere lo stesso nome di classe originale). La nuova classe order viene utilizzata per serializzare l'ordine nel corpo del messaggio.  
  
 Esempio di codice seguente è il lato client l'elaborazione, utilizzato per serializzare un ordine e le informazioni relative all'ordine in una coda di trasmissione. Il codice associa Item, Quantity e indirizzo informazioni con gli elementi dello schema che sono stati generati per la classe Order.cs dall'utilità XSD.exe. Un ordine viene inviato alla coda degli ordini nel computer locale.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Dopo che lo schema viene generato dalla classe order sul server, è possibile modificare la classe. A meno che le modifiche dello schema, è necessario ridistribuire lo schema. Dopo avere distribuito lo schema e generare una classe order dal lato client, tale classe di client può essere modificato indipendentemente dalla classe order del server, inoltre, purché lo schema stesso non viene modificato. Le due classi hanno diventano regime di controllo.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.XmlMessageFormatter" /> senza tipi di destinazione impostati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del costruttore viene utilizzato più frequentemente durante la scrittura in coda, come tipi di destinazione non sono necessari durante la scrittura.  
  
 Per leggere un messaggio da una coda usando un'istanza di <xref:System.Messaging.XmlMessageFormatter> creata utilizzando questo costruttore, è necessario impostare la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà affinché il formattatore sappia quali tipi nel tentativo di deserializzare.  
  
 Quando si crea una nuova <xref:System.Messaging.MessageQueue>, valore predefinito <xref:System.Messaging.XmlMessageFormatter> istanza viene creata, senza set di tipi di destinazione. Come con un formattatore creato utilizzando il costruttore, è necessario impostare i tipi di destinazione per l'istanza del formattatore se si desidera leggere dalla coda.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Matrice di tipo <see cref="T:System.String" /> che specifica l'insieme di tipi possibili che verranno deserializzati tramite il formattatore dal messaggio fornito. Tali valori devono essere completamente qualificati, ad esempio "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.XmlMessageFormatter" /> impostando i tipi di destinazione passati come matrice di valori di stringa (completamente qualificati).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I costruttori con parametri di tipo di destinazione vengono spesso usati durante la lettura dalla coda. Durante la scrittura, non è necessario specificare i tipi di destinazione.  
  
 Questo overload del metodo di <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> costruttore imposta la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> proprietà per i valori della matrice passato tramite la `targetTypeNames` parametro. Impostazione di questa proprietà consente a un <xref:System.Messaging.MessageQueue> usando questo <xref:System.Messaging.XmlMessageFormatter> istanza per leggere i messaggi che contiene gli oggetti di determinati tipi.  
  
 Sia la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. In questo modo il formattatore interpretare il corpo del messaggio.  
  
 L'istanza serializzato nel corpo del messaggio deve essere conformi con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio usando la <xref:System.Messaging.MessageQueue.Receive%2A> metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 Solo una delle due proprietà deve essere impostato durante la lettura dalla coda, ma è possibile impostare entrambe. Il set di tipi è il set combinato delle due proprietà. La scelta di quale uno da usare è specifico dell'applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un'eccezione in fase di lettura.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="targetTypeNames" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Matrice di tipo <see cref="T:System.Type" /> che specifica l'insieme di tipi possibili che verranno deserializzati tramite il formattatore dal messaggio fornito.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.XmlMessageFormatter" /> impostando i tipi di destinazione passati come matrice di tipi di oggetti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I costruttori con parametri di tipo di destinazione vengono spesso usati durante la lettura dalla coda. Durante la scrittura, non è necessario specificare i tipi di destinazione.  
  
 Questo overload del metodo di <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> costruttore imposta la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà per i valori della matrice passato tramite la `targetTypes` parametro. Impostazione di questa proprietà consente a un <xref:System.Messaging.MessageQueue> usando questo <xref:System.Messaging.XmlMessageFormatter> istanza per leggere i messaggi che contiene gli oggetti dei tipi specificati.  
  
 Sia la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. In questo modo il formattatore interpretare il corpo del messaggio.  
  
 L'istanza serializzato nel corpo del messaggio deve essere conformi con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio usando la <xref:System.Messaging.MessageQueue.Receive%2A> metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 Solo una delle due proprietà deve essere impostato durante la lettura dalla coda, ma è possibile impostare entrambe. Il set di tipi è il set combinato delle due proprietà. La scelta di quale uno da usare è specifico dell'applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un'eccezione in fase di lettura.  
  
 Quando si specificano <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> anziché <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, tipo esistenza viene verificata in fase di compilazione anziché in fase di lettura, riducendo la probabilità di errore. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> richiede che ogni voce sia completo, che specifica il nome dell'assembly. Inoltre, quando si usano più versioni simultanee, il numero di versione deve essere inoltre aggiunto al nome del tipo di destinazione anche.  
  
 Quando si usa <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, è possibile aggiungere ogni oggetto (ad esempio, `MyClass`) all'elenco nel modo descritto dal codice c# seguente.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="targetTypes" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" /> da esaminare.</param>
        <summary>Determina se il formattatore può deserializzare il messaggio.</summary>
        <returns>
          <see langword="true" /> se il formattatore XML può deserializzare il messaggio; altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> viene chiamato, il formattatore tenta di determinare se è possibile deserializzare il contenuto del messaggio. Il formattatore può deserializzare solo i messaggi se il tipo nel corpo del messaggio ha lo stesso schema di uno dei tipi nella matrice rappresentata dal <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Restituisce `false` due circostanze seguenti:  
  
-   Il messaggio non è stato formattato utilizzando il <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Lo schema del corpo del messaggio non è tra quelli elencati in entrambi i <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà.  
  
 Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà indicano al formattatore di quali tipi di oggetti deve essere in grado di deserializzare. Se qualsiasi tipo non è presente nell'elenco, anche se viene trovato all'interno del messaggio <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> restituisce `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna delle due proprietà <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> e <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> è stata impostata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="message" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un'istanza della classe <see cref="T:System.Messaging.XmlMessageFormatter" /> le cui proprietà di lettura/scrittura (gli insiemi dei tipi di destinazione) sono le stesse dell'istanza <see cref="T:System.Messaging.XmlMessageFormatter" /> corrente.</summary>
        <returns>Oggetto le cui proprietà sono identiche a quelle di questa istanza <see cref="T:System.Messaging.XmlMessageFormatter" />, ma i cui metadati non specificano che si tratta di un'istanza di classe formatter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea una copia del formattatore e la inizializza tutte le relative proprietà per i valori di questa <xref:System.Messaging.XmlMessageFormatter> oggetto.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Il <see cref="T:System.Messaging.Message" />, in formato XML da deserializzare.</param>
        <summary>Legge il contenuto del messaggio indicato e crea un oggetto contenente il messaggio deserializzato.</summary>
        <returns>Messaggio deserializzato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sia la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. Una di queste proprietà deve essere impostata prima che il messaggio può essere deserializzato.  
  
 L'istanza serializzato nel corpo del messaggio deve essere conformi con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio usando la <xref:System.Messaging.MessageQueue.Receive%2A> metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 I tipi di destinazione non è necessario specificare per poter scrivere nella coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna delle due proprietà <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> e <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> è stata impostata.  
  
oppure 
L'istanza serializzata nel corpo del messaggio non è conforme ad alcuno degli schemi rappresentati dai tipi nelle proprietà <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> e <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="message" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica l'insieme di tipi possibili che verranno deserializzati tramite il formattatore dal messaggio fornito.</summary>
        <value>Matrice di tipo <see cref="T:System.String" /> che specifica i tipi di oggetti da deserializzare dal corpo del messaggio durante la lettura del messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sia la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. In questo modo il formattatore interpretare il corpo del messaggio.  
  
 L'istanza serializzato nel corpo del messaggio deve essere conformi con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio usando la <xref:System.Messaging.MessageQueue.Receive%2A> metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 Solo una delle due proprietà deve essere impostato durante la lettura dalla coda, ma è possibile impostare entrambe. Il set di tipi è il set combinato delle due proprietà. La scelta della proprietà da utilizzare è specifica dell'applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un'eccezione quando il messaggio viene letto.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> richiede che ogni voce sia completo, che specifica il nome dell'assembly. Inoltre, quando si usano più versioni simultanee, il numero di versione deve essere inoltre aggiunto al nome del tipo di destinazione anche.  
  
 I tipi di destinazione sono solo necessarie durante la lettura dalla coda. Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà non sono necessario essere impostati per scrivere nella coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La proprietà <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica l'insieme di tipi possibili che verranno deserializzati tramite il formattatore dal messaggio fornito.</summary>
        <value>Matrice di tipo <see cref="T:System.Type" /> che specifica i tipi di oggetti da deserializzare dal corpo del messaggio durante la lettura del messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sia la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. In questo modo il formattatore interpretare il corpo del messaggio.  
  
 L'istanza serializzato nel corpo del messaggio deve essere conformi con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio usando la <xref:System.Messaging.MessageQueue.Receive%2A> metodo, il metodo crea un oggetto del tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 Solo una delle due proprietà deve essere impostato durante la lettura dalla coda, ma è possibile impostare entrambe. Il set di tipi è il set combinato delle due proprietà. La scelta della proprietà da utilizzare è specifica dell'applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un'eccezione quando il messaggio viene letto.  
  
 I tipi di destinazione sono solo necessarie durante la lettura dalla coda. Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà non sono necessario essere impostati per scrivere nella coda.  
  
 Quando si specificano <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> anziché <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, tipo esistenza viene verificata in fase di compilazione anziché in fase di lettura, riducendo la probabilità di errore.  
  
 Quando si usa <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, è possibile aggiungere ogni oggetto (ad esempio `MyClass`) all'elenco nel modo illustrato nel codice c# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio contenente un ordine a e da una coda.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La proprietà <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Body" /> conterrà l'oggetto serializzato.</param>
        <param name="obj">L'<see cref="T:System.Object" /> da serializzare nel corpo del messaggio.</param>
        <summary>Serializza un oggetto nel corpo del messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è necessario specificare i tipi di destinazione per scrivere nella coda come devono essere durante la lettura. Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà viene utilizzata dal formattatore solo quando si deserializza un messaggio.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> Usa il <xref:System.Xml.Serialization.XmlSerializer> (classe), che definisce ciò che può essere serializzato. Solo le proprietà pubbliche e campi pubblici possono essere serializzate. Strutture, le strutture con matrici e matrici di strutture sono tutti serializzabile, purché non usano lo stile codificato con il protocollo SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="message" /> è <see langword="null" />.  
  
oppure 
Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>