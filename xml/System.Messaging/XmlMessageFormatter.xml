<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="563e678b40760a20036da2630095cb8b05f461de" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460735" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serializza e deserializza oggetti nel e dal corpo di un messaggio, utilizzando il formato XML basato sulla definizione di schema XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.XmlMessageFormatter> è il formattatore predefinito che un'istanza di <xref:System.Messaging.MessageQueue> viene utilizzato per serializzare i messaggi scritti nella coda. Quando si crea un'istanza di <xref:System.Messaging.MessageQueue>, un'istanza di <xref:System.Messaging.XmlMessageFormatter> viene creato e associato il <xref:System.Messaging.MessageQueue>. È possibile specificare un formattatore differente creandolo nel codice e assegnarlo al <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà del <xref:System.Messaging.MessageQueue>.  
  
 Valore predefinito di una coda <xref:System.Messaging.XmlMessageFormatter> istanza può essere utilizzata per scrivere nella coda, ma non può essere utilizzato per leggere dalla coda fino a quando non si imposta la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> proprietà sul formattatore. È possibile impostare uno o entrambi i valori nell'istanza del formattatore predefinito oppure è possibile creare una nuova istanza del formattatore e impostare i valori automaticamente tramite il passaggio come argomenti in appropriata <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> costruttore.  
  
 Quando si specifica <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> anziché <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, esistenza di tipo viene verificata in fase di compilazione anziché in fase di lettura, riducendo la probabilità di errore. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> richiede che ogni voce sia completa, specificando il nome dell'assembly. Inoltre, quando si utilizzano più versioni simultanee, il numero di versione deve essere inoltre aggiunto al nome del tipo di destinazione nonché.  
  
 Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. In questo modo il formattatore interpretare il corpo del messaggio.  
  
 L'istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo), il metodo crea un oggetto di tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 Solo una delle due proprietà deve essere impostata durante la lettura dalla coda, ma è possibile impostare entrambi. Il set di tipi è il set combinato delle due proprietà. La decisione di quale proprietà utilizzare è specifica dell'applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un'eccezione quando viene letto il messaggio.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> è un componente fondamentale della messaggistica accoppiamento basato su XML. Utilizza l'utilità XSD.exe che viene utilizzato il formato XML per generare schemi XML, ad esempio quando si utilizza l'utilità per serializzare una classe utilizzata dall'applicazione. La classe deve disporre di un costruttore predefinito.  
  
 Viene utilizzato il formato nuovamente il processo inverso quando l'utilità genera una classe in base allo schema distribuito per descrivere i dati della classe. L'utilizzo dell'utilità e dello schema XML generato consente di evitare ridistribuire i file ogni volta che una classe viene ricompilata dopo che è stata modificata l'implementazione della classe. Fino a quando lo schema non viene modificato sul client o server, le altre modifiche su entrambi i lati non influisce sugli altri.  
  
   
  
## Examples  
 L'esempio di codice seguente include tre parti di codice: un componente server, una classe order e il codice client. La classe order è utilizzabile dall'utilità di XSD.exe per generare lo schema riconosciuto dal server all'interno di messaggi in ingresso. Lo schema è un file in formato XML che descrive la "forma" della classe. Questo schema può quindi essere utilizzato sul lato client per generare una classe order specifica di client che condivide lo stesso schema della classe server.  
  
 Esempio di codice seguente rappresenta un componente server che riceve gli ordini tramite una coda di messaggi. Il corpo del messaggio deve essere un oggetto ordine il cui schema corrisponde classe cs. Il processo del server o l'applicazione deserializza l'ordine.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 Esempio di codice seguente rappresenta la classe order che fornisce uno schema per gli oggetti di ordine che riceve l'applicazione sul server e la deserializzazione.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Qualsiasi applicazione client che interagisce con l'applicazione nel server deve inviare i messaggi al server serializzando le informazioni in una classe order definita localmente nel corpo del messaggio. La classe definita localmente order deve avere lo stesso schema della classe server definito dall'ordine in cui l'applicazione nel server tenterà di deserializzare il corpo del messaggio. Creare e distribuire lo schema a cui che il client deve utilizzare per serializzare i messaggi inviati al server, l'utilità di XSD.exe consente la gestione dell'applicazione nel server.  
  
 Quando il gestore dell'applicazione client riceve lo schema per la classe order, l'utilità di XSD.exe viene usato di nuovo per generare una classe order specifica dello schema. Questa classe che viene utilizzato nell'esempio di codice client seguente, non l'ordine della classe server (utilità di XSD.exe fa sì che la classe di schema generato per lo stesso nome della classe originale). La nuova classe order viene utilizzata per serializzare l'ordine nel corpo del messaggio.  
  
 Esempio di codice seguente è il lato client l'elaborazione, utilizzata per serializzare un ordine e inviare le informazioni associate con l'ordine in una coda. Il codice associa informazioni articolo, quantità e l'indirizzo a elementi dello schema per la classe cs generati dall'utilità di XSD.exe. Un ordine viene inviato alla coda degli ordini nel computer locale.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Dopo che lo schema viene generato dalla classe order sul server, è possibile modificare la classe. A meno che le modifiche dello schema, non è necessario ridistribuire lo schema. Dopo avere distribuito lo schema e generare una classe order sul lato client, tale classe client inoltre possibile modificare in modo indipendente da classe order del server, fino a quando non viene modificato lo schema stesso. Le due classi sono abbinate più.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.XmlMessageFormatter" /> senza tipi di destinazione impostati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del costruttore viene utilizzato più frequentemente durante la scrittura in coda, come tipi di destinazione non sono necessari durante la scrittura.  
  
 Per leggere un messaggio da una coda utilizzando un'istanza di <xref:System.Messaging.XmlMessageFormatter> creato utilizzando il costruttore, è necessario impostare il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà affinché il formattatore sappia quali tipi deserializzare.  
  
 Quando si crea un nuovo <xref:System.Messaging.MessageQueue>, valore predefinito è <xref:System.Messaging.XmlMessageFormatter> istanza viene creata, senza il set di tipi di destinazione. Come con un formattatore creato utilizzando il costruttore, è necessario impostare i tipi di destinazione per l'istanza del formattatore se si desidera leggere dalla coda.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Matrice di tipo <see cref="T:System.String" /> che specifica l'insieme di tipi possibili che verranno deserializzati tramite il formattatore dal messaggio fornito. Tali valori devono essere completamente qualificati, ad esempio "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.XmlMessageFormatter" /> impostando i tipi di destinazione passati come matrice di valori di stringa (completamente qualificati).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I costruttori con parametri di tipo di destinazione vengono utilizzati più frequentemente durante la lettura dalla coda. Durante la scrittura, non è necessario specificare i tipi di destinazione.  
  
 Questo overload del metodo di <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> costruttore imposta la <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> proprietà per i valori della matrice passato tramite il `targetTypeNames` parametro. L'impostazione di questa proprietà consente un <xref:System.Messaging.MessageQueue> usando questa <xref:System.Messaging.XmlMessageFormatter> istanza per leggere i messaggi contenenti oggetti di determinati tipi.  
  
 Sia il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. In questo modo il formattatore interpretare il corpo del messaggio.  
  
 L'istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo), il metodo crea un oggetto di tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 Solo una delle due proprietà deve essere impostata durante la lettura dalla coda, ma è possibile impostare entrambi. Il set di tipi è il set combinato delle due proprietà. La scelta di quale utilizzare è specifico dell'applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un'eccezione in fase di lettura.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="targetTypeNames" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Matrice di tipo <see cref="T:System.Type" /> che specifica l'insieme di tipi possibili che verranno deserializzati tramite il formattatore dal messaggio fornito.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.XmlMessageFormatter" /> impostando i tipi di destinazione passati come matrice di tipi di oggetti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I costruttori con parametri di tipo di destinazione vengono utilizzati più frequentemente durante la lettura dalla coda. Durante la scrittura, non è necessario specificare i tipi di destinazione.  
  
 Questo overload del metodo di <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> costruttore imposta la <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà per i valori della matrice passato tramite il `targetTypes` parametro. L'impostazione di questa proprietà consente un <xref:System.Messaging.MessageQueue> usando questa <xref:System.Messaging.XmlMessageFormatter> istanza per leggere i messaggi contenenti oggetti di tipi specificati.  
  
 Sia il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. In questo modo il formattatore interpretare il corpo del messaggio.  
  
 L'istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo), il metodo crea un oggetto di tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 Solo una delle due proprietà deve essere impostata durante la lettura dalla coda, ma è possibile impostare entrambi. Il set di tipi è il set combinato delle due proprietà. La scelta di quale utilizzare è specifico dell'applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un'eccezione in fase di lettura.  
  
 Quando si specifica <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> anziché <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, esistenza di tipo viene verificata in fase di compilazione anziché in fase di lettura, riducendo la probabilità di errore. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> richiede che ogni voce sia completa, specificando il nome dell'assembly. Inoltre, quando si utilizzano più versioni simultanee, il numero di versione deve essere inoltre aggiunto al nome del tipo di destinazione nonché.  
  
 Quando si utilizza <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, è possibile aggiungere ogni oggetto (ad esempio, `MyClass`) all'elenco nel modo descritto dal codice c# seguente.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="targetTypes" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" /> da esaminare.</param>
        <summary>Determina se il formattatore può deserializzare il messaggio.</summary>
        <returns>
          <see langword="true" /> se il formattatore XML può deserializzare il messaggio; altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> viene chiamato, il formattatore tenta di determinare se è possibile deserializzare il contenuto del messaggio. Il formattatore può deserializzare il messaggio solo se il tipo nel corpo del messaggio ha lo stesso schema di uno dei tipi nella matrice rappresentata dal <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Restituisce `false` nei due casi seguenti:  
  
-   Il messaggio non è stato formattato utilizzando il <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Lo schema del corpo del messaggio non è tra quelli elencati in entrambi i <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà.  
  
 Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano al formattatore i tipi di oggetti deve essere in grado di deserializzare. Se non è presente nell'elenco di qualsiasi tipo, viene trovato all'interno del messaggio, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> restituisce `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna delle due proprietà <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> e <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> è stata impostata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="message" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un'istanza della classe <see cref="T:System.Messaging.XmlMessageFormatter" /> le cui proprietà di lettura/scrittura (gli insiemi dei tipi di destinazione) sono le stesse dell'istanza <see cref="T:System.Messaging.XmlMessageFormatter" /> corrente.</summary>
        <returns>Oggetto le cui proprietà sono identiche a quelle di questa istanza <see cref="T:System.Messaging.XmlMessageFormatter" />, ma i cui metadati non specificano che si tratta di un'istanza di classe formatter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea una copia del formattatore e inizializza tutte le proprietà con valori di questo <xref:System.Messaging.XmlMessageFormatter> oggetto.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Il <see cref="T:System.Messaging.Message" />, in formato XML da deserializzare.</param>
        <summary>Legge il contenuto del messaggio indicato e crea un oggetto contenente il messaggio deserializzato.</summary>
        <returns>Messaggio deserializzato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sia il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. Una di queste proprietà deve essere impostata prima che il messaggio può essere deserializzato.  
  
 L'istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo), il metodo crea un oggetto di tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 I tipi di destinazione non è necessario specificare per scrivere nella coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna delle due proprietà <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> e <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> è stata impostata.  
  
 oppure  
  
 L'istanza serializzata nel corpo del messaggio non è conforme ad alcuno degli schemi rappresentati dai tipi nelle proprietà <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> e <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="message" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica l'insieme di tipi possibili che verranno deserializzati tramite il formattatore dal messaggio fornito.</summary>
        <value>Matrice di tipo <see cref="T:System.String" /> che specifica i tipi di oggetti da deserializzare dal corpo del messaggio durante la lettura del messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sia il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. In questo modo il formattatore interpretare il corpo del messaggio.  
  
 L'istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo), il metodo crea un oggetto di tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 Solo una delle due proprietà deve essere impostata durante la lettura dalla coda, ma è possibile impostare entrambi. Il set di tipi è il set combinato delle due proprietà. La decisione di quale proprietà utilizzare è specifica dell'applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un'eccezione quando viene letto il messaggio.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> richiede che ogni voce sia completa, specificando il nome dell'assembly. Inoltre, quando si utilizzano più versioni simultanee, il numero di versione deve essere inoltre aggiunto al nome del tipo di destinazione nonché.  
  
 I tipi di destinazione sono necessari durante la lettura dalla coda. Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà non è necessario impostare la scrittura nella coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La proprietà <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica l'insieme di tipi possibili che verranno deserializzati tramite il formattatore dal messaggio fornito.</summary>
        <value>Matrice di tipo <see cref="T:System.Type" /> che specifica i tipi di oggetti da deserializzare dal corpo del messaggio durante la lettura del messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sia il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> indicano il formattatore quali gli schemi per tentare di corrispondenza durante la deserializzazione di un messaggio. In questo modo il formattatore interpretare il corpo del messaggio.  
  
 L'istanza serializzata nel corpo del messaggio deve essere conforme con uno degli schemi rappresentati nella matrice del tipo. Quando si legge il messaggio utilizzando il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo), il metodo crea un oggetto di tipo che corrisponde allo schema indicato e in cui viene letto il corpo del messaggio.  
  
 Solo una delle due proprietà deve essere impostata durante la lettura dalla coda, ma è possibile impostare entrambi. Il set di tipi è il set combinato delle due proprietà. La decisione di quale proprietà utilizzare è specifica dell'applicazione. Se il corpo del messaggio contiene un tipo il cui schema non corrisponde a nessuno dei tipi nella matrice per delle proprietà, verrà generata un'eccezione quando viene letto il messaggio.  
  
 I tipi di destinazione sono necessari durante la lettura dalla coda. Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> proprietà non è necessario impostare la scrittura nella coda.  
  
 Quando si specifica <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> anziché <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, esistenza di tipo viene verificata in fase di compilazione anziché in fase di lettura, riducendo la probabilità di errore.  
  
 Quando si utilizza <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, è possibile aggiungere ogni oggetto (ad esempio, `MyClass`) per l'elenco nel modo illustrato nel codice c# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio che contiene un ordine da e verso una coda.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La proprietà <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Body" /> conterrà l'oggetto serializzato.</param>
        <param name="obj">L'<see cref="T:System.Object" /> da serializzare nel corpo del messaggio.</param>
        <summary>Serializza un oggetto nel corpo del messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è necessario specificare i tipi di destinazione devono essere durante la lettura di scrivere nella coda. Il <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> è utilizzata dal formattatore solo durante la deserializzazione di un messaggio.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> utilizza il <xref:System.Xml.Serialization.XmlSerializer> (classe), che definisce ciò che può essere serializzato. Solo le proprietà pubbliche e i campi pubblici possono essere serializzate. Strutture, le strutture con matrici e le matrici di strutture sono tutte serializzabili, purché non utilizzano lo stile codificato con il protocollo SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="message" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>