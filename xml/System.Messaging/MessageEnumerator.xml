<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6a3039a11d941cd3db611cb997eb17835525e4da" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460815" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornisce un cursore forward-only per enumerare i messaggi in una coda di messaggi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Messaging.MessageEnumerator> per un'interazione dinamica con i messaggi in una coda. Metodi disponibili tramite il <xref:System.Messaging.MessageQueue> classe può restituire un <xref:System.Messaging.MessageEnumerator> che punta a un elenco dinamico di messaggi nella coda o una matrice che contiene una copia in un determinato istante - uno snapshot - della coda al momento il metodo specificato è stato chiamato.  
  
 A differenza di uno snapshot statico, un enumeratore consente di modificare la raccolta. Utilizzando un <xref:System.Messaging.MessageEnumerator>, è possibile rimuovere i messaggi dalla coda e la modifica viene riflessa immediatamente nella coda.  
  
 Un enumeratore non rimuove i messaggi dalla coda quando viene eseguita una query la coda. Restituisce informazioni sul messaggio nella posizione corrente del cursore, ma lascia il messaggio nella coda.  
  
 Oggetto <xref:System.Messaging.MessageEnumerator> è un cursore, inizializzato all'inizio di un elenco dinamico. L'ordine dell'elenco è identico all'ordine dei messaggi nella coda, in base alla priorità del messaggio. È possibile spostare il cursore per il primo messaggio nella coda chiamando <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Dopo l'enumeratore è stato inizializzato, è possibile utilizzare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> per avanzare tra i messaggi rimanenti. È possibile specificare se per l'attesa di un messaggio diventi disponibile passando un timeout di <xref:System.Messaging.MessageEnumerator.MoveNext%2A> metodo.  
  
 Poiché l'enumeratore è dinamico, un messaggio che viene aggiunto oltre la posizione del cursore corrente (ad esempio, a causa di priorità bassa), sono accessibili dall'enumeratore. Un messaggio che viene inserito prima che la posizione corrente del cursore non è accessibile. Non è possibile tornare indietro con un <xref:System.Messaging.MessageEnumerator>. Un cursore consente lo spostamento di tipo forward-only. Il <xref:System.Messaging.MessageEnumerator.Reset%2A> metodo consente di posizionare il cursore all'inizio della coda.  
  
 Le istanze di <xref:System.Messaging.MessageEnumerator> per una determinata coda funzionano in modo indipendente. È possibile creare due <xref:System.Messaging.MessageEnumerator> istanze che si applicano alla stessa coda. Le modifiche che una <xref:System.Messaging.MessageEnumerator> esegue per i messaggi nella coda verranno riportate immediatamente in un secondo enumeratore se il secondo enumeratore è posizionato prima del primo. Tuttavia, se due enumeratori hanno la stessa posizione e uno di essi rimuove il messaggio in tale posizione, viene generata un'eccezione se l'altro enumeratore tenta di ottenere il valore della <xref:System.Messaging.MessageEnumerator.Current%2A> proprietà sul messaggio appena eliminato.  
  
> [!NOTE]
>  Se si crea un'istanza di <xref:System.Messaging.MessageQueue> con <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> impostato su `true`, altre applicazioni non possono modificare i messaggi dell'enumeratore mentre è attiva la connessione alla coda.  
  
   
  
## Examples  
 Nell'esempio seguente viene ottenuto un elenco dinamico di messaggi in una coda e conta tutti i messaggi con il <xref:System.Messaging.Message.Priority%2A> proprietà impostata su <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rende disponibili le risorse associate all'enumeratore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il sistema operativo mantiene un handle aperto per la coda nel corso della durata del cursore. Quando si termina di utilizzare con l'enumeratore, chiamare <xref:System.Messaging.MessageEnumerator.Close%2A> per rilasciare le risorse associate all'handle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il <see cref="T:System.Messaging.Message" /> corrente cui punta questo enumeratore.</summary>
        <value>Il messaggio corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene creato l'enumeratore, fa riferimento all'inizio della coda, in corrispondenza della posizione prima del primo messaggio. In questo caso, <xref:System.Messaging.MessageEnumerator.Current%2A> non è valido e verrà generata un'eccezione se vi si accede. È necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> per posizionare il cursore il primo messaggio nella coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">È stata chiamata la proprietà <see cref="P:System.Messaging.MessageEnumerator.Current" /> prima della prima chiamata al metodo <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. Il cursore precede il primo elemento dell'enumerazione del messaggio.  
  
 oppure  
  
 È stato chiamato <see cref="P:System.Messaging.MessageEnumerator.Current" /> dopo che una chiamata a <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> ha restituito <see langword="false" />, il che indica che il cursore è posizionato dopo l'ultimo elemento dell'enumerazione del messaggio.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il messaggio cui l'enumeratore punta correntemente non esiste più. Potrebbe essere stato eliminato.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle del cursore nativo di Accodamento messaggi utilizzato per visualizzare i messaggi della coda.</summary>
        <value>L'handle del cursore nativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà contiene l'handle nativo di enumerazione. Quando si termina di utilizzare con l'enumeratore, chiamare <xref:System.Messaging.MessageEnumerator.Close%2A> per rilasciare la risorsa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">L'handle non esiste.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse usate da <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate da <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata <xref:System.Messaging.MessageEnumerator.Dispose%2A> le risorse utilizzate da di <xref:System.Messaging.MessageEnumerator> riallocazione per altri scopi. Per ulteriori informazioni su <xref:System.Messaging.MessageEnumerator.Dispose%2A>, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.Messaging.MessageEnumerator" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal metodo pubblico <xref:System.Messaging.MessageEnumerator.Dispose%2A> (metodo) e <xref:System.Object.Finalize%2A> metodo. `Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama `Dispose` con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.Messaging.MessageEnumerator> fa riferimento. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            Il metodo <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. In caso di override di <see langword="Dispose(Boolean)" />, non fare riferimento a oggetti già eliminati in una chiamata precedente a <see langword="Dispose" />. Per ulteriori informazioni su come implementare <see langword="Dispose" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Per ulteriori informazioni su <see langword="Dispose" /> e <see langword="Finalize" />, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [si esegue l'override del metodo Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sposta l'enumeratore al messaggio successivo della coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sposta l'enumeratore al messaggio successivo della coda, se ve n'è uno disponibile.</summary>
        <returns>
          <see langword="true" />, se l'enumeratore ha completato il passaggio al messaggio successivo; <see langword="false" />, se l'enumeratore ha raggiunto la fine della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload restituisce immediatamente se non sono presenti messaggi nella coda. Un altro overload in attesa di un oggetto specificato è <xref:System.TimeSpan> per un messaggio in arrivo.  
  
 Se un messaggio non è attualmente disponibile perché la coda è vuota o perché sono stati spostati oltre l'ultimo elemento nella raccolta, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> restituisce `false` al metodo di chiamata.  
  
 Al momento della creazione, un enumeratore concettualmente prima del primo messaggio della coda e la prima chiamata a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> consente di visualizzare il primo messaggio della coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">È stata avviata un'eccezione specifica di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Il <see cref="T:System.TimeSpan" /> da attendere perché un messaggio diventi disponibile se l'enumeratore è posizionato alla fine della coda.</param>
        <summary>Sposta l'enumeratore al messaggio successivo della coda. Se l'enumeratore si trova alla fine della coda, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> attende finché non scade il timeout o finché è disponibile un messaggio.</summary>
        <returns>
          <see langword="true" />, se l'enumeratore ha completato il passaggio al messaggio successivo; <see langword="false" />, se l'enumeratore ha raggiunto la fine della coda e un messaggio non si rende disponibile nel tempo specificato dal parametro <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è in attesa se sono presenti messaggi nella coda o se il cursore ha raggiunto la fine della coda. Se un messaggio non è attualmente disponibile perché la coda è vuota o perché sono stati spostati oltre l'ultimo elemento nella raccolta, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> attende il timeout specificato.  
  
 Se il cursore si trova già alla fine della coda, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> restituisce solo `true` se il nuovo messaggio arriva entro l'intervallo di tempo specificato, ha una priorità inferiore rispetto a tutti i messaggi attualmente nella coda e viene inserito alla fine della coda. Un overload senza parametri restituisce immediatamente se sono presenti altri messaggi nella coda.  
  
 Al momento della creazione, un enumeratore concettualmente prima del primo messaggio dell'enumerazione e la prima chiamata a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> consente il primo messaggio dell'enumerazione nella visualizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro di timeout non è valido. Può rappresentare un numero negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">È stata avviata un'eccezione specifica di Accodamento messaggi.  
  
 oppure  
  
 Il timeout è scaduto.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rimuove il messaggio corrente dalla coda e restituisce il messaggio all'applicazione che ha eseguito la chiamata. La rimozione del messaggio determina la sua eliminazione dalla coda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento descritto per questi overload è applicabile solo se il <xref:System.Messaging.MessageEnumerator> istanza viene recuperata mediante la <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. Non utilizzare <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> per recuperare un'istanza di <xref:System.Messaging.MessageEnumerator> come questo metodo è stato deprecato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove il messaggio corrente da una coda transazionale o non transazionale e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Non esistono timeout specifici per l'arrivo di un messaggio nella coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore.  
  
 Se si utilizza l'inserimento nel journal della coda, la rimozione del messaggio provoca una copia da mantenere nella coda journal di come il <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato sul messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Se si chiama questo overload in una coda transazionale, Accodamento messaggi consente di creare una singola transazione interna.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">L'oggetto <see cref="T:System.Messaging.MessageQueueTransaction" /> che specifica la transazione nella quale verrà rimosso il messaggio.</param>
        <summary>Rimuove il messaggio corrente da una coda transazionale e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Non esistono timeout specifici per l'arrivo di un messaggio nella coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore, utilizzando il contesto di transazione interna definito per il `transaction` parametro.  
  
 Se si utilizza l'inserimento nel journal della coda, la rimozione del messaggio provoca una copia da mantenere nella coda journal di come il <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si utilizzano code transazionali, un rollback di una transazione provoca dei messaggi rimossi da una chiamata a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> deve essere restituito alla coda. La rimozione non è irreversibile fino a quando non viene eseguito il commit della transazione.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato sul messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Rimuove il messaggio corrente da una coda e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Non esistono timeout specifici per l'arrivo di un messaggio nella coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore, utilizzando il contesto di transazione definito dal `transactionType` parametro.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale di fuori di un contesto di transazione.  
  
 Se si utilizza l'inserimento nel journal della coda, la rimozione del messaggio provoca una copia da mantenere nella coda journal di come il <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si utilizzano code transazionali, un rollback di una transazione provoca dei messaggi rimossi da una chiamata a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> deve essere restituito alla coda. La rimozione non è irreversibile fino a quando non viene eseguito il commit della transazione.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato sul messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Il tempo di attesa dell'arrivo del messaggio nella coda.</param>
        <summary>Rimuove il messaggio corrente dalla coda e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Se è necessario rimuovere un messaggio, il metodo lo restituisce immediatamente. In caso contrario, il metodo attende il timeout specificato per l'arrivo di un nuovo messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore. Se il cursore si trova alla fine della coda, l'overload del metodo attende fino a quando non è disponibile un messaggio o l'intervallo specificato da di `timeout` parametro è scaduto.  
  
 Se si utilizza l'inserimento nel journal della coda, la rimozione del messaggio provoca una copia da mantenere nella coda journal di come il <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato sul messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Se si chiama questo overload in una coda transazionale, Accodamento messaggi consente di creare una singola transazione interna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il timeout è scaduto.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Il tempo di attesa per l'eliminazione del messaggio.</param>
        <param name="transaction">L'oggetto <see cref="T:System.Messaging.MessageQueueTransaction" /> che specifica il contesto della transazione per il messaggio.</param>
        <summary>Rimuove il messaggio corrente da una coda transazionale e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Se è necessario rimuovere un messaggio, il metodo lo restituisce immediatamente. In caso contrario, il metodo attende il timeout specificato per l'arrivo di un nuovo messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore. Se il cursore si trova alla fine della coda, l'overload del metodo attende fino a quando non è disponibile un messaggio o l'intervallo specificato da di `timeout` parametro è scaduto.  
  
 Quando si utilizzano code transazionali, un rollback di una transazione provoca dei messaggi rimossi da una chiamata a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> deve essere restituito alla coda. La rimozione non è irreversibile fino a quando non viene eseguito il commit della transazione.  
  
 Se si utilizza l'inserimento nel journal della coda, la rimozione del messaggio provoca una copia da mantenere nella coda journal di come il <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato sul messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il timeout è scaduto.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Il tempo di attesa per l'eliminazione del messaggio.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Rimuove il messaggio corrente da una coda e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Se è necessario rimuovere un messaggio, il metodo lo restituisce immediatamente. In caso contrario, il metodo attende il timeout specificato per l'arrivo di un nuovo messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore, utilizzando il contesto di transazione definito dal `transactionType` parametro. Se il cursore si trova alla fine della coda, l'overload del metodo attende fino a quando non è disponibile un messaggio o l'intervallo specificato da di `timeout` parametro è scaduto.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale di fuori di un contesto di transazione.  
  
 Se si utilizza l'inserimento nel journal della coda, la rimozione del messaggio provoca una copia da mantenere nella coda journal di come il <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si utilizzano code transazionali, un rollback di una transazione provoca dei messaggi rimossi da una chiamata a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> deve essere restituito alla coda. La rimozione non è irreversibile fino a quando non viene eseguito il commit della transazione.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato sul messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il timeout è scaduto.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta l'enumeratore corrente, in modo che punti all'inizio della coda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un enumeratore possibile solo spostare in avanti. Utilizzare questo metodo per ricominciare all'inizio della coda.  
  
 Dopo la chiamata <xref:System.Messaging.MessageEnumerator.Reset%2A>, il cursore punta al primo messaggio. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.Reset%2A> per spostare in avanti il cursore per il primo messaggio nella coda.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al messaggio nella posizione corrente del cursore.</summary>
        <value>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al messaggio nella posizione corrente del cursore.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>