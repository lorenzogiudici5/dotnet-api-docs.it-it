<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4379ee40d46f53235db4d9ead5c309e1261f398e" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39987347" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornisce un cursore forward-only per enumerare i messaggi in una coda di messaggi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Messaging.MessageEnumerator> per l'interazione dinamica con i messaggi in una coda. I metodi disponibili tramite il <xref:System.Messaging.MessageQueue> classe può restituire un <xref:System.Messaging.MessageEnumerator> che punta a un elenco dinamico di messaggi nella coda o una matrice che contiene una copia in un determinato istante - snapshot - della coda al momento il metodo specificato è stato chiamato.  
  
 A differenza di uno snapshot statico, un enumeratore consente di modificare la raccolta. Usando un <xref:System.Messaging.MessageEnumerator>, è possibile rimuovere i messaggi dalla coda e la modifica si riflette immediatamente in coda.  
  
 Un enumeratore non rimuove i messaggi dalla coda quando viene eseguita una query della coda. Restituisce informazioni sul messaggio nella posizione corrente del cursore, ma lascia il messaggio nella coda.  
  
 Oggetto <xref:System.Messaging.MessageEnumerator> viene inizializzato all'inizio di un elenco dinamico di un cursore. L'ordine dell'elenco è lo stesso l'ordine dei messaggi nella coda, in base alla priorità del messaggio. È possibile spostare il cursore per il primo messaggio nella coda chiamando <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Dopo che l'enumeratore è stato inizializzato, è possibile usare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> per avanzare attraverso i messaggi rimanenti. È possibile specificare se si desidera attendere un messaggio diventi disponibile mediante il passaggio di un timeout di <xref:System.Messaging.MessageEnumerator.MoveNext%2A> (metodo).  
  
 Poiché l'enumeratore è dinamico, un messaggio che viene aggiunto oltre la posizione del cursore corrente (ad esempio, a causa della priorità bassa), sono accessibili dall'enumeratore. Un messaggio inserito prima di iniziare la posizione del cursore corrente non è accessibile. Non è possibile tornare indietro con un <xref:System.Messaging.MessageEnumerator>. Un cursore consente lo spostamento di tipo forward-only. Il <xref:System.Messaging.MessageEnumerator.Reset%2A> metodo consente di posizionare il cursore all'inizio della coda.  
  
 Le istanze di <xref:System.Messaging.MessageEnumerator> per una determinata coda funzionano in modo indipendente. È possibile creare due <xref:System.Messaging.MessageEnumerator> istanze che si applicano alla stessa coda. Le modifiche che uno <xref:System.Messaging.MessageEnumerator> rende ai messaggi nella coda verranno riportate immediatamente in un secondo enumeratore se il secondo enumeratore è posizionato prima del primo. Tuttavia, se dispone di due enumeratori nella stessa posizione e uno di essi rimuove il messaggio in tale posizione, viene generata un'eccezione se l'altro enumeratore prova a ottenere il valore della <xref:System.Messaging.MessageEnumerator.Current%2A> proprietà del messaggio appena eliminato.  
  
> [!NOTE]
>  Se si crea un'istanza di <xref:System.Messaging.MessageQueue> con <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> impostato su `true`, nessun altra applicazione può modificare i messaggi dell'enumeratore mentre attiva la connessione alla coda.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene un elenco dinamico di messaggi in una coda e conta tutti i messaggi con il <xref:System.Messaging.Message.Priority%2A> impostata su <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rende disponibili le risorse associate all'enumeratore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il sistema operativo viene mantenuto un handle aperto per la coda nel corso della durata del cursore. Quando si have terminato di usare con l'enumeratore, chiamare <xref:System.Messaging.MessageEnumerator.Close%2A> per rilasciare le risorse associate all'handle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il <see cref="T:System.Messaging.Message" /> corrente cui punta questo enumeratore.</summary>
        <value>Il messaggio corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene creato l'enumeratore, fa riferimento all'inizio della coda, in corrispondenza della posizione prima del primo messaggio. In questo caso, <xref:System.Messaging.MessageEnumerator.Current%2A> non è valido e verrà generata un'eccezione se viene eseguito l'accesso. È necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> per posizionare il cursore il primo messaggio nella coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">È stata chiamata la proprietà <see cref="P:System.Messaging.MessageEnumerator.Current" /> prima della prima chiamata al metodo <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. Il cursore precede il primo elemento dell'enumerazione del messaggio.  
  
oppure 
È stato chiamato <see cref="P:System.Messaging.MessageEnumerator.Current" /> dopo che una chiamata a <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> ha restituito <see langword="false" />, il che indica che il cursore è posizionato dopo l'ultimo elemento dell'enumerazione del messaggio.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il messaggio cui l'enumeratore punta correntemente non esiste più. Potrebbe essere stato eliminato.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle del cursore nativo di Accodamento messaggi utilizzato per visualizzare i messaggi della coda.</summary>
        <value>L'handle del cursore nativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà contiene l'handle nativo all'enumerazione. Quando si have terminato di usare con l'enumeratore, chiamare <xref:System.Messaging.MessageEnumerator.Close%2A> per rilasciare la risorsa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">L'handle non esiste.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia le risorse usate da <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate da <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata <xref:System.Messaging.MessageEnumerator.Dispose%2A> consente le risorse usate dal <xref:System.Messaging.MessageEnumerator> riallocazione per altri scopi. Per altre informazioni sulle <xref:System.Messaging.MessageEnumerator.Dispose%2A>, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.Messaging.MessageEnumerator" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da parte del pubblico <xref:System.Messaging.MessageEnumerator.Dispose%2A> metodo e <xref:System.Object.Finalize%2A> (metodo). `Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama `Dispose` con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.Messaging.MessageEnumerator> fa riferimento. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. In caso di override di <see langword="Dispose(Boolean)" />, non fare riferimento a oggetti già eliminati in una chiamata precedente a <see langword="Dispose" />. Per altre informazioni su come implementare <see langword="Dispose" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  Per altre informazioni sulle <see langword="Dispose" /> e <see langword="Finalize" />, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [override del metodo Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sposta l'enumeratore al messaggio successivo della coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sposta l'enumeratore al messaggio successivo della coda, se ve n'è uno disponibile.</summary>
        <returns>
          <see langword="true" />, se l'enumeratore ha completato il passaggio al messaggio successivo; <see langword="false" />, se l'enumeratore ha raggiunto la fine della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload restituisce immediatamente se sono presenti messaggi nella coda. È un altro overload in attesa di un determinato <xref:System.TimeSpan> per un messaggio in arrivo.  
  
 Se un messaggio non è attualmente disponibile perché la coda è vuota o è stata spostata oltre l'ultimo elemento nella raccolta <xref:System.Messaging.MessageEnumerator.MoveNext%2A> restituisce `false` al metodo di chiamata.  
  
 Al momento della creazione, un enumeratore concettualmente precede il primo messaggio della coda e la prima chiamata a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> consente di visualizzare il primo messaggio della coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">È stata avviata un'eccezione specifica di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Il <see cref="T:System.TimeSpan" /> da attendere perché un messaggio diventi disponibile se l'enumeratore è posizionato alla fine della coda.</param>
        <summary>Sposta l'enumeratore al messaggio successivo della coda. Se l'enumeratore si trova alla fine della coda, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> attende finché non scade il timeout o finché è disponibile un messaggio.</summary>
        <returns>
          <see langword="true" />, se l'enumeratore ha completato il passaggio al messaggio successivo; <see langword="false" />, se l'enumeratore ha raggiunto la fine della coda e un messaggio non si rende disponibile nel tempo specificato dal parametro <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è in attesa se sono presenti messaggi nella coda o se il cursore ha raggiunto la fine della coda. Se un messaggio non è attualmente disponibile perché la coda è vuota o è stata spostata oltre l'ultimo elemento nella raccolta, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> attende il timeout specificato.  
  
 Se il cursore si trova già alla fine della coda <xref:System.Messaging.MessageEnumerator.MoveNext%2A> restituisce solo `true` se il nuovo messaggio pervenuto entro l'intervallo di tempo specificato, ha una priorità inferiore rispetto a tutti i messaggi attualmente nella coda e viene inserito alla fine della coda. Un overload senza parametri restituisce immediatamente se sono presenti altri messaggi nella coda.  
  
 Al momento della creazione, un enumeratore concettualmente precede il primo messaggio di enumerazione e la prima chiamata a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> consente il primo messaggio di enumerazione nella visualizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro di timeout non è valido. Può rappresentare un numero negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">È stata avviata un'eccezione specifica di Accodamento messaggi.  
  
oppure 
Il timeout è scaduto.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rimuove il messaggio corrente dalla coda e restituisce il messaggio all'applicazione che ha eseguito la chiamata. La rimozione del messaggio determina la sua eliminazione dalla coda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento descritto per questi overload è applicabile solo se il <xref:System.Messaging.MessageEnumerator> istanza viene recuperata utilizzando la <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. Non utilizzare <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> per recuperare un'istanza di <xref:System.Messaging.MessageEnumerator> come questo metodo è stato deprecato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove il messaggio corrente da una coda transazionale o non transazionale e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Non esistono timeout specifici per l'arrivo di un messaggio nella coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore.  
  
 Se si usa inserimento nel journal della coda, la rimozione del messaggio provoca una copia rimanere nella coda del journal, proprio come le <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato al messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Se si chiama questo overload su una coda transazionale, il servizio Accodamento messaggi consente di creare una singola transazione interna.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">L'oggetto <see cref="T:System.Messaging.MessageQueueTransaction" /> che specifica la transazione nella quale verrà rimosso il messaggio.</param>
        <summary>Rimuove il messaggio corrente da una coda transazionale e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Non esistono timeout specifici per l'arrivo di un messaggio nella coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore, utilizzando il contesto di transazione interna definito dal `transaction` parametro.  
  
 Se si usa inserimento nel journal della coda, la rimozione del messaggio provoca una copia rimanere nella coda del journal, proprio come le <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si utilizza code transazionali, un rollback di una transazione fa in modo che tutti i messaggi rimossi da una chiamata a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> da restituire alla coda. La rimozione non è irreversibile, fino a quando non viene eseguito il commit della transazione.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato al messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Rimuove il messaggio corrente da una coda e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Non esistono timeout specifici per l'arrivo di un messaggio nella coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore, utilizzando un contesto di transazione definito dal `transactionType` parametro.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale all'esterno di un contesto di transazione.  
  
 Se si usa inserimento nel journal della coda, la rimozione del messaggio provoca una copia rimanere nella coda del journal, proprio come le <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si utilizza code transazionali, un rollback di una transazione fa in modo che tutti i messaggi rimossi da una chiamata a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> da restituire alla coda. La rimozione non è irreversibile, fino a quando non viene eseguito il commit della transazione.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato al messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Il tempo di attesa dell'arrivo del messaggio nella coda.</param>
        <summary>Rimuove il messaggio corrente dalla coda e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Se è necessario rimuovere un messaggio, il metodo lo restituisce immediatamente. In caso contrario, il metodo attende il timeout specificato per l'arrivo di un nuovo messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore. Se il cursore si trova alla fine della coda, l'overload del metodo attende fino a quando non è disponibile un messaggio o l'intervallo specificato da di `timeout` parametro è scaduto.  
  
 Se si usa inserimento nel journal della coda, la rimozione del messaggio provoca una copia rimanere nella coda del journal, proprio come le <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato al messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Se si chiama questo overload su una coda transazionale, il servizio Accodamento messaggi consente di creare una singola transazione interna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il timeout è scaduto.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Il tempo di attesa per l'eliminazione del messaggio.</param>
        <param name="transaction">L'oggetto <see cref="T:System.Messaging.MessageQueueTransaction" /> che specifica il contesto della transazione per il messaggio.</param>
        <summary>Rimuove il messaggio corrente da una coda transazionale e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Se è necessario rimuovere un messaggio, il metodo lo restituisce immediatamente. In caso contrario, il metodo attende il timeout specificato per l'arrivo di un nuovo messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore. Se il cursore si trova alla fine della coda, l'overload del metodo attende fino a quando non è disponibile un messaggio o l'intervallo specificato da di `timeout` parametro è scaduto.  
  
 Quando si utilizza code transazionali, un rollback di una transazione fa in modo che tutti i messaggi rimossi da una chiamata a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> da restituire alla coda. La rimozione non è irreversibile, fino a quando non viene eseguito il commit della transazione.  
  
 Se si usa inserimento nel journal della coda, la rimozione del messaggio provoca una copia rimanere nella coda del journal, proprio come le <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato al messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il timeout è scaduto.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Il tempo di attesa per l'eliminazione del messaggio.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Rimuove il messaggio corrente da una coda e restituisce il messaggio all'applicazione che ha eseguito la chiamata. Se è necessario rimuovere un messaggio, il metodo lo restituisce immediatamente. In caso contrario, il metodo attende il timeout specificato per l'arrivo di un nuovo messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Rimuove e restituisce il messaggio nella posizione corrente del cursore, utilizzando un contesto di transazione definito dal `transactionType` parametro. Se il cursore si trova alla fine della coda, l'overload del metodo attende fino a quando non è disponibile un messaggio o l'intervallo specificato da di `timeout` parametro è scaduto.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale all'esterno di un contesto di transazione.  
  
 Se si usa inserimento nel journal della coda, la rimozione del messaggio provoca una copia rimanere nella coda del journal, proprio come le <xref:System.Messaging.MessageQueue> della classe <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Quando si utilizza code transazionali, un rollback di una transazione fa in modo che tutti i messaggi rimossi da una chiamata a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> da restituire alla coda. La rimozione non è irreversibile, fino a quando non viene eseguito il commit della transazione.  
  
 Quando si rimuove il messaggio corrente, il cursore viene spostato al messaggio successivo. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il timeout è scaduto.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta l'enumeratore corrente, in modo che punti all'inizio della coda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un enumeratore possibile solo spostare in avanti. Utilizzare questo metodo per ricominciare dall'inizio della coda.  
  
 Dopo aver chiamato <xref:System.Messaging.MessageEnumerator.Reset%2A>, il cursore fa riferimento al primo messaggio. Non è necessario chiamare <xref:System.Messaging.MessageEnumerator.MoveNext%2A> dopo la chiamata <xref:System.Messaging.MessageEnumerator.Reset%2A> per spostare in avanti il cursore per il primo messaggio nella coda.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al messaggio nella posizione corrente del cursore.</summary>
        <value>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al messaggio nella posizione corrente del cursore.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>