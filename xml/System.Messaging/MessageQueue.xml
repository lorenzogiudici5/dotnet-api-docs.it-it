<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="69f2777a276f8aef609d1f9fef1f688a44f8ef6f" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="it-IT" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52217446" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce l'accesso a una coda su un server di Accodamento messaggi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tecnologia di Accodamento messaggi consente alle applicazioni eseguite in momenti diversi di comunicare su reti eterogenee e sistemi che potrebbero essere temporaneamente offline. Viene inviato dalle applicazioni, ricevere o leggere i messaggi dalle code (sola lettura senza rimuoverlo). Il servizio Accodamento messaggi è un componente facoltativo di [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] e Windows NT e deve essere installato separatamente.  
  
 Il <xref:System.Messaging.MessageQueue> classe è un wrapper per il servizio Accodamento messaggi. Sono disponibili più versioni di Accodamento messaggi e l'utilizzo di <xref:System.Messaging.MessageQueue> classe può provocare un comportamento leggermente diverso, a seconda del sistema operativo in uso. Per informazioni sulle funzionalità specifiche di ogni versione di Microsoft Message Queuing, vedere l'argomento "What' s New in Accodamento messaggi" in Platform SDK in MSDN.  
  
 Il <xref:System.Messaging.MessageQueue> classe fornisce un riferimento a una coda di Accodamento messaggi. È possibile specificare un percorso nel <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore per la connessione a una risorsa esistente, oppure è possibile creare una nuova coda nel server. Prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, o <xref:System.Messaging.MessageQueue.Receive%2A>, è necessario associare la nuova istanza del <xref:System.Messaging.MessageQueue> classe con una coda esistente. A questo punto, è possibile modificare le proprietà della coda, ad esempio <xref:System.Messaging.MessageQueue.Category%2A> e <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> supporta due tipi di recupero dei messaggi: sincrone e asincrone. I metodi sincroni <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.Receive%2A>, provoca l'intervallo di tempo specificato per un nuovo messaggio in arrivo nella coda di attesa del thread di processo. I metodi asincroni <xref:System.Messaging.MessageQueue.BeginPeek%2A> e <xref:System.Messaging.MessageQueue.BeginReceive%2A>, consentire le attività principale dell'applicazione in un thread separato fino a un messaggio arriva nella coda. Questi metodi funzionano con gli oggetti di callback e oggetti di stato per comunicare informazioni tra i thread.  
  
 Quando si crea una nuova istanza di <xref:System.Messaging.MessageQueue> (classe), non si sta creando una nuova coda di Accodamento messaggi. In alternativa, è possibile usare la <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, e <xref:System.Messaging.MessageQueue.Purge%2A> metodi per gestire le code sul server.  
  
 A differenza <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> e <xref:System.Messaging.MessageQueue.Delete%28System.String%29> sono `static` membri, in modo da chiamarle senza creare una nuova istanza di <xref:System.Messaging.MessageQueue> classe.  
  
 È possibile impostare il <xref:System.Messaging.MessageQueue> dell'oggetto <xref:System.Messaging.MessageQueue.Path%2A> proprietà con uno dei tre nomi: il nome descrittivo, il <xref:System.Messaging.MessageQueue.FormatName%2A>, o <xref:System.Messaging.MessageQueue.Label%2A>. Il nome descrittivo, che viene definito per la coda <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> delle proprietà, viene <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> per una coda pubblica, e <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> per una coda privata. Il <xref:System.Messaging.MessageQueue.FormatName%2A> proprietà consente l'accesso offline per le code di messaggi. Infine, è possibile usare la coda <xref:System.Messaging.MessageQueue.Label%2A> proprietà per impostare la coda <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Per un elenco di valori di proprietà iniziali per un'istanza di <xref:System.Messaging.MessageQueue>, vedere il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore.  
  
   
  
## Examples  
 Esempio di codice seguente crea nuovi <xref:System.Messaging.MessageQueue> di oggetti usando vari tipi di sintassi di nome di percorso. In ogni caso, viene inviato un messaggio nella coda cui percorso viene definita nel costruttore.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 Esempio di codice seguente invia un messaggio a una coda e riceve un messaggio da una coda, utilizzando una classe specifica dell'applicazione denominata `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Solo il <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> metodo è thread-safe.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" />. Dopo che il costruttore predefinito ha inizializzato la nuova istanza, sarà necessario impostare la proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> dell'istanza prima di poterla utilizzare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare una nuova istanza di <xref:System.Messaging.MessageQueue> classe che non è immediatamente associati a una coda nel server di Accodamento messaggi. Prima di usare questa istanza, è necessario connetterla a una coda di Accodamento esistente impostando il <xref:System.Messaging.MessageQueue.Path%2A> proprietà. In alternativa, è possibile impostare il <xref:System.Messaging.MessageQueue> un riferimento di <xref:System.Messaging.MessageQueue.Create%28System.String%29> valore restituito del metodo, in modo da creare una nuova coda di Accodamento messaggi.  
  
 Il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore crea una nuova istanza del <xref:System.Messaging.MessageQueue> classe; non viene creata una nuova coda di Accodamento messaggi.  
  
 La tabella seguente illustra i valori iniziali delle proprietà per un'istanza di <xref:System.Messaging.MessageQueue>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.MessagePropertyFilter> classe. Tutti i valori di filtro sono impostati su `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 Esempio di codice seguente crea un nuovo <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" /> che fa riferimento alla coda di Accodamento messaggi nel percorso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload quando si desidera associare il nuovo <xref:System.Messaging.MessageQueue> istanza a una determinata coda Accodamento messaggi, per il quale si conosce il percorso, nome del formato o etichetta. Se si desidera concedere l'accesso esclusivo per la prima applicazione di cui fa riferimento alla coda, è necessario impostare il <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> proprietà `true` o utilizzare il costruttore che passa un parametro di restrizione di accesso in lettura.  
  
 Il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore crea una nuova istanza del <xref:System.Messaging.MessageQueue> classe; non viene creata una nuova coda di Accodamento messaggi. Per creare una nuova coda in Accodamento messaggi, usare <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintassi del `path` parametro dipende il tipo di coda cui fa riferimento, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|coda pubblica|`MachineName`\\`QueueName`|  
|coda privata|`MachineName`\\`Private$`\\`QueueName`|  
|Coda del diario|`MachineName`\\`QueueName`\\`Journal$`|  
|Coda journal computer|`MachineName`\\`Journal$`|  
|Computer non recapitabili|`MachineName`\\`Deadletter$`|  
|Macchina transazionale non recapitabili|`MachineName`\\`XactDeadletter$`|  
  
 In alternativa, è possibile usare la <xref:System.Messaging.MessageQueue.FormatName%2A> o <xref:System.Messaging.MessageQueue.Label%2A> per descrivere il percorso della coda, come illustrato nella tabella seguente.  
  
|Riferimenti|Sintassi|Esempio|  
|---------------|------------|-------------|  
|Nome del formato|`FormatName:` [ *nome del formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [ *etichetta* ]|`Label:` TheLabel|  
  
 Per funzionare offline, è necessario utilizzare la sintassi del nome di formato, non la sintassi del nome del percorso per il costruttore. In caso contrario, viene generata un'eccezione perché il controller di dominio primario non è disponibile per risolvere il percorso per il nome del formato.  
  
 La tabella seguente illustra i valori iniziali delle proprietà per un'istanza di <xref:System.Messaging.MessageQueue>. Questi valori sono basati sulle proprietà della coda di Accodamento con il percorso specificato da di `path` parametro.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, se l'impostazione del livello di privacy della coda di accodamento è "Corpo"; in caso contrario, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Il valore della proprietà nome computer della coda di Accodamento.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, se non impostato dal costruttore.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, se non impostato dal costruttore.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, se è abilitata l'impostazione del giornale di registrazione dell'oggetto Message Queuing; in caso contrario, `false`.|  
  
   
  
## Examples  
 Esempio di codice seguente crea nuovi <xref:System.Messaging.MessageQueue> di oggetti usando vari tipi di sintassi di nome di percorso. In ogni caso, viene inviato un messaggio nella coda cui percorso viene definita nel costruttore.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è valida, probabilmente perché non è stata impostata.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento, che può essere "." per il computer locale.</param>
        <param name="sharedModeDenyReceive"><see langword="true" /> per concedere l'accesso esclusivo in lettura alla prima applicazione con cui viene eseguito l'accesso alla coda; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" /> che fa riferimento alla coda di Accodamento messaggi nel percorso specificato e con la restrizione specificata per l'accesso in lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload quando si desidera associare il nuovo <xref:System.Messaging.MessageQueue> a una determinata coda Accodamento messaggi, per il quale si conosce il percorso, nome del formato o etichetta. Se si desidera concedere l'accesso esclusivo per la prima applicazione di cui fa riferimento alla coda, impostare il `sharedModeDenyReceive` parametro per `true`. In caso contrario, impostare `sharedModeDenyReceive` al `false` o usare il costruttore che ha solo un `path` parametro.  
  
 L'impostazione `sharedModeDenyReceive` a `true` influisce su tutti gli oggetti che accedono alla coda Accodamento messaggi, comprese le altre applicazioni. Gli effetti del parametro non sono limitati a questa applicazione.  
  
 Il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore crea una nuova istanza del <xref:System.Messaging.MessageQueue> classe; non viene creata una nuova coda di Accodamento messaggi. Per creare una nuova coda in Accodamento messaggi, usare <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintassi del `path` parametro dipende dal tipo di coda dei messaggi.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|coda pubblica|`MachineName`\\`QueueName`|  
|coda privata|`MachineName`\\`Private$`\\`QueueName`|  
|Coda del diario|`MachineName`\\`QueueName`\\`Journal$`|  
|Coda journal computer|`MachineName`\\`Journal$`|  
|Computer non recapitabili|`MachineName`\\`Deadletter$`|  
|Macchina transazionale non recapitabili|`MachineName`\\`XactDeadletter$`|  
  
 In alternativa, è possibile usare il nome del formato o l'etichetta di una coda di Accodamento messaggi per descrivere il percorso della coda.  
  
|Riferimenti|Sintassi|Esempio|  
|---------------|------------|-------------|  
|Nome del formato|`FormatName:` [ *nome del formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [ *etichetta* ]|`Label:` TheLabel|  
  
 Per funzionare offline, è necessario usare la sintassi del nome di formato, anziché la sintassi del nome descrittivo. In caso contrario, viene generata un'eccezione perché il controller di dominio primario (in cui risiede Active Directory) non è disponibile per risolvere il percorso per il nome del formato.  
  
 Se un <xref:System.Messaging.MessageQueue> apre una coda con il `sharedModeDenyReceive` parametro impostato su `true`, qualsiasi <xref:System.Messaging.MessageQueue> che successivamente cerca di leggere dalla coda genera una <xref:System.Messaging.MessageQueueException> a causa di una violazione di condivisione. Oggetto <xref:System.Messaging.MessageQueueException> viene generata anche se un <xref:System.Messaging.MessageQueue> prova ad accedere alla coda in modalità esclusiva mentre un oggetto <xref:System.Messaging.MessageQueue> dispone già dell'accesso non esclusivo alla coda.  
  
 La tabella seguente illustra i valori iniziali delle proprietà per un'istanza di <xref:System.Messaging.MessageQueue>. Questi valori sono basati sulle proprietà della coda di Accodamento messaggi, con il percorso specificato da di `path` parametro.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, se l'impostazione del livello di privacy della coda di accodamento è "Corpo"; in caso contrario, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Il valore della proprietà nome computer della coda di Accodamento.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, se non impostato dal costruttore.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, se non impostato dal costruttore.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Valore del parametro `sharedModeDenyReceive`.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, se è abilitata l'impostazione del giornale di registrazione dell'oggetto Message Queuing; in caso contrario, `false`.|  
  
   
  
## Examples  
 Esempio di codice seguente crea un nuovo <xref:System.Messaging.MessageQueue> con accesso esclusivo, viene impostato il percorso e invia un messaggio alla coda.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è valida, probabilmente perché non è stata impostata.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento, che può essere "." per il computer locale.</param>
        <param name="accessMode">Uno dei valori di <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento, che può essere "." per il computer locale.</param>
        <param name="sharedModeDenyReceive"><see langword="true" /> per concedere l'accesso esclusivo in lettura alla prima applicazione con cui viene eseguito l'accesso alla coda; in caso contrario, <see langword="false" />.</param>
        <param name="enableCache"><see langword="true" /> per creare e utilizzare una cache di connessioni; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente crea un nuovo <xref:System.Messaging.MessageQueue> con accesso in lettura esclusivo e con connessione la memorizzazione nella cache abilitata.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento, che può essere "." per il computer locale.</param>
        <param name="sharedModeDenyReceive"><see langword="true" /> per concedere l'accesso esclusivo in lettura alla prima applicazione con cui viene eseguito l'accesso alla coda; in caso contrario, <see langword="false" />.</param>
        <param name="enableCache"><see langword="true" /> per creare e utilizzare una cache di connessioni; in caso contrario, <see langword="false" />.</param>
        <param name="accessMode">Uno dei valori di <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica la modalità di accesso per la coda.</summary>
        <value>Uno dei valori di <see cref="T:System.Messaging.QueueAccessMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità di accesso predefinito per una coda è `QueueAccessMode.SendAndReceive`, se non diversamente specificato quando si chiama il costruttore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la coda accetta solo messaggi autenticati.</summary>
        <value><see langword="true" /> se la coda accetta solo messaggi autenticati; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'autenticazione dei messaggi fornisce un modo per garantire l'integrità del messaggio e per verificare chi ha inviato il messaggio. Per richiedere l'autenticazione, l'applicazione mittente Imposta livello di autenticazione del messaggio.  
  
 Quando si imposta <xref:System.Messaging.MessageQueue.Authenticate%2A> al `true`, si limiterà l'accesso alla coda nel server, non solo a questa <xref:System.Messaging.MessageQueue> istanza. Saranno interessati tutti i client che utilizzano la stessa coda di Accodamento messaggi.  
  
 Una coda che accetta solo messaggi autenticati rifiuta un messaggio non autenticato. Per richiedere la notifica di rifiuto di messaggio, è possibile impostare un'applicazione di invio di <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà del messaggio. Poiché non esiste alcun'altra indicazione di rifiuto di messaggio, l'applicazione mittente può perdere il messaggio a meno che non si richiede di essere inviato per la coda di messaggi non recapitabili.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.Authenticate%2A> proprietà.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la priorità di base utilizzata da Accodamento messaggi per effettuare il routing dei messaggi di una coda pubblica sulla rete.</summary>
        <value>La singola priorità di base relativa a tutti i messaggi inviati alla coda (pubblica). Il valore predefinito è zero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Priorità di base di una coda di messaggi specifica il modo in cui un messaggio di transito a quella coda viene considerata durante la trasmissione attraverso la rete. È possibile impostare il <xref:System.Messaging.MessageQueue.BasePriority%2A> proprietà per attribuire una priorità superiore o inferiore a tutti i messaggi inviati alla coda specificata rispetto a quelli inviati ad altre code. Impostando questa proprietà viene modificata la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica.  
  
 Una coda di messaggi <xref:System.Messaging.MessageQueue.BasePriority%2A> non è correlato il <xref:System.Messaging.Message.Priority%2A> proprietà di un messaggio che specifica l'ordine in cui viene inserito un messaggio in arrivo nella coda.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> si applica solo alle code pubbliche i cui percorsi sono specificati utilizzando il nome di formato. La priorità di base di una coda privata è sempre zero (0).  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.BasePriority%2A> proprietà.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La priorità di base è stata impostata su un valore non valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <summary>Avvia un'operazione di lettura asincrona, indicando ad Accodamento messaggi di avviare la lettura di un messaggio e inviare una notifica al gestore eventi al termine dell'operazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia un'operazione di lettura asincrona per la quale non è stato specificato un intervallo di timeout. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda.</summary>
        <returns><see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, si utilizza <xref:System.Messaging.MessageQueue.BeginPeek%2A> per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando un messaggio diventa disponibile nella coda.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato anche se esiste già un messaggio nella coda.  
  
 Usare <xref:System.Messaging.MessageQueue.BeginPeek%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarla al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Avvia un'operazione di lettura asincrona. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando arriva un messaggio nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> o recuperando il risultato mediante la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginPeek%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata fino a quando non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginPeek%2A> è asincrona, è possibile chiamare questo metodo per leggere la coda senza bloccare il thread di esecuzione corrente. Per leggere in modo sincrono la coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo).  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore dell'evento per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginPeek%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile usare questo <xref:System.IAsyncResult> tutta la durata dell'operazione, anche se in genere non si usa solo <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> i valori in una matrice e specificare se si desidera attendere che tutte le operazioni o qualsiasi operazione di completamento. In questo caso, si utilizza il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> viene `false`, viene generato l'evento di completamento, ma verrà generata un'eccezione quando si chiama <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea un gestore eventi denominato `MyPeekCompleted`, lo collega al <xref:System.Messaging.MessageQueue.PeekCompleted> delegato del gestore eventi e chiamate <xref:System.Messaging.MessageQueue.BeginPeek%2A> per avviare un'operazione di lettura asincrona in coda che si trova nel percorso ". \myQueue". Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato l'evento, l'esempio legge il messaggio e scrive il corpo sullo schermo. Nell'esempio viene quindi chiamato <xref:System.Messaging.MessageQueue.BeginPeek%2A> nuovamente per avviare una nuova operazione di lettura asincrona.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <summary>Avvia un'operazione di lettura asincrona per la quale è stato specificato un periodo di timeout. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns><see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, si utilizza <xref:System.Messaging.MessageQueue.BeginPeek%2A> per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato anche se esiste già un messaggio nella coda.  
  
 Usare <xref:System.Messaging.MessageQueue.BeginPeek%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarla al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Avvia un'operazione di lettura asincrona. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando arriva un messaggio nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> o recuperando il risultato mediante la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginPeek%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata fino a quando non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginPeek%2A> è asincrona, è possibile chiamare questo metodo per leggere la coda senza bloccare il thread di esecuzione corrente. Per leggere in modo sincrono la coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo).  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore dell'evento per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginPeek%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile usare questo <xref:System.IAsyncResult> tutta la durata dell'operazione, anche se in genere non si usa solo <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> i valori in una matrice e specificare se si desidera attendere che tutte le operazioni o qualsiasi operazione di completamento. In questo caso, si utilizza il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Questo overload specifica un timeout. Se l'intervallo specificato dal `timeout` scade parametro, questo componente genera il <xref:System.Messaging.MessageQueue.PeekCompleted> evento. Poiché è disponibile alcun messaggio, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> verrà generata un'eccezione.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> viene `false`, viene generato l'evento di completamento, ma verrà generata un'eccezione quando si chiama <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea un'operazione di lettura asincrona, usando il percorso della coda ". \myQueue". Crea un gestore eventi `MyPeekCompleted`e lo collega al <xref:System.Messaging.MessageQueue.PeekCompleted> delegato del gestore eventi. <xref:System.Messaging.MessageQueue.BeginPeek%2A> viene chiamato con un timeout di un minuto, per avviare l'operazione di lettura asincrona. Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato l'evento o alla scadenza del timeout, se presente, e il relativo corpo è scritto alla schermata, viene recuperato il messaggio. Quindi <xref:System.Messaging.MessageQueue.BeginPeek%2A> viene chiamata nuovamente per avviare una nuova operazione di lettura asincrona con il timeout stesso.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="stateObject">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <summary>Avvia un'operazione di lettura asincrona per la quale sono stati specificati un timeout e un oggetto di stato, che fornisce le informazioni associate per tutta la durata dell'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns><see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, si utilizza <xref:System.Messaging.MessageQueue.BeginPeek%2A> per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato anche se esiste già un messaggio nella coda.  
  
 Utilizzare questo overload per associare informazioni con l'operazione che verrà mantenuto per tutta la durata dell'operazione. Il gestore eventi può accedere a queste informazioni esaminando i <xref:System.IAsyncResult.AsyncState%2A> proprietà del <xref:System.IAsyncResult> associato con l'operazione.  
  
 Usare <xref:System.Messaging.MessageQueue.BeginPeek%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarla al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Avvia un'operazione di lettura asincrona. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando arriva un messaggio nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> o recuperando il risultato mediante la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginPeek%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata fino a quando non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginPeek%2A> è asincrona, è possibile chiamare questo metodo per leggere la coda senza bloccare il thread di esecuzione corrente. Per leggere in modo sincrono la coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo).  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore dell'evento per continuare a ricevere le notifiche.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Restituisce un <xref:System.IAsyncResult> che identifica l'operazione asincrona avviata dal metodo. È possibile usare questo <xref:System.IAsyncResult> tutta la durata dell'operazione, anche se in genere non si usa solo <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> i valori in una matrice e specificare se si desidera attendere che tutte le operazioni o qualsiasi operazione di completamento. In questo caso, si utilizza il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Questo overload specifica un timeout e un oggetto di stato. Se l'intervallo specificato dal `timeout` scade parametro, questo componente genera il <xref:System.Messaging.MessageQueue.PeekCompleted> evento. Poiché è disponibile alcun messaggio, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> verrà generata un'eccezione.  
  
 L'oggetto di stato associa le informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginPeek%2A> più volte per avviare più operazioni, è possibile identificare ogni operazione tramite un oggetto di stato separato definiti. Per un'illustrazione di questo scenario, vedere la sezione esempio.  
  
 È anche possibile usare l'oggetto di stato per passare informazioni tra i thread di processo. Se viene avviato un thread, ma il callback è in un thread diverso in uno scenario asincrono, l'oggetto di stato viene effettuato il marshalling e passato insieme alle informazioni dall'evento.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> viene `false`, viene generato l'evento di completamento, ma verrà generata un'eccezione quando si chiama <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea un'operazione di lettura asincrona, usando il percorso della coda ". \myQueue". Crea un gestore eventi `MyPeekCompleted`e lo collega al <xref:System.Messaging.MessageQueue.PeekCompleted> delegato del gestore eventi. <xref:System.Messaging.MessageQueue.BeginPeek%2A> viene chiamato con un timeout di un minuto. Ogni chiamata a <xref:System.Messaging.MessageQueue.BeginPeek%2A> è associato un intero univoco che identifica la specifica operazione. Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato l'evento o della scadenza del timeout, viene recuperato il messaggio, se presente, e il relativo corpo e l'identificatore di tipo integer specifici dell'operazione vengono scritti allo schermo. Quindi <xref:System.Messaging.MessageQueue.BeginPeek%2A> viene chiamata nuovamente per avviare una nuova operazione di lettura asincrona con il timeout stesso e il valore integer associato dell'operazione semplicemente completata.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="stateObject">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> che riceverà la notifica del completamento dell'operazione asincrona.</param>
        <summary>Avvia un'operazione di lettura asincrona per la quale sono stati specificati un timeout e un oggetto di stato, che fornisce le informazioni associate per tutta la durata dell'operazione. Questo overload riceve mediante un callback la notifica dell'identità del gestore eventi per l'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns><see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo overload, il callback specificato nel parametro di callback viene richiamato direttamente quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto. il <xref:System.Messaging.MessageQueue.PeekCompleted> non viene generato l'evento. Gli altri overload del <xref:System.Messaging.MessageQueue.BeginPeek%2A> si basano su questo componente per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato anche se esiste già un messaggio nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.BeginPeek%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata fino a quando non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginPeek%2A> è asincrona, è possibile chiamare questo metodo per leggere la coda senza bloccare il thread di esecuzione corrente. Per leggere in modo sincrono la coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo).  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore dell'evento per continuare a ricevere le notifiche.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Restituisce un <xref:System.IAsyncResult> che identifica l'operazione asincrona avviata dal metodo. È possibile usare questo <xref:System.IAsyncResult> tutta la durata dell'operazione, anche se in genere non si usa solo <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> i valori in una matrice e specificare se si desidera attendere che tutte le operazioni o qualsiasi operazione di completamento. In questo caso, si utilizza il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 L'oggetto di stato associa le informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginPeek%2A> più volte per avviare più operazioni, è possibile identificare ogni operazione tramite un oggetto di stato separato definiti.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea un'operazione di lettura asincrona. Il codice riportato di seguito viene inviato un messaggio a una coda di messaggi locale, quindi chiama <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passando: un valore di timeout di 10 secondi, un numero intero univoco che identifica il messaggio in questione; e una nuova istanza della <xref:System.AsyncCallback> che identifica il gestore eventi `MyPeekCompleted`. Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato l'evento, il gestore dell'evento Visualizza il messaggio e scrive il corpo del messaggio e l'identificatore del messaggio sullo schermo.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <param name="action">Uno dei valori di <see cref="T:System.Messaging.PeekAction" />. Indica se leggere il messaggio corrente nella coda oppure il messaggio successivo.</param>
        <param name="state">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> che riceve la notifica del completamento dell'operazione asincrona.</param>
        <summary>Avvia un'operazione di lettura asincrona che presenta il timeout specificato e che utilizza il cursore specificato, l'azione di lettura specificata e l'oggetto di stato specificato. L'oggetto di stato fornisce informazioni associate per l'intera durata dell'operazione. Questo overload riceve mediante un callback la notifica dell'identità del gestore eventi per l'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns><see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo overload, il callback specificato nel parametro di callback viene richiamato direttamente quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto. Il <xref:System.Messaging.MessageQueue.PeekCompleted> non viene generato l'evento. Gli altri overload del <xref:System.Messaging.MessageQueue.BeginPeek%2A> si basano su questo componente per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato anche se esiste già un messaggio nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.BeginPeek%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata fino a quando non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginPeek%2A> è asincrona, è possibile chiamare questo metodo per leggere la coda senza bloccare il thread di esecuzione corrente. Per leggere in modo sincrono la coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo).  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore dell'evento per continuare a ricevere le notifiche.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Restituisce un <xref:System.IAsyncResult> che identifica l'operazione asincrona avviata dal metodo. È possibile usare questo <xref:System.IAsyncResult> tutta la durata dell'operazione, anche se in genere non si usa solo <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> i valori in una matrice e specificare se si desidera attendere che tutte le operazioni o qualsiasi operazione di completamento. In questo caso, usare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 L'oggetto di stato associa le informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginPeek%2A> più volte per avviare più operazioni, è possibile identificare ogni operazione tramite un oggetto di stato separato definiti.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">È stato specificato un valore diverso da <see langword="PeekAction.Current" /> o <see langword="PeekAction.Next" /> per il parametro <paramref name="action" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="cursor" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <summary>Avvia un'operazione di ricezione asincrona, indicando ad Accodamento messaggi di avviare la ricezione di un messaggio e inviare una notifica al gestore eventi al termine dell'operazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia un'operazione di ricezione asincrona per la quale non è stato specificato alcun timeout. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda.</summary>
        <returns><see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, si utilizza <xref:System.Messaging.MessageQueue.BeginReceive%2A> per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando un messaggio è stato rimosso dalla coda.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato anche se esiste già un messaggio nella coda.  
  
 Usare <xref:System.Messaging.MessageQueue.BeginReceive%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarla al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Avvia un'asincrona operazione di ricezione. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando arriva un messaggio nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata fino a quando non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginReceive%2A> è asincrona, è possibile chiamare in modo da ricevere un messaggio dalla coda senza bloccare il thread di esecuzione corrente. Per ricevere in modo sincrono un messaggio, utilizzare il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo).  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore dell'evento per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginReceive%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile usare questo <xref:System.IAsyncResult> tutta la durata dell'operazione, anche se in genere non si usa solo <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> i valori in una matrice e specificare se si desidera attendere che tutte le operazioni o qualsiasi operazione di completamento. In questo caso, si utilizza il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> viene `false`, viene generato l'evento di completamento, ma verrà generata un'eccezione quando si chiama <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Non usare la chiamata asincrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transazioni. Se si desidera eseguire un'operazione asincrona transazionale, chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A>e inserire la transazione e (sincrona) <xref:System.Messaging.MessageQueue.Receive%2A> metodo all'interno del gestore di evento è creare per l'operazione di visualizzazione. Il gestore eventi potrebbe contenere funzionalità come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente vengono concatenate le richieste asincrone. Presuppone che ci sia una coda sul computer locale denominato "myQueue". Il `Main` funzione inizia l'operazione asincrona che viene gestita dal `MyReceiveCompleted` routine. `MyReceiveCompleted` Elabora il messaggio corrente e avvia un nuovo asincrona operazione di ricezione.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 Esempio di codice seguente Accoda le richieste asincrone. La chiamata a <xref:System.Messaging.MessageQueue.BeginReceive%2A> utilizza il <xref:System.IAsyncResult.AsyncWaitHandle%2A> nel relativo valore restituito. Il `Main` routine attende che tutte le operazioni asincrone essere completati prima di uscire.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <summary>Avvia un'operazione di ricezione asincrona per la quale è stato specificato un periodo di timeout. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns><see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, si utilizza <xref:System.Messaging.MessageQueue.BeginReceive%2A> per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato anche se esiste già un messaggio nella coda.  
  
 Usare <xref:System.Messaging.MessageQueue.BeginReceive%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarla al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Avvia un'asincrona operazione di ricezione. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando arriva un messaggio nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o il recupero di risultato mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata fino a quando non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginReceive%2A> è asincrona, è possibile chiamare in modo da ricevere un messaggio dalla coda senza bloccare il thread di esecuzione corrente. Per ricevere in modo sincrono un messaggio, utilizzare il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo).  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore dell'evento per continuare a ricevere le notifiche.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> viene `false`, viene generato l'evento di completamento, ma verrà generata un'eccezione quando si chiama <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginReceive%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile usare questo <xref:System.IAsyncResult> tutta la durata dell'operazione, anche se in genere non si usa solo <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> i valori in una matrice e specificare se si desidera attendere che tutte le operazioni o qualsiasi operazione di completamento. In questo caso, si utilizza il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Questo overload specifica un timeout. Se l'intervallo specificato dal `timeout` scade parametro, questo componente genera il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento. Poiché è disponibile alcun messaggio, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> verrà generata un'eccezione.  
  
 Non usare la chiamata asincrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transazioni. Se si desidera eseguire un'operazione asincrona transazionale, chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A>e inserire la transazione e (sincrona) <xref:System.Messaging.MessageQueue.Receive%2A> metodo all'interno del gestore di evento è creare per l'operazione di visualizzazione. Il gestore eventi potrebbe contenere funzionalità come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea asincrono operazione di ricezione. L'esempio di codice crea un gestore eventi `MyReceiveCompleted`e lo collega al <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegato del gestore eventi. Il codice riportato di seguito viene inviato un messaggio a una coda di messaggi locale, quindi chiama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, passando un valore di timeout di 10 secondi. Quando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato l'evento, il gestore eventi riceve il messaggio e scrive il corpo del messaggio sullo schermo.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché rappresenta un numero negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="stateObject">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <summary>Avvia un'operazione di ricezione asincrona per la quale sono stati specificati un timeout e un oggetto di stato, che fornisce le informazioni associate per tutta la durata dell'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns><see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, si utilizza <xref:System.Messaging.MessageQueue.BeginReceive%2A> per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato anche se esiste già un messaggio nella coda.  
  
 Utilizzare questo overload per associare informazioni con l'operazione che verrà mantenuto per tutta la durata dell'operazione. Il gestore eventi può rilevare queste informazioni esaminando i <xref:System.IAsyncResult.AsyncState%2A> proprietà del <xref:System.IAsyncResult> associato con l'operazione.  
  
 Usare <xref:System.Messaging.MessageQueue.BeginReceive%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarla al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Avvia un'asincrona operazione di ricezione. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando arriva un messaggio nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o il recupero di risultato mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata fino a quando non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginReceive%2A> è asincrona, è possibile chiamare in modo da ricevere un messaggio dalla coda senza bloccare il thread di esecuzione corrente. Per ricevere in modo sincrono un messaggio, utilizzare il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo).  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore dell'evento per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginReceive%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile usare questo <xref:System.IAsyncResult> tutta la durata dell'operazione, anche se in genere non si usa solo <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> i valori in una matrice e specificare se si desidera attendere che tutte le operazioni o qualsiasi operazione di completamento. In questo caso, si utilizza il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Questo overload specifica un timeout e un oggetto di stato. Se l'intervallo specificato dal `timeout` scade parametro, questo componente genera il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento. Poiché è disponibile alcun messaggio, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> verrà generata un'eccezione.  
  
 L'oggetto di stato associa le informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginReceive%2A> più volte per avviare più operazioni, è possibile identificare ogni operazione tramite un oggetto di stato separato definiti.  
  
 È anche possibile usare l'oggetto di stato per passare informazioni tra i thread di processo. Se viene avviato un thread, ma il callback è in un thread diverso in uno scenario asincrono, l'oggetto di stato viene effettuato il marshalling e passato insieme alle informazioni dall'evento.  
  
 Non usare la chiamata asincrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transazioni. Se si desidera eseguire un'operazione asincrona transazionale, chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A>e inserire la transazione e (sincrona) <xref:System.Messaging.MessageQueue.Receive%2A> metodo all'interno del gestore di evento è creare per l'operazione di visualizzazione. Il gestore eventi potrebbe contenere funzionalità come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea asincrono operazione di ricezione. L'esempio di codice crea un gestore eventi `MyReceiveCompleted`e lo collega al <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegato del gestore eventi. Il codice riportato di seguito viene inviato un messaggio a una coda di messaggi locale, quindi chiama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, passando un valore di timeout di 10 secondi e un integer univoco che identifica il messaggio in questione. Quando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato l'evento, il gestore eventi riceve il messaggio e scrive il corpo del messaggio e l'identificatore del messaggio sullo schermo.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="stateObject">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> che riceverà la notifica del completamento dell'operazione asincrona.</param>
        <summary>Avvia un'operazione di ricezione asincrona per la quale sono stati specificati un timeout e un oggetto di stato, che fornisce le informazioni associate per tutta la durata dell'operazione. Questo overload riceve mediante un callback la notifica dell'identità del gestore eventi per l'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns><see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo overload, il callback specificato nel parametro di callback viene richiamato direttamente quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto. il <xref:System.Messaging.MessageQueue.ReceiveCompleted> non viene generato l'evento. Gli altri overload del <xref:System.Messaging.MessageQueue.BeginReceive%2A> si basano su questo componente per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato anche se esiste già un messaggio nella coda.  
  
 Usare <xref:System.Messaging.MessageQueue.BeginReceive%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarla al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Avvia un'asincrona operazione di ricezione. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando arriva un messaggio nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o il recupero di risultato mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata fino a quando non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginReceive%2A> è asincrona, è possibile chiamare in modo da ricevere un messaggio dalla coda senza bloccare il thread di esecuzione corrente. Per ricevere in modo sincrono un messaggio, utilizzare il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo).  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore dell'evento per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginReceive%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile usare questo <xref:System.IAsyncResult> tutta la durata dell'operazione, anche se in genere non si usa solo <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> i valori in una matrice e specificare se si desidera attendere che tutte le operazioni o qualsiasi operazione di completamento. In questo caso, si utilizza il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 L'oggetto di stato associa le informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginReceive%2A> più volte per avviare più operazioni, è possibile identificare ogni operazione tramite un oggetto di stato separato definiti.  
  
 È anche possibile usare l'oggetto di stato per passare informazioni tra i thread di processo. Se viene avviato un thread, ma il callback è in un thread diverso in uno scenario asincrono, l'oggetto di stato viene effettuato il marshalling e passato insieme alle informazioni dall'evento.  
  
 Non usare la chiamata asincrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transazioni. Se si desidera eseguire un'operazione asincrona transazionale, chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A>e inserire la transazione e (sincrona) <xref:System.Messaging.MessageQueue.Receive%2A> metodo all'interno del gestore di evento è creare per l'operazione di visualizzazione. Il gestore eventi potrebbe contenere funzionalità come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea asincrono operazione di ricezione. Il codice riportato di seguito viene inviato un messaggio a una coda di messaggi locale, quindi chiama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passando: un valore di timeout di 10 secondi, un numero intero univoco che identifica il messaggio in questione; e una nuova istanza della <xref:System.AsyncCallback> che identifica il gestore eventi `MyReceiveCompleted`. Quando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato l'evento, il gestore eventi riceve il messaggio e scrive il corpo del messaggio e l'identificatore del messaggio sullo schermo.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <param name="state">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> che riceve la notifica del completamento dell'operazione asincrona.</param>
        <summary>Avvia un'operazione di ricezione asincrona che presenta il timeout specificato e che utilizza il cursore specificato, l'azione di lettura specificata e l'oggetto di stato specificato. L'oggetto di stato fornisce informazioni associate per l'intera durata dell'operazione. Questo overload riceve mediante un callback la notifica dell'identità del gestore eventi per l'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns><see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo overload, il callback specificato nel parametro di callback viene richiamato direttamente quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto. il <xref:System.Messaging.MessageQueue.ReceiveCompleted> non viene generato l'evento. Gli altri overload del <xref:System.Messaging.MessageQueue.BeginReceive%2A> si basano su questo componente per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato anche se esiste già un messaggio nella coda.  
  
 Usare <xref:System.Messaging.MessageQueue.BeginReceive%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarla al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Avvia un'asincrona operazione di ricezione. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando arriva un messaggio nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o il recupero di risultato mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata fino a quando non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginReceive%2A> è asincrona, è possibile chiamare in modo da ricevere un messaggio dalla coda senza bloccare il thread di esecuzione corrente. Per ricevere in modo sincrono un messaggio, utilizzare il <xref:System.Messaging.MessageQueue.Receive%2A> (metodo).  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore dell'evento per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginReceive%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile usare questo <xref:System.IAsyncResult> tutta la durata dell'operazione, anche se in genere non si usa solo <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> i valori in una matrice e specificare se si desidera attendere che tutte le operazioni o qualsiasi operazione di completamento. In questo caso, usare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 L'oggetto di stato associa le informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginReceive%2A> più volte per avviare più operazioni, è possibile identificare ogni operazione tramite un oggetto di stato separato definiti.  
  
 È anche possibile usare l'oggetto di stato per passare informazioni tra i thread di processo. Se viene avviato un thread, ma il callback è in un thread diverso in uno scenario asincrono, l'oggetto di stato viene effettuato il marshalling e passato insieme alle informazioni dall'evento.  
  
 Non usare la chiamata asincrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transazioni. Se si desidera eseguire un'operazione asincrona transazionale, chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A>e inserire la transazione e (sincrona) <xref:System.Messaging.MessageQueue.Receive%2A> metodo all'interno del gestore di evento è creare per l'operazione di visualizzazione. Il gestore eventi potrebbe contenere funzionalità come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="cursor" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è possibile leggere l'oggetto <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value><see langword="true" /> se <see cref="T:System.Messaging.MessageQueue" /> esiste e l'applicazione è in grado di eseguirne la lettura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> indica se l'applicazione è in grado di leggere o ricevere messaggi dalla coda. Se <xref:System.Messaging.MessageQueue.CanRead%2A> viene `true`, il <xref:System.Messaging.MessageQueue> può ricevere o leggere i messaggi dalla coda. In caso contrario, questo non è possibile.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> viene `false` se una coda è già aperta con accesso in lettura esclusivo (o se è aperto con accesso non esclusivo e ciò <xref:System.Messaging.MessageQueue> richiede l'accesso esclusivo), o se l'applicazione non ha diritti sufficienti per accedervi. Se l'applicazione tenta di leggere da una coda quando <xref:System.Messaging.MessageQueue.CanRead%2A> è `false`, viene negato l'accesso.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.CanRead%2A> proprietà.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è possibile scrivere nell'oggetto <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value><see langword="true" /> se <see cref="T:System.Messaging.MessageQueue" /> esiste e l'applicazione è in grado di eseguirne la scrittura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> indica se l'applicazione è in grado di inviare messaggi alla coda. Se <xref:System.Messaging.MessageQueue.CanWrite%2A> viene `true`, il <xref:System.Messaging.MessageQueue> può inviare messaggi alla coda. In caso contrario, questo non è possibile.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> viene `false` se una coda è già aperta con accesso in scrittura esclusivo (o se è aperto con accesso non esclusivo e ciò <xref:System.Messaging.MessageQueue> richiede l'accesso esclusivo), o se l'applicazione non ha diritti sufficienti per accedervi. Se l'applicazione tenta di scrivere in una coda quando <xref:System.Messaging.MessageQueue.CanWrite%2A> è `false`, viene negato l'accesso.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.CanWrite%2A> proprietà.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la categoria della coda.</summary>
        <value>Oggetto <see cref="T:System.Guid" /> che rappresenta la categoria della coda (identificatore del tipo di Accodamento messaggi), che consente a un'applicazione di suddividere per categoria le relative code. Il valore predefinito è <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La categoria della coda consente a un'applicazione suddividere in categorie proprie code. Ad esempio, è possibile inserire tutte le code di fatturazione in un'unica categoria e tutte le code di ordini in un altro.  
  
 Il <xref:System.Messaging.MessageQueue.Category%2A> proprietà offre l'accesso alla proprietà ID del tipo Accodamento messaggi, ovvero di lettura/scrittura, accessibile tramite il **le proprietà della coda** finestra di dialogo nella Console di gestione di Computer. È possibile definire una nuova categoria. Sebbene sia possibile usare <xref:System.Guid.NewGuid%2A> per creare un valore di categoria che sia univoco all'interno <xref:System.Guid> valori, tale operazione è necessaria. Il valore della categoria deve essere distinti solo da altre categorie, non da tutte le altre <xref:System.Guid> valori. Ad esempio, è possibile assegnare {00000000-0000-0000-0000-000000000001} come il <xref:System.Messaging.MessageQueue.Category%2A> per un set di code e {00000000-0000-0000-0000-000000000002} come il <xref:System.Messaging.MessageQueue.Category%2A> per un altro set.  
  
 Non è necessario impostare il <xref:System.Messaging.MessageQueue.Category%2A>. Il valore può essere `null`.  
  
 Impostando questa proprietà viene modificata la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.Category%2A> proprietà.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La categoria della coda è stata impostata su un valore non valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Svuota la cache delle connessioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, i nomi dei formati memorizzati nella cache vengono rimossi e vengono chiusi gli handle aperti e memorizzato nella cache.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene chiamato il metodo <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera tutte le risorse allocate da <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> libera tutte le risorse associate un <xref:System.Messaging.MessageQueue>, tra cui risorse condivise, se appropriato. Il sistema acquisisce di nuovo queste risorse automaticamente se sono ancora disponibili, ad esempio quando si chiama il <xref:System.Messaging.MessageQueue.Send%28System.Object%29> (metodo), come nel codice c# seguente.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Quando si chiama <xref:System.Messaging.MessageQueue.Close%2A>, tutte le <xref:System.Messaging.MessageQueue> proprietà che accedono direttamente la coda di Accodamento messaggi vengono eliminate. Il <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, e <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> tutti rimangono invariati.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> non sempre gratuito di lettura e scrittura handle a una coda, perché potrebbero essere condivisi. È possibile usare uno dei passaggi seguenti per garantire che <xref:System.Messaging.MessageQueue.Close%2A> libera gli handle di lettura e scrittura a una coda:  
  
-   Creare il <xref:System.Messaging.MessageQueue> con accesso esclusivo. A tale scopo, chiamare il <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> oppure <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e set il `sharedModeDenyReceive` parametro per `true`.  
  
-   Creare il <xref:System.Messaging.MessageQueue> con connessione la memorizzazione nella cache disabilitata. A tale scopo, chiamare il <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e impostare il `enableConnectionCache` parametro per `false`.  
  
-   Disabilitare la memorizzazione nella cache di connessione. A tale scopo, impostare il <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> proprietà `false`.  
  
 È necessario chiamare <xref:System.Messaging.MessageQueue.Close%2A> per una coda prima di eliminare la coda nel server di Accodamento messaggi. In caso contrario, i messaggi inviati alla coda è stato possibile generare eccezioni o vengono visualizzati nella coda di messaggi non recapitabili.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente chiude una coda di Accodamento messaggi.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova coda nel percorso specificato su un server di Accodamento messaggi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso della coda da creare.</param>
        <summary>Crea una coda non transazionale di Accodamento messaggi nel percorso specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.MessageQueue" /> che rappresenta la nuova coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare una coda non transazionale di Accodamento messaggi.  
  
 Per creare una nuova istanza della <xref:System.Messaging.MessageQueue> classe nell'applicazione e associarlo a una coda esistente, usare il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore. Per creare una nuova coda in Accodamento messaggi, chiamare <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintassi per il `path` parametro dipende il tipo di coda cui fa riferimento, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|coda pubblica|`MachineName`\\`QueueName`|  
|coda privata|`MachineName`\\`Private$`\\`QueueName`|  
  
 Usare "." per il computer locale. Per ulteriori informazioni sulla sintassi, vedere il <xref:System.Messaging.MessageQueue.Path%2A> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente crea le code pubbliche e private. Invia un messaggio a code selezionate.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è <see langword="null" /> o è una stringa vuota ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La coda è già presente nel percorso specificato.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso della coda da creare.</param>
        <param name="transactional"><see langword="true" /> per creare una coda transazionale; <see langword="false" /> per creare una coda non transazionale.</param>
        <summary>Crea una coda transazionale o non transazionale di Accodamento messaggi nel percorso specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.MessageQueue" /> che rappresenta la nuova coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare questo overload per creare una coda transazionale in Accodamento messaggi. È possibile creare una coda non transazionale, impostando il `transactional` parametro per `false` oppure chiamando l'altro overload di <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Per creare una nuova istanza della <xref:System.Messaging.MessageQueue> classe nell'applicazione e associarlo a una coda esistente, usare il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore. Per creare una nuova coda in Accodamento messaggi, chiamare <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintassi per il `path` parametro dipende il tipo di coda cui fa riferimento, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|coda pubblica|`MachineName`\\`QueueName`|  
|coda privata|`MachineName`\\`Private$`\\`QueueName`|  
  
 Usare "." per il computer locale. Per ulteriori informazioni sulla sintassi, vedere il <xref:System.Messaging.MessageQueue.Path%2A> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente crea pubbliche e private code transazionali. Invia un messaggio a code selezionate.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è <see langword="null" /> o è una stringa vuota ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La coda è già presente nel percorso specificato.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Messaging.Cursor" /> per la coda messaggi corrente.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Messaging.Cursor" /> per la coda messaggi corrente. Questo cursore viene utilizzato per mantenere una posizione specifica nella coda durante la lettura dei messaggi della coda.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la data e l'ora di creazione della coda in Accodamento messaggi.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> che rappresenta la data e l'ora in cui la coda è stata creata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> fa riferimento alla coda nel server di accodamento, non il <xref:System.Messaging.MessageQueue> istanza.  
  
 Se la coda esiste, questa proprietà rappresenta il tempo che la coda è stata creata, aggiornata all'ora locale del server in cui la coda esiste.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.CreateTime%2A> proprietà.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i valori di proprietà dei messaggi da utilizzare per impostazione predefinita quando vengono inviati messaggi alla coda dall'applicazione.</summary>
        <value>Oggetto <see cref="T:System.Messaging.DefaultPropertiesToSend" /> contenente i valori predefiniti delle proprietà dei messaggi di Accodamento messaggi utilizzati quando l'applicazione invia alla coda oggetti diversi dalle istanze di <see cref="T:System.Messaging.Message" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si invia un oggetto che non è di tipo <xref:System.Messaging.Message> alla coda, il <xref:System.Messaging.MessageQueue> inserisce l'oggetto in un messaggio di Accodamento messaggi. A quel punto, il <xref:System.Messaging.MessageQueue> si applica al messaggio i valori di proprietà specificati nel <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà. Viceversa, se si invia un <xref:System.Messaging.Message> alla coda, queste proprietà sono già specificate per l'istanza di se stesso, pertanto <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> viene ignorato per il <xref:System.Messaging.Message>.  
  
 Anche se si impostano le proprietà tramite il <xref:System.Messaging.MessageQueue> oggetti, il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> fa riferimento alle proprietà dei messaggi che vengono inviati alla coda, non alla coda stessa.  
  
 I valori predefiniti per le proprietà vengono visualizzati nella tabella seguente.  
  
|Proprietà|Valore predefinito|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|zero (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Una matrice di byte di lunghezza zero|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|una stringa vuota ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente usa la priorità di un messaggio per determinare le proprietà predefinite per l'invio del messaggio.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Non è possibile impostare le proprietà predefinite per la coda, probabilmente perché una proprietà non è valida.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda da eliminare.</param>
        <summary>Elimina una coda su un server di Accodamento messaggi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sintassi per il `path` parametro dipende dal tipo di coda dei messaggi.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|coda pubblica|`MachineName`\\`QueueName`|  
|coda privata|`MachineName`\\`Private$`\\`QueueName`|  
  
 Per ulteriori informazioni sulla sintassi, vedere il <xref:System.Messaging.MessageQueue.Path%2A> proprietà.  
  
 In alternativa, è possibile usare la <xref:System.Messaging.MessageQueue.FormatName%2A> o <xref:System.Messaging.MessageQueue.Label%2A> per descrivere il percorso della coda.  
  
|Riferimenti|Sintassi|  
|---------------|------------|  
|Nome del formato|FormatName: [ *nome del formato* ]|  
|Label|Etichetta: [ *etichetta* ]|  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente elimina una coda di accodamento, se presente.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è <see langword="null" /> o è una stringa vuota ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La sintassi del parametro <paramref name="path" /> non è valida.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'oggetto <see cref="T:System.Messaging.MessageQueue" /> dispone dell'accesso esclusivo per la ricezione dei messaggi dalla coda di Accodamento messaggi.</summary>
        <value><see langword="true" /> se <see cref="T:System.Messaging.MessageQueue" /> dispone dei diritti esclusivi per ricevere messaggi dalla coda; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Specifica la modalità condivisa della coda fa riferimento questo <xref:System.Messaging.MessageQueue>. Impostare <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> al `true` per indicare che solo ciò <xref:System.Messaging.MessageQueue> devono avere accesso a leggere o ricevere messaggi dalla coda con l'oggetto specificato <xref:System.Messaging.MessageQueue.Path%2A>. Se un'altra <xref:System.Messaging.MessageQueue> o un'altra applicazione è associata a tale istanza, la stessa risorsa coda o dell'applicazione non sarà in grado di leggere o ricevere messaggi, ma comunque possibile inviarli.  
  
 Se <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> è `false`, la coda è disponibile per più applicazioni per l'invio, la lettura o la ricezione di messaggi.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> proprietà.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Elimina le risorse, diverse dalla memoria, usate dall'oggetto <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il metodo <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> dopo aver terminato di utilizzare l'oggetto <xref:System.Messaging.MessageQueue>. Il metodo <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> lascia l'oggetto <xref:System.Messaging.MessageQueue> in una condizione di inutilizzabilità. Dopo avere chiamato <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, è necessario rilasciare tutti i riferimenti al <xref:System.Messaging.MessageQueue> in modo che la memoria occupata può essere recuperata da garbage collection.  
  
 È necessario chiamare <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> prima di rilasciare l'ultimo riferimento al <xref:System.Messaging.MessageQueue>. In caso contrario, le risorse di <xref:System.Messaging.MessageQueue> non è verranno liberate finché le chiamate di procedura di garbage collection di <xref:System.Messaging.MessageQueue> distruttore dell'oggetto.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'applicazione gestirà una cache di connessioni.</summary>
        <value><see langword="true" /> per creare e utilizzare una cache di connessioni; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una cache di connessione è un elenco di riferimenti alle strutture che contengono leggere o scrivere gli handle di code. Quando <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> viene `true`, il <xref:System.Messaging.MessageQueue> sfrutta gli handle della cache ogni volta che si chiama <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, o <xref:System.Messaging.MessageQueue.Receive%2A>, invece di aprire gli handle di nuovo. Ciò può migliorare le prestazioni. Uso di una cache di connessione isola anche il <xref:System.Messaging.MessageQueue> da modifiche della topologia di rete.  
  
 Se si crea una nuova connessione a una coda quando la cache di connessione è piena, il <xref:System.Messaging.MessageQueue> sovrascrive la struttura di accesso meno recente con la nuova connessione. È possibile cancellare la cache completamente chiamando <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, ad esempio, se i nomi dei formati delle code si lavora con sono stati modificati in modo che la precedente leggere e scrivere gli handle non sono più validi.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> proprietà.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la coda accetta solo messaggi non privati (non crittografati).</summary>
        <value>Uno dei valori di <see cref="T:System.Messaging.EncryptionRequired" />. Il valore predefinito è <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si specifica che la crittografia è necessaria per i messaggi inviati a una coda, vengono crittografati solo i corpi dei messaggi. Gli altri membri (ad esempio, il <xref:System.Messaging.Message.Label%2A> e <xref:System.Messaging.Message.SenderId%2A> proprietà) non può essere crittografata.  
  
 Impostando questa proprietà viene modificata la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica.  
  
 La crittografia di un messaggio rende privato il messaggio. È possibile specificare il requisito di crittografia della coda per essere `None`, `Body`, o `Optional` impostando il <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> proprietà in modo appropriato. Il <xref:System.Messaging.Message.UseEncryption%2A> impostazione del messaggio deve corrispondere ai requisiti di crittografia della coda. Se il messaggio non è crittografato ma la coda specifica `Body`, oppure se il messaggio è crittografato, ma la coda specifica `None`, il rifiuto del messaggio dalla coda. Se l'applicazione mittente lo richiede un messaggio di riconoscimento negativo in questo caso, il servizio Accodamento messaggi indica il rifiuto del messaggio all'applicazione mittente. Se il <xref:System.Messaging.Message.UseDeadLetterQueue%2A> è di proprietà `true`, viene inviato un messaggio che si verifica un errore di crittografia per la coda di messaggi non recapitabili. In caso contrario, il messaggio va perso.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> proprietà.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> che identifica l'operazione di visualizzazione asincrona da completare e da cui recuperare un risultato finale.</param>
        <summary>Completa l'operazione di visualizzazione asincrona specificata.</summary>
        <returns><see cref="T:System.Messaging.Message" /> associato all'operazione asincrona completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando la <xref:System.Messaging.MessageQueue.PeekCompleted> evento viene generato, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> completa l'operazione che è stata avviata dal <xref:System.Messaging.MessageQueue.BeginPeek%2A> chiamare. A tale scopo, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> legge il messaggio.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> può specificare un timeout, provocando la <xref:System.Messaging.MessageQueue.PeekCompleted> evento da generare se si verifica il timeout prima che venga visualizzato un messaggio nella coda. Quando si verifica un timeout senza un messaggio che arriva nella coda, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> genera un'eccezione.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene usato per leggere il messaggio che ha causato il <xref:System.Messaging.MessageQueue.PeekCompleted> generazione dell'evento.  
  
 Se si desidera continuare a leggere i messaggi in modo asincrono, è possibile chiamare nuovamente <xref:System.Messaging.MessageQueue.BeginPeek%2A> dopo la chiamata <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea un gestore eventi denominato `MyPeekCompleted`, lo collega al <xref:System.Messaging.MessageQueue.PeekCompleted> delegato del gestore eventi e chiamate <xref:System.Messaging.MessageQueue.BeginPeek%2A> per avviare un'operazione di lettura asincrona in coda che si trova nel percorso ". \myQueue". Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato l'evento, l'esempio legge il messaggio e scrive il corpo sullo schermo. Nell'esempio viene quindi chiamato <xref:System.Messaging.MessageQueue.BeginPeek%2A> nuovamente per avviare una nuova operazione di lettura asincrona.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La sintassi del parametro <paramref name="asyncResult" /> non è valida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> che identifica l'operazione di ricezione asincrona da completare e da cui recuperare un risultato finale.</param>
        <summary>Completa l'operazione di ricezione asincrona specificata.</summary>
        <returns><see cref="T:System.Messaging.Message" /> associato all'operazione asincrona completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando la <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento viene generato, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> completa l'operazione che è stata avviata dal <xref:System.Messaging.MessageQueue.BeginReceive%2A> chiamare. A tale scopo, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> riceve il messaggio.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> può specificare un timeout, provocando la <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento da generare se si verifica il timeout prima che venga visualizzato un messaggio nella coda. Quando si verifica un timeout senza un messaggio che arriva nella coda, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> genera un'eccezione.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> Consente di leggere (rimozione dalla coda) il messaggio che ha causato il <xref:System.Messaging.MessageQueue.ReceiveCompleted> generazione dell'evento.  
  
 Se si desidera continuare a ricevere in modo asincrono i messaggi, è possibile chiamare nuovamente <xref:System.Messaging.MessageQueue.BeginReceive%2A> dopo la chiamata <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente vengono concatenate le richieste asincrone. Presuppone che ci sia una coda sul computer locale denominato "myQueue". Il `Main` funzione inizia l'operazione asincrona che viene gestita dal `MyReceiveCompleted` routine. `MyReceiveCompleted` Elabora il messaggio corrente e avvia un nuovo asincrona operazione di ricezione.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La sintassi del parametro <paramref name="asyncResult" /> non è valida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda da trovare.</param>
        <summary>Determina se una coda di Accodamento messaggi è presente nel percorso specificato.</summary>
        <returns><see langword="true" /> se esiste una coda con il percorso specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.Exists%28System.String%29> metodo determina se una coda di Accodamento messaggi è presente nel percorso specificato. Non esiste alcun metodo per determinare se esiste una coda con un nome di formato specificato. Per altre informazioni sulla sintassi del nome di formato e altre forme di sintassi del percorso, vedere il <xref:System.Messaging.MessageQueue.Path%2A> proprietà.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> è un'operazione costosa. Usarla solo quando è necessario all'interno dell'applicazione.  
  
> [!NOTE]
>  Il <xref:System.Messaging.MessageQueue.Exists%28System.String%29> metodo non supporta il <xref:System.Messaging.MessageQueue.FormatName%2A> prefisso.  
  
 La sintassi per il `path` parametro dipende dal tipo di coda, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|coda pubblica|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> non può essere chiamato per verificare l'esistenza di una coda privata remota.  
  
 Per ulteriori informazioni sulla sintassi, vedere il <xref:System.Messaging.MessageQueue.Path%2A> proprietà.  
  
 In alternativa, è possibile usare il <xref:System.Messaging.MessageQueue.Label%2A> per descrivere il percorso della coda.  
  
|Riferimenti|Sintassi|  
|---------------|------------|  
|Label|Etichetta: [ `label` ]|  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente verifica se esiste una coda di Accodamento messaggi e quindi di eliminarlo.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La sintassi di <paramref name="path" /> non è valida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.  
  
oppure 
Il metodo <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> viene chiamato su una coda privata remota.</exception>
        <exception cref="T:System.InvalidOperationException">Nell'applicazione è stata utilizzata la sintassi dei nomi di formato durante la verifica dell'esistenza della coda.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome univoco generato per la coda da Accodamento messaggi al momento della creazione della coda.</summary>
        <value>Nome della coda, univoco nella rete.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.FormatName%2A> proprietà contiene il nome di formato della coda. In Accodamento messaggi utilizza il nome di formato per identificare la coda da aprire e come accedervi. A differenza la maggior parte delle caratteristiche di una coda, il nome di formato non è una proprietà di coda dell'applicazione Accodamento messaggi, in modo che non è possibile accedervi tramite lo strumento di gestione di Accodamento messaggi. Il nome di formato è semplicemente un nome univoco per la coda, che il servizio Accodamento messaggi genera quando si crea la coda o che l'applicazione genera in un secondo momento.  
  
 Se si specifica un percorso usando la sintassi del nome percorso (ad esempio `myComputer\myQueue`) invece di usare la sintassi del nome di formato durante la lettura o scrittura per la coda, traduce il controller di dominio primario (che usa Active Directory) il <xref:System.Messaging.MessageQueue.Path%2A> nell'associati <xref:System.Messaging.MessageQueue.FormatName%2A> prima di accedere alla coda. Se l'applicazione è offline, è necessario utilizzare la sintassi di nome di formato. in caso contrario, il controller di dominio primario non sarà disponibile per eseguire la conversione del percorso.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.FormatName%2A> proprietà.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è impostata.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il formattatore utilizzato per serializzare o deserializzare un oggetto dal corpo di un messaggio letto o scritto in una coda.</summary>
        <value><see cref="T:System.Messaging.IMessageFormatter" /> che produce un flusso da scrivere o leggere dal corpo del messaggio. Il valore predefinito è <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà contiene un'istanza di un oggetto formattatore, che consente di trasformare i messaggi quando l'applicazione legge o scrive nella coda.  
  
 Quando l'applicazione invia messaggi alla coda, il formattatore serializza l'oggetto in un flusso e lo inserisce nel corpo del messaggio. Durante la lettura da una coda, il formattatore deserializza i dati del messaggio nel <xref:System.Messaging.Message.Body%2A> proprietà di un <xref:System.Messaging.Message>.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> è regime di controllo, in modo che non è necessario avere lo stesso oggetto di tipo per il mittente e ricevitore quando si usa questo formato. Il <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializzare i dati in una rappresentazione binaria. Il <xref:System.Messaging.ActiveXMessageFormatter> viene usato per inviare o ricevere i componenti COM.  
  
 <xref:System.Messaging.BinaryMessageFormatter> e <xref:System.Messaging.ActiveXMessageFormatter> ottenere velocità maggiori rispetto la <xref:System.Messaging.XmlMessageFormatter>. Il <xref:System.Messaging.ActiveXMessageFormatter> consente l'interoperabilità con applicazioni di Accodamento messaggi di Visual Basic 6.0.  
  
 Quando l'applicazione invia messaggi alla coda, il <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> si applica solo a quei messaggi che usano le proprietà di messaggio predefinite, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Se si invia un <xref:System.Messaging.Message> Accodamento messaggi alla coda, verrà utilizzato il formattatore definito nel <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> proprietà da serializzare il corpo.  
  
 Il <xref:System.Messaging.MessageQueue> classe utilizza sempre un <xref:System.Messaging.Message> per ricevere o leggere un messaggio dalla coda. Il messaggio viene deserializzato utilizzando il <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente vengono illustrate la formattazione di un corpo del messaggio utilizzando <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Esempio di codice seguente vengono illustrate la formattazione di un corpo del messaggio utilizzando <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce tutti i messaggi presenti nella coda.</summary>
        <returns>Matrice di tipo <see cref="T:System.Messaging.Message" /> che rappresenta tutti i messaggi nella coda nello stesso ordine in cui vengono visualizzati nella coda di Accodamento messaggi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Restituisce uno snapshot statico di messaggi nella coda, non dinamici collegamenti a tali messaggi. Pertanto, è possibile utilizzare la matrice per modificare i messaggi nella coda. Se si desidera un'interazione dinamica e in tempo reale con la coda (ad esempio la possibilità di eliminare i messaggi), chiamare il <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> metodo, che restituisce un elenco dinamico di messaggi nella coda.  
  
 Poiché <xref:System.Messaging.MessageQueue.GetAllMessages%2A> restituisce una copia dei messaggi nella coda al momento della chiamata al metodo, la matrice non riflette nuovi messaggi che arrivano nella coda o messaggi che vengono rimossi dalla coda.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Recupera solo le proprietà non filtrate dal <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enumera i messaggi in una coda. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> è stato deprecato. È consigliabile utilizzare invece <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che fornisce una connessione dinamica ai messaggi della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nome del computer contenente la coda, non preceduto dalle due barre rovesciate (\\\\).</param>
        <summary>Ottiene l'identificatore del computer in cui viene posizionata la coda cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento.</summary>
        <returns>Oggetto <see cref="T:System.Guid" /> che rappresenta un identificatore univoco del computer in cui viene posizionata la coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare l'identificatore del computer per due scopi, tra gli altri: per il journal del computer di leggere e impostare i certificati di sicurezza. Tuttavia, non è possibile chiamare <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> per un computer remoto quando si lavora offline perché l'applicazione deve avere accesso al servizio directory nel controller di dominio.  
  
 L'identificatore del computer (o identificatore del computer) è un <xref:System.Guid> creati quando un computer viene aggiunto alla sezione aziendale di Accodamento messaggi. Il servizio Accodamento messaggi combina l'identificatore del computer con il `Machine` e `Journal` parole chiave per creare il nome formato del journal del computer, che presenta la sintassi `Machine=<computeridentifier>;Journal`. I messaggi il journal del computer, è anche noto come coda del journal, è una coda di sistema che vengono archiviate copie delle generati dall'applicazione quando la <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> è di proprietà `true`.  
  
 Questa sintassi per la registrazione è valida solo quando si crea il nome di formato per la coda. La sintassi del nome di percorso viene `MachineName` \\ `Journal$`.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene chiamato il metodo <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Non è stato possibile recuperare l'identificatore del computer, probabilmente perché il servizio directory non è disponibile, ad esempio se si sta lavorando in modalità offline.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un oggetto enumeratore per tutti i messaggi contenuti nella coda. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> è stato deprecato. È consigliabile utilizzare invece <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns><see cref="T:System.Messaging.MessageEnumerator" /> contenente i messaggi presenti nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> Crea un elenco dinamico di tutti i messaggi in una coda. È possibile rimuovere dalla coda il messaggio nella posizione corrente dell'enumeratore chiamando <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> per il <xref:System.Messaging.MessageEnumerator> che <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> restituisce.  
  
 Poiché il cursore è associato l'elenco dinamico di messaggi nella coda, l'enumerazione riflette tutte le modifiche apportate ai messaggi nella coda, se il messaggio è oltre la posizione corrente del cursore. Ad esempio, l'enumeratore può accedere automaticamente un messaggio con priorità inferiore inserito oltre la posizione del cursore corrente, ma non un messaggio con priorità più alta inseriti prima di quella posizione. Tuttavia, è possibile reimpostare l'enumerazione, spostare il cursore all'inizio dell'elenco, chiamando <xref:System.Messaging.MessageEnumerator.Reset%2A> per il <xref:System.Messaging.MessageEnumerator>.  
  
 L'ordine dei messaggi nell'enumerazione riflette l'ordine nella coda, in modo che i messaggi con priorità più alta vengono visualizzati prima di quelli con priorità inferiore.  
  
 Se si desidera uno snapshot statico i messaggi in coda piuttosto che una connessione dinamica ad essi, chiamare <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Questo metodo restituisce una matrice di <xref:System.Messaging.Message> gli oggetti che rappresentano i messaggi al momento della chiamata al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene un elenco dinamico di messaggi in una coda e conta tutti i messaggi con il <xref:System.Messaging.Message.Priority%2A> impostata su <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un oggetto enumeratore per tutti i messaggi contenuti nella coda.</summary>
        <returns><see cref="T:System.Messaging.MessageEnumerator" /> contenente i messaggi presenti nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> Crea un elenco dinamico di tutti i messaggi in una coda. È possibile rimuovere dalla coda il messaggio nella posizione corrente dell'enumeratore chiamando <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> per il <xref:System.Messaging.MessageEnumerator> che <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> restituisce.  
  
 Poiché il cursore è associato l'elenco dinamico di messaggi nella coda, l'enumerazione riflette tutte le modifiche apportate ai messaggi nella coda, se il messaggio è oltre la posizione corrente del cursore. Ad esempio, l'enumeratore può accedere automaticamente un messaggio con priorità inferiore inserito oltre la posizione del cursore corrente, ma non un messaggio con priorità più alta inseriti prima di quella posizione. Tuttavia, è possibile reimpostare l'enumerazione, spostare il cursore all'inizio dell'elenco, chiamando <xref:System.Messaging.MessageEnumerator.Reset%2A> per il <xref:System.Messaging.MessageEnumerator>.  
  
 L'ordine dei messaggi nell'enumerazione riflette l'ordine nella coda, in modo che i messaggi con priorità più alta vengono visualizzati prima di quelli con priorità inferiore.  
  
 Se si desidera uno snapshot statico i messaggi in coda piuttosto che una connessione dinamica ad essi, chiamare <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Questo metodo restituisce una matrice di <xref:System.Messaging.Message> gli oggetti che rappresentano i messaggi al momento della chiamata al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un oggetto enumeratore per un elenco dinamico delle code pubbliche presenti sulla rete.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornisce la semantica del cursore forward-only per enumerare tutte le code pubbliche sulla rete.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.MessageQueueEnumerator" /> che fornisce un elenco dinamico di tutte le code di messaggi pubbliche sulla rete.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> restituisce un'enumerazione di tutte le code pubbliche sulla rete.  
  
 Poiché il cursore è associato a un elenco dinamico, l'enumerazione riflette tutte le modifiche apportate a un elenco di coda per le code eliminati o aggiunti oltre la posizione del cursore corrente. Aggiunta o eliminazione di code che si trova prima della posizione corrente del cursore non vengono riflesse. Ad esempio, l'enumeratore può accedere automaticamente una coda aggiunto oltre la posizione del cursore, ma non quello inserito prima di tale posizione. Tuttavia, è possibile reimpostare l'enumerazione, spostare il cursore all'inizio dell'elenco, chiamando <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> per il <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Non è stato definito nessun ordine delle code in una rete. Un enumeratore non vengono ordinate, ad esempio, per computer, un'etichetta, lo stato di tipo pubblico o privato o altri criteri accessibili.  
  
 Se si desidera uno snapshot statico delle code sulla rete anziché una connessione dinamica ad essi, chiamare <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> o <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Ognuno di questi due metodi restituisce una matrice di <xref:System.Messaging.MessageQueue> gli oggetti che rappresentano le code al momento della chiamata al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente esegue l'iterazione attraverso tutte le code di messaggi nella rete e viene esaminato il percorso per ogni coda. Infine, Visualizza il numero di code pubbliche sulla rete.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Oggetto <see cref="T:System.Messaging.MessageQueueCriteria" /> contenente i criteri utilizzati per filtrare le code di messaggi disponibili.</param>
        <summary>Fornisce la semantica del cursore forward-only per enumerare tutte le code pubbliche sulla rete che soddisfano i criteri specificati.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.MessageQueueEnumerator" /> che fornisce un elenco dinamico delle code di messaggi pubbliche sulla rete che soddisfano le restrizioni specificate dal parametro <paramref name="criteria" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> restituisce un elenco di tutte le code pubbliche sulla rete che soddisfano i criteri definiti nei criteri dell'applicazione. È possibile specificare i criteri da includere, ad esempio, accodare la creazione o modifica l'ora, nome del computer, etichetta, categoria o qualsiasi combinazione di questi.  
  
 Poiché il cursore è associato a un elenco dinamico, l'enumerazione riflette tutte le modifiche apportate a una coda che si trova oltre la posizione del cursore corrente. Non vengono riflesse le modifiche apportate a code che si trova prima della posizione corrente del cursore. Ad esempio, l'enumeratore può accedere automaticamente una coda aggiunto oltre la posizione del cursore, ma non quello inserito prima di tale posizione. Tuttavia, è possibile reimpostare l'enumerazione, spostare il cursore all'inizio dell'elenco, chiamando <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> per il <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Non è stato definito nessun ordine delle code in una rete. Un enumeratore non vengono ordinate, ad esempio, per computer, un'etichetta, lo stato di tipo pubblico o privato o altri criteri accessibili.  
  
 Se si desidera uno snapshot statico delle code sulla rete anziché una connessione dinamica ad essi, specificare i criteri per <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> oppure chiamare <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Ognuno di questi due metodi restituisce una matrice di <xref:System.Messaging.MessageQueue> gli oggetti che rappresentano le code al momento della chiamata al metodo. La chiamata <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, o <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> offre gli stessi risultati di chiamata <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> con i criteri di filtro del <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, e <xref:System.Messaging.MessageQueue.MachineName%2A>, rispettivamente.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente esegue l'iterazione attraverso le code di messaggi e visualizza il percorso di ogni coda, che è stato creato nell'ultimo giorno e che esista nel computer "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Computer da cui recuperare le code private.</param>
        <summary>Recupera tutte le code private sul computer specificato.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code private recuperate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> Consente di recuperare uno snapshot statico di code in un computer specifico.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="machineName" /> è <see langword="null" /> o una stringa vuota ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera tutte le code pubbliche sulla rete.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera tutte le code pubbliche sulla rete.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code pubbliche recuperate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload se si desidera un elenco completo di tutte le code pubbliche sulla rete. Se si desidera limitare l'elenco in base a determinati criteri, ad esempio <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, o l'ora dell'ultima modifica Usa un altro overload di questo metodo. (In alternativa, è possibile usare <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, o <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Consente di recuperare uno snapshot statico di code. Per interagire con un elenco dinamico delle code, usare <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Oggetto <see cref="T:System.Messaging.MessageQueueCriteria" /> contenente i criteri utilizzati per filtrare le code.</param>
        <summary>Recupera tutte le code pubbliche sulla rete che soddisfano i criteri specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code pubbliche recuperate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si desidera filtrare tutte le code pubbliche sulla rete per l'etichetta, categoria o nome del computer, il <xref:System.Messaging.MessageQueue> classe contiene metodi specifici che offrono tale funzionalità (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, e <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>rispettivamente). Utilizzare questo overload per ottenere un elenco di tutte le code pubbliche sulla rete che soddisfano più di uno di questi criteri (ad esempio, se si desidera specificare un'etichetta e una categoria). È possibile anche filtrare in base ai criteri di messaggio diverso da <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, e <xref:System.Messaging.MessageQueue.MachineName%2A>. Ad esempio, utilizzare questo overload per filtrare in base l'ora dell'ultima modifica della coda. È sufficiente creare una nuova istanza della <xref:System.Messaging.MessageQueueCriteria> classe, impostare le proprietà appropriate nell'istanza e passare l'istanza come il `criteria` parametro.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Consente di recuperare uno snapshot statico di code. Per interagire con un elenco dinamico delle code, usare <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Oggetto <see cref="T:System.Guid" /> che raggruppa il set di code da recuperare.</param>
        <summary>Recupera tutte le code pubbliche sulla rete appartenenti alla categoria specificata.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code pubbliche recuperate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per filtrare le code pubbliche per categoria. Il <xref:System.Messaging.MessageQueue.Category%2A> proprietà offre l'accesso alla proprietà ID tipo di Accodamento messaggi, ovvero di lettura/scrittura, di una determinata coda. Sebbene sia possibile usare <xref:System.Guid.NewGuid%2A> per creare un valore di categoria che sia univoco all'interno <xref:System.Guid> valori, non è necessario. Il valore della categoria deve essere distinti solo da altre categorie, non da tutte le altre <xref:System.Guid> valori. Ad esempio, è possibile assegnare {00000000-0000-0000-0000-000000000001} come il <xref:System.Messaging.MessageQueue.Category%2A> per un set di code e {00000000-0000-0000-0000-000000000002} come il <xref:System.Messaging.MessageQueue.Category%2A> per un altro set.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> Consente di recuperare uno snapshot statico di code. Per interagire con un elenco dinamico delle code, usare <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. È possibile specificare la categoria come parte di <xref:System.Messaging.MessageQueueCriteria> è passato al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Etichetta che raggruppa il set di code da recuperare.</param>
        <summary>Recupera tutte le code pubbliche sulla rete contenenti l'etichetta specificata.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code pubbliche recuperate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per filtrare le code pubbliche da etichetta.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> Consente di recuperare uno snapshot statico di code. Per interagire con un elenco dinamico delle code, usare <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. È possibile specificare l'etichetta come parte di <xref:System.Messaging.MessageQueueCriteria> è passato al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="label" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nome del computer contenente il set di code pubbliche da recuperare.</param>
        <summary>Recupera tutte le code pubbliche che risiedono sul computer specificato.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code pubbliche sul computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per filtrare le code pubbliche da computer.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> Consente di recuperare uno snapshot statico di code. Per interagire con un elenco dinamico delle code, usare <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. È possibile specificare il nome del computer come parte di <xref:System.Messaging.MessageQueueCriteria> è passato al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La sintassi del parametro <paramref name="machineName" /> non è corretta.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera il contesto di sicurezza che MSMQ associa all'utente corrente (identità del thread) nel momento in cui viene eseguita questa chiamata.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.SecurityContext" /> contenente il contesto di sicurezza.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identificatore univoco di Accodamento messaggi per la coda.</summary>
        <value>Proprietà <see cref="P:System.Messaging.MessageQueue.Id" /> che rappresenta l'identificatore del messaggio generato dall'applicazione Accodamento messaggi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accodamento messaggi imposta il <xref:System.Messaging.MessageQueue.Id%2A> proprietà durante la creazione della coda. Questa proprietà è disponibile solo per le code pubbliche.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.Id%2A> proprietà.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che non sono previste restrizioni relative alle dimensioni di una coda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro viene spesso utilizzato durante l'impostazione <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> o <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Messaging.MessageQueue.InfiniteQueueSize> membro.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che non è previsto un timeout per i metodi che leggono o ricevono messaggi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> supporta due tipi di recupero dei messaggi: sincrone e asincrone. I metodi sincroni <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.Receive%2A>, provoca l'intervallo di tempo specificato per un nuovo messaggio in arrivo nella coda di attesa del thread di processo. Se l'intervallo di tempo specificato è <xref:System.Messaging.MessageQueue.InfiniteTimeout>, il thread di processo rimane bloccato fino a quando non è disponibile un nuovo messaggio. D'altra parte, <xref:System.Messaging.MessageQueue.BeginPeek%2A> e <xref:System.Messaging.MessageQueue.BeginReceive%2A> (i metodi asincroni), consentire le attività principale dell'applicazione in un thread separato fino a un messaggio arriva nella coda.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Messaging.MessageQueue.InfiniteTimeout> membro.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la descrizione della coda.</summary>
        <value>Etichetta della coda di messaggi. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lunghezza massima di un'etichetta di messaggio della coda è 124 caratteri.  
  
 Il <xref:System.Messaging.MessageQueue.Label%2A> proprietà non deve essere univoco tra tutte le code. Tuttavia, se più code condividono lo stesso <xref:System.Messaging.MessageQueue.Label%2A>, non è possibile usare il <xref:System.Messaging.MessageQueue.Send%28System.Object%29> metodo trasmettere un messaggio a tutti i tipi. Se si usa la sintassi dell'etichetta per il <xref:System.Messaging.MessageQueue.Path%2A> proprietà quando si invia il messaggio, verrà generata un'eccezione se il <xref:System.Messaging.MessageQueue.Label%2A> non è univoco.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.Label%2A> proprietà.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'etichetta è stata impostata su un valore non valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la data e l'ora dell'ultima modifica delle proprietà di una coda.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> che indica la data e l'ora dell'ultima modifica delle proprietà della coda.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ora dell'ultima modifica include quando la coda è stata creata e l'eventuale <xref:System.Messaging.MessageQueue> proprietà che modifica la coda di accodamento, ad esempio <xref:System.Messaging.MessageQueue.BasePriority%2A>. Il valore della <xref:System.Messaging.MessageQueue.LastModifyTime%2A> proprietà rappresenta l'ora di sistema del computer locale.  
  
 È necessario chiamare <xref:System.Messaging.MessageQueue.Refresh%2A> prima di ottenere il <xref:System.Messaging.MessageQueue.LastModifyTime%2A> proprietà; in caso contrario, l'ora di modifica associato a questo <xref:System.Messaging.MessageQueue> potrebbero non essere aggiornate.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.LastModifyTime%2A> proprietà.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del computer in cui si trova la coda di Accodamento messaggi.</summary>
        <value>Nome del computer in cui si trova la coda. Il valore predefinito di Accodamento messaggi è "." per indicare il computer locale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.MachineName%2A> è un componente integrale della sintassi del nome descrittivo della coda <xref:System.Messaging.MessageQueue.Path%2A>. La tabella seguente illustra la sintassi da utilizzare per una coda di un tipo specificato quando si desidera identificare il percorso della coda utilizzando il relativo nome descrittivo.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|coda pubblica|`MachineName`\\`QueueName`|  
|coda privata|`MachineName`\\`Private$`\\`QueueName`|  
|Coda del diario|`MachineName`\\`QueueName`\\`Journal$`|  
|Coda journal computer|`MachineName`\\`Journal$`|  
|Computer non recapitabili|`MachineName`\\`Deadletter$`|  
|Macchina transazionale non recapitabili|`MachineName`\\`XactDeadletter$`|  
  
 Usare "." per il computer locale quando si specifica il <xref:System.Messaging.MessageQueue.MachineName%2A>. Solo il nome del computer è riconosciuto per questa proprietà, ad esempio, `Server0`. Il <xref:System.Messaging.MessageQueue.MachineName%2A> proprietà non supporta il formato dell'indirizzo IP.  
  
 Se si definiscono i <xref:System.Messaging.MessageQueue.Path%2A> in termini del <xref:System.Messaging.MessageQueue.MachineName%2A>, l'applicazione genera un'eccezione quando si lavora offline perché il controller di dominio è obbligatorio per la conversione del percorso. Pertanto, è necessario usare il <xref:System.Messaging.MessageQueue.FormatName%2A> per il <xref:System.Messaging.MessageQueue.Path%2A> sintassi quando si lavora offline.  
  
 Il <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, e <xref:System.Messaging.MessageQueue.QueueName%2A> sono correlate. Modifica il <xref:System.Messaging.MessageQueue.MachineName%2A> proprietà causa la <xref:System.Messaging.MessageQueue.Path%2A> proprietà da modificare. Si basa dalla nuova <xref:System.Messaging.MessageQueue.MachineName%2A> e il <xref:System.Messaging.MessageQueue.QueueName%2A>. Modifica il <xref:System.Messaging.MessageQueue.Path%2A> (ad esempio, per usare la sintassi del nome di formato) Reimposta le <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> proprietà per fare riferimento alla nuova coda. Se il <xref:System.Messaging.MessageQueue.QueueName%2A> la proprietà è vuota, il <xref:System.Messaging.MessageQueue.Path%2A> è impostata nella coda Journal del computer specificato.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.MachineName%2A> proprietà.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome del computer non è valido, probabilmente perché la sintassi non è corretta.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione massima della coda del giornale di registrazione.</summary>
        <value>Dimensione massima, espressa in kilobyte, della coda del journal. L'impostazione predefinita di Accodamento messaggi specifica che non esiste alcun limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> fornisce l'accesso per il limite di archiviazione di Accodamento messaggi journal. È pertinente solo quando <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> è `true`. Impostando questa proprietà viene modificata la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica  
  
 Se si archiviano i messaggi in una coda del diario o non recapitabilità, è necessario cancellare periodicamente la coda da cui rimuovere i messaggi che non sono più necessari. I messaggi in tale coda vengono conteggiati la quota per il computer in cui risiede la coda. (L'amministratore imposta la quota del computer).  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> proprietà.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione massima della coda del journal è stata impostata su un valore non valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione massima della coda.</summary>
        <value>La dimensione massima, espressa in kilobyte (KB), della coda. L'impostazione predefinita di Accodamento messaggi specifica che non esiste alcun limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> fornisce l'accesso al limite di archiviazione dei messaggi di Accodamento messaggi, separato dalla quota di messaggi del computer che l'amministratore definisce. Per altre informazioni sulla quota messaggi, vedere <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Impostando questa proprietà viene modificata la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica  
  
 Se viene effettuato un tentativo di superare le dimensioni massime della coda o la quota del messaggio di computer, i messaggi potrebbero essere persi. Quando viene raggiunta la quota della coda, Accodamento messaggi di notifica la coda di amministrazione dell'applicazione mittente per indicare che la coda è piena, restituendo un messaggio di riconoscimento negativo. Il servizio Accodamento messaggi continua a inviare i riconoscimenti negativi fino a quando le dimensioni totali dei messaggi nella coda scende sotto il limite.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> proprietà.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione massima della coda contiene un valore negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il filtro di proprietà per la ricezione o la visualizzazione dei messaggi.</summary>
        <value><see cref="T:System.Messaging.MessagePropertyFilter" /> utilizzato dalla coda per filtrare l'insieme di proprietà ricevute o visualizzate per ciascun messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo filtro è un set di valori booleani che limita le proprietà del messaggio che il <xref:System.Messaging.MessageQueue> ricevute o visualizzate. Quando il <xref:System.Messaging.MessageQueue> riceve o preleva un messaggio dalla coda del server, recupera solo le proprietà per cui la <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> valore `true`.  
  
 Di seguito è riportato i valori iniziali delle proprietà per il <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> proprietà. Queste impostazioni sono identiche alla chiamata <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> su un <xref:System.Messaging.MessagePropertyFilter>.  
  
|Proprietà|Valore predefinito|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 byte|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 byte|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 byte|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> per limitare le proprietà del messaggio ricevute.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il filtro è <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introdotto in MSMQ 3.0. Ottiene o imposta l'indirizzo multicast associato alla coda.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene un indirizzo multicast valido (nel formato riportato di seguito) o <see langword="null" />, a indicare che alla coda non è associato alcun indirizzo multicast.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.MulticastAddress%2A> proprietà viene utilizzata per associare una coda non transazionale a un indirizzo multicast che può essere usato quando l'invio di messaggi. È una coda transazionale non è possibile associare un indirizzo multicast. Quando l'applicazione mittente invia messaggi a un indirizzo multicast, il servizio Accodamento messaggi invia una copia del messaggio per ogni coda associata a quell'indirizzo.  
  
 Indirizzi IP multicast indirizzi devono essere nell'intervallo di classe D tra 224.0.0.0 e 239.255.255.255, che corrisponde all'impostazione su 1110 i primi quattro bit più significativi. Tuttavia, solo alcuni intervalli di indirizzi in questo intervallo sono riservati e disponibile per l'invio di messaggi multicast. Per un elenco aggiornato degli indirizzi multicast riservati, vedere la [indirizzi Multicast Internet numero autorità IANA (Internet Assigned)](https://go.microsoft.com/fwlink/?linkid=3859) pagina Web. Non sono previste restrizioni al numero di porta.  
  
 Se diversi computer di origine sono l'invio di messaggi multicast e si vuole una coda specifica per ricevere messaggi da un solo computer di origine, ogni computer di origine deve inviare messaggi a una diversa combinazione di numero di porta e indirizzo IP.  
  
 Per annullare l'associazione di una coda e un indirizzo multicast, impostare il <xref:System.Messaging.MessageQueue.MulticastAddress%2A> proprietà in una stringa di lunghezza zero. Non impostarlo su `null`, come l'operazione comporterà un <xref:System.ArgumentNullException>.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il percorso della coda. Impostando la proprietà <see cref="P:System.Messaging.MessageQueue.Path" />, <see cref="T:System.Messaging.MessageQueue" /> punta a una nuova coda.</summary>
        <value>Coda a cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Il valore predefinito dipende dal costruttore <see cref="M:System.Messaging.MessageQueue.#ctor" /> utilizzato e può essere <see langword="null" /> oppure può essere specificato dal parametro <paramref name="path" /> del costruttore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sintassi per il <xref:System.Messaging.MessageQueue.Path%2A> proprietà dipende dal tipo di coda dei messaggi, punti, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|coda pubblica|`MachineName`\\`QueueName`|  
|coda privata|`MachineName`\\`Private$`\\`QueueName`|  
|Coda del diario|`MachineName`\\`QueueName`\\`Journal$`|  
|Coda journal computer|`MachineName`\\`Journal$`|  
|Computer non recapitabili|`MachineName`\\`Deadletter$`|  
|Macchina transazionale non recapitabili|`MachineName`\\`XactDeadletter$`|  
  
 Usare "." per rappresentare il computer locale.  
  
 Il <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, e <xref:System.Messaging.MessageQueue.QueueName%2A> sono correlate. Modifica il <xref:System.Messaging.MessageQueue.MachineName%2A> proprietà causa la <xref:System.Messaging.MessageQueue.Path%2A> proprietà da modificare. Si basa dalla nuova <xref:System.Messaging.MessageQueue.MachineName%2A> e il <xref:System.Messaging.MessageQueue.QueueName%2A>. Modifica il <xref:System.Messaging.MessageQueue.Path%2A> (ad esempio, per usare la sintassi del nome di formato) Reimposta le <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> proprietà per fare riferimento alla nuova coda.  
  
 In alternativa, è possibile usare la <xref:System.Messaging.MessageQueue.FormatName%2A> o <xref:System.Messaging.MessageQueue.Label%2A> per descrivere il percorso della coda, come illustrato nella tabella seguente.  
  
|Riferimenti|Sintassi|Esempio|  
|---------------|------------|-------------|  
|Nome del formato|`FormatName:` [ *nome del formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Label|`Label:` [ *etichetta* ]|`Label:` TheLabel|  
  
 Se si usa la sintassi dell'etichetta per il <xref:System.Messaging.MessageQueue.Path%2A> proprietà quando si invia il messaggio, verrà generata un'eccezione se il <xref:System.Messaging.MessageQueue.Label%2A> non è univoco.  
  
 Per funzionare offline, è necessario usare la sintassi del nome di formato, anziché la sintassi del nome descrittivo della prima tabella. In caso contrario, viene generata un'eccezione perché il controller di dominio primario (in cui risiede Active Directory) non è disponibile per risolvere il percorso per il nome del formato.  
  
 L'impostazione di un nuovo percorso chiude la coda di messaggi e rilascia tutti gli handle.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
> [!NOTE]
>  In modalità gruppo di lavoro è possibile usare solo le code private. Specificare il percorso utilizzando la sintassi di coda privata `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 Esempio di codice seguente crea nuovi <xref:System.Messaging.MessageQueue> di oggetti usando vari tipi di sintassi di nome di percorso. In ogni caso, viene inviato un messaggio nella coda cui percorso viene definita nel costruttore.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido, probabilmente perché la sintassi non è valida.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <summary>Restituisce una copia del primo messaggio della coda senza rimuoverlo da quest'ultima.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina senza rimuovere (legge) il primo messaggio nella coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Poiché il metodo <see cref="M:System.Messaging.MessageQueue.Peek" /> è sincrono, blocca il thread corrente finché non viene reso disponibile un messaggio.</summary>
        <returns><see cref="T:System.Messaging.Message" /> che rappresenta il primo messaggio della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per leggere una coda o in attesa fino a quando non è disponibile un messaggio nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo legge, ma non rimuove, il primo messaggio dalla coda. Di conseguenza, le chiamate ripetute a <xref:System.Messaging.MessageQueue.Peek%2A> restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo, d'altra parte, legge e rimuove il primo messaggio dalla coda. Chiamate ripetute a <xref:System.Messaging.MessageQueue.Receive%2A>, pertanto restituire diversi tipi di messaggi.  
  
 I messaggi vengono ordinati in Accodamento messaggi nella coda in base all'ora di arrivo e priorità. Un messaggio più recente viene inserito prima di quello precedente solo se si tratta di una priorità più alta.  
  
 Utilizzare il metodo <xref:System.Messaging.MessageQueue.Peek%2A> quando è possibile bloccare il thread corrente durante l'attesa dell'arrivo di un messaggio nella coda. Poiché questo overload non specifica un timeout, l'applicazione potrebbe attendere all'infinito. Se si desidera che l'elaborazione dell'applicazione continui senza attendere, utilizzare il metodo asincrono <xref:System.Messaging.MessageQueue.BeginPeek%2A>. In alternativa, è possibile specificare un timeout per un messaggio in arrivo nella coda tramite l'overload del metodo <xref:System.Messaging.MessageQueue.Peek%2A> che specifica un timeout.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Gli esempi seguenti usano il <xref:System.Messaging.MessageQueue.Peek%2A> metodo in una coda.  
  
 Nel primo esempio, l'applicazione attende un messaggio diventa disponibile nella coda. Si noti che il primo esempio non acceda il messaggio che arriva; semplicemente sospende l'elaborazione fino a quando non arriva un messaggio. Se già presente un messaggio nella coda, verrà restituito immediatamente.  
  
 Nel secondo esempio, un messaggio che contiene un parametro definito dall'applicazione `Order` classe viene inviato alla coda e successivamente viene letto dalla coda.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo massimo di attesa affinché un messaggio venga inserito nella coda.</param>
        <summary>Termina senza rimuovere (legge) il primo messaggio nella coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Poiché il metodo <see cref="M:System.Messaging.MessageQueue.Peek" /> è sincrono, blocca il thread corrente finché non viene reso disponibile un messaggio o non si verifica il timeout specificato.</summary>
        <returns><see cref="T:System.Messaging.Message" /> che rappresenta il primo messaggio della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per leggere una coda o a un determinato periodo di tempo fino a quando non è disponibile un messaggio nella coda di attesa. Il metodo restituisce immediatamente se un messaggio esiste già nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo legge, ma non rimuove, il primo messaggio dalla coda. Di conseguenza, le chiamate ripetute a <xref:System.Messaging.MessageQueue.Peek%2A> restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo, d'altra parte, legge e rimuove il primo messaggio dalla coda. Chiamate ripetute a <xref:System.Messaging.MessageQueue.Receive%2A>, pertanto restituire diversi tipi di messaggi.  
  
 I messaggi vengono ordinati in Accodamento messaggi nella coda in base all'ora di arrivo e priorità. Un messaggio più recente viene inserito prima di quello precedente solo se si tratta di una priorità più alta.  
  
 Utilizzare il metodo <xref:System.Messaging.MessageQueue.Peek%2A> quando è possibile bloccare il thread corrente durante l'attesa dell'arrivo di un messaggio nella coda. Il thread verrà bloccato fino al periodo specificato di tempo o per un periodo illimitato se si indicato <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Se si desidera che l'elaborazione dell'applicazione continui senza attendere, utilizzare il metodo asincrono <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo con un timeout pari a zero per verificare se la coda è vuota.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo massimo di attesa affinché un messaggio venga inserito nella coda.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <param name="action">Uno dei valori di <see cref="T:System.Messaging.PeekAction" />. Indica se leggere il messaggio corrente nella coda oppure il messaggio successivo.</param>
        <summary>Termina senza rimuovere (legge) il messaggio corrente o successivo della coda, utilizzando il cursore specificato. Poiché il metodo <see cref="M:System.Messaging.MessageQueue.Peek" /> è sincrono, blocca il thread corrente finché non viene reso disponibile un messaggio o non si verifica il timeout specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che rappresenta un messaggio della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per leggere una coda o a un determinato periodo di tempo fino a quando non è disponibile un messaggio nella coda di attesa. Il metodo restituisce immediatamente se un messaggio esiste già nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo legge, ma non rimuove, un messaggio dalla coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo, d'altra parte, legge e lo rimuove un messaggio dalla coda.  
  
 Utilizzare il metodo <xref:System.Messaging.MessageQueue.Peek%2A> quando è possibile bloccare il thread corrente durante l'attesa dell'arrivo di un messaggio nella coda. Il thread è bloccato fino al periodo specificato di tempo o per un periodo illimitato se si indicato <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Se si desidera che l'elaborazione dell'applicazione continui senza attendere, utilizzare il metodo asincrono <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">È stato specificato un valore diverso da <see langword="PeekAction.Current" /> o <see langword="PeekAction.Next" /> per il parametro <paramref name="action" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="cursor" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido. Probabilmente <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge un messaggio che corrisponde a un determinato identificatore di correlazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da leggere.</param>
        <summary>Legge il messaggio che corrisponde all'identificatore di correlazione specificato e, se nella coda non è disponibile correntemente alcun messaggio con l'identificatore di correlazione specificato, genererà immediatamente un'eccezione.</summary>
        <returns><see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo effettua ricerche nella coda cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio la cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Se viene trovato alcun messaggio che corrisponde alla `correlationID` parametro, viene generata un'eccezione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, un report o riconoscimento associati.  
  
 Altri due metodi consentono di leggere i messaggi in una coda. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo viene utilizzato per recuperare un messaggio, specificando il relativo identificatore univoco.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio contenente un ordine a e da una coda. In particolare richiede una conferma positiva quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="correlationId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da leggere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <summary>Legge il messaggio che corrisponde all'identificatore di correlazione specificato e attende che un messaggio con l'identificatore di correlazione specificato sia disponibile nella coda o che il timeout scada.</summary>
        <returns><see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo effettua ricerche nella coda cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio la cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Se viene trovato alcun messaggio che corrisponde alla `correlationID` parametro e nessun nuovo messaggio arriva nella coda entro il periodo specificato da di `timeout` parametro, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina la <xref:System.Messaging.Message.CorrelationId%2A> del nuovo messaggio per verificare se corrisponde il `correlationId` parametro. In caso contrario, questo metodo avvia nuovamente il periodo di timeout e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare entro il periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, fino a quando non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.CorrelationId%2A> corrisponde alla `correlationId` parametro.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, un report o riconoscimento associati.  
  
 Altri due metodi consentono di leggere i messaggi in una coda. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo viene utilizzato per recuperare un messaggio, specificando il relativo identificatore univoco.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il messaggio con l'oggetto <paramref name="correlationId" /> specificato non è presente nella coda e non è arrivato prima della scadenza del timeout.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato prima della scadenza del timeout.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una copia del messaggio con l'identificatore di messaggio specificato, senza rimuovere il messaggio dalla coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da leggere.</param>
        <summary>Legge il messaggio il cui identificatore corrisponde al parametro <paramref name="id" />.</summary>
        <returns><see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> per leggere, senza rimozione dalla coda, un messaggio contenente un identificatore di messaggio conosciuto. L'identificatore di un messaggio è univoco all'interno dell'azienda di Accodamento messaggi, in modo che esisterà al massimo un messaggio nella coda che corrisponde al determinato `id` parametro. Questo overload genera un'eccezione se la coda non è attualmente contiene il messaggio.  
  
 Consentono di leggere i messaggi in una coda di altri due metodi: <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce il primo messaggio nella coda. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> restituisce un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Non è disponibile alcun messaggio con il parametro <paramref name="id" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da leggere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <summary>Legge il messaggio il cui identificatore corrisponde al parametro <paramref name="id" />. Attende che il messaggio venga visualizzato nella coda o che si verifichi il timeout.</summary>
        <returns><see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> per leggere, senza rimozione dalla coda, un messaggio contenente un identificatore di messaggio conosciuto. L'identificatore di un messaggio è univoco all'interno dell'azienda di Accodamento messaggi, in modo che esisterà al massimo un messaggio nella coda che corrisponde al determinato `id` parametro. Questo overload genera un'eccezione se la coda non è attualmente contiene il messaggio e un nuovo messaggio è arrivato prima che si verifichi il timeout.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina la <xref:System.Messaging.Message.Id%2A> del nuovo messaggio per verificare se corrisponde il `id` parametro. In caso contrario, questo metodo avvia nuovamente il periodo di timeout e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare entro il periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, fino a quando non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.Id%2A> corrisponde alla `id` parametro.  
  
 Consentono di leggere i messaggi in una coda di altri due metodi: <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce il primo messaggio nella coda. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> restituisce un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il messaggio con l'oggetto <paramref name="id" /> specificato non è presente nella coda e non è arrivato prima della scadenza del periodo di tempo specificato dal parametro <paramref name="timeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introdotto in MSMQ 3.0. Legge un messaggio specifico nella coda. Il messaggio può essere specificato da un identificatore di ricerca o in base alla relativa posizione all'inizio o alla fine della coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Proprietà <see cref="P:System.Messaging.Message.LookupId" /> del messaggio da leggere.</param>
        <summary>Introdotto in MSMQ 3.0. Legge il messaggio che corrisponde all'identificatore di ricerca specificato da una coda non transazionale.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.LookupId" /> corrisponde al parametro <paramref name="lookupId" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per leggere un messaggio con un identificatore di ricerca noti senza rimuoverlo dalla coda. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà di un messaggio è univoca per la coda in cui si trova il messaggio, in modo che esisterà al massimo un messaggio nella coda che corrisponde al determinato `lookupId` parametro.  
  
 Per leggere un messaggio con un identificatore di ricerca specificato e rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> (metodo).  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="lookupId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">Uno dei valori di <see cref="T:System.Messaging.MessageLookupAction" />, che specifica come deve essere letto il messaggio nella coda. Specificare uno dei valori seguenti: 
 <see langword="MessageLookupAction.Current" />: legge il messaggio specificato da <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Next" />: legge il messaggio che segue il messaggio specificato da <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Previous" />: legge il messaggio che precede il messaggio specificato da <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.First" />: legge il primo messaggio della coda. Il parametro <paramref name="lookupId" /> deve essere impostato su 0.  
  
 <see langword="MessageLookupAction.Last" />: legge l'ultimo messaggio della coda. Il parametro <paramref name="lookupId" /> deve essere impostato su 0.</param>
        <param name="lookupId">Proprietà <see cref="P:System.Messaging.Message.LookupId" /> del messaggio da leggere oppure 0. 0 viene utilizzato quando si accede al primo o all'ultimo messaggio della coda.</param>
        <summary>Introdotto in MSMQ 3.0. Legge un messaggio specifico nella coda. Il messaggio può essere specificato da un identificatore di ricerca o in base alla relativa posizione all'inizio o alla fine della coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> specificato dai parametri <paramref name="action" /> e <paramref name="lookupId" /> passati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per leggere un messaggio con un identificatore di ricerca noti senza rimuoverlo dalla coda. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà di un messaggio è univoca per la coda in cui si trova il messaggio, in modo che esisterà al massimo un messaggio nella coda che corrisponde al determinato `lookupId` parametro.  
  
 Per leggere un messaggio con un identificatore specificato e rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> (metodo).  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="lookupId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="action" /> non è uno dei membri di <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando un messaggio viene letto senza essere rimosso dalla coda. Si tratta del risultato dell'operazione asincrona <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> viene utilizzato per generare l'elaborazione asincrona di <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando un messaggio sia disponibile nella coda.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene usato per completare l'operazione avviata da una chiamata a <xref:System.Messaging.MessageQueue.BeginPeek%2A> e visualizza il messaggio quando il <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato l'evento.  
  
 Quando si crea un delegato <xref:System.Messaging.PeekCompletedEventHandler>, si identifica il metodo che gestirà l'evento. Per associare l'evento al gestore eventi in uso, aggiungere all'evento un'istanza del delegato. Il gestore eventi viene chiamato ogni volta che si verifica l'evento, a meno che non venga rimosso il delegato. Per altre informazioni sui delegati del gestore eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un gestore eventi denominato `MyPeekCompleted`, lo collega al <xref:System.Messaging.MessageQueue.PeekCompleted> delegato del gestore eventi e chiamate <xref:System.Messaging.MessageQueue.BeginPeek%2A> per avviare un'operazione di lettura asincrona in coda che si trova nel percorso ". \myQueue". Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato l'evento, l'esempio legge il messaggio e scrive il corpo sullo schermo. Nell'esempio viene quindi chiamato <xref:System.Messaging.MessageQueue.BeginPeek%2A> nuovamente per avviare una nuova operazione di lettura asincrona  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina tutti i messaggi contenuti nella coda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene eliminata la coda di Accodamento messaggi impostare il flag di modifica della coda, che interessa il <xref:System.Messaging.MessageQueue.LastModifyTime%2A> proprietà. I messaggi vengono eliminati dalla coda vengono andrà persi. essi non vengono inviati per la coda di messaggi non recapitabili o nella coda journal.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome descrittivo che identifica la coda.</summary>
        <value>Nome che identifica la coda a cui questo oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Il valore non può essere <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile combinare le <xref:System.Messaging.MessageQueue.QueueName%2A> con il <xref:System.Messaging.MessageQueue.MachineName%2A> per creare una semplice <xref:System.Messaging.MessageQueue.Path%2A> nome per la coda. La sintassi per le variazioni del nome descrittivo del <xref:System.Messaging.MessageQueue.Path%2A> proprietà dipende dal tipo di coda, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|coda pubblica|`MachineName`\\`QueueName`|  
|coda privata|`MachineName`\\`Private$`\\`QueueName`|  
|Coda del diario|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Usare "." per rappresentare il computer locale.  
  
 Modifica il <xref:System.Messaging.MessageQueue.QueueName%2A> influisce sulle proprietà di <xref:System.Messaging.MessageQueue.Path%2A> proprietà. Se si imposta la <xref:System.Messaging.MessageQueue.QueueName%2A> senza impostare il <xref:System.Messaging.MessageQueue.MachineName%2A> proprietà, il <xref:System.Messaging.MessageQueue.Path%2A> diventa di proprietà.\\ `QueueName`. In caso contrario, il <xref:System.Messaging.MessageQueue.Path%2A> diviene `MachineName` \\ `QueueName`.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.QueueName%2A> proprietà.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome della coda è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle nativo utilizzato per leggere i messaggi dalla coda di messaggi.</summary>
        <value>Handle all'oggetto coda nativo utilizzato per leggere e ricevere messaggi dalla coda.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.ReadHandle%2A> fornisce un handle nativo di Windows all'oggetto coda di messaggi che viene usato per leggere e ricevere messaggi dalla coda. Se si modifica il percorso della coda, l'handle viene chiusa e riaperta con un nuovo valore.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <summary>Riceve il primo messaggio della coda rimuovendolo da quest'ultima.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riceve il primo messaggio disponibile nella coda a cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Questa chiamata è sincrona e blocca il thread corrente di esecuzione finché non è disponibile un messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda o attendere fino a quando non sono presenti messaggi nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura di un messaggio sincrona, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> restituirà i messaggi successivi nella coda o i nuovi messaggi con priorità più alta.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo). Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Usare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre si attende un messaggio in arrivo nella coda. Poiché questo overload del metodo di <xref:System.Messaging.MessageQueue.Receive%2A> metodo specifica un timeout infinito, l'applicazione potrebbe attendere all'infinito. Se l'elaborazione dell'applicazione continui senza attendere che il messaggio, è consigliabile usare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente riceve un messaggio da una coda e restituisce informazioni su tale messaggio sullo schermo.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il primo messaggio disponibile nella coda transazionale a cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Questa chiamata è sincrona e blocca il thread corrente di esecuzione finché non è disponibile un messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda transazionale utilizzando il contesto di transazione interna definito dal `transaction` parametro, o attendere fino a quando non sono presenti messaggi nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura di un messaggio sincrona, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> restituirà i messaggi successivi nella coda.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo). Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. In quanto <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non vi sarà alcuna operazione di rollback da una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre si attende un messaggio in arrivo nella coda. Poiché questo overload del metodo di <xref:System.Messaging.MessageQueue.Receive%2A> metodo specifica un timeout infinito, l'applicazione potrebbe attendere all'infinito. Se l'elaborazione dell'applicazione continui senza attendere che il messaggio, è consigliabile usare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente si connette a una coda transazionale nel computer locale e invia un messaggio alla coda. Viene quindi ricevuto il messaggio che contiene un ordine. Se si verifica una coda non transazionale, verrà generata eccezione e il rollback della transazione.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.  
  
oppure 
La coda non è transazionale.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il primo messaggio disponibile nella coda a cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Questa chiamata è sincrona e blocca il thread corrente di esecuzione finché non è disponibile un messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda usando un contesto di transazione definito dal `transactionType` parametro, o attendere fino a quando non sono presenti messaggi nella coda.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale all'esterno di un contesto di transazione.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura di un messaggio sincrona, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> restituirà i messaggi successivi nella coda.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo). Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. In quanto <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non vi sarà alcuna operazione di rollback da una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre si attende un messaggio in arrivo nella coda. Poiché questo overload del metodo di <xref:System.Messaging.MessageQueue.Receive%2A> metodo specifica un timeout infinito, l'applicazione potrebbe attendere all'infinito. Se l'elaborazione dell'applicazione continui senza attendere che il messaggio, è consigliabile usare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <summary>Riceve il primo messaggio disponibile nella coda cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento e attende che un messaggio sia disponibile nella coda o che il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere e restituire un messaggio in un periodo di tempo specificato se nella coda non sono disponibili messaggi.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura sincrona di un messaggio, rimuoverlo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> restituirà i messaggi successivi nella coda o i nuovi messaggi con priorità più alta.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo). Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Usare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre si attende un messaggio in arrivo nella coda. Il thread verrà bloccato per il periodo di tempo specificato o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro. Se l'elaborazione dell'applicazione continui senza attendere un messaggio, è consigliabile usare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente riceve un messaggio da una coda e restituisce informazioni su tale messaggio sullo schermo. Nell'esempio viene sospeso l'esecuzione fino a cinque secondi durante l'attesa di un messaggio in arrivo nella coda.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <summary>Riceve il messaggio corrente nella coda, utilizzando il cursore specificato. Se non è disponibile alcun messaggio, il metodo aspetta finché non risulta disponibile un messaggio o finché non scade il periodo di timeout.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi. 
Utilizzare questo overload per ricevere e restituire un messaggio in un periodo di tempo specificato se nella coda non sono disponibili messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il primo messaggio disponibile nella coda transazionale cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento e attende che un messaggio sia disponibile nella coda o che il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda transazionale utilizzando il contesto di transazione interna definito dal `transaction` parametro e restituire all'interno di un determinato periodo di tempo se non sono presenti messaggi nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura di un messaggio sincrona, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> restituirà i messaggi successivi nella coda.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo). Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. In quanto <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non vi sarà alcuna operazione di rollback da una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre si attende un messaggio in arrivo nella coda. Il thread verrà bloccato per il periodo di tempo specificato o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro. Se l'elaborazione dell'applicazione continui senza attendere un messaggio, è consigliabile usare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo metodo.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
oppure 
La coda non è transazionale.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il primo messaggio disponibile nella coda a cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Questa chiamata è sincrona e attende che un messaggio venga reso disponibile nella coda o il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda usando un contesto di transazione definito dal `transactionType` parametro e restituire in un determinato periodo di tempo se non sono presenti messaggi nella coda.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale all'esterno di un contesto di transazione.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura di un messaggio sincrona, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> restituirà i messaggi successivi nella coda.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo). Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. In quanto <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non vi sarà alcuna operazione di rollback da una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre si attende un messaggio in arrivo nella coda. Il thread verrà bloccato per il periodo di tempo specificato o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro. Se l'elaborazione dell'applicazione continui senza attendere un messaggio, è consigliabile usare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo metodo.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il messaggio corrente nella coda, utilizzando il cursore specificato. Se non è disponibile alcun messaggio, il metodo aspetta finché non risulta disponibile un messaggio o finché non scade il periodo di timeout.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento a un messaggio della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda transazionale utilizzando il contesto di transazione interna definito dal `transaction` parametro e restituire all'interno di un determinato periodo di tempo se non sono presenti messaggi nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura di un messaggio sincrona, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> restituiscono i messaggi successivi nella coda.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere un messaggio in una coda senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo). Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. In quanto <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non c'è niente di rollback da una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre si attende un messaggio in arrivo nella coda. Il thread è bloccato per il periodo di tempo specificato o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro. Se l'elaborazione dell'applicazione continui senza attendere un messaggio, è consigliabile usare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="cursor" /> è <see langword="null" />.  
  
oppure 
Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido. Probabilmente <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
oppure 
La coda non è transazionale.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il messaggio corrente nella coda, utilizzando il cursore specificato. Se non è disponibile alcun messaggio, il metodo aspetta finché non risulta disponibile un messaggio o finché non scade il periodo di timeout.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento a un messaggio della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda usando un contesto di transazione definito dal `transactionType` parametro e restituire in un determinato periodo di tempo se non sono presenti messaggi nella coda.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale all'esterno di un contesto di transazione.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura di un messaggio sincrona, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> restituiscono i messaggi successivi nella coda.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere un messaggio in una coda senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.Peek%2A> (metodo). Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. In quanto <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non c'è niente di rollback da una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre si attende un messaggio in arrivo nella coda. Il thread è bloccato per il periodo di tempo specificato o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro. Se l'elaborazione dell'applicazione continui senza attendere un messaggio, è consigliabile usare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="cursor" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido. Probabilmente <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riceve un messaggio che corrisponde a un determinato identificatore di correlazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato (da una coda non transazionale) e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore di correlazione specificato.</summary>
        <returns><see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo effettua ricerche nella coda non transazionale a cui fanno riferimento le <xref:System.Messaging.MessageQueue> per un messaggio la cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Se viene trovato alcun messaggio che corrisponde alla `correlationID` parametro, viene generata un'eccezione. In caso contrario, il messaggio viene rimosso dalla coda e restituito all'applicazione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, un report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo recupera un messaggio, specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio contenente un ordine a e da una coda. In particolare richiede una conferma positiva quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="correlationId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato (da una coda transazionale) e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore di correlazione specificato.</summary>
        <returns><see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo effettua ricerche nella coda transazionale a cui fanno riferimento le <xref:System.Messaging.MessageQueue> per un messaggio la cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Se viene trovato alcun messaggio che corrisponde alla `correlationID` parametro, viene generata un'eccezione. In caso contrario, il messaggio viene rimosso dalla coda e restituito all'applicazione utilizzando il contesto di transazione interna definito dal `transaction` parametro.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, un report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo viene utilizzato per recuperare un messaggio, specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> non rimuove i messaggi nella coda, non vi sarà alcuna operazione per eseguire il rollback della transazione sono state interrotte.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.  
  
oppure 
Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="correlationId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La coda non è transazionale.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore di correlazione specificato.</summary>
        <returns><see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo effettua ricerche nella coda cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio la cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Se viene trovato alcun messaggio che corrisponde alla `correlationID` parametro, viene generata un'eccezione. In caso contrario, il messaggio viene rimosso dalla coda e restituito all'applicazione usando un contesto di transazione definito dal `transactionType` parametro.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale all'esterno di un contesto di transazione.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, un report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo viene utilizzato per recuperare un messaggio, specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> non rimuove i messaggi nella coda, non vi sarà alcuna operazione per eseguire il rollback della transazione sono state interrotte.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="correlationId" /> specificato.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato (da una coda non transazionale) e attende che un messaggio con l'identificatore di correlazione specificato sia disponibile nella coda oppure che il timeout scada.</summary>
        <returns><see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo effettua ricerche nella coda non transazionale a cui fanno riferimento le <xref:System.Messaging.MessageQueue> per un messaggio la cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Questo metodo restituisce immediatamente se il messaggio con l'identificatore di correlazione specificato mediante il `correlationId` parametro si trova nella coda. In caso contrario, il metodo attende il periodo di tempo per un nuovo messaggio in arrivo specificato. Se un nuovo messaggio non perviene prima il timeout scada, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina la <xref:System.Messaging.Message.CorrelationId%2A> del nuovo messaggio per verificare se corrisponde il `correlationId` parametro. In caso contrario, questo metodo avvia nuovamente il periodo di timeout e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare entro il periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, fino a quando non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.CorrelationId%2A> corrisponde alla `correlationId` parametro.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, un report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo viene utilizzato per recuperare un messaggio, specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il messaggio con l'oggetto <paramref name="correlationId" /> specificato non è presente nella coda e non è arrivato prima della scadenza del timeout.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato (da una coda transazionale) e attende che un messaggio con l'identificatore di correlazione specificato sia disponibile nella coda oppure che il timeout scada.</summary>
        <returns><see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo effettua ricerche nella coda transazionale a cui fanno riferimento le <xref:System.Messaging.MessageQueue> per un messaggio la cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Questo metodo restituisce immediatamente se il messaggio con l'identificatore di correlazione specificato mediante il `correlationId` parametro è presente nella coda, utilizzando il contesto di transazione interna definito dal `transaction` parametro. In caso contrario, il metodo attende il periodo di tempo per un nuovo messaggio in arrivo specificato. Se un nuovo messaggio non perviene prima il timeout scada, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina la <xref:System.Messaging.Message.CorrelationId%2A> del nuovo messaggio per verificare se corrisponde il `correlationId` parametro. In caso contrario, questo metodo avvia nuovamente il periodo di timeout e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare entro il periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, fino a quando non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.CorrelationId%2A> corrisponde alla `correlationId` parametro.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, un report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo viene utilizzato per recuperare un messaggio, specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> non rimuove i messaggi nella coda, non vi sarà alcuna operazione per eseguire il rollback della transazione sono state interrotte.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.  
  
oppure 
Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il messaggio con l'oggetto <paramref name="correlationId" /> specificato non è presente nella coda e non è arrivato prima della scadenza del timeout.  
  
oppure 
La coda non è transazionale.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato e attende che un messaggio con l'identificatore di correlazione specificato sia disponibile nella coda o che il timeout scada.</summary>
        <returns><see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo effettua ricerche nella coda cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio la cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Questo metodo restituisce immediatamente se il messaggio con l'identificatore di correlazione specificato mediante il `correlationId` parametro è presente nella coda, utilizzando un contesto di transazione definito dalla `transactionType` parametro. In caso contrario, il metodo attende il periodo di tempo per un nuovo messaggio in arrivo specificato. Se un nuovo messaggio non perviene prima il timeout scada, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina la <xref:System.Messaging.Message.CorrelationId%2A> del nuovo messaggio per verificare se corrisponde il `correlationId` parametro. In caso contrario, questo metodo avvia nuovamente il periodo di timeout e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare entro il periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, fino a quando non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.CorrelationId%2A> corrisponde alla `correlationId` parametro. Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale all'esterno di un contesto di transazione.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, un report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo viene utilizzato per recuperare un messaggio, specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> non rimuove i messaggi nella coda, non vi sarà alcuna operazione per eseguire il rollback della transazione sono state interrotte.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="correlationId" /> specificato.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il messaggio con l'oggetto <paramref name="correlationId" /> specificato non è presente nella coda e non è arrivato prima della scadenza del timeout.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riceve il messaggio corrispondente all'identificatore specificato rimuovendolo dalla coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore specificato da una coda non transazionale e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore noto e lo rimuove dalla coda. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.Id%2A> proprietà di un messaggio è univoca all'interno dell'azienda di Accodamento messaggi, esisterà al massimo un messaggio nella coda che corrisponde al determinato `id` parametro.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="id" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore specificato (da una coda transazionale) e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per leggere un messaggio con un identificatore noto e lo rimuove dalla coda, utilizzando il contesto di transazione interna definito dal `transaction` parametro. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda  
  
 Il <xref:System.Messaging.Message.Id%2A> proprietà di un messaggio è univoca all'interno dell'azienda di Accodamento messaggi, esisterà al massimo un messaggio nella coda che corrisponde al determinato `id` parametro.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> non rimuove i messaggi nella coda, non vi sarà alcuna operazione per eseguire il rollback della transazione sono state interrotte.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.  
  
oppure 
Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="id" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La coda non è transazionale.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il messaggio corrispondente all'identificatore specificato e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore noto e lo rimuove dalla coda. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda. In caso contrario, il messaggio viene rimosso dalla coda e restituito all'applicazione usando un contesto di transazione definito dal `transactionType` parametro.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale all'esterno di un contesto di transazione.  
  
 Il <xref:System.Messaging.Message.Id%2A> proprietà di un messaggio è univoca all'interno dell'azienda di Accodamento messaggi, esisterà al massimo un messaggio nella coda che corrisponde al determinato `id` parametro. Se il messaggio con l'identificatore specificato si trova in una coda diverso da quello associato a questo <xref:System.Messaging.MessageQueue> istanza, il messaggio non sarà reperibile.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> non rimuove i messaggi nella coda, non vi sarà alcuna operazione per eseguire il rollback della transazione sono state interrotte.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="id" /> specificato.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <summary>Riceve il messaggio corrispondente all'identificatore specificato (da una coda non transazionale) e attende che un messaggio con l'identificatore specificato sia disponibile nella coda o che il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore noto e lo rimuove dalla coda. Questo metodo restituisce immediatamente se il messaggio con l'identificatore specificato mediante il `id` parametro si trova nella coda. In caso contrario, il metodo attende il periodo di tempo per un nuovo messaggio in arrivo specificato. Se un nuovo messaggio non perviene prima il timeout scada, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina la <xref:System.Messaging.Message.Id%2A> del nuovo messaggio per verificare se corrisponde il `id` parametro. In caso contrario, questo metodo avvia nuovamente il periodo di timeout e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare entro il periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, fino a quando non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.Id%2A> corrisponde alla `id` parametro.  
  
 Il <xref:System.Messaging.Message.Id%2A> proprietà di un messaggio è univoca all'interno dell'azienda di Accodamento messaggi, esisterà al massimo un messaggio nella coda che corrisponde al determinato `id` parametro.  
  
 Utilizzare questo overload del metodo <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando è accettabile per il thread corrente resti bloccato fino a quando i nuovi messaggi continuano a arrivano nella coda entro il periodo di timeout specificato il `timeout` parametro. Il thread verrà bloccato per il periodo di tempo specificato o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro, o se i nuovi messaggi continuano a arrivano nella coda entro il periodo di timeout specificato il `timeout` parametro.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio con il parametro <paramref name="id" /> specificato non è arrivato nella coda prima della scadenza del timeout.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il messaggio corrispondente all'identificatore specificato (da una coda transazionale) e attende che un messaggio con l'identificatore specificato sia disponibile nella coda o che il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per leggere un messaggio con un identificatore noto e lo rimuove dalla coda, utilizzando il contesto di transazione interna definito dal `transaction` parametro. Questo metodo restituisce immediatamente se il messaggio con l'identificatore specificato mediante il `id` parametro si trova nella coda. In caso contrario, il metodo attende il periodo di tempo per un nuovo messaggio in arrivo specificato. Se un nuovo messaggio non perviene prima il timeout scada, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina la <xref:System.Messaging.Message.Id%2A> del nuovo messaggio per verificare se corrisponde il `id` parametro. In caso contrario, questo metodo avvia nuovamente il periodo di timeout e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare entro il periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, fino a quando non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.Id%2A> corrisponde alla `id` parametro.  
  
 Il <xref:System.Messaging.Message.Id%2A> proprietà di un messaggio è univoca all'interno dell'azienda di Accodamento messaggi, esisterà al massimo un messaggio nella coda che corrisponde al determinato `id` parametro.  
  
 Utilizzare questo overload del metodo <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando è accettabile per il thread corrente resti bloccato fino a quando i nuovi messaggi continuano a arrivano nella coda entro il periodo di timeout specificato il `timeout` parametro. Il thread verrà bloccato per il periodo di tempo specificato o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro, o se i nuovi messaggi continuano a arrivano nella coda all'interno del periodo di timeout specificato il `timeout` parametro.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> non rimuove i messaggi nella coda, non vi sarà alcuna operazione per eseguire il rollback della transazione sono state interrotte.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.  
  
oppure 
Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio con il parametro <paramref name="id" /> specificato non è arrivato nella coda prima della scadenza del timeout.  
  
oppure 
La coda non è transazionale.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore specificato e attende che un messaggio con l'identificatore specificato sia disponibile nella coda o che il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore noto e lo rimuove dalla coda. Questo metodo restituisce immediatamente se il messaggio con l'identificatore specificato mediante il `id` parametro è presente nella coda, utilizzando un contesto di transazione definito dalla `transactionType` parametro. In caso contrario, il metodo attende il periodo di tempo per un nuovo messaggio in arrivo specificato. Se un nuovo messaggio non perviene prima il timeout scada, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina la <xref:System.Messaging.Message.Id%2A> del nuovo messaggio per verificare se corrisponde il `id` parametro. In caso contrario, questo metodo avvia nuovamente il periodo di timeout e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare entro il periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, fino a quando non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.Id%2A> corrisponde alla `id` parametro.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale all'esterno di un contesto di transazione.  
  
 Il <xref:System.Messaging.Message.Id%2A> proprietà di un messaggio è univoca all'interno dell'azienda di Accodamento messaggi, esisterà al massimo un messaggio nella coda che corrisponde al determinato `id` parametro. Se il messaggio con l'identificatore specificato si trova in una coda diverso da quello associato a questo <xref:System.Messaging.MessageQueue> istanza, il messaggio non sarà reperibile.  
  
 Utilizzare questo overload del metodo <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando è accettabile per il thread corrente resti bloccato fino a quando i nuovi messaggi continuano a arrivano nella coda entro il periodo di timeout specificato il `timeout` parametro. Il thread verrà bloccato per il periodo di tempo specificato o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro, o se i nuovi messaggi continuano a arrivano nella coda entro il periodo di timeout specificato il `timeout` parametro.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio nella coda e il <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (metodo). Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio nella coda, in modo che le successive chiamate al metodo di restituiranno lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> non rimuove i messaggi nella coda, non vi sarà alcuna operazione per eseguire il rollback della transazione sono state interrotte.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio con il parametro <paramref name="id" /> specificato non è arrivato nella coda prima della scadenza del timeout.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introdotto in MSMQ 3.0. Riceve un messaggio specifico della coda. Il messaggio può essere specificato da un identificatore di ricerca o in base alla relativa posizione all'inizio o alla fine della coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Oggetto <see cref="P:System.Messaging.Message.LookupId" /> del messaggio da ricevere.</param>
        <summary>Introdotto in MSMQ 3.0. Riceve il messaggio che corrisponde all'identificatore di ricerca specificato da una coda non transazionale.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.LookupId" /> corrisponde al parametro <paramref name="lookupId" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per leggere un messaggio con un identificatore di ricerca note e rimuoverlo dalla coda. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà di un messaggio è univoca per la coda in cui si trova il messaggio, in modo che esisterà al massimo un messaggio nella coda che corrisponde al determinato `lookupId` parametro.  
  
 Per leggere un messaggio con un identificatore di ricerca specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> (metodo).  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="lookupId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">Uno dei valori di <see cref="T:System.Messaging.MessageLookupAction" />, che specifica come deve essere letto il messaggio nella coda. Specificare uno dei valori seguenti: 
 <see langword="MessageLookupAction.Current" />: riceve il messaggio specificato da <paramref name="lookupId" /> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.Next" />: riceve il messaggio che segue il messaggio specificato da <paramref name="lookupId" /> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.Previous" />: riceve il messaggio che precede il messaggio specificato da <paramref name="lookupId" /> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.First" />: riceve il primo messaggio della coda e lo rimuove da quest'ultima. Il parametro <paramref name="lookupId" /> deve essere impostato su 0.  
  
 <see langword="MessageLookupAction.Last" />: riceve l'ultimo messaggio della coda e lo rimuove da quest'ultima. Il parametro <paramref name="lookupId" /> deve essere impostato su 0.</param>
        <param name="lookupId">Oggetto <see cref="P:System.Messaging.Message.LookupId" /> del messaggio da ricevere oppure 0. 0 viene utilizzato quando si accede al primo o all'ultimo messaggio della coda.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Introdotto in MSMQ 3.0. Riceve un messaggio specifico da una coda transazionale. Il messaggio può essere specificato da un identificatore di ricerca o in base alla relativa posizione all'inizio o alla fine della coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> specificato dai parametri <paramref name="lookupId" /> e <paramref name="action" /> passati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per leggere un messaggio con un identificatore di ricerca note e lo rimuove dalla coda, utilizzando un contesto di transazione definito dal `transaction` parametro. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà di un messaggio è univoca per la coda in cui si trova il messaggio, in modo che esisterà al massimo un messaggio nella coda che corrisponde al determinato `lookupId` parametro.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> (metodo). Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Poiché <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> non rimuove i messaggi dalla coda, non vi sarà alcuna operazione per eseguire il rollback della transazione sono state interrotte.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="lookupId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.  
  
oppure 
La coda non è transazionale.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="action" /> non è uno dei membri di <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">Uno dei valori di <see cref="T:System.Messaging.MessageLookupAction" />, che specifica come deve essere letto il messaggio nella coda. Specificare uno dei valori seguenti: 
 <see langword="MessageLookupAction.Current" />: riceve il messaggio specificato da <paramref name="lookupId" /> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.Next" />: riceve il messaggio che segue il messaggio specificato da <paramref name="lookupId" /> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.Previous" />: riceve il messaggio che precede il messaggio specificato da <paramref name="lookupId" /> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.First" />: riceve il primo messaggio della coda e lo rimuove da quest'ultima. Il parametro <paramref name="lookupId" /> deve essere impostato su 0.  
  
 <see langword="MessageLookupAction.Last" />: riceve l'ultimo messaggio della coda e lo rimuove da quest'ultima. Il parametro <paramref name="lookupId" /> deve essere impostato su 0.</param>
        <param name="lookupId">Oggetto <see cref="P:System.Messaging.Message.LookupId" /> del messaggio da ricevere oppure 0. 0 viene utilizzato quando si accede al primo o all'ultimo messaggio della coda.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Introdotto in MSMQ 3.0. Riceve un messaggio specifico della coda, utilizzando il contesto di transazione specificato. Il messaggio può essere specificato da un identificatore di ricerca o in base alla relativa posizione all'inizio o alla fine della coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> specificato dai parametri <paramref name="action" /> e <paramref name="lookupId" /> passati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per leggere un messaggio con un identificatore di ricerca note e lo rimuove dalla coda, utilizzando un contesto di transazione definito dal `transactionType` parametro. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà di un messaggio è univoca per la coda in cui si trova il messaggio, in modo che esisterà al massimo un messaggio nella coda che corrisponde al determinato `lookupId` parametro.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, usare il <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> (metodo). Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Poiché <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> non rimuove i messaggi dalla coda, non vi sarà alcuna operazione per eseguire il rollback della transazione sono state interrotte.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale all'esterno di un contesto di transazione.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="lookupId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="action" /> non è uno dei membri di <see cref="T:System.Messaging.MessageLookupAction" />.  
  
oppure 
Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando un messaggio è stato rimosso dalla coda. Questo evento viene generato dall'operazione asincrona <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> viene utilizzato per generare l'elaborazione asincrona di <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando un messaggio sia disponibile nella coda.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene usato per completare l'operazione avviata da una chiamata a <xref:System.Messaging.MessageQueue.BeginReceive%2A> e visualizza il messaggio quando il <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato l'evento.  
  
 Quando si crea un delegato <xref:System.Messaging.ReceiveCompletedEventHandler>, si identifica il metodo che gestirà l'evento. Per associare l'evento al gestore eventi in uso, aggiungere all'evento un'istanza del delegato. Il gestore eventi viene chiamato ogni volta che si verifica l'evento, a meno che non venga rimosso il delegato. Per altre informazioni sui delegati del gestore eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un gestore eventi denominato `MyReceiveCompleted`, lo collega al <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegato del gestore eventi e chiamate <xref:System.Messaging.MessageQueue.BeginReceive%2A> per avviare un'operazione di ricezione asincrona in coda che si trova nel percorso ". \myQueue". Quando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato l'evento, l'esempio riceve il messaggio e scrive il corpo sullo schermo. Nell'esempio viene quindi chiamato <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente per avviare una nuova asincrona operazione di ricezione.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aggiorna le proprietà presentate da <see cref="T:System.Messaging.MessageQueue" /> per riflettere lo stato corrente della risorsa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> Consente di sincronizzare le proprietà di un <xref:System.Messaging.MessageQueue> con la risorsa server Accodamento messaggi associata. Se qualsiasi proprietà, come <xref:System.Messaging.MessageQueue.Label%2A> o <xref:System.Messaging.MessageQueue.Category%2A>, è stato modificato nel server dal momento la <xref:System.Messaging.MessageQueue> è stata creata, <xref:System.Messaging.MessageQueue.Refresh%2A> aggiornamenti il <xref:System.Messaging.MessageQueue> con le nuove informazioni.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta l'elenco delle autorizzazioni sui valori predefiniti del sistema operativo. Rimuove tutte le autorizzazioni relative alla coda aggiunte all'elenco predefinito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, si restituisce l'elenco di autorizzazioni sui valori predefiniti. In genere, si concede tutte le autorizzazioni al creatore della coda e concede al gruppo Everyone diritti seguenti:  
  
-   Ottenere le proprietà della coda.  
  
-   Ottenere le autorizzazioni delle code.  
  
-   Scrivere nella coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invia un oggetto a una coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <summary>Invia un oggetto alla coda non transazionale a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro per la coda cui fa riferimento il <xref:System.Messaging.MessageQueue>. L'oggetto inviato nella coda può essere un <xref:System.Messaging.Message> o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio.  
  
 Se si utilizza questo overload per inviare un messaggio a una coda transazionale, il messaggio verrà inviato per la coda di messaggi non recapitabili. Se si desidera che il messaggio da parte di una transazione che contiene altri messaggi, usare un overload che accetta un <xref:System.Messaging.MessageQueueTransaction> o <xref:System.Messaging.MessageQueueTransactionType> come parametro.  
  
 Se non si impostano i <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto diverso da un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità usando il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori vengono applicati a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione li invia alla coda. Durante l'invio di un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza sulle <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza su della coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente si connette a una coda di messaggi e invia un messaggio alla coda.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 L'esempio di codice seguente invia definito dall'applicazione `Order` classe a una coda e quindi riceve un messaggio dalla coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Invia un oggetto alla coda transazionale a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro alla coda transazionale a cui fa riferimento il <xref:System.Messaging.MessageQueue>, utilizzando un contesto di transazione interna definito dal `transaction` parametro. L'oggetto inviato nella coda può essere un <xref:System.Messaging.Message> o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio.  
  
 Se si utilizza questo overload per inviare un messaggio a una coda non transazionale, il messaggio potrebbe essere inviato per la coda di messaggi non recapitabili senza generare un'eccezione.  
  
 Se non si impostano i <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto diverso da un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità usando il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori vengono applicati a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione li invia alla coda. Durante l'invio di un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza sulle <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza su della coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 <xref:System.Messaging.MessageQueueTransaction> il threading apartment, pertanto se lo stato di apartment è `STA`, è possibile utilizzare la transazione in più thread. Visual Basic imposta lo stato del thread principale per `STA`, pertanto è necessario applicare il <xref:System.MTAThreadAttribute> nel `Main` subroutine. In caso contrario, l'invio di un messaggio transazionale mediante un altro thread genererà un'eccezione <xref:System.Messaging.MessageQueueException>. Si applica il <xref:System.MTAThreadAttribute> usando il frammento seguente.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente invia una stringa a una coda transazionale e quindi riceve un messaggio dalla coda.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
oppure 
Nell'applicazione Accodamento messaggi è stato segnalato un utilizzo non corretto delle transazioni.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Invia un oggetto alla coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro alla coda a cui fa riferimento il <xref:System.Messaging.MessageQueue>, utilizzando un contesto di transazione definito dal `transactionType` parametro. Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per inviare il messaggio. Specificare `Single` se si desidera inviare il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera inviare un messaggio transazionale a un thread non transazionale.  
  
 L'oggetto inviato nella coda può essere un <xref:System.Messaging.Message> o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio.  
  
 Se non si impostano i <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto diverso da un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità usando il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori vengono applicati a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione li invia alla coda. Durante l'invio di un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza sulle <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza su della coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <param name="label">L'etichetta del messaggio.</param>
        <summary>Invia un oggetto alla coda non transazionale a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento e specifica un'etichetta per il messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro per la coda cui fa riferimento il <xref:System.Messaging.MessageQueue>. Con questo overload, è possibile specificare l'etichetta di stringa che identifica il messaggio. L'oggetto inviato nella coda può essere un <xref:System.Messaging.Message>, una struttura, un oggetto dati o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio.  
  
 L'etichetta del messaggio è distinto dall'etichetta della coda di messaggi, ma entrambi sono dipendenti dall'applicazione e non hanno alcun significato di ereditarietà per il servizio Accodamento messaggi.  
  
 Se si utilizza questo overload per inviare un messaggio a una coda transazionale, il messaggio verrà inviato per la coda di messaggi non recapitabili. Se si desidera che il messaggio da parte di una transazione che contiene altri messaggi, usare un overload che accetta un <xref:System.Messaging.MessageQueueTransaction> o <xref:System.Messaging.MessageQueueTransactionType> come parametro.  
  
 Il <xref:System.Messaging.MessageQueue.Path%2A> proprietà per questo <xref:System.Messaging.MessageQueue> istanza deve essere specificata prima di inviare il messaggio. Se non si impostano i <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto diverso da un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità usando il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori vengono applicati a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione li invia alla coda. Durante l'invio di un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza sulle <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza su della coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="label" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <param name="label">L'etichetta del messaggio.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Invia un oggetto alla coda transazionale a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento e specifica un'etichetta per il messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro alla coda transazionale a cui fa riferimento il <xref:System.Messaging.MessageQueue>, utilizzando un contesto di transazione interna definito dal `transaction` parametro. Con questo overload, è possibile specificare l'etichetta di stringa che identifica il messaggio. L'oggetto inviato nella coda può essere un <xref:System.Messaging.Message>, una struttura, un oggetto dati o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio.  
  
 L'etichetta del messaggio è distinto dall'etichetta della coda di messaggi, ma entrambi sono dipendenti dall'applicazione e non hanno alcun significato di ereditarietà per il servizio Accodamento messaggi.  
  
 Se si utilizza questo overload per inviare un messaggio a una coda non transazionale, il messaggio potrebbe essere inviato per la coda di messaggi non recapitabili senza generare un'eccezione.  
  
 Se non si impostano i <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto diverso da un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità usando il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori vengono applicati a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione li invia alla coda. Durante l'invio di un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza sulle <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza su della coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà  
  
 <xref:System.Messaging.MessageQueueTransaction> il threading apartment, pertanto se lo stato di apartment è `STA`, è possibile utilizzare la transazione in più thread. Visual Basic imposta lo stato del thread principale per `STA`, pertanto è necessario applicare il <xref:System.MTAThreadAttribute> nel `Main` subroutine. In caso contrario, l'invio di un messaggio transazionale mediante un altro thread genererà un'eccezione <xref:System.Messaging.MessageQueueException>. Si applica il <xref:System.MTAThreadAttribute> usando il frammento seguente.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="label" /> è <see langword="null" />.  
  
oppure 
Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
oppure 
Nell'applicazione Accodamento messaggi è stato segnalato un utilizzo non corretto delle transazioni.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <param name="label">L'etichetta del messaggio.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Invia un oggetto alla coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento e specifica un'etichetta per il messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro alla coda a cui fa riferimento il <xref:System.Messaging.MessageQueue>, utilizzando un contesto di transazione definito dal `transactionType` parametro. Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera usare per inviare il messaggio. Specificare `Single` se si desidera inviare il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera inviare un messaggio transazionale a un thread non transazionale.  
  
 L'oggetto inviato nella coda può essere un <xref:System.Messaging.Message> o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio. Con questo overload, è possibile specificare l'etichetta di stringa che identifica il messaggio.  
  
 L'etichetta del messaggio è distinto dall'etichetta della coda di messaggi, ma entrambi sono dipendenti dall'applicazione e non hanno alcun significato di ereditarietà per il servizio Accodamento messaggi.  
  
 Se non si impostano i <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto diverso da un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità usando il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori vengono applicati a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione li invia alla coda. Durante l'invio di un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza sulle <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza su della coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="label" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Nell'applicazione Accodamento messaggi è stato segnalato un utilizzo non corretto delle transazioni.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
oppure 
Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge le autorizzazioni al set di autorizzazioni corrente. Controlla gli utenti che dispongono dei diritti di accesso alle proprietà della coda e ai messaggi presenti nella coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Oggetto <see cref="T:System.Messaging.AccessControlList" /> contenente una o più voci di controllo di accesso che specificano le terze parti trusted e le autorizzazioni da concedere.</param>
        <summary>Assegna i diritti di accesso alla coda in base al contenuto di un elenco di controllo di accesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per concedere, negare o revocare i diritti di utilizzando una raccolta di voci di controllo di accesso per specificare le informazioni di trustee e le autorizzazioni. Ciò consente, ad esempio, concedere autorizzazioni a più utenti contemporaneamente.  
  
 Il fiduciario specificato quando si costruisce la `ace` parametro può essere un singolo utente, un gruppo di utenti o un computer. Se il fiduciario è un singolo utente, usare il formato `DOMAIN` \\ `user`. È possibile specificare "." per il dominio trusted indicare il computer locale.  
  
 Le autorizzazioni assegnate tramite <xref:System.Messaging.MessageQueue.SetPermissions%2A> aggiungere le autorizzazioni per l'elenco esistente. Per impostazione predefinita, l'autore di una coda pubblica o privata abbia il pieno controllo e il gruppo di dominio Everyone dispone dell'autorizzazione per ottenere le proprietà della coda, ottenere le autorizzazioni e scrivere nella coda. Quando si chiama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, le informazioni utente e le autorizzazioni vengono aggiunte alla fine dell'elenco esistente.  
  
 Il sistema esamina ciascuna <xref:System.Messaging.AccessControlEntry> in sequenza fino a quando non si verifica uno degli eventi seguenti:  
  
-   Un accesso negato <xref:System.Messaging.AccessControlEntry> nega in modo esplicito uno qualsiasi dei diritti di accesso richiesto a una delle fiduciari elencati nel token di accesso del thread.  
  
-   Uno o più Autorizzazione dell'accesso <xref:System.Messaging.AccessControlEntry> elementi per tutti i diritti di accesso richiesto di concessione fiduciari elencati nel token di accesso del thread in modo esplicito.  
  
-   Tutti i <xref:System.Messaging.AccessControlEntry> articoli sono stati verificati e vi è ancora presente almeno un diritto di accesso che non è stato esplicitamente concesso, nel qual caso, l'accesso viene implicitamente negato.  
  
 Quando si costruisce il `dacl` parametro, si aggiungono <xref:System.Messaging.AccessControlEntry> alle istanze di <xref:System.Messaging.AccessControlList> raccolta. Quando si crea ogni voce di controllo di accesso, è possibile specificare i diritti di accesso generici o standard. I diritti a una coda possono essere qualsiasi combinazione delle operazioni seguenti:  
  
-   Eliminare  
  
-   Sicurezza da lettura  
  
-   Protezione da scrittura  
  
-   Sincronizzare  
  
-   Modifica proprietario  
  
-   Lettura  
  
-   Write  
  
-   Esegui  
  
-   Obbligatorio  
  
-   Tutti  
  
-   nessuno  
  
 Tali diritti sono un set di flag di bit che è possibile combinare utilizzando l'operatore OR bit per bit.  
  
-   Controllo completo  
  
-   Eliminare messaggio  
  
-   Ricezione messaggio  
  
-   Visualizza il messaggio  
  
-   Ricevi messaggio Journal  
  
-   Ottenere le proprietà della coda  
  
-   Impostare le proprietà della coda  
  
-   Ottenere le autorizzazioni  
  
-   Impostare le autorizzazioni  
  
-   Assumere la proprietà di coda  
  
-   WriteMessage  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Oggetto <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> che specifica un utente, un tipo di accesso e un tipo di autorizzazione.</param>
        <summary>Assegna i diritti di accesso alla coda in base al contenuto di una voce di controllo di accesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per concedere, negare o revocare i diritti tramite una voce di controllo di accesso per specificare le informazioni sui diritti e fiduciario.  
  
 Il fiduciario specificato quando si costruisce la `ace` parametro può essere un singolo utente, un gruppo di utenti o un computer. Se il fiduciario è un singolo utente, usare il formato `DOMAIN` \\ `user`. È possibile specificare "." per il dominio trusted indicare il computer locale.  
  
 Le autorizzazioni assegnate tramite <xref:System.Messaging.MessageQueue.SetPermissions%2A> aggiungere le autorizzazioni per l'elenco esistente. Per impostazione predefinita, l'autore di una coda pubblica o privata abbia il pieno controllo e il gruppo di dominio Everyone dispone dell'autorizzazione per ottenere le proprietà della coda, ottenere le autorizzazioni e scrivere nella coda. Quando si chiama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, le informazioni utente e le autorizzazioni vengono aggiunte alla fine dell'elenco esistente.  
  
 Il sistema esamina ciascuna <xref:System.Messaging.AccessControlEntry> in sequenza fino a quando non si verifica uno degli eventi seguenti:  
  
-   Un accesso negato <xref:System.Messaging.AccessControlEntry> nega in modo esplicito uno qualsiasi dei diritti di accesso richiesto a una delle fiduciari elencati nel token di accesso del thread.  
  
-   Uno o più Autorizzazione dell'accesso <xref:System.Messaging.AccessControlEntry> elementi per tutti i diritti di accesso richiesto di concessione fiduciari elencati nel token di accesso del thread in modo esplicito.  
  
-   Tutti i <xref:System.Messaging.AccessControlEntry> articoli sono stati verificati e vi è ancora presente almeno un diritto di accesso che non è stato esplicitamente concesso, nel qual caso, l'accesso viene implicitamente negato.  
  
 I diritti a una coda, specificata nella `rights` parametro quando si costruisce il <xref:System.Messaging.MessageQueueAccessControlEntry>, può essere qualsiasi combinazione delle opzioni seguenti:  
  
-   Controllo completo  
  
-   Eliminare messaggio  
  
-   Ricezione messaggio  
  
-   Visualizza il messaggio  
  
-   Ricevi messaggio Journal  
  
-   Ottenere le proprietà della coda  
  
-   Impostare le proprietà della coda  
  
-   Ottenere le autorizzazioni  
  
-   Impostare le autorizzazioni  
  
-   Assumere la proprietà di coda  
  
-   WriteMessage  
  
 Il `rights` parametro specificato nel costruttore per il `ace` parametro è un flag del <xref:System.Messaging.MessageQueueAccessRights> enumerazione. Rappresenta un set di flag di bit che è possibile combinare l'uso dell'operatore OR bit per bit o quando si compila il `rights` parametro.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Singolo utente, gruppo o computer che ottiene ulteriori diritti per la coda.</param>
        <param name="rights">Oggetto <see cref="T:System.Messaging.MessageQueueAccessRights" /> che indica una serie di diritti per la coda assegnati da Accodamento messaggi al parametro <paramref name="user" /> passato.</param>
        <summary>Fornisce a un computer, a un gruppo o a un utente i diritti di accesso specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per concedere i diritti specificati per un singolo utente. L'utente può essere qualsiasi fiduciario valido, che include i singoli utenti, gruppi di utenti o un computer. Se l'utente è una persona, usare il formato `DOMAIN` \\ `user` per il `user` parametro. È possibile specificare "." per il `user` parametro per indicare il computer locale.  
  
 Le autorizzazioni assegnate tramite <xref:System.Messaging.MessageQueue.SetPermissions%2A> aggiungere le autorizzazioni per l'elenco esistente. Per impostazione predefinita, l'autore di una coda pubblica o privata abbia il pieno controllo e il gruppo di dominio Everyone dispone dell'autorizzazione per ottenere le proprietà della coda, ottenere le autorizzazioni e scrivere nella coda. Quando si chiama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, le informazioni utente e le autorizzazioni vengono aggiunte alla fine dell'elenco esistente.  
  
 Il sistema esamina ciascuna <xref:System.Messaging.AccessControlEntry> in sequenza fino a quando non si verifica uno degli eventi seguenti:  
  
-   Un accesso negato <xref:System.Messaging.AccessControlEntry> nega in modo esplicito uno qualsiasi dei diritti di accesso richiesto a una delle fiduciari elencati nel token di accesso del thread.  
  
-   Uno o più Autorizzazione dell'accesso <xref:System.Messaging.AccessControlEntry> elementi per tutti i diritti di accesso richiesto di concessione fiduciari elencati nel token di accesso del thread in modo esplicito.  
  
-   Tutti i <xref:System.Messaging.AccessControlEntry> articoli sono stati verificati e vi è ancora presente almeno un diritto di accesso che non è stato esplicitamente concesso, nel qual caso, l'accesso viene implicitamente negato.  
  
 I diritti a una coda, specificato nella `rights` parametro, può essere qualsiasi combinazione delle opzioni seguenti:  
  
-   Controllo completo  
  
-   Eliminare messaggio  
  
-   Ricezione messaggio  
  
-   Visualizza il messaggio  
  
-   Ricevi messaggio Journal  
  
-   Ottenere le proprietà della coda  
  
-   Impostare le proprietà della coda  
  
-   Ottenere le autorizzazioni  
  
-   Impostare le autorizzazioni  
  
-   Assumere la proprietà di coda  
  
-   WriteMessage  
  
 Il <xref:System.Messaging.MessageQueueAccessRights> enumerazione rappresenta un set di flag di bit che è possibile combinare l'uso dell'operatore OR bit per bit o per compilare il `rights` parametro.  
  
 Con questo overload, è possibile concedere solo autorizzazioni. non è possibile revocare o negare loro. È necessario usare un overload diverso per concedere in modo esplicito qualsiasi <xref:System.Messaging.AccessControlEntryType> diverso da `Allow`.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'elemento <paramref name="user" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Singolo utente, gruppo o computer che ottiene ulteriori diritti per la coda.</param>
        <param name="rights">Oggetto <see cref="T:System.Messaging.MessageQueueAccessRights" /> che indica una serie di diritti per la coda assegnati da Accodamento messaggi al parametro <paramref name="user" /> passato.</param>
        <param name="entryType">Oggetto <see cref="T:System.Messaging.AccessControlEntryType" /> che specifica se concedere, negare o revocare le autorizzazioni specificate dal parametro <paramref name="rights" />.</param>
        <summary>Concede a un computer, a un utente o a un gruppo di utenti i diritti di accesso specificati con il tipo di controllo di accesso specificato (concessione, rifiuto, revoca o impostazione).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per concedere, negare o revocare i diritti specificati per un singolo utente. L'utente può essere qualsiasi fiduciario valido, che include i singoli utenti, gruppi di utenti o un computer. Se l'utente è una persona, usare il formato `DOMAIN` \\ `user` per il `user` parametro. È possibile specificare "." per il `user` parametro per indicare il computer locale.  
  
 Le autorizzazioni assegnate tramite <xref:System.Messaging.MessageQueue.SetPermissions%2A> aggiungere le autorizzazioni per l'elenco esistente. Per impostazione predefinita, l'autore di una coda pubblica o privata abbia il pieno controllo e il gruppo di dominio Everyone dispone dell'autorizzazione per ottenere le proprietà della coda, ottenere le autorizzazioni e scrivere nella coda. Quando si chiama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, le informazioni utente e le autorizzazioni vengono aggiunte alla fine dell'elenco esistente.  
  
 Il sistema esamina ciascuna <xref:System.Messaging.AccessControlEntry> in sequenza fino a quando non si verifica uno degli eventi seguenti:  
  
-   Un accesso negato <xref:System.Messaging.AccessControlEntry> nega in modo esplicito uno qualsiasi dei diritti di accesso richiesto a una delle fiduciari elencati nel token di accesso del thread.  
  
-   Uno o più Autorizzazione dell'accesso <xref:System.Messaging.AccessControlEntry> elementi per tutti i diritti di accesso richiesto di concessione fiduciari elencati nel token di accesso del thread in modo esplicito.  
  
-   Tutti i <xref:System.Messaging.AccessControlEntry> articoli sono stati verificati e vi è ancora presente almeno un diritto di accesso che non è stato esplicitamente concesso, nel qual caso, l'accesso viene implicitamente negato.  
  
 I diritti a una coda, specificato nella `rights` parametro, può essere qualsiasi combinazione delle opzioni seguenti:  
  
-   Controllo completo  
  
-   Eliminare messaggio  
  
-   Ricezione messaggio  
  
-   Visualizza il messaggio  
  
-   Ricevi messaggio Journal  
  
-   Ottenere le proprietà della coda  
  
-   Impostare le proprietà della coda  
  
-   Ottenere le autorizzazioni  
  
-   Impostare le autorizzazioni  
  
-   Assumere la proprietà di coda  
  
-   WriteMessage  
  
 Il <xref:System.Messaging.MessageQueueAccessRights> enumerazione rappresenta un set di flag di bit che è possibile combinare l'uso dell'operatore OR bit per bit o per compilare il `rights` parametro.  
  
 Nella tabella seguente indica se questo metodo è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto utilizzato per effettuare il marshalling della chiamata al gestore eventi risultante da un evento <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> o <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />.</summary>
        <value>Oggetto <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> che rappresenta l'oggetto utilizzato per effettuare il marshalling della chiamata al gestore eventi risultante da un evento <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> o <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Messaging.MessageQueue.ReceiveCompleted> oppure <xref:System.Messaging.MessageQueue.PeekCompleted> evento risultante da una <xref:System.Messaging.MessageQueue.BeginReceive%2A> o <xref:System.Messaging.MessageQueue.BeginPeek%2A> richiedere, rispettivamente, a un thread specifico. In genere, il <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> viene impostato quando il relativo componente viene posizionato all'interno di un controllo o un form, in quanto tali componenti vengono associati a un thread specifico.  
  
 In genere, l'oggetto di sincronizzazione effettua il marshalling di una chiamata al metodo in un singolo thread.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la coda accetta solo transazioni.</summary>
        <value><see langword="true" /> se la coda accetta solo messaggi inviati come parte di una transazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La messaggistica transazionale si intende l'accoppiamento di diversi messaggi correlati in un'unica transazione. L'invio di messaggi come parte di una transazione garantisce che i messaggi vengano recapitati in ordine, recapitato una sola volta e recuperato correttamente dalla propria coda di destinazione.  
  
 Se la coda è transazionale, accetta solo messaggi che vengono inviati come parte di una transazione. Tuttavia, un messaggio non transazionale può essere inviato o ricevuto da una coda di transazione locale senza in modo esplicito usando transazionali <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, e <xref:System.Messaging.MessageQueueTransaction.Abort%2A> sintassi. Se viene inviato un messaggio non transazionale a una coda transazionale, questo componente crea una transazione di messaggio singolo, tranne nel caso che fanno riferimento a una coda in un computer remoto utilizzando un nome di formato direct. In questo caso, se non si specifica un contesto di transazione quando si invia un messaggio, non ne viene creato automaticamente e verrà inviato il messaggio per la coda di messaggi non recapitabili.  
  
 Se si invia un messaggio non transazionale a una coda transazionale, non sarà in grado di eseguire il rollback il messaggio in caso di un'eccezione.  
  
 <xref:System.Messaging.MessageQueueTransaction> il threading apartment, pertanto se lo stato di apartment è `STA`, è possibile utilizzare la transazione in più thread. Visual Basic imposta lo stato del thread principale per `STA`, pertanto è necessario applicare il <xref:System.MTAThreadAttribute> nel `Main` subroutine. In caso contrario, l'invio di un messaggio transazionale mediante un altro thread genererà un'eccezione <xref:System.Messaging.MessageQueueException>. Si applica il <xref:System.MTAThreadAttribute> usando il frammento seguente.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.Transactional%2A> proprietà.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se i messaggi ricevuti vengono copiati nella coda del giornale di registrazione.</summary>
        <value><see langword="true" /> se i messaggi ricevuti dalla coda vengono copiati nella relativa coda del journal; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando l'applicazione di Accodamento messaggi consente di creare una nuova coda dell'applicazione, viene creato automaticamente una coda del journal associata nello stesso percorso. Consente di rilevare i messaggi rimossi da una coda nella coda journal. Impostando questa proprietà viene modificata la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica.  
  
 La coda del giornale di registrazione non rileva messaggi rimossi dalla coda in quanto i timer all'ora di ricezione è scaduto, né tiene traccia dei messaggi eliminati dalla coda con un servizio di directory, Accodamento messaggi (informazioni Store o Active Directory).  
  
 Le applicazioni non è possibile inviare messaggi alle code journal; sono limitate a accesso in sola lettura di queste code. Inoltre, il servizio Accodamento messaggi mai rimuove i messaggi dalle code di registrazione. L'applicazione che utilizza la coda è necessario deselezionare questi messaggi riceverli oppure eliminando la coda.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> proprietà.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle nativo utilizzato per inviare messaggi alla coda di messaggi.</summary>
        <value>Handle all'oggetto coda nativo utilizzato per inviare messaggi alla coda.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.WriteHandle%2A> fornisce un handle nativo di Windows all'oggetto coda di messaggi che viene usato per l'invio di messaggi alla coda. Se si modifica il percorso della coda, l'handle viene chiusa e riaperta con un nuovo valore.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in varie modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">La coda di messaggi non è disponibile per la scrittura.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>