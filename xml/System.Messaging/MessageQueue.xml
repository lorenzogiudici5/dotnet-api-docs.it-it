<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f362dd97709b65574ff7b9474682818d0cb2c4b1" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32038294" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce l'accesso a una coda su un server di Accodamento messaggi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tecnologia di Accodamento messaggi consente ad applicazioni eseguite in momenti diversi di comunicare su reti eterogenee e sistemi che potrebbero essere temporaneamente offline. Applicazioni di inviare, ricevere o leggere (senza rimuovere) i messaggi dalle code. Il servizio Accodamento messaggi è un componente facoltativo di [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] e Windows NT e deve essere installato separatamente.  
  
 La <xref:System.Messaging.MessageQueue> classe è un wrapper di Accodamento messaggi. Sono disponibili più versioni di accodamento, utilizzando la <xref:System.Messaging.MessageQueue> classe può provocare un comportamento leggermente diverso, a seconda del sistema operativo in uso. Per informazioni sulle caratteristiche specifiche di ogni versione di Accodamento messaggi, vedere l'argomento "Novità di Accodamento messaggi" in Platform SDK in MSDN.  
  
 La <xref:System.Messaging.MessageQueue> classe fornisce un riferimento a una coda di Accodamento messaggi. È possibile specificare un percorso nel <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore per la connessione a una risorsa esistente oppure è possibile creare una nuova coda nel server. Prima di poter chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, o <xref:System.Messaging.MessageQueue.Receive%2A>, è necessario associare la nuova istanza di <xref:System.Messaging.MessageQueue> classe con una coda esistente. A questo punto, è possibile modificare le proprietà della coda, ad esempio <xref:System.Messaging.MessageQueue.Category%2A> e <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> supporta due tipi di recupero dei messaggi: sincrone e asincrone. I metodi sincroni, <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.Receive%2A>, il thread di processo in attesa di un intervallo di tempo specificato per un nuovo messaggio in arrivo nella coda. I metodi asincroni, <xref:System.Messaging.MessageQueue.BeginPeek%2A> e <xref:System.Messaging.MessageQueue.BeginReceive%2A>, consentire l'attività principale dell'applicazione proseguire in un thread separato fino a quando non arriva un messaggio nella coda. Questi metodi funzionano tramite gli oggetti di callback e oggetti di stato per comunicare informazioni tra thread.  
  
 Quando si crea una nuova istanza di <xref:System.Messaging.MessageQueue> (classe), non si sta creando una nuova coda di Accodamento messaggi. In alternativa, è possibile utilizzare il <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, e <xref:System.Messaging.MessageQueue.Purge%2A> metodi per gestire le code sul server.  
  
 A differenza di <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> e <xref:System.Messaging.MessageQueue.Delete%28System.String%29> sono `static` membri, quindi è possibile chiamarli senza creare una nuova istanza di <xref:System.Messaging.MessageQueue> classe.  
  
 È possibile impostare il <xref:System.Messaging.MessageQueue> dell'oggetto <xref:System.Messaging.MessageQueue.Path%2A> proprietà con uno dei tre nomi: il nome descrittivo, il <xref:System.Messaging.MessageQueue.FormatName%2A>, o <xref:System.Messaging.MessageQueue.Label%2A>. Il nome descrittivo, che è definito per la coda <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> proprietà, è <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> per una coda pubblica, e <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> per una coda privata. Il <xref:System.Messaging.MessageQueue.FormatName%2A> proprietà consente l'accesso offline alle code di messaggi. Infine, è possibile utilizzare la coda <xref:System.Messaging.MessageQueue.Label%2A> proprietà per impostare la coda <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Per un elenco di valori di proprietà iniziali per un'istanza di <xref:System.Messaging.MessageQueue>, vedere il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore.  
  
   
  
## Examples  
 Esempio di codice seguente crea nuovi <xref:System.Messaging.MessageQueue> oggetti utilizzando diversi tipi di sintassi di nome di percorso. In ogni caso, viene inviato un messaggio alla coda il cui percorso è definita nel costruttore.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 Esempio di codice seguente invia un messaggio a una coda e riceve un messaggio da una coda, utilizzando una classe specifica dell'applicazione denominata `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Solo il <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> metodo è thread-safe.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" />. Dopo che il costruttore predefinito ha inizializzato la nuova istanza, sarà necessario impostare la proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> dell'istanza prima di poterla utilizzare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare una nuova istanza di <xref:System.Messaging.MessageQueue> classe che non è immediatamente associata a una coda nel server di Accodamento messaggi. Prima di usare questa istanza, è necessario associarla a una coda di Accodamento messaggi esistente impostando il <xref:System.Messaging.MessageQueue.Path%2A> proprietà. In alternativa, è possibile impostare il <xref:System.Messaging.MessageQueue> fanno riferimento al <xref:System.Messaging.MessageQueue.Create%28System.String%29> valore restituito del metodo, in modo da creare una nuova coda di Accodamento messaggi.  
  
 Il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore crea una nuova istanza del <xref:System.Messaging.MessageQueue> classe; non viene creata una nuova coda di Accodamento messaggi.  
  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Messaging.MessageQueue>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.MessagePropertyFilter> classe. Tutti i valori di filtro sono impostati su `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 Esempio di codice seguente crea un nuovo <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" /> che fa riferimento alla coda di Accodamento messaggi nel percorso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload quando si desidera associare il nuovo <xref:System.Messaging.MessageQueue> istanza a una determinata coda Accodamento messaggi, per il quale si conosce il percorso, il nome di formato o etichetta. Se si desidera concedere l'accesso esclusivo per la prima applicazione che fa riferimento alla coda, è necessario impostare il <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> proprietà `true` o utilizzare il costruttore che passa un parametro di restrizione di accesso in lettura.  
  
 Il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore crea una nuova istanza del <xref:System.Messaging.MessageQueue> classe; non viene creata una nuova coda di Accodamento messaggi. Per creare una nuova coda in Accodamento messaggi, utilizzare <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintassi del `path` parametro dipende il tipo di coda a cui fa riferimento, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|Coda pubblica|`MachineName`\\`QueueName`|  
|Coda privata|`MachineName`\\`Private$`\\`QueueName`|  
|Coda journal|`MachineName`\\`QueueName`\\`Journal$`|  
|Coda journal di computer|`MachineName`\\`Journal$`|  
|Coda di messaggi non recapitabili|`MachineName`\\`Deadletter$`|  
|Coda messaggi non recapitabili transazionale|`MachineName`\\`XactDeadletter$`|  
  
 In alternativa, è possibile utilizzare il <xref:System.Messaging.MessageQueue.FormatName%2A> o <xref:System.Messaging.MessageQueue.Label%2A> per descrivere il percorso della coda, come illustrato nella tabella seguente.  
  
|Riferimenti|Sintassi|Esempio|  
|---------------|------------|-------------|  
|Nome del formato|`FormatName:` [ *nome formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [ *etichetta* ]|`Label:` TheLabel|  
  
 Per lavorare offline, è necessario utilizzare la sintassi del nome di formato, non la sintassi del nome del percorso per il costruttore. In caso contrario, viene generata un'eccezione perché il controller di dominio primario non è disponibile per risolvere il percorso per il nome di formato.  
  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Messaging.MessageQueue>. Questi valori in base alle proprietà della coda di Accodamento con il percorso specificato per il `path` parametro.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, se l'impostazione del livello di privacy della coda di Accodamento messaggi è "Body"; in caso contrario, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Il valore della proprietà di nome computer della coda di Accodamento messaggi.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, se non impostato dal costruttore.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, se non impostato dal costruttore.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, se è abilitata l'impostazione giornale di registrazione dell'oggetto di Accodamento messaggi. in caso contrario, `false`.|  
  
   
  
## Examples  
 Esempio di codice seguente crea nuovi <xref:System.Messaging.MessageQueue> oggetti utilizzando diversi tipi di sintassi di nome di percorso. In ogni caso, viene inviato un messaggio alla coda il cui percorso è definita nel costruttore.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è valida, probabilmente perché non è stata impostata.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento, che può essere "." per il computer locale.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> per concedere l'accesso esclusivo in lettura alla prima applicazione con cui viene eseguito l'accesso alla coda; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" /> che fa riferimento alla coda di Accodamento messaggi nel percorso specificato e con la restrizione specificata per l'accesso in lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload quando si desidera associare il nuovo <xref:System.Messaging.MessageQueue> a una determinata coda Accodamento messaggi, per il quale si conosce il percorso, il nome di formato o etichetta. Se si desidera concedere l'accesso esclusivo per la prima applicazione che fa riferimento alla coda, impostare il `sharedModeDenyReceive` parametro `true`. In caso contrario, impostare `sharedModeDenyReceive` a `false` o utilizzare il costruttore che ha solo un `path` parametro.  
  
 Impostazione `sharedModeDenyReceive` a `true` influisce su tutti gli oggetti che accedono alla coda di Accodamento messaggi, comprese le altre applicazioni. Gli effetti del parametro non sono limitati a questa applicazione.  
  
 Il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore crea una nuova istanza di <xref:System.Messaging.MessageQueue> classe; non viene creata una nuova coda di Accodamento messaggi. Per creare una nuova coda in Accodamento messaggi, utilizzare <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintassi del `path` parametro dipende dal tipo di coda.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|Coda pubblica|`MachineName`\\`QueueName`|  
|Coda privata|`MachineName`\\`Private$`\\`QueueName`|  
|Coda journal|`MachineName`\\`QueueName`\\`Journal$`|  
|Coda journal di computer|`MachineName`\\`Journal$`|  
|Coda di messaggi non recapitabili|`MachineName`\\`Deadletter$`|  
|Coda messaggi non recapitabili transazionale|`MachineName`\\`XactDeadletter$`|  
  
 In alternativa, è possibile utilizzare il nome di formato o l'etichetta di una coda di Accodamento messaggi per descrivere il percorso della coda.  
  
|Riferimenti|Sintassi|Esempio|  
|---------------|------------|-------------|  
|Nome del formato|`FormatName:` [ *nome formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Label|`Label:` [ *etichetta* ]|`Label:` TheLabel|  
  
 Per lavorare offline, è necessario utilizzare la sintassi del nome di formato, anziché la sintassi del nome descrittivo. In caso contrario, viene generata un'eccezione perché il controller di dominio primario (in cui risiede Active Directory) non è disponibile per risolvere il percorso per il nome di formato.  
  
 Se un <xref:System.Messaging.MessageQueue> apre una coda con il `sharedModeDenyReceive` parametro impostato su `true`, qualsiasi <xref:System.Messaging.MessageQueue> che tenteranno successivamente di leggere tale coda genereranno un <xref:System.Messaging.MessageQueueException> a causa di una violazione di condivisione. Oggetto <xref:System.Messaging.MessageQueueException> viene inoltre generata se un <xref:System.Messaging.MessageQueue> tenta di accedere alla coda in modalità esclusiva mentre un altro <xref:System.Messaging.MessageQueue> dispone già dell'accesso non esclusivo alla coda.  
  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Messaging.MessageQueue>. Questi valori in base alle proprietà della coda di accodamento, con il percorso specificato per il `path` parametro.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, se l'impostazione del livello di privacy della coda di Accodamento messaggi è "Body"; in caso contrario, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Il valore della proprietà di nome computer della coda di Accodamento messaggi.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|I valori impostati dal costruttore predefinito del <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, se non impostato dal costruttore.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, se non impostato dal costruttore.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Valore del parametro `sharedModeDenyReceive`.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, se è abilitata l'impostazione giornale di registrazione dell'oggetto di Accodamento messaggi. in caso contrario, `false`.|  
  
   
  
## Examples  
 Esempio di codice seguente crea un nuovo <xref:System.Messaging.MessageQueue> con accesso esclusivo, viene impostato il percorso e invia un messaggio alla coda.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è valida, probabilmente perché non è stata impostata.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento, che può essere "." per il computer locale.</param>
        <param name="accessMode">Uno dei valori di <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento, che può essere "." per il computer locale.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> per concedere l'accesso esclusivo in lettura alla prima applicazione con cui viene eseguito l'accesso alla coda; in caso contrario, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> per creare e utilizzare una cache di connessioni; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente crea un nuovo <xref:System.Messaging.MessageQueue> con accesso in lettura esclusivo e con connessione abilitata la cache.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento, che può essere "." per il computer locale.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> per concedere l'accesso esclusivo in lettura alla prima applicazione con cui viene eseguito l'accesso alla coda; in caso contrario, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> per creare e utilizzare una cache di connessioni; in caso contrario, <see langword="false" />.</param>
        <param name="accessMode">Uno dei valori di <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica la modalità di accesso per la coda.</summary>
        <value>Uno dei valori di <see cref="T:System.Messaging.QueueAccessMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità di accesso predefinito per una coda è `QueueAccessMode.SendAndReceive`, se non diversamente specificato quando si chiama il costruttore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la coda accetta solo messaggi autenticati.</summary>
        <value>
          <see langword="true" /> se la coda accetta solo messaggi autenticati; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'autenticazione dei messaggi fornisce un modo per garantire l'integrità del messaggio e per verificare chi ha inviato il messaggio. Per richiedere l'autenticazione, l'applicazione di invio imposta il livello di autenticazione del messaggio.  
  
 Quando si imposta <xref:System.Messaging.MessageQueue.Authenticate%2A> a `true`, si è la limitazione dell'accesso alla coda nel server, non solo a questa <xref:System.Messaging.MessageQueue> istanza. Tutti i client che utilizzano la stessa coda di Accodamento messaggi saranno interessati.  
  
 Una coda che accetta solo messaggi autenticati verrà rifiutato un messaggio non autenticato. Per richiedere la notifica di rifiuto di messaggio, è possibile impostare un'applicazione di invio di <xref:System.Messaging.Message.AcknowledgeType%2A> proprietà del messaggio. Poiché non esiste alcun'altra indicazione di rifiuto di messaggio, l'applicazione mittente può perdere il messaggio a meno che non si richiede di essere inviato alla coda di messaggi non recapitabili.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.Authenticate%2A> proprietà.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la priorità di base utilizzata da Accodamento messaggi per effettuare il routing dei messaggi di una coda pubblica sulla rete.</summary>
        <value>La singola priorità di base relativa a tutti i messaggi inviati alla coda (pubblica). Il valore predefinito è zero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Priorità di base di una coda di messaggi specifica il modo in cui un messaggio alla coda viene considerata come viaggia attraverso la rete. È possibile impostare il <xref:System.Messaging.MessageQueue.BasePriority%2A> proprietà per assegnare una priorità superiore o inferiore a tutti i messaggi inviati alla coda specificata rispetto a quelle inviate ad altre code. Impostazione di questa proprietà consente di modificare la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica.  
  
 Una coda di messaggi <xref:System.Messaging.MessageQueue.BasePriority%2A> non è correlato il <xref:System.Messaging.Message.Priority%2A> proprietà di un messaggio, che specifica l'ordine in cui un messaggio in arrivo viene inserito nella coda.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> si applica solo alle code pubbliche i cui percorsi sono specificati utilizzando il nome di formato. La priorità di base di una coda privata è sempre zero (0).  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.BasePriority%2A> proprietà.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La priorità di base è stata impostata su un valore non valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <summary>Avvia un'operazione di lettura asincrona, indicando ad Accodamento messaggi di avviare la lettura di un messaggio e inviare una notifica al gestore eventi al termine dell'operazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia un'operazione di lettura asincrona per la quale non è stato specificato un intervallo di timeout. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, utilizzare <xref:System.Messaging.MessageQueue.BeginPeek%2A> per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando un messaggio diventa disponibile nella coda.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato anche se è già presente un messaggio nella coda.  
  
 Per utilizzare <xref:System.Messaging.MessageQueue.BeginPeek%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarlo al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Avvia un'operazione di lettura asincrona. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.PeekCompleted> evento, se un messaggio arriva nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> o recuperando il risultato mediante la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginPeek%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata finché non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginPeek%2A> è asincrona, è possibile chiamare questo metodo per leggere la coda senza bloccare il thread di esecuzione corrente. Per leggere in modo sincrono la coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo.  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore eventi per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginPeek%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile utilizzare questo <xref:System.IAsyncResult> per tutta la durata dell'operazione, anche se in genere non viene utilizzato fino a quando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> valori in una matrice e specificare se si desidera attendere che tutte le operazioni o di qualsiasi operazione di completamento. In questo caso, utilizzare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> è `false`, viene generato l'evento di completamento, ma verrà generata un'eccezione quando si chiama <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea un gestore eventi denominato `MyPeekCompleted`, lo collega al <xref:System.Messaging.MessageQueue.PeekCompleted> delegato del gestore eventi e chiamate <xref:System.Messaging.MessageQueue.BeginPeek%2A> per avviare un'operazione di lettura asincrona in coda che si trova nel percorso ". \myQueue". Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> evento viene generato, l'esempio legge il messaggio e scrive il corpo sullo schermo. Nell'esempio viene quindi chiamato <xref:System.Messaging.MessageQueue.BeginPeek%2A> per avviare una nuova operazione di lettura asincrona.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <summary>Avvia un'operazione di lettura asincrona per la quale è stato specificato un periodo di timeout. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, utilizzare <xref:System.Messaging.MessageQueue.BeginPeek%2A> per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato anche se è già presente un messaggio nella coda.  
  
 Per utilizzare <xref:System.Messaging.MessageQueue.BeginPeek%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarlo al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Avvia un'operazione di lettura asincrona. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.PeekCompleted> evento, se un messaggio arriva nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> o recuperando il risultato mediante la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginPeek%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata finché non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginPeek%2A> è asincrona, è possibile chiamare questo metodo per leggere la coda senza bloccare il thread di esecuzione corrente. Per leggere in modo sincrono la coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo.  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore eventi per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginPeek%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile utilizzare questo <xref:System.IAsyncResult> per tutta la durata dell'operazione, anche se in genere non viene utilizzato fino a quando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> valori in una matrice e specificare se si desidera attendere che tutte le operazioni o di qualsiasi operazione di completamento. In questo caso, utilizzare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Questo overload specifica un timeout. Se l'intervallo specificato per il `timeout` parametro scade, il componente genera il <xref:System.Messaging.MessageQueue.PeekCompleted> evento. Poiché è disponibile alcun messaggio, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> genererà un'eccezione.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> è `false`, viene generato l'evento di completamento, ma verrà generata un'eccezione quando si chiama <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea un'operazione di lettura asincrona, utilizzando il percorso della coda ". \myQueue". Crea un gestore eventi, `MyPeekCompleted`e lo collega al <xref:System.Messaging.MessageQueue.PeekCompleted> delegato del gestore eventi. <xref:System.Messaging.MessageQueue.BeginPeek%2A> viene chiamato con un timeout di un minuto, per avviare l'operazione di lettura asincrona. Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato l'evento o il timeout scade, viene recuperato il messaggio, se presente, e il relativo corpo è scritto alla schermata. Quindi <xref:System.Messaging.MessageQueue.BeginPeek%2A> viene nuovamente chiamata per avviare una nuova operazione di lettura asincrona con lo stesso timeout.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="stateObject">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <summary>Avvia un'operazione di lettura asincrona per la quale sono stati specificati un timeout e un oggetto di stato, che fornisce le informazioni associate per tutta la durata dell'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, utilizzare <xref:System.Messaging.MessageQueue.BeginPeek%2A> per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato anche se è già presente un messaggio nella coda.  
  
 Utilizzare questo overload per associare le informazioni con l'operazione che verrà mantenuto per tutta la durata dell'operazione. Il gestore dell'evento può accedere a queste informazioni esaminando il <xref:System.IAsyncResult.AsyncState%2A> proprietà del <xref:System.IAsyncResult> che viene associato all'operazione.  
  
 Per utilizzare <xref:System.Messaging.MessageQueue.BeginPeek%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarlo al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Avvia un'operazione di lettura asincrona. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.PeekCompleted> evento, se un messaggio arriva nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> o recuperando il risultato mediante la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginPeek%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata finché non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginPeek%2A> è asincrona, è possibile chiamare questo metodo per leggere la coda senza bloccare il thread di esecuzione corrente. Per leggere in modo sincrono la coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo.  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore eventi per continuare a ricevere le notifiche.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Restituisce un <xref:System.IAsyncResult> che identifica l'operazione asincrona avviata dal metodo. È possibile utilizzare questo <xref:System.IAsyncResult> per tutta la durata dell'operazione, anche se in genere non viene utilizzato fino a quando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> valori in una matrice e specificare se si desidera attendere che tutte le operazioni o di qualsiasi operazione di completamento. In questo caso, utilizzare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Questo overload specifica un timeout e un oggetto di stato. Se l'intervallo specificato per il `timeout` parametro scade, il componente genera il <xref:System.Messaging.MessageQueue.PeekCompleted> evento. Poiché è disponibile alcun messaggio, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> genererà un'eccezione.  
  
 L'oggetto stato associa informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginPeek%2A> più volte per avviare più operazioni, è possibile identificare ciascuna operazione mediante un oggetto di stato separato definiti. Per un'illustrazione di questo scenario, vedere la sezione esempio.  
  
 È inoltre possibile utilizzare l'oggetto di stato per passare informazioni tra i thread di processo. Se un thread viene avviato il callback è in un thread diverso in uno scenario asincrono, l'oggetto stato è il marshalling e passato nuovamente insieme alle informazioni dall'evento.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> è `false`, viene generato l'evento di completamento, ma verrà generata un'eccezione quando si chiama <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea un'operazione di lettura asincrona, utilizzando il percorso della coda ". \myQueue". Crea un gestore eventi, `MyPeekCompleted`e lo collega al <xref:System.Messaging.MessageQueue.PeekCompleted> delegato del gestore eventi. <xref:System.Messaging.MessageQueue.BeginPeek%2A> viene chiamato con un timeout di un minuto. Ogni chiamata a <xref:System.Messaging.MessageQueue.BeginPeek%2A> è associato un intero univoco che identifica la specifica operazione. Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato l'evento o della scadenza del timeout, il messaggio, se presente, viene recuperato e il relativo corpo e l'identificatore di tipo integer specifici dell'operazione vengono scritti nella schermata. Quindi <xref:System.Messaging.MessageQueue.BeginPeek%2A> viene nuovamente chiamata per avviare una nuova operazione di lettura asincrona con lo stesso timeout e l'intero associato dell'operazione appena completata.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="stateObject">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> che riceverà la notifica del completamento dell'operazione asincrona.</param>
        <summary>Avvia un'operazione di lettura asincrona per la quale sono stati specificati un timeout e un oggetto di stato, che fornisce le informazioni associate per tutta la durata dell'operazione. Questo overload riceve mediante un callback la notifica dell'identità del gestore eventi per l'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo overload, il callback specificato nel parametro di callback viene richiamato direttamente quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto. il <xref:System.Messaging.MessageQueue.PeekCompleted> non viene generato l'evento. Gli altri overload di <xref:System.Messaging.MessageQueue.BeginPeek%2A> si basano su questo componente per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato anche se è già presente un messaggio nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.BeginPeek%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata finché non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginPeek%2A> è asincrona, è possibile chiamare questo metodo per leggere la coda senza bloccare il thread di esecuzione corrente. Per leggere in modo sincrono la coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo.  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore eventi per continuare a ricevere le notifiche.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Restituisce un <xref:System.IAsyncResult> che identifica l'operazione asincrona avviata dal metodo. È possibile utilizzare questo <xref:System.IAsyncResult> per tutta la durata dell'operazione, anche se in genere non viene utilizzato fino a quando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> valori in una matrice e specificare se si desidera attendere che tutte le operazioni o di qualsiasi operazione di completamento. In questo caso, utilizzare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 L'oggetto stato associa informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginPeek%2A> più volte per avviare più operazioni, è possibile identificare ciascuna operazione mediante un oggetto di stato separato definiti.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea un'operazione di lettura asincrona. Il codice viene inviato un messaggio a una coda di messaggi locale, quindi chiama <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passando: un valore di timeout di dieci secondi, un tipo integer univoco che identifica il messaggio in questione; e una nuova istanza della <xref:System.AsyncCallback> che identifica il gestore dell'evento, `MyPeekCompleted`. Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> evento viene generato, il gestore dell'evento legge il messaggio e scrive il corpo del messaggio e l'identificatore del messaggio sullo schermo.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <param name="action">Uno dei valori di <see cref="T:System.Messaging.PeekAction" />. Indica se leggere il messaggio corrente nella coda oppure il messaggio successivo.</param>
        <param name="state">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> che riceve la notifica del completamento dell'operazione asincrona.</param>
        <summary>Avvia un'operazione di lettura asincrona che presenta il timeout specificato e che utilizza il cursore specificato, l'azione di lettura specificata e l'oggetto di stato specificato. L'oggetto di stato fornisce informazioni associate per l'intera durata dell'operazione. Questo overload riceve mediante un callback la notifica dell'identità del gestore eventi per l'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo overload, il callback specificato nel parametro di callback viene richiamato direttamente quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto. Il <xref:System.Messaging.MessageQueue.PeekCompleted> non viene generato l'evento. Gli altri overload di <xref:System.Messaging.MessageQueue.BeginPeek%2A> si basano su questo componente per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato anche se è già presente un messaggio nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.BeginPeek%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata finché non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginPeek%2A> è asincrona, è possibile chiamare questo metodo per leggere la coda senza bloccare il thread di esecuzione corrente. Per leggere in modo sincrono la coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo.  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore eventi per continuare a ricevere le notifiche.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Restituisce un <xref:System.IAsyncResult> che identifica l'operazione asincrona avviata dal metodo. È possibile utilizzare questo <xref:System.IAsyncResult> per tutta la durata dell'operazione, anche se in genere non viene utilizzato fino a quando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> valori in una matrice e specificare se si desidera attendere che tutte le operazioni o di qualsiasi operazione di completamento. In questo caso, utilizzare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 L'oggetto stato associa informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginPeek%2A> più volte per avviare più operazioni, è possibile identificare ciascuna operazione mediante un oggetto di stato separato definiti.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">È stato specificato un valore diverso da <see langword="PeekAction.Current" /> o <see langword="PeekAction.Next" /> per il parametro <paramref name="action" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="cursor" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <summary>Avvia un'operazione di ricezione asincrona, indicando ad Accodamento messaggi di avviare la ricezione di un messaggio e inviare una notifica al gestore eventi al termine dell'operazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia un'operazione di ricezione asincrona per la quale non è stato specificato alcun timeout. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, utilizzare <xref:System.Messaging.MessageQueue.BeginReceive%2A> per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando un messaggio è stato rimosso dalla coda.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato anche se è già presente un messaggio nella coda.  
  
 Per utilizzare <xref:System.Messaging.MessageQueue.BeginReceive%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarlo al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Avvia un'asincrona operazione di ricezione. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, se un messaggio arriva nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata finché non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginReceive%2A> è asincrona, è possibile chiamare in modo da ricevere un messaggio dalla coda senza bloccare il thread di esecuzione corrente. Per ricevere in modo sincrono un messaggio, utilizzare il <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore eventi per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginReceive%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile utilizzare questo <xref:System.IAsyncResult> per tutta la durata dell'operazione, anche se in genere non viene utilizzato fino a quando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> valori in una matrice e specificare se si desidera attendere che tutte le operazioni o di qualsiasi operazione di completamento. In questo caso, utilizzare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> è `false`, viene generato l'evento di completamento, ma verrà generata un'eccezione quando si chiama <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Non utilizzare la chiamata asincrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transazioni. Se si desidera eseguire un'operazione transazionale asincrona, chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A>e inserire la transazione e (sincrona) <xref:System.Messaging.MessageQueue.Receive%2A> metodo nel gestore eventi creati per l'operazione di lettura. Il gestore eventi potrebbe contenere funzionalità, come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente vengono concatenate richieste asincrone. Si presuppone che nel computer locale, denominato "myQueue" è una coda. Il `Main` funzione inizia l'operazione asincrona viene gestita dal `MyReceiveCompleted` routine. `MyReceiveCompleted` Elabora il messaggio corrente e avvia una nuova asincrono l'operazione di ricezione.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 Esempio di codice seguente in coda le richieste asincrone. La chiamata a <xref:System.Messaging.MessageQueue.BeginReceive%2A> utilizza il <xref:System.IAsyncResult.AsyncWaitHandle%2A> nel valore restituito. Il `Main` routine attende il completamento prima di uscire da tutte le operazioni asincrone.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <summary>Avvia un'operazione di ricezione asincrona per la quale è stato specificato un periodo di timeout. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, utilizzare <xref:System.Messaging.MessageQueue.BeginReceive%2A> per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato anche se è già presente un messaggio nella coda.  
  
 Per utilizzare <xref:System.Messaging.MessageQueue.BeginReceive%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarlo al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Avvia un'asincrona operazione di ricezione. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, se un messaggio arriva nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o recuperando il risultato mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata finché non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginReceive%2A> è asincrona, è possibile chiamare in modo da ricevere un messaggio dalla coda senza bloccare il thread di esecuzione corrente. Per ricevere in modo sincrono un messaggio, utilizzare il <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore eventi per continuare a ricevere le notifiche.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> è `false`, viene generato l'evento di completamento, ma verrà generata un'eccezione quando si chiama <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginReceive%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile utilizzare questo <xref:System.IAsyncResult> per tutta la durata dell'operazione, anche se in genere non viene utilizzato fino a quando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> valori in una matrice e specificare se si desidera attendere che tutte le operazioni o di qualsiasi operazione di completamento. In questo caso, utilizzare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Questo overload specifica un timeout. Se l'intervallo specificato per il `timeout` parametro scade, il componente genera il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento. Poiché è disponibile alcun messaggio, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> genererà un'eccezione.  
  
 Non utilizzare la chiamata asincrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transazioni. Se si desidera eseguire un'operazione transazionale asincrona, chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A>e inserire la transazione e (sincrona) <xref:System.Messaging.MessageQueue.Receive%2A> metodo nel gestore eventi creati per l'operazione di lettura. Il gestore eventi potrebbe contenere funzionalità, come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea asincrono l'operazione di ricezione. L'esempio di codice crea un gestore eventi, `MyReceiveCompleted`e lo collega al <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegato del gestore eventi. Il codice viene inviato un messaggio a una coda di messaggi locale, quindi chiama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, passando un valore di timeout di dieci secondi. Quando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento viene generato, il gestore eventi riceve il messaggio e scrive il corpo del messaggio sullo schermo.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché rappresenta un numero negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="stateObject">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <summary>Avvia un'operazione di ricezione asincrona per la quale sono stati specificati un timeout e un oggetto di stato, che fornisce le informazioni associate per tutta la durata dell'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'elaborazione asincrona, utilizzare <xref:System.Messaging.MessageQueue.BeginReceive%2A> per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato anche se è già presente un messaggio nella coda.  
  
 Utilizzare questo overload per associare le informazioni con l'operazione che verrà mantenuto per tutta la durata dell'operazione. Il gestore dell'evento può rilevare queste informazioni esaminando il <xref:System.IAsyncResult.AsyncState%2A> proprietà del <xref:System.IAsyncResult> che viene associato all'operazione.  
  
 Per utilizzare <xref:System.Messaging.MessageQueue.BeginReceive%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarlo al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Avvia un'asincrona operazione di ricezione. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, se un messaggio arriva nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o recuperando il risultato mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata finché non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginReceive%2A> è asincrona, è possibile chiamare in modo da ricevere un messaggio dalla coda senza bloccare il thread di esecuzione corrente. Per ricevere in modo sincrono un messaggio, utilizzare il <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore eventi per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginReceive%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile utilizzare questo <xref:System.IAsyncResult> per tutta la durata dell'operazione, anche se in genere non viene utilizzato fino a quando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> valori in una matrice e specificare se si desidera attendere che tutte le operazioni o di qualsiasi operazione di completamento. In questo caso, utilizzare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 Questo overload specifica un timeout e un oggetto di stato. Se l'intervallo specificato per il `timeout` parametro scade, il componente genera il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento. Poiché è disponibile alcun messaggio, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> genererà un'eccezione.  
  
 L'oggetto stato associa informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginReceive%2A> più volte per avviare più operazioni, è possibile identificare ciascuna operazione mediante un oggetto di stato separato definiti.  
  
 È inoltre possibile utilizzare l'oggetto di stato per passare informazioni tra i thread di processo. Se un thread viene avviato il callback è in un thread diverso in uno scenario asincrono, l'oggetto stato è il marshalling e passato nuovamente insieme alle informazioni dall'evento.  
  
 Non utilizzare la chiamata asincrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transazioni. Se si desidera eseguire un'operazione transazionale asincrona, chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A>e inserire la transazione e (sincrona) <xref:System.Messaging.MessageQueue.Receive%2A> metodo nel gestore eventi creati per l'operazione di lettura. Il gestore eventi potrebbe contenere funzionalità, come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea asincrono l'operazione di ricezione. L'esempio di codice crea un gestore eventi, `MyReceiveCompleted`e lo collega al <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegato del gestore eventi. Il codice viene inviato un messaggio a una coda di messaggi locale, quindi chiama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, passando un valore di timeout di dieci secondi e un valore integer univoco che identifica il messaggio in questione. Quando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento viene generato, il gestore eventi riceve il messaggio e scrive il corpo del messaggio e l'identificatore del messaggio sullo schermo.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="stateObject">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> che riceverà la notifica del completamento dell'operazione asincrona.</param>
        <summary>Avvia un'operazione di ricezione asincrona per la quale sono stati specificati un timeout e un oggetto di stato, che fornisce le informazioni associate per tutta la durata dell'operazione. Questo overload riceve mediante un callback la notifica dell'identità del gestore eventi per l'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo overload, il callback specificato nel parametro di callback viene richiamato direttamente quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto. il <xref:System.Messaging.MessageQueue.ReceiveCompleted> non viene generato l'evento. Gli altri overload di <xref:System.Messaging.MessageQueue.BeginReceive%2A> si basano su questo componente per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato anche se è già presente un messaggio nella coda.  
  
 Per utilizzare <xref:System.Messaging.MessageQueue.BeginReceive%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarlo al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Avvia un'asincrona operazione di ricezione. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, se un messaggio arriva nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o recuperando il risultato mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata finché non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginReceive%2A> è asincrona, è possibile chiamare in modo da ricevere un messaggio dalla coda senza bloccare il thread di esecuzione corrente. Per ricevere in modo sincrono un messaggio, utilizzare il <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore eventi per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginReceive%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile utilizzare questo <xref:System.IAsyncResult> per tutta la durata dell'operazione, anche se in genere non viene utilizzato fino a quando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> valori in una matrice e specificare se si desidera attendere che tutte le operazioni o di qualsiasi operazione di completamento. In questo caso, utilizzare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 L'oggetto stato associa informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginReceive%2A> più volte per avviare più operazioni, è possibile identificare ciascuna operazione mediante un oggetto di stato separato definiti.  
  
 È inoltre possibile utilizzare l'oggetto di stato per passare informazioni tra i thread di processo. Se un thread viene avviato il callback è in un thread diverso in uno scenario asincrono, l'oggetto stato è il marshalling e passato nuovamente insieme alle informazioni dall'evento.  
  
 Non utilizzare la chiamata asincrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transazioni. Se si desidera eseguire un'operazione transazionale asincrona, chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A>e inserire la transazione e (sincrona) <xref:System.Messaging.MessageQueue.Receive%2A> metodo nel gestore eventi creati per l'operazione di lettura. Il gestore eventi potrebbe contenere funzionalità, come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea asincrono l'operazione di ricezione. Il codice viene inviato un messaggio a una coda di messaggi locale, quindi chiama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passando: un valore di timeout di dieci secondi, un tipo integer univoco che identifica il messaggio in questione; e una nuova istanza della <xref:System.AsyncCallback> che identifica il gestore dell'evento, `MyReceiveCompleted`. Quando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento viene generato, il gestore eventi riceve il messaggio e scrive il corpo del messaggio e l'identificatore del messaggio sullo schermo.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo di attesa necessario affinché un messaggio diventi disponibile.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <param name="state">Oggetto di stato, specificato dall'applicazione, che contiene le informazioni associate all'operazione asincrona.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> che riceve la notifica del completamento dell'operazione asincrona.</param>
        <summary>Avvia un'operazione di ricezione asincrona che presenta il timeout specificato e che utilizza il cursore specificato, l'azione di lettura specificata e l'oggetto di stato specificato. L'oggetto di stato fornisce informazioni associate per l'intera durata dell'operazione. Questo overload riceve mediante un callback la notifica dell'identità del gestore eventi per l'operazione. L'operazione non è completa fino a quando un messaggio non viene reso disponibile nella coda o non si verifica il timeout.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che identifica la richiesta asincrona inviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo overload, il callback specificato nel parametro di callback viene richiamato direttamente quando un messaggio diventa disponibile nella coda o quando l'intervallo di tempo specificato è scaduto. il <xref:System.Messaging.MessageQueue.ReceiveCompleted> non viene generato l'evento. Gli altri overload di <xref:System.Messaging.MessageQueue.BeginReceive%2A> si basano su questo componente per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato anche se è già presente un messaggio nella coda.  
  
 Per utilizzare <xref:System.Messaging.MessageQueue.BeginReceive%2A>, creare un gestore eventi che elabora i risultati dell'operazione asincrona e associarlo al delegato dell'evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Avvia un'asincrona operazione di ricezione. il <xref:System.Messaging.MessageQueue> viene informato, tramite la generazione del <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, se un messaggio arriva nella coda. Il <xref:System.Messaging.MessageQueue> può quindi accedere al messaggio chiamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> o recuperando il risultato mediante la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Il <xref:System.Messaging.MessageQueue.BeginReceive%2A> metodo viene restituito immediatamente, ma l'operazione asincrona non viene completata finché non viene chiamato il gestore dell'evento.  
  
 Poiché <xref:System.Messaging.MessageQueue.BeginReceive%2A> è asincrona, è possibile chiamare in modo da ricevere un messaggio dalla coda senza bloccare il thread di esecuzione corrente. Per ricevere in modo sincrono un messaggio, utilizzare il <xref:System.Messaging.MessageQueue.Receive%2A> metodo.  
  
 Al termine dell'operazione asincrona, è possibile chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A> o <xref:System.Messaging.MessageQueue.BeginReceive%2A> nuovamente nel gestore eventi per continuare a ricevere le notifiche.  
  
 Il <xref:System.IAsyncResult> che <xref:System.Messaging.MessageQueue.BeginReceive%2A> restituisce identifica l'operazione asincrona avviata dal metodo. È possibile utilizzare questo <xref:System.IAsyncResult> per tutta la durata dell'operazione, anche se in genere non viene utilizzato fino a quando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene chiamato. Tuttavia, se si avviano più operazioni asincrone, è possibile inserire i <xref:System.IAsyncResult> valori in una matrice e specificare se si desidera attendere che tutte le operazioni o di qualsiasi operazione di completamento. In questo caso, utilizzare il <xref:System.IAsyncResult.AsyncWaitHandle%2A> proprietà del <xref:System.IAsyncResult> per identificare l'operazione completata.  
  
 L'oggetto stato associa informazioni sullo stato dell'operazione. Ad esempio, se si chiama <xref:System.Messaging.MessageQueue.BeginReceive%2A> più volte per avviare più operazioni, è possibile identificare ciascuna operazione mediante un oggetto di stato separato definiti.  
  
 È inoltre possibile utilizzare l'oggetto di stato per passare informazioni tra i thread di processo. Se un thread viene avviato il callback è in un thread diverso in uno scenario asincrono, l'oggetto stato è il marshalling e passato nuovamente insieme alle informazioni dall'evento.  
  
 Non utilizzare la chiamata asincrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> con transazioni. Se si desidera eseguire un'operazione transazionale asincrona, chiamare <xref:System.Messaging.MessageQueue.BeginPeek%2A>e inserire la transazione e (sincrona) <xref:System.Messaging.MessageQueue.Receive%2A> metodo nel gestore eventi creati per l'operazione di lettura. Il gestore eventi potrebbe contenere funzionalità, come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="cursor" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è possibile leggere l'oggetto <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Messaging.MessageQueue" /> esiste e l'applicazione è in grado di eseguirne la lettura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> indica se l'applicazione è in grado di leggere o ricevere messaggi dalla coda. Se <xref:System.Messaging.MessageQueue.CanRead%2A> è `true`, <xref:System.Messaging.MessageQueue> può ricevere o leggere i messaggi dalla coda. In caso contrario, questo non è possibile.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> è `false` se una coda è già aperta con accesso in lettura esclusivo (o se è aperto con accesso non esclusivo e questo <xref:System.Messaging.MessageQueue> richiede l'accesso esclusivo), o se l'applicazione non dispone di diritti sufficienti per accedervi. Se l'applicazione tenta di leggere da una coda quando <xref:System.Messaging.MessageQueue.CanRead%2A> è `false`, viene negato l'accesso.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.CanRead%2A> proprietà.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è possibile scrivere nell'oggetto <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Messaging.MessageQueue" /> esiste e l'applicazione è in grado di eseguirne la scrittura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> indica se l'applicazione è in grado di inviare messaggi alla coda. Se <xref:System.Messaging.MessageQueue.CanWrite%2A> è `true`, <xref:System.Messaging.MessageQueue> può inviare messaggi alla coda. In caso contrario, questo non è possibile.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> è `false` se una coda è già aperta con accesso in scrittura esclusivo (o se è aperto con accesso non esclusivo e questo <xref:System.Messaging.MessageQueue> richiede l'accesso esclusivo), o se l'applicazione non dispone di diritti sufficienti per accedervi. Se l'applicazione tenta di scrivere in una coda quando <xref:System.Messaging.MessageQueue.CanWrite%2A> è `false`, viene negato l'accesso.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.CanWrite%2A> proprietà.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la categoria della coda.</summary>
        <value>Oggetto <see cref="T:System.Guid" /> che rappresenta la categoria della coda (identificatore del tipo di Accodamento messaggi), che consente a un'applicazione di suddividere per categoria le relative code. Il valore predefinito è <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La categoria di coda consente alle applicazioni di suddividere in categorie proprie code. Ad esempio, è possibile inserire tutte le code di fatturazione in una categoria e tutte le code di ordini in un altro.  
  
 Il <xref:System.Messaging.MessageQueue.Category%2A> proprietà fornisce l'accesso alla proprietà ID tipo di Accodamento messaggi (che è in lettura/scrittura), accessibile tramite il **le proprietà della coda** la finestra di dialogo nella Console di gestione Computer. È possibile definire una nuova categoria. Sebbene sia possibile utilizzare <xref:System.Guid.NewGuid%2A> per creare un valore di categoria che è univoco tra tutti <xref:System.Guid> valori, tale operazione è necessaria. Il valore della categoria deve essere diverso da quello solo di altre categorie, non da tutti gli altri <xref:System.Guid> valori. Ad esempio, è possibile assegnare {00000000-0000-0000-0000-000000000001} come il <xref:System.Messaging.MessageQueue.Category%2A> da un insieme di code e {00000000-0000-0000-0000-000000000002} come la <xref:System.Messaging.MessageQueue.Category%2A> per un altro set.  
  
 Non è necessario impostare il <xref:System.Messaging.MessageQueue.Category%2A>. Il valore può essere `null`.  
  
 Impostazione di questa proprietà consente di modificare la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.Category%2A> proprietà.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La categoria della coda è stata impostata su un valore non valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Svuota la cache delle connessioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, i nomi di formato memorizzati nella cache vengono rimossi e gli handle aperti e memorizzati nella cache vengono chiusi.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene chiamato il metodo <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera tutte le risorse allocate da <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> libera tutte le risorse associate un <xref:System.Messaging.MessageQueue>, tra cui le risorse condivise, se appropriato. Il sistema acquisisce di nuovo queste risorse automaticamente se sono ancora disponibili, ad esempio quando si chiama il <xref:System.Messaging.MessageQueue.Send%28System.Object%29> (metodo), come illustrato nel codice c# seguente.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Quando si chiama <xref:System.Messaging.MessageQueue.Close%2A>tutti <xref:System.Messaging.MessageQueue> le proprietà che accedono direttamente alla coda di Accodamento messaggi vengono eliminate. Il <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, e <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> tutti rimangono invariati.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> non è sempre liberare la lettura e scrittura handle per una coda, perché potrebbero essere condivisi. È possibile eseguire i passaggi seguenti per garantire che <xref:System.Messaging.MessageQueue.Close%2A> libera l'handle di lettura e scrittura a una coda:  
  
-   Creare il <xref:System.Messaging.MessageQueue> con accesso esclusivo. A tale scopo, chiamare il <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> o <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e set di `sharedModeDenyReceive` parametro `true`.  
  
-   Creare il <xref:System.Messaging.MessageQueue> con connessione la memorizzazione nella cache disabilitata. A tale scopo, chiamare il <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> costruttore e impostare il `enableConnectionCache` parametro `false`.  
  
-   Disabilitare la memorizzazione nella cache di connessione. A tale scopo, impostare il <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> proprietà `false`.  
  
 È necessario chiamare <xref:System.Messaging.MessageQueue.Close%2A> per una coda prima di eliminare la coda nel server di Accodamento messaggi. In caso contrario, i messaggi inviati alla coda potrebbero generare eccezioni o visualizzati nella coda di messaggi non recapitabili.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Nell'esempio seguente chiude una coda di Accodamento messaggi.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova coda nel percorso specificato su un server di Accodamento messaggi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso della coda da creare.</param>
        <summary>Crea una coda non transazionale di Accodamento messaggi nel percorso specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.MessageQueue" /> che rappresenta la nuova coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare una coda di Accodamento messaggi non transazionali.  
  
 Per creare una nuova istanza di <xref:System.Messaging.MessageQueue> nell'applicazione e associarlo a una coda esistente, utilizzare il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore. Per creare una nuova coda in Accodamento messaggi, chiamare <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintassi per la `path` parametro dipende il tipo di coda a cui fa riferimento, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|Coda pubblica|`MachineName`\\`QueueName`|  
|Coda privata|`MachineName`\\`Private$`\\`QueueName`|  
  
 Utilizzare "." per il computer locale. Per ulteriori informazioni sulla sintassi, vedere il <xref:System.Messaging.MessageQueue.Path%2A> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente crea le code pubbliche e private. Invia un messaggio alle code selezionate.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è <see langword="null" /> o è una stringa vuota ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La coda è già presente nel percorso specificato.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso della coda da creare.</param>
        <param name="transactional">
          <see langword="true" /> per creare una coda transazionale; <see langword="false" /> per creare una coda non transazionale.</param>
        <summary>Crea una coda transazionale o non transazionale di Accodamento messaggi nel percorso specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.MessageQueue" /> che rappresenta la nuova coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare questo overload per creare una coda transazionale in Accodamento messaggi. È possibile creare una coda non transazionale, impostando il `transactional` parametro `false` o chiamando l'altro overload di <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Per creare una nuova istanza di <xref:System.Messaging.MessageQueue> nell'applicazione e associarlo a una coda esistente, utilizzare il <xref:System.Messaging.MessageQueue.%23ctor%2A> costruttore. Per creare una nuova coda in Accodamento messaggi, chiamare <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La sintassi per la `path` parametro dipende il tipo di coda a cui fa riferimento, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|Coda pubblica|`MachineName`\\`QueueName`|  
|Coda privata|`MachineName`\\`Private$`\\`QueueName`|  
  
 Utilizzare "." per il computer locale. Per ulteriori informazioni sulla sintassi, vedere il <xref:System.Messaging.MessageQueue.Path%2A> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente crea code transazionali pubbliche e private. Invia un messaggio alle code selezionate.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è <see langword="null" /> o è una stringa vuota ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La coda è già presente nel percorso specificato.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Messaging.Cursor" /> per la coda messaggi corrente.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Messaging.Cursor" /> per la coda messaggi corrente. Questo cursore viene utilizzato per mantenere una posizione specifica nella coda durante la lettura dei messaggi della coda.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la data e l'ora di creazione della coda in Accodamento messaggi.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> che rappresenta la data e l'ora in cui la coda è stata creata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> fa riferimento alla coda sul server di accodamento, non il <xref:System.Messaging.MessageQueue> istanza.  
  
 Se la coda esiste, questa proprietà rappresenta l'ora di creazione della coda, con l'ora locale del server in cui la coda esista.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.CreateTime%2A> proprietà.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i valori di proprietà dei messaggi da utilizzare per impostazione predefinita quando vengono inviati messaggi alla coda dall'applicazione.</summary>
        <value>Oggetto <see cref="T:System.Messaging.DefaultPropertiesToSend" /> contenente i valori predefiniti delle proprietà dei messaggi di Accodamento messaggi utilizzati quando l'applicazione invia alla coda oggetti diversi dalle istanze di <see cref="T:System.Messaging.Message" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si invia un oggetto non è di tipo <xref:System.Messaging.Message> alla coda, il <xref:System.Messaging.MessageQueue> inserisce l'oggetto in un messaggio di Accodamento messaggi. In quel momento, il <xref:System.Messaging.MessageQueue> si applica al messaggio i valori di proprietà specificati nel <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà. Viceversa, se si invia un <xref:System.Messaging.Message> alla coda, queste proprietà sono già specificate per l'istanza stessa, pertanto <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> viene ignorato per il <xref:System.Messaging.Message>.  
  
 Anche se si impostano le proprietà tramite il <xref:System.Messaging.MessageQueue> oggetto, il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> fa riferimento alle proprietà dei messaggi che vengono inviati alla coda, non alla coda stessa.  
  
 I valori predefiniti per le proprietà vengono visualizzati nella tabella seguente.  
  
|Proprietà|Valore predefinito|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Zero (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Una matrice di lunghezza zero byte|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|una stringa vuota ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente usa la priorità di un messaggio per determinare le proprietà predefinite per l'invio del messaggio.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Non è possibile impostare le proprietà predefinite per la coda, probabilmente perché una proprietà non è valida.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda da eliminare.</param>
        <summary>Elimina una coda su un server di Accodamento messaggi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sintassi per la `path` parametro dipende dal tipo di coda.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|Coda pubblica|`MachineName`\\`QueueName`|  
|Coda privata|`MachineName`\\`Private$`\\`QueueName`|  
  
 Per ulteriori informazioni sulla sintassi, vedere il <xref:System.Messaging.MessageQueue.Path%2A> proprietà.  
  
 In alternativa, è possibile utilizzare il <xref:System.Messaging.MessageQueue.FormatName%2A> o <xref:System.Messaging.MessageQueue.Label%2A> per descrivere il percorso della coda.  
  
|Riferimenti|Sintassi|  
|---------------|------------|  
|Nome del formato|FormatName: [ *nome formato* ]|  
|Label|Etichetta: [ *etichetta* ]|  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente elimina una coda di Accodamento messaggi, se esiste.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> è <see langword="null" /> o è una stringa vuota ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La sintassi del parametro <paramref name="path" /> non è valida.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'oggetto <see cref="T:System.Messaging.MessageQueue" /> dispone dell'accesso esclusivo per la ricezione dei messaggi dalla coda di Accodamento messaggi.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Messaging.MessageQueue" /> dispone dei diritti esclusivi per ricevere messaggi dalla coda; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Specifica la modalità condivisa della coda a cui fa riferimento questo <xref:System.Messaging.MessageQueue>. Impostare <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> a `true` per indicare che solo questo <xref:System.Messaging.MessageQueue> devono avere accesso a leggere o ricevere messaggi dalla coda con l'oggetto specificato <xref:System.Messaging.MessageQueue.Path%2A>. Se un altro <xref:System.Messaging.MessageQueue> o un'altra applicazione è associata a tale istanza, la stessa risorsa coda o applicazione non sarà in grado di leggere o ricevere messaggi, ma possono comunque inviare.  
  
 Se <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> è `false`, la coda sia disponibile per più applicazioni per l'invio, visualizzazione o la ricezione di messaggi.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> proprietà.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Elimina le risorse, diverse dalla memoria, usate dall'oggetto <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il metodo <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> dopo aver terminato di utilizzare l'oggetto <xref:System.Messaging.MessageQueue>. Il metodo <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> lascia l'oggetto <xref:System.Messaging.MessageQueue> in una condizione di inutilizzabilità. Dopo la chiamata <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, è necessario rilasciare tutti i riferimenti al <xref:System.Messaging.MessageQueue> in modo che la memoria occupata può essere recuperata tramite garbage collection.  
  
 È necessario chiamare <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> prima di rilasciare l'ultimo riferimento al <xref:System.Messaging.MessageQueue>. In caso contrario, le risorse di <xref:System.Messaging.MessageQueue> non è verranno liberate finché garbage collection di <xref:System.Messaging.MessageQueue> distruttore dell'oggetto.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'applicazione gestirà una cache di connessioni.</summary>
        <value>
          <see langword="true" /> per creare e utilizzare una cache di connessioni; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una cache di connessione è un elenco di riferimenti a strutture che contengono lettura o scrittura handle alle code. Quando <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> è `true`, <xref:System.Messaging.MessageQueue> utilizza gli handle dalla cache ogni volta che si chiama <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, o <xref:System.Messaging.MessageQueue.Receive%2A>, anziché aprire nuovi handle. Ciò può migliorare le prestazioni. Uso di una cache di connessione isola anche il <xref:System.Messaging.MessageQueue> dalle modifiche nella topologia di rete.  
  
 Se si crea una nuova connessione a una coda quando la cache di connessione è piena, il <xref:System.Messaging.MessageQueue> sovrascrive la struttura di accesso meno recente con la nuova connessione. È possibile cancellare la cache interamente chiamando <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, ad esempio, se le code a cui si lavora con i nomi di formato sono stati modificati in modo che il precedente leggere e scrivere gli handle non sono più validi.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> proprietà.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la coda accetta solo messaggi non privati (non crittografati).</summary>
        <value>Uno dei valori di <see cref="T:System.Messaging.EncryptionRequired" />. Il valore predefinito è <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si specifica che la crittografia è necessaria per i messaggi inviati a una coda, vengono crittografati solo i corpi dei messaggi. Gli altri membri (ad esempio, il <xref:System.Messaging.Message.Label%2A> e <xref:System.Messaging.Message.SenderId%2A> proprietà) non può essere crittografata.  
  
 Impostazione di questa proprietà consente di modificare la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica.  
  
 La crittografia di un messaggio rende privato il messaggio. È possibile specificare i requisiti di crittografia della coda su `None`, `Body`, o `Optional` impostando il <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> proprietà in modo appropriato. Il <xref:System.Messaging.Message.UseEncryption%2A> impostazione del messaggio deve corrispondere ai requisiti di crittografia della coda. Se il messaggio non è crittografato, ma la coda specifica `Body`, o se il messaggio è crittografato, ma la coda specifica `None`, il messaggio viene rifiutato dalla coda. Se richiesto dall'applicazione mittente un messaggio di riconoscimento negativo in questo caso, il servizio Accodamento messaggi indica il rifiuto del messaggio all'applicazione mittente. Se il <xref:System.Messaging.Message.UseDeadLetterQueue%2A> proprietà `true`, un messaggio che si verifica un errore di crittografia viene inviato alla coda di messaggi non recapitabili. In caso contrario, il messaggio va perduto.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> proprietà.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> che identifica l'operazione di visualizzazione asincrona da completare e da cui recuperare un risultato finale.</param>
        <summary>Completa l'operazione di visualizzazione asincrona specificata.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> associato all'operazione asincrona completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Messaging.MessageQueue.PeekCompleted> evento viene generato, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> completa l'operazione è stata avviata dal <xref:System.Messaging.MessageQueue.BeginPeek%2A> chiamare. A tale scopo, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> legge il messaggio.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> può specificare un timeout, il che comporta la <xref:System.Messaging.MessageQueue.PeekCompleted> evento da generare se si verifica il timeout prima che venga visualizzato un messaggio nella coda. Quando si verifica un timeout senza un messaggio che arriva nella coda, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> genera un'eccezione.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene utilizzato per leggere il messaggio che ha causato il <xref:System.Messaging.MessageQueue.PeekCompleted> dell'evento.  
  
 Se si desidera continuare a leggere i messaggi in modo asincrono, è possibile chiamare nuovamente <xref:System.Messaging.MessageQueue.BeginPeek%2A> dopo la chiamata <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente crea un gestore eventi denominato `MyPeekCompleted`, lo collega al <xref:System.Messaging.MessageQueue.PeekCompleted> delegato del gestore eventi e chiamate <xref:System.Messaging.MessageQueue.BeginPeek%2A> per avviare un'operazione di lettura asincrona in coda che si trova nel percorso ". \myQueue". Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> evento viene generato, l'esempio legge il messaggio e scrive il corpo sullo schermo. Nell'esempio viene quindi chiamato <xref:System.Messaging.MessageQueue.BeginPeek%2A> per avviare una nuova operazione di lettura asincrona.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La sintassi del parametro <paramref name="asyncResult" /> non è valida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> che identifica l'operazione di ricezione asincrona da completare e da cui recuperare un risultato finale.</param>
        <summary>Completa l'operazione di ricezione asincrona specificata.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> associato all'operazione asincrona completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento viene generato, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> completa l'operazione è stata avviata dal <xref:System.Messaging.MessageQueue.BeginReceive%2A> chiamare. A tale scopo, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> riceve il messaggio.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> può specificare un timeout, il che comporta la <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento da generare se si verifica il timeout prima che venga visualizzato un messaggio nella coda. Quando si verifica un timeout senza un messaggio che arriva nella coda, una chiamata successiva a <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> genera un'eccezione.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene utilizzato per leggere il messaggio che ha causato (rimuovendolo dalla coda) il <xref:System.Messaging.MessageQueue.ReceiveCompleted> dell'evento.  
  
 Se si desidera continuare a ricevere i messaggi in modo asincrono, è possibile chiamare nuovamente <xref:System.Messaging.MessageQueue.BeginReceive%2A> dopo la chiamata <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente vengono concatenate richieste asincrone. Si presuppone che nel computer locale, denominato "myQueue" è una coda. Il `Main` funzione inizia l'operazione asincrona viene gestita dal `MyReceiveCompleted` routine. `MyReceiveCompleted` Elabora il messaggio corrente e avvia una nuova asincrono l'operazione di ricezione.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La sintassi del parametro <paramref name="asyncResult" /> non è valida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Posizione della coda da trovare.</param>
        <summary>Determina se una coda di Accodamento messaggi è presente nel percorso specificato.</summary>
        <returns>
          <see langword="true" /> se esiste una coda con il percorso specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.Exists%28System.String%29> metodo determina se una coda di Accodamento messaggi è presente nel percorso specificato. Non esiste alcun metodo per determinare se esiste una coda con un nome di formato specificato. Per ulteriori informazioni sulla sintassi del nome di formato e ad altre forme di sintassi del percorso, vedere il <xref:System.Messaging.MessageQueue.Path%2A> proprietà.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> è un'operazione costosa. Utilizzato solo quando è necessario all'interno dell'applicazione.  
  
> [!NOTE]
>  Il <xref:System.Messaging.MessageQueue.Exists%28System.String%29> metodo non supporta il <xref:System.Messaging.MessageQueue.FormatName%2A> prefisso.  
  
 La sintassi per la `path` parametro dipende dal tipo di coda, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|Coda pubblica|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> non può essere chiamato per verificare l'esistenza di una coda privata remota.  
  
 Per ulteriori informazioni sulla sintassi, vedere il <xref:System.Messaging.MessageQueue.Path%2A> proprietà.  
  
 In alternativa, è possibile utilizzare il <xref:System.Messaging.MessageQueue.Label%2A> per descrivere il percorso della coda.  
  
|Riferimenti|Sintassi|  
|---------------|------------|  
|Label|Etichetta: [ `label` ]|  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente consente di verificare se esiste una coda di Accodamento messaggi e quindi eliminarlo.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La sintassi di <paramref name="path" /> non è valida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.  
  
 oppure  
  
 Il metodo <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> viene chiamato su una coda privata remota.</exception>
        <exception cref="T:System.InvalidOperationException">Nell'applicazione è stata utilizzata la sintassi dei nomi di formato durante la verifica dell'esistenza della coda.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome univoco generato per la coda da Accodamento messaggi al momento della creazione della coda.</summary>
        <value>Nome della coda, univoco nella rete.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.FormatName%2A> proprietà contiene il nome di formato della coda. Accodamento messaggi utilizza il nome di formato per identificare la coda da aprire e come accedervi. A differenza la maggior parte delle caratteristiche di una coda, il nome di formato non è una proprietà di coda dell'applicazione Accodamento messaggi, in modo che non è possibile accedervi tramite lo strumento di gestione di Accodamento messaggi. Il nome di formato è semplicemente un nome univoco per la coda, che il servizio Accodamento messaggi genera durante la creazione della coda o l'applicazione genera l'errore in un secondo momento.  
  
 Se si specifica un percorso utilizzando la sintassi del nome percorso (ad esempio `myComputer\myQueue`) invece di usare la sintassi del nome di formato durante la lettura o scrittura per la coda, il controller di dominio primario (che usa Active Directory) traduce il <xref:System.Messaging.MessageQueue.Path%2A> nel associato<xref:System.Messaging.MessageQueue.FormatName%2A> prima di accedere alla coda. Se l'applicazione è offline, è necessario utilizzare la sintassi del nome di formato; in caso contrario, il controller di dominio primario non sarà disponibile per eseguire la conversione del percorso.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.FormatName%2A> proprietà.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è impostata.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il formattatore utilizzato per serializzare o deserializzare un oggetto dal corpo di un messaggio letto o scritto in una coda.</summary>
        <value>
          <see cref="T:System.Messaging.IMessageFormatter" /> che produce un flusso da scrivere o leggere dal corpo del messaggio. Il valore predefinito è <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà contiene un'istanza di un oggetto formattatore, che trasforma i messaggi quando l'applicazione legge o scrive nella coda.  
  
 Quando l'applicazione invia messaggi alla coda, il formattatore serializza l'oggetto in un flusso e lo inserisce nel corpo del messaggio. Durante la lettura da una coda, il formattatore deserializza i dati del messaggio nel <xref:System.Messaging.Message.Body%2A> proprietà di un <xref:System.Messaging.Message>.  
  
 Il <xref:System.Messaging.XmlMessageFormatter> ad accoppiamento ridotto, pertanto non è necessario avere lo stesso oggetto di tipo per il mittente e destinatario, quando si utilizza questo formato. Il <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializzare i dati in una rappresentazione binaria. Il <xref:System.Messaging.ActiveXMessageFormatter> viene utilizzato durante l'invio o la ricezione di componenti COM.  
  
 <xref:System.Messaging.BinaryMessageFormatter> e <xref:System.Messaging.ActiveXMessageFormatter> forniscono una velocità più il <xref:System.Messaging.XmlMessageFormatter>. Il <xref:System.Messaging.ActiveXMessageFormatter> consente l'interoperabilità con applicazioni di Accodamento messaggi di Visual Basic 6.0.  
  
 Quando l'applicazione invia messaggi alla coda, il <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> si applica solo a quei messaggi che utilizzano le proprietà del messaggio predefinite, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Se si invia un <xref:System.Messaging.Message> alla coda di Accodamento messaggi utilizza il formattatore definito nella <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> proprietà da serializzare il corpo.  
  
 Il <xref:System.Messaging.MessageQueue> classe utilizza sempre un <xref:System.Messaging.Message> per ricevere o leggere un messaggio dalla coda. Il messaggio viene deserializzato mediante il <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente illustra la formattazione di un corpo del messaggio tramite <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Esempio di codice seguente illustra la formattazione di un corpo del messaggio tramite <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce tutti i messaggi presenti nella coda.</summary>
        <returns>Matrice di tipo <see cref="T:System.Messaging.Message" /> che rappresenta tutti i messaggi nella coda nello stesso ordine in cui vengono visualizzati nella coda di Accodamento messaggi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Restituisce uno snapshot statico dei messaggi nella coda, non dinamici collegamenti a tali messaggi. Pertanto, è possibile utilizzare la matrice per modificare i messaggi nella coda. Se si desidera in tempo reale, dinamica e di interazione con la coda (ad esempio la possibilità di eliminare i messaggi), chiamare il <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> metodo, che restituisce un elenco dinamico di messaggi nella coda.  
  
 Poiché <xref:System.Messaging.MessageQueue.GetAllMessages%2A> restituisce una copia dei messaggi nella coda al momento in cui è stato chiamato il metodo, la matrice non riflette i messaggi vengono rimossi dalla coda o nuovi messaggi che arrivano nella coda.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Recupera solo le proprietà non filtrate dal <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enumera i messaggi in una coda. L'oggetto <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> è deprecato. È consigliabile utilizzare invece <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> che fornisce una connessione dinamica ai messaggi della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nome del computer contenente la coda, non preceduto dalle due barre rovesciate (\\\\).</param>
        <summary>Ottiene l'identificatore del computer in cui viene posizionata la coda cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento.</summary>
        <returns>Oggetto <see cref="T:System.Guid" /> che rappresenta un identificatore univoco del computer in cui viene posizionata la coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare l'identificatore del computer per due scopi: per il journal del computer di leggere e impostare i certificati di sicurezza. Tuttavia, non è possibile chiamare <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> per un computer remoto quando si lavora offline perché l'applicazione deve avere accesso al servizio directory nel controller di dominio.  
  
 L'identificatore del computer (o identificatore computer) è un <xref:System.Guid> che Accodamento messaggi crea quando un computer viene aggiunto all'organizzazione. Il servizio Accodamento messaggi consente di combinare l'identificatore del computer con il `Machine` e `Journal` parole chiave per creare formato nome del journal computer, con la sintassi `Machine=<computeridentifier>;Journal`. I messaggi il journal del computer, è anche noto come coda journal di è una coda di sistema che vengono archiviate copie delle generati dall'applicazione quando il <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> proprietà `true`.  
  
 Questa sintassi per la registrazione è valida solo quando si crea il nome di formato per la coda. La sintassi del nome di percorso è `MachineName` \\ `Journal$`.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene chiamato il metodo <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Non è stato possibile recuperare l'identificatore del computer, probabilmente perché il servizio directory non è disponibile, ad esempio se si sta lavorando in modalità offline.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un oggetto enumeratore per tutti i messaggi contenuti nella coda. L'oggetto <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> è deprecato. È consigliabile utilizzare invece <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" /> contenente i messaggi presenti nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> Crea un elenco dinamico di tutti i messaggi in una coda. È possibile rimuovere dalla coda il messaggio nella posizione corrente dell'enumeratore chiamando <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> per il <xref:System.Messaging.MessageEnumerator> che <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> restituisce.  
  
 Poiché il cursore è associato a un elenco dinamico di messaggi nella coda, l'enumerazione rifletterà le eventuali modifiche apportate ai messaggi nella coda, se il messaggio è oltre la posizione corrente del cursore. Ad esempio, l'enumeratore può accedere automaticamente un messaggio con priorità inferiore inserito oltre la posizione corrente del cursore, ma non un messaggio di priorità più alta inserito prima di quella posizione. Tuttavia, è possibile reimpostare l'enumerazione, spostare il cursore all'inizio dell'elenco, chiamando <xref:System.Messaging.MessageEnumerator.Reset%2A> per il <xref:System.Messaging.MessageEnumerator>.  
  
 L'ordine dei messaggi nell'enumerazione riflette l'ordine nella coda, i messaggi con priorità superiore verranno visualizzati prima di quelli con priorità inferiore.  
  
 Se si desidera uno snapshot statico dei messaggi in coda, anziché una connessione dinamica ad essi, chiamare <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Questo metodo restituisce una matrice di <xref:System.Messaging.Message> oggetti che rappresentano i messaggi al momento della chiamata al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene un elenco dinamico di messaggi in una coda e conta tutti i messaggi con il <xref:System.Messaging.Message.Priority%2A> proprietà impostata su <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un oggetto enumeratore per tutti i messaggi contenuti nella coda.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" /> contenente i messaggi presenti nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> Crea un elenco dinamico di tutti i messaggi in una coda. È possibile rimuovere dalla coda il messaggio nella posizione corrente dell'enumeratore chiamando <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> per il <xref:System.Messaging.MessageEnumerator> che <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> restituisce.  
  
 Poiché il cursore è associato a un elenco dinamico di messaggi nella coda, l'enumerazione rifletterà le eventuali modifiche apportate ai messaggi nella coda, se il messaggio è oltre la posizione corrente del cursore. Ad esempio, l'enumeratore può accedere automaticamente un messaggio con priorità inferiore inserito oltre la posizione corrente del cursore, ma non un messaggio di priorità più alta inserito prima di quella posizione. Tuttavia, è possibile reimpostare l'enumerazione, spostare il cursore all'inizio dell'elenco, chiamando <xref:System.Messaging.MessageEnumerator.Reset%2A> per il <xref:System.Messaging.MessageEnumerator>.  
  
 L'ordine dei messaggi nell'enumerazione riflette l'ordine nella coda, i messaggi con priorità superiore verranno visualizzati prima di quelli con priorità inferiore.  
  
 Se si desidera uno snapshot statico dei messaggi in coda, anziché una connessione dinamica ad essi, chiamare <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Questo metodo restituisce una matrice di <xref:System.Messaging.Message> oggetti che rappresentano i messaggi al momento della chiamata al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un oggetto enumeratore per un elenco dinamico delle code pubbliche presenti sulla rete.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornisce la semantica del cursore forward-only per enumerare tutte le code pubbliche sulla rete.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.MessageQueueEnumerator" /> che fornisce un elenco dinamico di tutte le code di messaggi pubbliche sulla rete.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> restituisce un'enumerazione di tutte le code pubbliche nella rete.  
  
 Poiché il cursore è associato a un elenco dinamico, l'enumerazione rifletterà le eventuali modifiche apportate a un elenco di coda per le code, eliminati o aggiunti oltre la posizione corrente del cursore. Aggiunta o eliminazione di code che si trovano prima della posizione corrente del cursore non sono visibili. Ad esempio, l'enumeratore può accedere automaticamente una coda aggiunta oltre la posizione del cursore, ma non è inserita prima di tale posizione. Tuttavia, è possibile reimpostare l'enumerazione, spostare il cursore all'inizio dell'elenco, chiamando <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> per il <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Non è stato definito nessun ordine di code in una rete. Un enumeratore non vengono ordinate, ad esempio, per computer, etichetta, stato pubblico o privato o altri criteri accessibili.  
  
 Se si desidera uno snapshot statico delle code in rete anziché una connessione dinamica ad essi, chiamare <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> o <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Ognuno di questi due metodi restituisce una matrice di <xref:System.Messaging.MessageQueue> oggetti che rappresentano le code al momento della chiamata al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente scorre tutte le code di messaggi nella rete e viene esaminato il percorso per ogni coda. Infine, visualizzato il numero di code pubbliche nella rete.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Oggetto <see cref="T:System.Messaging.MessageQueueCriteria" /> contenente i criteri utilizzati per filtrare le code di messaggi disponibili.</param>
        <summary>Fornisce la semantica del cursore forward-only per enumerare tutte le code pubbliche sulla rete che soddisfano i criteri specificati.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.MessageQueueEnumerator" /> che fornisce un elenco dinamico delle code di messaggi pubbliche sulla rete che soddisfano le restrizioni specificate dal parametro <paramref name="criteria" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> restituisce un elenco di tutte le code pubbliche nella rete che soddisfano i criteri definiti nei criteri dell'applicazione. È possibile specificare i criteri da includere, coda, ad esempio, l'ora di creazione o la modifica, nome del computer, etichetta, categoria o qualsiasi combinazione di questi.  
  
 Poiché il cursore è associato a un elenco dinamico, l'enumerazione rifletterà le eventuali modifiche apportate a una coda che si trova oltre la posizione del cursore corrente. A code che si trovano prima della posizione corrente del cursore non vengono riflesse. Ad esempio, l'enumeratore può accedere automaticamente una coda aggiunta oltre la posizione del cursore, ma non è inserita prima di tale posizione. Tuttavia, è possibile reimpostare l'enumerazione, spostare il cursore all'inizio dell'elenco, chiamando <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> per il <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Non è stato definito nessun ordine di code in una rete. Un enumeratore non vengono ordinate, ad esempio, per computer, etichetta, stato pubblico o privato o altri criteri accessibili.  
  
 Se si desidera uno snapshot statico delle code in rete anziché una connessione dinamica ad essi, specificare i criteri per <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> o chiamare <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Ognuno di questi due metodi restituisce una matrice di <xref:System.Messaging.MessageQueue> oggetti che rappresentano le code al momento della chiamata al metodo. La chiamata <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, o <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> fornisce gli stessi risultati di una chiamata <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> con i criteri di filtro di <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, e <xref:System.Messaging.MessageQueue.MachineName%2A>, rispettivamente.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente scorre le code di messaggi e visualizza il percorso di ogni coda che è stato creato nell'ultimo giorno e che esista nel computer "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Computer da cui recuperare le code private.</param>
        <summary>Recupera tutte le code private sul computer specificato.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code private recuperate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> Recupera uno snapshot statico delle code in un computer specifico.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="machineName" /> è <see langword="null" /> o una stringa vuota ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera tutte le code pubbliche sulla rete.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera tutte le code pubbliche sulla rete.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code pubbliche recuperate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload se si desidera un elenco completo di tutte le code pubbliche nella rete. Se si desidera limitare l'elenco in base a determinati criteri, ad esempio <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, o l'ora dell'ultima modifica utilizzare un altro overload di questo metodo. (In alternativa, è possibile utilizzare <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, o <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Recupera uno snapshot statico delle code. Per interagire con un elenco dinamico di code, utilizzare <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Oggetto <see cref="T:System.Messaging.MessageQueueCriteria" /> contenente i criteri utilizzati per filtrare le code.</param>
        <summary>Recupera tutte le code pubbliche sulla rete che soddisfano i criteri specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code pubbliche recuperate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si desidera filtrare tutte le code pubbliche nella rete per l'etichetta, categoria o nome del computer, il <xref:System.Messaging.MessageQueue> classe contenente metodi specifici che forniscono tale funzionalità (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, e <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, rispettivamente). Utilizzare questo overload per ottenere un elenco di tutte le code pubbliche nella rete che soddisfano più di uno di questi criteri (ad esempio, se si desidera specificare un'etichetta e una categoria). È possibile anche filtrare in base a criteri messaggio diverso da <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, e <xref:System.Messaging.MessageQueue.MachineName%2A>. Ad esempio, utilizzare questo overload per filtrare in base l'ora dell'ultima modifica di una coda. È sufficiente creare una nuova istanza di <xref:System.Messaging.MessageQueueCriteria> classe, impostare le proprietà appropriate nell'istanza e passare l'istanza come il `criteria` parametro.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Recupera uno snapshot statico delle code. Per interagire con un elenco dinamico di code, utilizzare <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Oggetto <see cref="T:System.Guid" /> che raggruppa il set di code da recuperare.</param>
        <summary>Recupera tutte le code pubbliche sulla rete appartenenti alla categoria specificata.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code pubbliche recuperate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per filtrare le code pubbliche in base alla categoria. Il <xref:System.Messaging.MessageQueue.Category%2A> proprietà fornisce l'accesso alla proprietà ID tipo di Accodamento messaggi (che è in lettura/scrittura) di una determinata coda. Sebbene sia possibile utilizzare <xref:System.Guid.NewGuid%2A> per creare un valore di categoria che è univoco tra tutti <xref:System.Guid> valori, non è necessario. Il valore della categoria deve essere diverso da quello solo di altre categorie, non da tutti gli altri <xref:System.Guid> valori. Ad esempio, è possibile assegnare {00000000-0000-0000-0000-000000000001} come il <xref:System.Messaging.MessageQueue.Category%2A> da un insieme di code e {00000000-0000-0000-0000-000000000002} come la <xref:System.Messaging.MessageQueue.Category%2A> per un altro set.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> Recupera uno snapshot statico delle code. Per interagire con un elenco dinamico di code, utilizzare <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. È possibile specificare la categoria come parte di <xref:System.Messaging.MessageQueueCriteria> passato al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Etichetta che raggruppa il set di code da recuperare.</param>
        <summary>Recupera tutte le code pubbliche sulla rete contenenti l'etichetta specificata.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code pubbliche recuperate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per filtrare le code pubbliche da un'etichetta.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> Recupera uno snapshot statico delle code. Per interagire con un elenco dinamico di code, utilizzare <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. È possibile specificare l'etichetta come parte di <xref:System.Messaging.MessageQueueCriteria> passato al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="label" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nome del computer contenente il set di code pubbliche da recuperare.</param>
        <summary>Recupera tutte le code pubbliche che risiedono sul computer specificato.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Messaging.MessageQueue" /> che fanno riferimento alle code pubbliche sul computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per filtrare le code pubbliche dal computer.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> Recupera uno snapshot statico delle code. Per interagire con un elenco dinamico di code, utilizzare <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. È possibile specificare il nome del computer come parte di <xref:System.Messaging.MessageQueueCriteria> passato al metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|No|  
|Computer locale e il nome di formato direct|No|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente recupera gli elenchi di code.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La sintassi del parametro <paramref name="machineName" /> non è corretta.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera il contesto di sicurezza che MSMQ associa all'utente corrente (identità del thread) nel momento in cui viene eseguita questa chiamata.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.SecurityContext" /> contenente il contesto di sicurezza.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identificatore univoco di Accodamento messaggi per la coda.</summary>
        <value>Proprietà <see cref="P:System.Messaging.MessageQueue.Id" /> che rappresenta l'identificatore del messaggio generato dall'applicazione Accodamento messaggi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Accodamento messaggi imposta la <xref:System.Messaging.MessageQueue.Id%2A> proprietà durante la creazione della coda. Questa proprietà è disponibile solo per le code pubbliche.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.Id%2A> proprietà.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che non sono previste restrizioni relative alle dimensioni di una coda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è frequente quando si imposta <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> o <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Messaging.MessageQueue.InfiniteQueueSize> membro.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che non è previsto un timeout per i metodi che leggono o ricevono messaggi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> supporta due tipi di recupero dei messaggi: sincrone e asincrone. I metodi sincroni, <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.Receive%2A>, il thread di processo in attesa di un intervallo di tempo specificato per un nuovo messaggio in arrivo nella coda. Se l'intervallo di tempo specificato è <xref:System.Messaging.MessageQueue.InfiniteTimeout>, il thread del processo rimane bloccato fino a quando non è disponibile un nuovo messaggio. D'altra parte, <xref:System.Messaging.MessageQueue.BeginPeek%2A> e <xref:System.Messaging.MessageQueue.BeginReceive%2A> (metodi asincroni), consentire l'attività principale dell'applicazione proseguire in un thread separato fino a quando non arriva un messaggio nella coda.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Messaging.MessageQueue.InfiniteTimeout> membro.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la descrizione della coda.</summary>
        <value>Etichetta della coda di messaggi. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lunghezza massima di un'etichetta di coda di messaggi è 124 caratteri.  
  
 Il <xref:System.Messaging.MessageQueue.Label%2A> proprietà non devono essere univoci tra tutte le code. Tuttavia, se più code condividono lo stesso <xref:System.Messaging.MessageQueue.Label%2A>, non è possibile utilizzare il <xref:System.Messaging.MessageQueue.Send%28System.Object%29> metodo per trasmettere un messaggio a tutti gli elementi. Se si utilizza la sintassi dell'etichetta per il <xref:System.Messaging.MessageQueue.Path%2A> proprietà quando si invia il messaggio, verrà generata un'eccezione se il <xref:System.Messaging.MessageQueue.Label%2A> non è univoco.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.Label%2A> proprietà.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'etichetta è stata impostata su un valore non valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la data e l'ora dell'ultima modifica delle proprietà di una coda.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> che indica la data e l'ora dell'ultima modifica delle proprietà della coda.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ora dell'ultima modifica include quando è stata creata la coda e qualsiasi <xref:System.Messaging.MessageQueue> proprietà che modifica la coda di Accodamento messaggi, ad esempio <xref:System.Messaging.MessageQueue.BasePriority%2A>. Il valore di <xref:System.Messaging.MessageQueue.LastModifyTime%2A> proprietà rappresenta l'ora di sistema del computer locale.  
  
 È necessario chiamare <xref:System.Messaging.MessageQueue.Refresh%2A> prima di ottenere il <xref:System.Messaging.MessageQueue.LastModifyTime%2A> proprietà; in caso contrario, l'ora di modifica associato a questo <xref:System.Messaging.MessageQueue> potrebbero non essere aggiornate.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.LastModifyTime%2A> proprietà.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del computer in cui si trova la coda di Accodamento messaggi.</summary>
        <value>Nome del computer in cui si trova la coda. Il valore predefinito di Accodamento messaggi è "." per indicare il computer locale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.MachineName%2A> è un componente integrale della sintassi del nome descrittivo della coda <xref:System.Messaging.MessageQueue.Path%2A>. La tabella seguente illustra la sintassi da utilizzare per una coda di un tipo specificato quando si desidera identificare il percorso della coda utilizzando il relativo nome.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|Coda pubblica|`MachineName`\\`QueueName`|  
|Coda privata|`MachineName`\\`Private$`\\`QueueName`|  
|Coda journal|`MachineName`\\`QueueName`\\`Journal$`|  
|Coda journal di computer|`MachineName`\\`Journal$`|  
|Coda di messaggi non recapitabili|`MachineName`\\`Deadletter$`|  
|Coda messaggi non recapitabili transazionale|`MachineName`\\`XactDeadletter$`|  
  
 Utilizzare "." per il computer locale quando si specifica il <xref:System.Messaging.MessageQueue.MachineName%2A>. Solo il nome del computer è riconosciuto per questa proprietà, ad esempio, `Server0`. Il <xref:System.Messaging.MessageQueue.MachineName%2A> proprietà non supporta il formato dell'indirizzo IP.  
  
 Se si definisce la <xref:System.Messaging.MessageQueue.Path%2A> in termini del <xref:System.Messaging.MessageQueue.MachineName%2A>, l'applicazione genera un'eccezione quando si lavora offline perché il controller di dominio è obbligatorio per la conversione del percorso. Pertanto, è necessario utilizzare il <xref:System.Messaging.MessageQueue.FormatName%2A> per il <xref:System.Messaging.MessageQueue.Path%2A> sintassi in modalità offline.  
  
 Il <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, e <xref:System.Messaging.MessageQueue.QueueName%2A> sono correlate. Modifica il <xref:System.Messaging.MessageQueue.MachineName%2A> proprietà causa la <xref:System.Messaging.MessageQueue.Path%2A> proprietà da modificare. È compilato dalla nuova <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A>. Modifica il <xref:System.Messaging.MessageQueue.Path%2A> (ad esempio, utilizzare la sintassi del nome di formato) Reimposta il <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> proprietà per fare riferimento alla nuova coda. Se il <xref:System.Messaging.MessageQueue.QueueName%2A> proprietà è vuota, il <xref:System.Messaging.MessageQueue.Path%2A> è impostato nella coda Journal del computer specificato.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.MachineName%2A> proprietà.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome del computer non è valido, probabilmente perché la sintassi non è corretta.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione massima della coda del giornale di registrazione.</summary>
        <value>Dimensione massima, espressa in kilobyte, della coda del journal. L'impostazione predefinita di Accodamento messaggi specifica che non esiste alcun limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> fornisce l'accesso per il limite di archiviazione di Accodamento messaggi journal. È rilevante solo quando <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> è `true`. Impostazione di questa proprietà consente di modificare la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica  
  
 Se si archiviano i messaggi in una coda del diario o inattiva, è necessario cancellare periodicamente la coda per rimuovere i messaggi che non sono più necessari. I messaggi in una coda conteggiati per la quota per il computer in cui risiede la coda. (L'amministratore imposta la quota del computer).  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> proprietà.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione massima della coda del journal è stata impostata su un valore non valido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione massima della coda.</summary>
        <value>La dimensione massima, espressa in kilobyte (KB), della coda. L'impostazione predefinita di Accodamento messaggi specifica che non esiste alcun limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> fornisce l'accesso al limite di archiviazione dei messaggi di Accodamento messaggi, che è diverso dalla quota messaggi del computer che l'amministratore definisce. Per ulteriori informazioni sulla quota dei messaggi, vedere <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Impostazione di questa proprietà consente di modificare la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica  
  
 Se viene effettuato un tentativo di superare le dimensioni massime della coda o la quota dei messaggi del computer, potrebbe essere persi i messaggi. Quando viene raggiunta la quota della coda, Accodamento messaggi di notifica la coda di amministrazione dell'applicazione mittente per indicare che la coda è piena, restituendo un messaggio di riconoscimento negativo. In Accodamento messaggi continua a inviare messaggi di riconoscimento negativo fino a quando le dimensioni totali dei messaggi nella coda scende di sotto del limite.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> proprietà.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione massima della coda contiene un valore negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il filtro di proprietà per la ricezione o la visualizzazione dei messaggi.</summary>
        <value>
          <see cref="T:System.Messaging.MessagePropertyFilter" /> utilizzato dalla coda per filtrare l'insieme di proprietà ricevute o visualizzate per ciascun messaggio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo filtro è un set di valori Boolean che limita le proprietà del messaggio che il <xref:System.Messaging.MessageQueue> riceve o legge. Quando il <xref:System.Messaging.MessageQueue> riceve o legge un messaggio dalla coda del server, recupera solo le proprietà per il quale il <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> valore `true`.  
  
 Nell'esempio seguente viene valori iniziali delle proprietà per il <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> proprietà. Queste impostazioni sono identiche alla chiamata al metodo <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> su un <xref:System.Messaging.MessagePropertyFilter>.  
  
|Proprietà|Valore predefinito|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 byte|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 byte|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 byte|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> per limitare le proprietà del messaggio ricevute.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il filtro è <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introdotto in MSMQ 3.0. Ottiene o imposta l'indirizzo multicast associato alla coda.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene un indirizzo multicast valido (nel formato riportato di seguito) o <see langword="null" />, a indicare che alla coda non è associato alcun indirizzo multicast.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.MulticastAddress%2A> proprietà viene utilizzata per associare una coda non transazionale a un indirizzo multicast che può essere usato quando si inviano messaggi. Una coda transazionale non è possibile associare un indirizzo multicast. Quando l'applicazione mittente invia messaggi a un indirizzo multicast, Accodamento messaggi invia una copia del messaggio per ogni coda associata a tale indirizzo.  
  
 Multicast IP indirizzi devono essere nell'intervallo di classe D tra 224.0.0.0 e 239.255.255.255, che corrisponde all'impostazione su 1110 dei primi quattro bit significativo. Tuttavia, solo alcuni intervalli di indirizzi in questo intervallo sono disponibili per l'invio di messaggi multicast non riservata. Per un elenco aggiornato degli indirizzi multicast riservati, vedere il [numero autorità IANA (Internet Assigned) Internet Multicast Addresses](http://go.microsoft.com/fwlink/?linkid=3859) pagina Web. Non sono previste restrizioni sul numero di porta.  
  
 Se più computer di origine sono l'invio di messaggi multicast e si desidera una coda specifica per ricevere i messaggi solo da un computer di origine, ogni computer di origine deve inviare messaggi a una combinazione diversa di numero di porta e indirizzo IP.  
  
 Per annullare l'associazione di una coda da un indirizzo multicast, impostare il <xref:System.Messaging.MessageQueue.MulticastAddress%2A> proprietà in una stringa di lunghezza zero. Non si imposta su `null`, come il risultato sarà un <xref:System.ArgumentNullException>.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il percorso della coda. Impostando la proprietà <see cref="P:System.Messaging.MessageQueue.Path" />, <see cref="T:System.Messaging.MessageQueue" /> punta a una nuova coda.</summary>
        <value>Coda a cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Il valore predefinito dipende dal costruttore <see cref="M:System.Messaging.MessageQueue.#ctor" /> utilizzato e può essere <see langword="null" /> oppure può essere specificato dal parametro <paramref name="path" /> del costruttore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sintassi per la <xref:System.Messaging.MessageQueue.Path%2A> proprietà dipende dal tipo di coda, punti, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|Coda pubblica|`MachineName`\\`QueueName`|  
|Coda privata|`MachineName`\\`Private$`\\`QueueName`|  
|Coda journal|`MachineName`\\`QueueName`\\`Journal$`|  
|Coda journal di computer|`MachineName`\\`Journal$`|  
|Coda di messaggi non recapitabili|`MachineName`\\`Deadletter$`|  
|Coda messaggi non recapitabili transazionale|`MachineName`\\`XactDeadletter$`|  
  
 Utilizzare "." per rappresentare il computer locale.  
  
 Il <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, e <xref:System.Messaging.MessageQueue.QueueName%2A> sono correlate. Modifica il <xref:System.Messaging.MessageQueue.MachineName%2A> proprietà causa la <xref:System.Messaging.MessageQueue.Path%2A> proprietà da modificare. È compilato dalla nuova <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A>. Modifica il <xref:System.Messaging.MessageQueue.Path%2A> (ad esempio, utilizzare la sintassi del nome di formato) Reimposta il <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> proprietà per fare riferimento alla nuova coda.  
  
 In alternativa, è possibile utilizzare il <xref:System.Messaging.MessageQueue.FormatName%2A> o <xref:System.Messaging.MessageQueue.Label%2A> per descrivere il percorso della coda, come illustrato nella tabella seguente.  
  
|Riferimenti|Sintassi|Esempio|  
|---------------|------------|-------------|  
|Nome del formato|`FormatName:` [ *nome formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Label|`Label:` [ *etichetta* ]|`Label:` TheLabel|  
  
 Se si utilizza la sintassi dell'etichetta per il <xref:System.Messaging.MessageQueue.Path%2A> proprietà quando si invia il messaggio, verrà generata un'eccezione se il <xref:System.Messaging.MessageQueue.Label%2A> non è univoco.  
  
 Per lavorare offline, è necessario utilizzare la sintassi del nome di formato, anziché la sintassi del nome descrittivo della prima tabella. In caso contrario, viene generata un'eccezione perché il controller di dominio primario (in cui risiede Active Directory) non è disponibile per risolvere il percorso per il nome di formato.  
  
 L'impostazione di un nuovo percorso chiude la coda di messaggi e rilascia tutti gli handle.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|Yes|  
  
> [!NOTE]
>  In modalità gruppo di lavoro è possibile utilizzare solo le code private. Specificare il percorso utilizzando la sintassi di coda privata `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 Esempio di codice seguente crea nuovi <xref:System.Messaging.MessageQueue> oggetti utilizzando diversi tipi di sintassi di nome di percorso. In ogni caso, viene inviato un messaggio alla coda il cui percorso è definita nel costruttore.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il percorso non è valido, probabilmente perché la sintassi non è valida.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <summary>Restituisce una copia del primo messaggio della coda senza rimuoverlo da quest'ultima.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina senza rimuovere (legge) il primo messaggio nella coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Poiché il metodo <see cref="M:System.Messaging.MessageQueue.Peek" /> è sincrono, blocca il thread corrente finché non viene reso disponibile un messaggio.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> che rappresenta il primo messaggio della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per leggere una coda o in attesa fino a quando non è disponibile un messaggio nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo legge, ma non rimuovere il primo messaggio dalla coda. Pertanto, le chiamate ripetute a <xref:System.Messaging.MessageQueue.Peek%2A> restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo, d'altra parte, legge e rimuove il primo messaggio dalla coda. Le chiamate ripetute a <xref:System.Messaging.MessageQueue.Receive%2A>, pertanto, restituire diversi tipi di messaggi.  
  
 I messaggi vengono ordinati da Accodamento messaggi nella coda in base al tempo di priorità e di arrivo. Un messaggio più recente viene inserito prima uno precedente solo se si tratta di una priorità più alta.  
  
 Utilizzare il metodo <xref:System.Messaging.MessageQueue.Peek%2A> quando è possibile bloccare il thread corrente durante l'attesa dell'arrivo di un messaggio nella coda. Poiché questo overload non specifica un timeout, l'applicazione potrebbe attendere all'infinito. Se si desidera che l'elaborazione dell'applicazione continui senza attendere, utilizzare il metodo asincrono <xref:System.Messaging.MessageQueue.BeginPeek%2A>. In alternativa, è possibile specificare un timeout di un messaggio è arrivato nella coda utilizzando il metodo di overload <xref:System.Messaging.MessageQueue.Peek%2A> che specifica un timeout.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Messaging.MessageQueue.Peek%2A> metodo in una coda.  
  
 Nel primo esempio, l'applicazione attende un messaggio diventa disponibile nella coda. Si noti che nel primo esempio di non accedere al messaggio che arriva; semplicemente sospende l'elaborazione fino a quando non arriva un messaggio. Se già presente un messaggio nella coda, verrà restituito immediatamente.  
  
 Nel secondo esempio, un messaggio che contiene un parametro definito dall'applicazione `Order` classe viene inviato alla coda e successivamente viene letto dalla coda.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo massimo di attesa affinché un messaggio venga inserito nella coda.</param>
        <summary>Termina senza rimuovere (legge) il primo messaggio nella coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Poiché il metodo <see cref="M:System.Messaging.MessageQueue.Peek" /> è sincrono, blocca il thread corrente finché non viene reso disponibile un messaggio o non si verifica il timeout specificato.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> che rappresenta il primo messaggio della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per leggere una coda o di un determinato periodo di tempo fino a quando non è disponibile un messaggio nella coda di attesa. Il metodo restituisce immediatamente se nella coda è già presente un messaggio.  
  
 Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo legge, ma non rimuovere il primo messaggio dalla coda. Pertanto, le chiamate ripetute a <xref:System.Messaging.MessageQueue.Peek%2A> restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo, d'altra parte, legge e rimuove il primo messaggio dalla coda. Le chiamate ripetute a <xref:System.Messaging.MessageQueue.Receive%2A>, pertanto, restituire diversi tipi di messaggi.  
  
 I messaggi vengono ordinati da Accodamento messaggi nella coda in base al tempo di priorità e di arrivo. Un messaggio più recente viene inserito prima uno precedente solo se si tratta di una priorità più alta.  
  
 Utilizzare il metodo <xref:System.Messaging.MessageQueue.Peek%2A> quando è possibile bloccare il thread corrente durante l'attesa dell'arrivo di un messaggio nella coda. Il thread verrà bloccato fino al periodo specificato di tempo o in modo indefinito se è stato specificato <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Se si desidera che l'elaborazione dell'applicazione continui senza attendere, utilizzare il metodo asincrono <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo con un timeout pari a zero per verificare se la coda è vuota.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica il tempo massimo di attesa affinché un messaggio venga inserito nella coda.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <param name="action">Uno dei valori di <see cref="T:System.Messaging.PeekAction" />. Indica se leggere il messaggio corrente nella coda oppure il messaggio successivo.</param>
        <summary>Termina senza rimuovere (legge) il messaggio corrente o successivo della coda, utilizzando il cursore specificato. Poiché il metodo <see cref="M:System.Messaging.MessageQueue.Peek" /> è sincrono, blocca il thread corrente finché non viene reso disponibile un messaggio o non si verifica il timeout specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che rappresenta un messaggio della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per leggere una coda o di un determinato periodo di tempo fino a quando non è disponibile un messaggio nella coda di attesa. Il metodo restituisce immediatamente se nella coda è già presente un messaggio.  
  
 Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo legge, ma non rimuove, un messaggio dalla coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo, d'altra parte, legge e rimuove un messaggio dalla coda.  
  
 Utilizzare il metodo <xref:System.Messaging.MessageQueue.Peek%2A> quando è possibile bloccare il thread corrente durante l'attesa dell'arrivo di un messaggio nella coda. Il thread è bloccato fino al periodo specificato di tempo o in modo indefinito se è stato specificato <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Se si desidera che l'elaborazione dell'applicazione continui senza attendere, utilizzare il metodo asincrono <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">È stato specificato un valore diverso da <see langword="PeekAction.Current" /> o <see langword="PeekAction.Next" /> per il parametro <paramref name="action" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="cursor" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido. Probabilmente <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge un messaggio che corrisponde a un determinato identificatore di correlazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da leggere.</param>
        <summary>Legge il messaggio che corrisponde all'identificatore di correlazione specificato e, se nella coda non è disponibile correntemente alcun messaggio con l'identificatore di correlazione specificato, genererà immediatamente un'eccezione.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca nella coda a cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio il cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Se non viene trovato alcun messaggio corrispondente la `correlationID` parametro, viene generata un'eccezione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, report o riconoscimento associati.  
  
 È possibile leggere i messaggi in una coda utilizzando altri due metodi. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo viene utilizzato per recuperare un messaggio specificando il relativo identificatore univoco.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio che contiene un ordine da e verso una coda. Richiede un riconoscimento positivo in particolare quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="correlationId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da leggere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <summary>Legge il messaggio che corrisponde all'identificatore di correlazione specificato e attende che un messaggio con l'identificatore di correlazione specificato sia disponibile nella coda o che il timeout scada.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca nella coda a cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio il cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Se non viene trovato alcun messaggio corrispondente il `correlationID` parametro e nessun nuovo messaggio arriva nella coda entro il periodo specificato per il `timeout` parametro, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina il <xref:System.Messaging.Message.CorrelationId%2A> del nuovo messaggio per verificare che corrisponda il `correlationId` parametro. In caso contrario, questo metodo avvia il periodo di timeout su e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare all'interno del periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, finché non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.CorrelationId%2A> corrisponde il `correlationId` parametro.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, report o riconoscimento associati.  
  
 È possibile leggere i messaggi in una coda utilizzando altri due metodi. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo viene utilizzato per recuperare un messaggio specificando il relativo identificatore univoco.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il messaggio con l'oggetto <paramref name="correlationId" /> specificato non è presente nella coda e non è arrivato prima della scadenza del timeout.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato prima della scadenza del timeout.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una copia del messaggio con l'identificatore di messaggio specificato, senza rimuovere il messaggio dalla coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da leggere.</param>
        <summary>Legge il messaggio il cui identificatore corrisponde al parametro <paramref name="id" />.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> per leggere, senza rimozione dalla coda, un messaggio che contiene un identificatore di messaggio conosciuto. L'identificatore di un messaggio è univoco all'interno dell'azienda, Accodamento messaggi verrà al massimo un messaggio nella coda corrispondente il determinato `id` parametro. Questo overload genera un'eccezione se la coda non è attualmente contiene il messaggio.  
  
 Altri due metodi consentono di leggere i messaggi in una coda: <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce il primo messaggio nella coda. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> restituisce un riconoscimento, report o il messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Non è disponibile alcun messaggio con il parametro <paramref name="id" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da leggere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <summary>Legge il messaggio il cui identificatore corrisponde al parametro <paramref name="id" />. Attende che il messaggio venga visualizzato nella coda o che si verifichi il timeout.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> per leggere, senza rimozione dalla coda, un messaggio che contiene un identificatore di messaggio conosciuto. L'identificatore di un messaggio è univoco all'interno dell'azienda, Accodamento messaggi verrà al massimo un messaggio nella coda corrispondente il determinato `id` parametro. Questo overload genera un'eccezione se la coda non è attualmente contiene il messaggio e un nuovo messaggio è arrivato prima del timeout.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina il <xref:System.Messaging.Message.Id%2A> del nuovo messaggio per verificare che corrisponda il `id` parametro. In caso contrario, questo metodo avvia il periodo di timeout su e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare all'interno del periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, finché non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.Id%2A> corrisponde il `id` parametro.  
  
 Altri due metodi consentono di leggere i messaggi in una coda: <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce il primo messaggio nella coda. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> restituisce un riconoscimento, report o il messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il messaggio con l'oggetto <paramref name="id" /> specificato non è presente nella coda e non è arrivato prima della scadenza del periodo di tempo specificato dal parametro <paramref name="timeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introdotto in MSMQ 3.0. Legge un messaggio specifico nella coda. Il messaggio può essere specificato da un identificatore di ricerca o in base alla relativa posizione all'inizio o alla fine della coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Proprietà <see cref="P:System.Messaging.Message.LookupId" /> del messaggio da leggere.</param>
        <summary>Introdotto in MSMQ 3.0. Legge il messaggio che corrisponde all'identificatore di ricerca specificato da una coda non transazionale.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.LookupId" /> corrisponde al parametro <paramref name="lookupId" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore di ricerca conosciuto senza rimuoverlo dalla coda. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà di un messaggio è univoca per la coda in cui risiede il messaggio, pertanto si verificheranno al massimo un messaggio nella coda corrispondente il determinato `lookupId` parametro.  
  
 Per leggere un messaggio con un identificatore di ricerca specificato e rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="lookupId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">Uno dei valori di <see cref="T:System.Messaging.MessageLookupAction" />, che specifica come deve essere letto il messaggio nella coda. Specificare uno dei valori seguenti:  
  
 <see langword="MessageLookupAction.Current" />: legge il messaggio specificato da <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Next" />: legge il messaggio che segue il messaggio specificato da <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Previous" />: legge il messaggio che precede il messaggio specificato da <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.First" />: legge il primo messaggio della coda. È necessario che il parametro <c>lookupId</c> sia impostato su 0.  
  
 <see langword="MessageLookupAction.Last" />: legge l'ultimo messaggio della coda. È necessario che il parametro <c>lookupId</c> sia impostato su 0.</param>
        <param name="lookupId">Proprietà <see cref="P:System.Messaging.Message.LookupId" /> del messaggio da leggere oppure 0. 0 viene utilizzato quando si accede al primo o all'ultimo messaggio della coda.</param>
        <summary>Introdotto in MSMQ 3.0. Legge un messaggio specifico nella coda. Il messaggio può essere specificato da un identificatore di ricerca o in base alla relativa posizione all'inizio o alla fine della coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> specificato dai parametri <paramref name="action" /> e <paramref name="lookupId" /> passati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore di ricerca conosciuto senza rimuoverlo dalla coda. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà di un messaggio è univoca per la coda in cui risiede il messaggio, pertanto si verificheranno al massimo un messaggio nella coda corrispondente il determinato `lookupId` parametro.  
  
 Per leggere un messaggio con un identificatore specificato e rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="lookupId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="action" /> non è uno dei membri di <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando un messaggio viene letto senza essere rimosso dalla coda. Si tratta del risultato dell'operazione asincrona <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> viene utilizzato nell'elaborazione asincrona per generare il <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando un messaggio è disponibile nella coda.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> viene usato per completare l'operazione avviata da una chiamata a <xref:System.Messaging.MessageQueue.BeginPeek%2A> e per leggere il messaggio quando il <xref:System.Messaging.MessageQueue.PeekCompleted> viene generato l'evento.  
  
 Quando si crea un delegato <xref:System.Messaging.PeekCompletedEventHandler>, si identifica il metodo che gestirà l'evento. Per associare l'evento al gestore eventi in uso, aggiungere all'evento un'istanza del delegato. Il gestore eventi viene chiamato ogni volta che si verifica l'evento, a meno che non venga rimosso il delegato. Per ulteriori informazioni sui delegati del gestore eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un gestore eventi denominato `MyPeekCompleted`, lo collega al <xref:System.Messaging.MessageQueue.PeekCompleted> delegato del gestore eventi e chiamate <xref:System.Messaging.MessageQueue.BeginPeek%2A> per avviare un'operazione di lettura asincrona in coda che si trova nel percorso ". \myQueue". Quando un <xref:System.Messaging.MessageQueue.PeekCompleted> evento viene generato, l'esempio legge il messaggio e scrive il corpo sullo schermo. Nell'esempio viene quindi chiamato <xref:System.Messaging.MessageQueue.BeginPeek%2A> per avviare una nuova operazione di lettura asincrona  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina tutti i messaggi contenuti nella coda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La coda viene eliminata, impostare il flag di modifica della coda, che influisce sull'accodamento messaggi di <xref:System.Messaging.MessageQueue.LastModifyTime%2A> proprietà. I messaggi vengono eliminati dalla coda vanno persi. essi non vengono inviati per la coda di messaggi non recapitabili o nella coda journal.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome descrittivo che identifica la coda.</summary>
        <value>Nome che identifica la coda a cui questo oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Il valore non può essere <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile combinare la <xref:System.Messaging.MessageQueue.QueueName%2A> con il <xref:System.Messaging.MessageQueue.MachineName%2A> per creare un semplice <xref:System.Messaging.MessageQueue.Path%2A> nome per la coda. La sintassi per la variazione del nome descrittivo della <xref:System.Messaging.MessageQueue.Path%2A> proprietà dipende dal tipo di coda, come illustrato nella tabella seguente.  
  
|Tipo di coda|Sintassi|  
|----------------|------------|  
|Coda pubblica|`MachineName`\\`QueueName`|  
|Coda privata|`MachineName`\\`Private$`\\`QueueName`|  
|Coda journal|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Utilizzare "." per rappresentare il computer locale.  
  
 Modifica il <xref:System.Messaging.MessageQueue.QueueName%2A> influisce sulle proprietà di <xref:System.Messaging.MessageQueue.Path%2A> proprietà. Se si imposta la <xref:System.Messaging.MessageQueue.QueueName%2A> senza impostare il <xref:System.Messaging.MessageQueue.MachineName%2A> proprietà, il <xref:System.Messaging.MessageQueue.Path%2A> proprietà diventa.\\ `QueueName`. In caso contrario, il <xref:System.Messaging.MessageQueue.Path%2A> diventa `MachineName` \\ `QueueName`.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|Yes|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.QueueName%2A> proprietà.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome della coda è <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle nativo utilizzato per leggere i messaggi dalla coda di messaggi.</summary>
        <value>Handle all'oggetto coda nativo utilizzato per leggere e ricevere messaggi dalla coda.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.ReadHandle%2A> fornisce un handle nativo di Windows per l'oggetto coda di messaggi utilizzato per leggere e ricevere messaggi dalla coda. Se si modifica il percorso della coda, l'handle è chiuso e riaperto con un nuovo valore.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <summary>Riceve il primo messaggio della coda rimuovendolo da quest'ultima.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riceve il primo messaggio disponibile nella coda a cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Questa chiamata è sincrona e blocca il thread corrente di esecuzione finché non è disponibile un messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda o attendere fino a quando non sono presenti messaggi nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura sincrona di un messaggio, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> verranno restituiti i messaggi successivi nella coda o i nuovi messaggi con priorità più alta.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Utilizzare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre è in attesa di un messaggio è arrivato nella coda. Poiché questo overload del metodo di <xref:System.Messaging.MessageQueue.Receive%2A> metodo specifica un timeout infinito, l'applicazione potrebbe attendere all'infinito. Se l'elaborazione dell'applicazione continui senza attendere il messaggio, è consigliabile utilizzare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente riceve un messaggio da una coda e restituisce informazioni su tale messaggio sullo schermo.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il primo messaggio disponibile nella coda transazionale a cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Questa chiamata è sincrona e blocca il thread corrente di esecuzione finché non è disponibile un messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda transazionale utilizzando il contesto di transazione interna definito dal `transaction` parametro o attendere fino a quando non sono presenti messaggi nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura sincrona di un messaggio, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> verranno restituiti i messaggi successivi nella coda.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. Poiché <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback mediante una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilizzare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre è in attesa di un messaggio è arrivato nella coda. Poiché questo overload del metodo di <xref:System.Messaging.MessageQueue.Receive%2A> metodo specifica un timeout infinito, l'applicazione potrebbe attendere all'infinito. Se l'elaborazione dell'applicazione continui senza attendere il messaggio, è consigliabile utilizzare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente si connette a una coda transazionale nel computer locale e invia un messaggio alla coda. Viene quindi ricevuto il messaggio che contiene un ordine. Se viene rilevata una coda non transazionale, verrà generata eccezione e il rollback della transazione.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.  
  
 oppure  
  
 La coda non è transazionale.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il primo messaggio disponibile nella coda a cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Questa chiamata è sincrona e blocca il thread corrente di esecuzione finché non è disponibile un messaggio.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda utilizzando il contesto di transazione definito dal `transactionType` parametro o attendere fino a quando non sono presenti messaggi nella coda.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale di fuori di un contesto di transazione.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura sincrona di un messaggio, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> verranno restituiti i messaggi successivi nella coda.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. Poiché <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback mediante una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilizzare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre è in attesa di un messaggio è arrivato nella coda. Poiché questo overload del metodo di <xref:System.Messaging.MessageQueue.Receive%2A> metodo specifica un timeout infinito, l'applicazione potrebbe attendere all'infinito. Se l'elaborazione dell'applicazione continui senza attendere il messaggio, è consigliabile utilizzare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <summary>Riceve il primo messaggio disponibile nella coda cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento e attende che un messaggio sia disponibile nella coda o che il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere e restituire un messaggio in un periodo di tempo specificato se nella coda non sono disponibili messaggi.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura sincrona di un messaggio, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> verranno restituiti i messaggi successivi nella coda o i nuovi messaggi con priorità più alta.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Utilizzare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre è in attesa di un messaggio è arrivato nella coda. Il thread verrà bloccato per il periodo di tempo o in modo indefinito se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro. Se l'elaborazione dell'applicazione continui senza attendere un messaggio, è consigliabile utilizzare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente riceve un messaggio da una coda e restituisce informazioni su tale messaggio sullo schermo. Nell'esempio viene sospesa l'esecuzione per un massimo di cinque secondi, durante l'attesa di un messaggio è arrivato nella coda.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <summary>Riceve il messaggio corrente nella coda, utilizzando il cursore specificato. Se non è disponibile alcun messaggio, il metodo aspetta finché non risulta disponibile un messaggio o finché non scade il periodo di timeout.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.  
  
 Utilizzare questo overload per ricevere e restituire un messaggio in un periodo di tempo specificato se nella coda non sono disponibili messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il primo messaggio disponibile nella coda transazionale cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento e attende che un messaggio sia disponibile nella coda o che il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda transazionale utilizzando il contesto di transazione interna definito dal `transaction` parametro e restituire all'interno di un determinato periodo di tempo se non sono presenti messaggi nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura sincrona di un messaggio, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> verranno restituiti i messaggi successivi nella coda.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. Poiché <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback mediante una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilizzare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre è in attesa di un messaggio è arrivato nella coda. Il thread verrà bloccato per il periodo di tempo o in modo indefinito se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro. Se l'elaborazione dell'applicazione continui senza attendere un messaggio, è consigliabile utilizzare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo metodo.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
 oppure  
  
 La coda non è transazionale.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il primo messaggio disponibile nella coda a cui <see cref="T:System.Messaging.MessageQueue" /> fa riferimento. Questa chiamata è sincrona e attende che un messaggio venga reso disponibile nella coda o il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento al primo messaggio disponibile nella coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda utilizzando il contesto di transazione definito dal `transactionType` parametro e restituire in un determinato periodo di tempo se non sono presenti messaggi nella coda.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale di fuori di un contesto di transazione.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura sincrona di un messaggio, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> verranno restituiti i messaggi successivi nella coda.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere il primo messaggio in una coda senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo. Il <xref:System.Messaging.MessageQueue.Peek%2A> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. Poiché <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback mediante una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilizzare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre è in attesa di un messaggio è arrivato nella coda. Il thread verrà bloccato per il periodo di tempo o in modo indefinito se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro. Se l'elaborazione dell'applicazione continui senza attendere un messaggio, è consigliabile utilizzare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di questo metodo.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il messaggio corrente nella coda, utilizzando il cursore specificato. Se non è disponibile alcun messaggio, il metodo aspetta finché non risulta disponibile un messaggio o finché non scade il periodo di timeout.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento a un messaggio della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda transazionale utilizzando il contesto di transazione interna definito dal `transaction` parametro e restituire all'interno di un determinato periodo di tempo se non sono presenti messaggi nella coda.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura sincrona di un messaggio, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> restituiscono i messaggi successivi nella coda.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere un messaggio in una coda senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. Poiché <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non è necessario eseguire il rollback da una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilizzare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre è in attesa di un messaggio è arrivato nella coda. Il thread è bloccato per il periodo di tempo o in modo indefinito se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro. Se l'elaborazione dell'applicazione continui senza attendere un messaggio, è consigliabile utilizzare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="cursor" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido. Probabilmente <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
 oppure  
  
 La coda non è transazionale.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="cursor">Oggetto <see cref="T:System.Messaging.Cursor" /> che occupa una posizione specifica nella coda messaggi.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il messaggio corrente nella coda, utilizzando il cursore specificato. Se non è disponibile alcun messaggio, il metodo aspetta finché non risulta disponibile un messaggio o finché non scade il periodo di timeout.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> che fa riferimento a un messaggio della coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per ricevere un messaggio da una coda utilizzando il contesto di transazione definito dal `transactionType` parametro e restituire in un determinato periodo di tempo se non sono presenti messaggi nella coda.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale di fuori di un contesto di transazione.  
  
 Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo consente la lettura sincrona di un messaggio, rimuovendolo dalla coda. Le chiamate successive a <xref:System.Messaging.MessageQueue.Receive%2A> restituiscono i messaggi successivi nella coda.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto viene restituito alla coda se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere un messaggio in una coda senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.Peek%2A> metodo. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.Peek%2A>. Poiché <xref:System.Messaging.MessageQueue.Peek%2A> non rimuove i messaggi nella coda, non è necessario eseguire il rollback da una chiamata a <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilizzare una chiamata a <xref:System.Messaging.MessageQueue.Receive%2A> quando è accettabile per il thread corrente resti bloccato mentre è in attesa di un messaggio è arrivato nella coda. Il thread è bloccato per il periodo di tempo o in modo indefinito se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro. Se l'elaborazione dell'applicazione continui senza attendere un messaggio, è consigliabile utilizzare il metodo asincrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="cursor" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido. Probabilmente <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio non è arrivato nella coda prima della scadenza del timeout.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <threadsafe>Il metodo non è thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riceve un messaggio che corrisponde a un determinato identificatore di correlazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato (da una coda non transazionale) e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore di correlazione specificato.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca nella coda non transazionale a cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio il cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Se non viene trovato alcun messaggio corrispondente la `correlationID` parametro, viene generata un'eccezione. In caso contrario, il messaggio viene rimosso dalla coda e restituito all'applicazione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> che consente di recuperare un messaggio specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente invia e riceve un messaggio che contiene un ordine da e verso una coda. Richiede un riconoscimento positivo in particolare quando il messaggio originale raggiunge o viene recuperato dalla coda.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="correlationId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato (da una coda transazionale) e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore di correlazione specificato.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca nella coda transazionale a cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio il cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Se non viene trovato alcun messaggio corrispondente la `correlationID` parametro, viene generata un'eccezione. In caso contrario, il messaggio viene rimosso dalla coda e restituito all'applicazione utilizzando il contesto di transazione interna definito dal `transaction` parametro.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo viene utilizzato per recuperare un messaggio specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback se la transazione viene interrotta.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="correlationId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La coda non è transazionale.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore di correlazione specificato.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca nella coda a cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio il cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Se non viene trovato alcun messaggio corrispondente la `correlationID` parametro, viene generata un'eccezione. In caso contrario, il messaggio viene rimosso dalla coda e restituito all'applicazione utilizzando il contesto di transazione definito dal `transactionType` parametro.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale di fuori di un contesto di transazione.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo viene utilizzato per recuperare un messaggio specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback se la transazione viene interrotta.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="correlationId" /> specificato.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato (da una coda non transazionale) e attende che un messaggio con l'identificatore di correlazione specificato sia disponibile nella coda oppure che il timeout scada.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca nella coda non transazionale a cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio il cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Questo metodo restituisce immediatamente se il messaggio con l'identificatore di correlazione specificato mediante il `correlationId` parametro si trova nella coda. In caso contrario, il metodo attende il periodo di tempo per l'arrivo di un nuovo messaggio specifico. Se non arriva un nuovo messaggio prima della scadenza del timeout, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina il <xref:System.Messaging.Message.CorrelationId%2A> del nuovo messaggio per verificare che corrisponda il `correlationId` parametro. In caso contrario, questo metodo avvia il periodo di timeout su e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare all'interno del periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, finché non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.CorrelationId%2A> corrisponde il `correlationId` parametro.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo viene utilizzato per recuperare un messaggio specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il messaggio con l'oggetto <paramref name="correlationId" /> specificato non è presente nella coda e non è arrivato prima della scadenza del timeout.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato (da una coda transazionale) e attende che un messaggio con l'identificatore di correlazione specificato sia disponibile nella coda oppure che il timeout scada.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca nella coda transazionale a cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio il cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Questo metodo restituisce immediatamente se il messaggio con l'identificatore di correlazione specificato mediante il `correlationId` si trova nella coda, utilizzando il contesto di transazione interna definito dal parametro di `transaction` parametro. In caso contrario, il metodo attende il periodo di tempo per l'arrivo di un nuovo messaggio specifico. Se non arriva un nuovo messaggio prima della scadenza del timeout, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina il <xref:System.Messaging.Message.CorrelationId%2A> del nuovo messaggio per verificare che corrisponda il `correlationId` parametro. In caso contrario, questo metodo avvia il periodo di timeout su e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare all'interno del periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, finché non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.CorrelationId%2A> corrisponde il `correlationId` parametro.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo viene utilizzato per recuperare un messaggio specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback se la transazione viene interrotta.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il messaggio con l'oggetto <paramref name="correlationId" /> specificato non è presente nella coda e non è arrivato prima della scadenza del timeout.  
  
 oppure  
  
 La coda non è transazionale.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Oggetto <see cref="P:System.Messaging.Message.CorrelationId" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore di correlazione specificato e attende che un messaggio con l'identificatore di correlazione specificato sia disponibile nella coda o che il timeout scada.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> il cui <see cref="P:System.Messaging.Message.CorrelationId" /> corrisponde al parametro <paramref name="correlationId" /> trasmesso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca nella coda a cui fa riferimento il <xref:System.Messaging.MessageQueue> per un messaggio il cui <xref:System.Messaging.Message.CorrelationId%2A> corrisponde al valore specificato `correlationId` parametro. Questo metodo restituisce immediatamente se il messaggio con l'identificatore di correlazione specificato mediante il `correlationId` si trova nella coda, utilizzando il contesto di transazione definito dal parametro di `transactionType` parametro. In caso contrario, il metodo attende il periodo di tempo per l'arrivo di un nuovo messaggio specifico. Se non arriva un nuovo messaggio prima della scadenza del timeout, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina il <xref:System.Messaging.Message.CorrelationId%2A> del nuovo messaggio per verificare che corrisponda il `correlationId` parametro. In caso contrario, questo metodo avvia il periodo di timeout su e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare all'interno del periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, finché non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.CorrelationId%2A> corrisponde il `correlationId` parametro. Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale di fuori di un contesto di transazione.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Il <xref:System.Messaging.Message.CorrelationId%2A> proprietà viene utilizzata per collegare un messaggio inviato alla coda di messaggi di risposta, report o riconoscimento associati.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metodo viene utilizzato per recuperare un messaggio specificando il relativo identificatore univoco.  
  
 Per leggere un messaggio con un identificatore di correlazione specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback se la transazione viene interrotta.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="correlationId" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="correlationId" /> specificato.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Il messaggio con l'oggetto <paramref name="correlationId" /> specificato non è presente nella coda e non è arrivato prima della scadenza del timeout.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riceve il messaggio corrispondente all'identificatore specificato rimuovendolo dalla coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore specificato da una coda non transazionale e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore noto e rimuoverlo dalla coda. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.Id%2A> verrà al massimo un messaggio nella coda corrispondente è univoca in Accodamento messaggi, proprietà di un messaggio il determinato `id` parametro.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="id" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore specificato (da una coda transazionale) e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore noto e rimuoverlo dalla coda, utilizzando il contesto di transazione interna definito per il `transaction` parametro. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda  
  
 Il <xref:System.Messaging.Message.Id%2A> verrà al massimo un messaggio nella coda corrispondente è univoca in Accodamento messaggi, proprietà di un messaggio il determinato `id` parametro.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback se la transazione viene interrotta.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="id" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La coda non è transazionale.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il messaggio corrispondente all'identificatore specificato e genera subito un'eccezione se nella coda non è disponibile alcun messaggio con l'identificatore specificato.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore noto e rimuoverlo dalla coda. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda. In caso contrario, il messaggio viene rimosso dalla coda e restituito all'applicazione utilizzando il contesto di transazione definito dal `transactionType` parametro.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale di fuori di un contesto di transazione.  
  
 Il <xref:System.Messaging.Message.Id%2A> verrà al massimo un messaggio nella coda corrispondente è univoca in Accodamento messaggi, proprietà di un messaggio il determinato `id` parametro. Se il messaggio con l'identificatore specificato è in una coda diversa da quella associata a questo <xref:System.Messaging.MessageQueue> , il messaggio verrà trovare l'istanza.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback se la transazione viene interrotta.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="id" /> specificato.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <summary>Riceve il messaggio corrispondente all'identificatore specificato (da una coda non transazionale) e attende che un messaggio con l'identificatore specificato sia disponibile nella coda o che il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore noto e rimuoverlo dalla coda. Questo metodo restituisce immediatamente se il messaggio con l'identificatore specificato mediante il `id` parametro si trova nella coda. In caso contrario, il metodo attende il periodo di tempo per l'arrivo di un nuovo messaggio specifico. Se non arriva un nuovo messaggio prima della scadenza del timeout, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina il <xref:System.Messaging.Message.Id%2A> del nuovo messaggio per verificare che corrisponda il `id` parametro. In caso contrario, questo metodo avvia il periodo di timeout su e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare all'interno del periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, finché non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.Id%2A> corrisponde il `id` parametro.  
  
 Il <xref:System.Messaging.Message.Id%2A> verrà al massimo un messaggio nella coda corrispondente è univoca in Accodamento messaggi, proprietà di un messaggio il determinato `id` parametro.  
  
 Utilizzare questo overload di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando è accettabile per il thread corrente resti bloccato fino a quando nuovi messaggi continuano ad arrivare nella coda durante il periodo di timeout specificato il `timeout` parametro. Il thread verrà bloccato per il periodo di tempo o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro, o se i nuovi messaggi continuano ad arrivare nella coda entro il periodo di timeout specificato per il `timeout` parametro.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio con il parametro <paramref name="id" /> specificato non è arrivato nella coda prima della scadenza del timeout.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Riceve il messaggio corrispondente all'identificatore specificato (da una coda transazionale) e attende che un messaggio con l'identificatore specificato sia disponibile nella coda o che il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore noto e rimuoverlo dalla coda, utilizzando il contesto di transazione interna definito per il `transaction` parametro. Questo metodo restituisce immediatamente se il messaggio con l'identificatore specificato mediante il `id` parametro si trova nella coda. In caso contrario, il metodo attende il periodo di tempo per l'arrivo di un nuovo messaggio specifico. Se non arriva un nuovo messaggio prima della scadenza del timeout, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina il <xref:System.Messaging.Message.Id%2A> del nuovo messaggio per verificare che corrisponda il `id` parametro. In caso contrario, questo metodo avvia il periodo di timeout su e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare all'interno del periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, finché non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.Id%2A> corrisponde il `id` parametro.  
  
 Il <xref:System.Messaging.Message.Id%2A> verrà al massimo un messaggio nella coda corrispondente è univoca in Accodamento messaggi, proprietà di un messaggio il determinato `id` parametro.  
  
 Utilizzare questo overload di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando è accettabile per il thread corrente resti bloccato fino a quando nuovi messaggi continuano ad arrivare nella coda durante il periodo di timeout specificato il `timeout` parametro. Il thread verrà bloccato per il periodo di tempo o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro, o se nuovi messaggi arrivano nella coda entro il periodo di timeout specificato per il `timeout` parametro.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback se la transazione viene interrotta.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio con il parametro <paramref name="id" /> specificato non è arrivato nella coda prima della scadenza del timeout.  
  
 oppure  
  
 La coda non è transazionale.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.Messaging.Message.Id" /> del messaggio da ricevere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che indica l'intervallo di attesa prima che un nuovo messaggio venga reso disponibile per il controllo.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Riceve il messaggio che corrisponde all'identificatore specificato e attende che un messaggio con l'identificatore specificato sia disponibile nella coda o che il timeout scada.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.Id" /> corrisponde al parametro <paramref name="id" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore noto e rimuoverlo dalla coda. Questo metodo restituisce immediatamente se il messaggio con l'identificatore specificato mediante il `id` si trova nella coda, utilizzando il contesto di transazione definito dal parametro di `transactionType` parametro. In caso contrario, il metodo attende il periodo di tempo per l'arrivo di un nuovo messaggio specifico. Se non arriva un nuovo messaggio prima della scadenza del timeout, viene generata un'eccezione.  
  
 Il `timeout` parametro specifica il totale tempo di esecuzione per questo metodo. Piuttosto, specifica il tempo di attesa per un nuovo messaggio in arrivo nella coda. Ogni volta che arriva un nuovo messaggio, questo metodo esamina il <xref:System.Messaging.Message.Id%2A> del nuovo messaggio per verificare che corrisponda il `id` parametro. In caso contrario, questo metodo avvia il periodo di timeout su e attende l'arrivo di un nuovo messaggio. Pertanto, se i nuovi messaggi continuano ad arrivare all'interno del periodo di timeout, è possibile che questo metodo venga eseguito all'infinito, finché non scade il periodo di timeout senza eventuali nuovi messaggi in arrivo o fino a quando non arriva un messaggio la cui proprietà <xref:System.Messaging.Message.Id%2A> corrisponde il `id` parametro.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale di fuori di un contesto di transazione.  
  
 Il <xref:System.Messaging.Message.Id%2A> verrà al massimo un messaggio nella coda corrispondente è univoca in Accodamento messaggi, proprietà di un messaggio il determinato `id` parametro. Se il messaggio con l'identificatore specificato è in una coda diversa da quella associata a questo <xref:System.Messaging.MessageQueue> , il messaggio verrà trovare l'istanza.  
  
 Utilizzare questo overload di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando è accettabile per il thread corrente resti bloccato fino a quando nuovi messaggi continuano ad arrivare nella coda durante il periodo di timeout specificato il `timeout` parametro. Il thread verrà bloccato per il periodo di tempo o per un periodo illimitato se è stato specificato il valore <xref:System.Messaging.MessageQueue.InfiniteTimeout> per il `timeout` parametro, o se i nuovi messaggi continuano ad arrivare nella coda entro il periodo di timeout specificato per il `timeout` parametro.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Altri due metodi consentono di ricevere messaggi da una coda. Il <xref:System.Messaging.MessageQueue.Receive%2A> metodo restituisce il primo messaggio della coda e <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metodo viene utilizzato per recuperare un riconoscimento, un report o un messaggio di risposta generati dall'applicazione che è stato creato come risultato di un messaggio inviato alla coda.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo. Il <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metodo restituisce sempre il primo messaggio della coda, le chiamate successive al metodo restituiscono lo stesso messaggio, a meno che un messaggio con priorità più alta arriva nella coda. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Poiché <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> non rimuove i messaggi nella coda, non vi sarà nulla per eseguire il rollback se la transazione viene interrotta.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per il parametro <paramref name="timeout" /> non è valido, probabilmente perché <paramref name="timeout" /> è minore di <see cref="F:System.TimeSpan.Zero" /> o maggiore di <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un messaggio con il parametro <paramref name="id" /> specificato non è arrivato nella coda prima della scadenza del timeout.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introdotto in MSMQ 3.0. Riceve un messaggio specifico della coda. Il messaggio può essere specificato da un identificatore di ricerca o in base alla relativa posizione all'inizio o alla fine della coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Oggetto <see cref="P:System.Messaging.Message.LookupId" /> del messaggio da ricevere.</param>
        <summary>Introdotto in MSMQ 3.0. Riceve il messaggio che corrisponde all'identificatore di ricerca specificato da una coda non transazionale.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> la cui proprietà <see cref="P:System.Messaging.Message.LookupId" /> corrisponde al parametro <paramref name="lookupId" /> passato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore di ricerca noto e rimuoverlo dalla coda. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà di un messaggio è univoca per la coda in cui risiede il messaggio, pertanto si verificheranno al massimo un messaggio nella coda corrispondente il determinato `lookupId` parametro.  
  
 Per leggere un messaggio con un identificatore di ricerca specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metodo.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="lookupId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">Uno dei valori di <see cref="T:System.Messaging.MessageLookupAction" />, che specifica come deve essere letto il messaggio nella coda. Specificare uno dei valori seguenti:  
  
 <see langword="MessageLookupAction.Current" />: riceve il messaggio specificato da <c>lookupId</c> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.Next" />: riceve il messaggio che segue il messaggio specificato da <c>lookupId</c> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.Previous" />: riceve il messaggio che precede il messaggio specificato da <c>lookupId</c> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.First" />: riceve il primo messaggio della coda e lo rimuove da quest'ultima. È necessario che il parametro <c>lookupId</c> sia impostato su 0.  
  
 <see langword="MessageLookupAction.Last" />: riceve l'ultimo messaggio della coda e lo rimuove da quest'ultima. È necessario che il parametro <c>lookupId</c> sia impostato su 0.</param>
        <param name="lookupId">Oggetto <see cref="P:System.Messaging.Message.LookupId" /> del messaggio da ricevere oppure 0. 0 viene utilizzato quando si accede al primo o all'ultimo messaggio della coda.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Introdotto in MSMQ 3.0. Riceve un messaggio specifico da una coda transazionale. Il messaggio può essere specificato da un identificatore di ricerca o in base alla relativa posizione all'inizio o alla fine della coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> specificato dai parametri <paramref name="lookupId" /> e <paramref name="action" /> passati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore di ricerca noto e rimuoverlo dalla coda, utilizzando il contesto di transazione definito dal `transaction` parametro. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà di un messaggio è univoca per la coda in cui risiede il messaggio, pertanto si verificheranno al massimo un messaggio nella coda corrispondente il determinato `lookupId` parametro.  
  
 Poiché questo metodo viene chiamato su una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metodo. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Poiché <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> non rimuove i messaggi dalla coda, non vi sarà nulla per eseguire il rollback se la transazione viene interrotta.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="lookupId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.  
  
 oppure  
  
 La coda non è transazionale.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="action" /> non è uno dei membri di <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">Uno dei valori di <see cref="T:System.Messaging.MessageLookupAction" />, che specifica come deve essere letto il messaggio nella coda. Specificare uno dei valori seguenti:  
  
 <see langword="MessageLookupAction.Current" />: riceve il messaggio specificato da <c>lookupId</c> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.Next" />: riceve il messaggio che segue il messaggio specificato da <c>lookupId</c> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.Previous" />: riceve il messaggio che precede il messaggio specificato da <c>lookupId</c> e lo rimuove dalla coda.  
  
 <see langword="MessageLookupAction.First" />: riceve il primo messaggio della coda e lo rimuove da quest'ultima. È necessario che il parametro <c>lookupId</c> sia impostato su 0.  
  
 <see langword="MessageLookupAction.Last" />: riceve l'ultimo messaggio della coda e lo rimuove da quest'ultima. È necessario che il parametro <c>lookupId</c> sia impostato su 0.</param>
        <param name="lookupId">Oggetto <see cref="P:System.Messaging.Message.LookupId" /> del messaggio da ricevere oppure 0. 0 viene utilizzato quando si accede al primo o all'ultimo messaggio della coda.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Introdotto in MSMQ 3.0. Riceve un messaggio specifico della coda, utilizzando il contesto di transazione specificato. Il messaggio può essere specificato da un identificatore di ricerca o in base alla relativa posizione all'inizio o alla fine della coda.</summary>
        <returns>Oggetto <see cref="T:System.Messaging.Message" /> specificato dai parametri <paramref name="action" /> e <paramref name="lookupId" /> passati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per leggere un messaggio con un identificatore di ricerca noto e rimuoverlo dalla coda, utilizzando il contesto di transazione definito dal `transactionType` parametro. Questo metodo genera un'eccezione immediatamente se il messaggio non è presente nella coda.  
  
 Il <xref:System.Messaging.Message.LookupId%2A> proprietà di un messaggio è univoca per la coda in cui risiede il messaggio, pertanto si verificheranno al massimo un messaggio nella coda corrispondente il determinato `lookupId` parametro.  
  
 Per leggere un messaggio con un identificatore specificato senza rimuoverlo dalla coda, utilizzare il <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metodo. Nessun contesto di transazione associata a un messaggio restituito da una chiamata a <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Poiché <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> non rimuove i messaggi dalla coda, non vi sarà nulla per eseguire il rollback se la transazione viene interrotta.  
  
 Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per ricevere il messaggio. Specificare `Single` se si desidera ricevere il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera ricevere un messaggio da una coda transazionale di fuori di un contesto di transazione.  
  
 Se questo metodo viene chiamato per ricevere un messaggio da una coda transazionale, il messaggio ricevuto verrebbe restituito alla coda, se la transazione viene interrotta. Il messaggio non verrà rimosso definitivamente dalla coda fino a quando non viene eseguito il commit della transazione.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 non è installato.</exception>
        <exception cref="T:System.InvalidOperationException">Impossibile trovare il messaggio con il parametro <paramref name="lookupId" /> specificato.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="action" /> non è uno dei membri di <see cref="T:System.Messaging.MessageLookupAction" />.  
  
 oppure  
  
 Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Viene generato quando un messaggio è stato rimosso dalla coda. Questo evento viene generato dall'operazione asincrona <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> viene utilizzato nell'elaborazione asincrona per generare il <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando un messaggio è disponibile nella coda.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> viene usato per completare l'operazione avviata da una chiamata a <xref:System.Messaging.MessageQueue.BeginReceive%2A> e per leggere il messaggio quando il <xref:System.Messaging.MessageQueue.ReceiveCompleted> viene generato l'evento.  
  
 Quando si crea un delegato <xref:System.Messaging.ReceiveCompletedEventHandler>, si identifica il metodo che gestirà l'evento. Per associare l'evento al gestore eventi in uso, aggiungere all'evento un'istanza del delegato. Il gestore eventi viene chiamato ogni volta che si verifica l'evento, a meno che non venga rimosso il delegato. Per ulteriori informazioni sui delegati del gestore eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un gestore eventi denominato `MyReceiveCompleted`, lo collega al <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegato del gestore eventi e chiamate <xref:System.Messaging.MessageQueue.BeginReceive%2A> per avviare un'operazione di ricezione asincrona nella coda che si trova nel percorso ". \myQueue". Quando un <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento viene generato, l'esempio riceve il messaggio e scrive il corpo sullo schermo. Nell'esempio viene quindi chiamato <xref:System.Messaging.MessageQueue.BeginReceive%2A> per avviare un nuovo asincrono l'operazione di ricezione.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aggiorna le proprietà presentate da <see cref="T:System.Messaging.MessageQueue" /> per riflettere lo stato corrente della risorsa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> Sincronizza le proprietà di un <xref:System.Messaging.MessageQueue> con la risorsa server Accodamento messaggi associata. Se qualsiasi proprietà, ad esempio <xref:System.Messaging.MessageQueue.Label%2A> o <xref:System.Messaging.MessageQueue.Category%2A>, è stato modificato nel server dal momento la <xref:System.Messaging.MessageQueue> è stato creato, <xref:System.Messaging.MessageQueue.Refresh%2A> aggiornamenti il <xref:System.Messaging.MessageQueue> con le nuove informazioni.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta l'elenco delle autorizzazioni sui valori predefiniti del sistema operativo. Rimuove tutte le autorizzazioni relative alla coda aggiunte all'elenco predefinito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, restituire l'elenco di autorizzazione ai valori predefiniti. In genere, si concede al creatore della coda di tutte le autorizzazioni e concede al gruppo Everyone i diritti seguenti:  
  
-   Ottenere le proprietà della coda.  
  
-   Ottenere le autorizzazioni di coda.  
  
-   Consente di scrivere nella coda.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invia un oggetto a una coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <summary>Invia un oggetto alla coda non transazionale a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro alla coda a cui fa riferimento il <xref:System.Messaging.MessageQueue>. L'oggetto inviato alla coda può essere un <xref:System.Messaging.Message> o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio.  
  
 Se si utilizza questo overload per inviare un messaggio a una coda transazionale, il messaggio verrà inviato alla coda di messaggi non recapitabili. Se si desidera che il messaggio da parte di una transazione che contiene altri messaggi, usare un overload che accetta un <xref:System.Messaging.MessageQueueTransaction> o <xref:System.Messaging.MessageQueueTransactionType> come parametro.  
  
 Se non si imposta la <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto tranne un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità con il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori si applicano a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione invia alla coda. Quando si invia un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza su <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza sulla coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente si connette a una coda di messaggi e invia un messaggio alla coda.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 Esempio di codice seguente invia un parametro definito dall'applicazione `Order` classe a una coda e viene ricevuto un messaggio da tale coda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Invia un oggetto alla coda transazionale a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro nella coda transazionale a cui fa riferimento il <xref:System.Messaging.MessageQueue>, utilizzando un contesto di transazione interna definito dal `transaction` parametro. L'oggetto inviato alla coda può essere un <xref:System.Messaging.Message> o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio.  
  
 Se si utilizza questo overload per inviare un messaggio a una coda non transazionale, il messaggio potrebbe essere inviato alla coda di messaggi non recapitabili senza generare un'eccezione.  
  
 Se non si imposta la <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto tranne un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità con il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori si applicano a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione invia alla coda. Quando si invia un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza su <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza sulla coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 <xref:System.Messaging.MessageQueueTransaction> il threading apartment, pertanto se lo stato dell'apartment è `STA`, è possibile utilizzare la transazione in più thread. Visual Basic imposta lo stato del thread principale di `STA`, pertanto è necessario applicare il <xref:System.MTAThreadAttribute> nel `Main` subroutine. In caso contrario, l'invio di un messaggio transazionale mediante un altro thread genererà un'eccezione <xref:System.Messaging.MessageQueueException>. Si applica il <xref:System.MTAThreadAttribute> utilizzando il seguente frammento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 Esempio di codice seguente invia una stringa a una coda transazionale e viene ricevuto un messaggio da tale coda.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
 oppure  
  
 Nell'applicazione Accodamento messaggi è stato segnalato un utilizzo non corretto delle transazioni.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Invia un oggetto alla coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro alla coda a cui fa riferimento il <xref:System.Messaging.MessageQueue>, utilizzando il contesto di transazione definito dal `transactionType` parametro. Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per inviare il messaggio. Specificare `Single` se si desidera inviare il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera inviare un messaggio transazionale a un thread non transazionale.  
  
 L'oggetto inviato alla coda può essere un <xref:System.Messaging.Message> o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio.  
  
 Se non si imposta la <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto tranne un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità con il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori si applicano a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione invia alla coda. Quando si invia un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza su <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza sulla coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <param name="label">L'etichetta del messaggio.</param>
        <summary>Invia un oggetto alla coda non transazionale a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento e specifica un'etichetta per il messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro alla coda a cui fa riferimento il <xref:System.Messaging.MessageQueue>. Con questo overload, è possibile specificare l'etichetta della stringa che identifica il messaggio. L'oggetto inviato alla coda può essere un <xref:System.Messaging.Message>, una struttura, un oggetto dati o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio.  
  
 L'etichetta di messaggio è diverso dall'etichetta di coda di messaggi, ma entrambi sono dipendenti dall'applicazione e non hanno alcun significato di ereditarietà per Accodamento messaggi.  
  
 Se si utilizza questo overload per inviare un messaggio a una coda transazionale, il messaggio verrà inviato alla coda di messaggi non recapitabili. Se si desidera che il messaggio da parte di una transazione che contiene altri messaggi, usare un overload che accetta un <xref:System.Messaging.MessageQueueTransaction> o <xref:System.Messaging.MessageQueueTransactionType> come parametro.  
  
 Il <xref:System.Messaging.MessageQueue.Path%2A> proprietà per questo <xref:System.Messaging.MessageQueue> istanza deve essere specificata prima di inviare il messaggio. Se non si imposta la <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto tranne un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità con il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori si applicano a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione invia alla coda. Quando si invia un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza su <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza sulla coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="label" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <param name="label">L'etichetta del messaggio.</param>
        <param name="transaction">Oggetto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Invia un oggetto alla coda transazionale a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento e specifica un'etichetta per il messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro nella coda transazionale a cui fa riferimento il <xref:System.Messaging.MessageQueue>, utilizzando un contesto di transazione interna definito dal `transaction` parametro. Con questo overload, è possibile specificare l'etichetta della stringa che identifica il messaggio. L'oggetto inviato alla coda può essere un <xref:System.Messaging.Message>, una struttura, un oggetto dati o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio.  
  
 L'etichetta di messaggio è diverso dall'etichetta di coda di messaggi, ma entrambi sono dipendenti dall'applicazione e non hanno alcun significato di ereditarietà per Accodamento messaggi.  
  
 Se si utilizza questo overload per inviare un messaggio a una coda non transazionale, il messaggio potrebbe essere inviato alla coda di messaggi non recapitabili senza generare un'eccezione.  
  
 Se non si imposta la <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto tranne un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità con il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori si applicano a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione invia alla coda. Quando si invia un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza su <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza sulla coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà  
  
 <xref:System.Messaging.MessageQueueTransaction> il threading apartment, pertanto se lo stato dell'apartment è `STA`, è possibile utilizzare la transazione in più thread. Visual Basic imposta lo stato del thread principale di `STA`, pertanto è necessario applicare il <xref:System.MTAThreadAttribute> nel `Main` subroutine. In caso contrario, l'invio di un messaggio transazionale mediante un altro thread genererà un'eccezione <xref:System.Messaging.MessageQueueException>. Si applica il <xref:System.MTAThreadAttribute> utilizzando il seguente frammento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="label" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore del parametro <paramref name="transaction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
 oppure  
  
 Nell'applicazione Accodamento messaggi è stato segnalato un utilizzo non corretto delle transazioni.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da inviare alla coda.</param>
        <param name="label">L'etichetta del messaggio.</param>
        <param name="transactionType">Uno dei valori di <see cref="T:System.Messaging.MessageQueueTransactionType" /> che descrive il tipo di contesto di transazione da associare al messaggio.</param>
        <summary>Invia un oggetto alla coda a cui l'oggetto <see cref="T:System.Messaging.MessageQueue" /> fa riferimento e specifica un'etichetta per il messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per inviare un messaggio che contiene il `obj` parametro alla coda a cui fa riferimento il <xref:System.Messaging.MessageQueue>, utilizzando il contesto di transazione definito dal `transactionType` parametro. Specificare `Automatic` per il `transactionType` parametro se è già presente un contesto di transazione esterno associato al thread che si desidera utilizzare per inviare il messaggio. Specificare `Single` se si desidera inviare il messaggio come una singola transazione interna. È possibile specificare `None` se si desidera inviare un messaggio transazionale a un thread non transazionale.  
  
 L'oggetto inviato alla coda può essere un <xref:System.Messaging.Message> o qualsiasi oggetto gestito. Se si invia un oggetto diverso da un <xref:System.Messaging.Message>, l'oggetto viene serializzato e inserito nel corpo del messaggio. Con questo overload, è possibile specificare l'etichetta della stringa che identifica il messaggio.  
  
 L'etichetta di messaggio è diverso dall'etichetta di coda di messaggi, ma entrambi sono dipendenti dall'applicazione e non hanno alcun significato di ereditarietà per Accodamento messaggi.  
  
 Se non si imposta la <xref:System.Messaging.MessageQueue.Formatter%2A> proprietà prima di chiamare <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, per impostazione predefinita il formattatore di <xref:System.Messaging.XmlMessageFormatter>.  
  
 Il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> proprietà si applica a qualsiasi oggetto tranne un <xref:System.Messaging.Message>. Se si specifica, ad esempio, un'etichetta o una priorità con il <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, questi valori si applicano a qualsiasi messaggio che contiene un oggetto che non è di tipo <xref:System.Messaging.Message> quando l'applicazione invia alla coda. Quando si invia un <xref:System.Messaging.Message>, impostare i valori delle proprietà per il <xref:System.Messaging.Message> hanno la precedenza su <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>e il messaggio <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> avrà la precedenza sulla coda <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> proprietà.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="label" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Nell'applicazione Accodamento messaggi è stato segnalato un utilizzo non corretto delle transazioni.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Il parametro <paramref name="transactionType" /> non è uno dei membri di <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La proprietà <see cref="P:System.Messaging.MessageQueue.Path" /> non è stata impostata.  
  
 oppure  
  
 Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge le autorizzazioni al set di autorizzazioni corrente. Controlla gli utenti che dispongono dei diritti di accesso alle proprietà della coda e ai messaggi presenti nella coda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Oggetto <see cref="T:System.Messaging.AccessControlList" /> contenente una o più voci di controllo di accesso che specificano le terze parti trusted e le autorizzazioni da concedere.</param>
        <summary>Assegna i diritti di accesso alla coda in base al contenuto di un elenco di controllo di accesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per concedere, negare o revocare i diritti tramite una raccolta di voci di controllo di accesso per specificare informazioni trustee e le autorizzazioni. Questa viene utilizzata, ad esempio, per concedere le autorizzazioni a più utenti contemporaneamente.  
  
 Il trustee specificato quando si costruisce la `ace` parametro può essere un singolo utente, un gruppo di utenti o un computer. Se il dominio trusted è un singolo, utilizzare il formato `DOMAIN` \\ `user`. È possibile specificare "." per il dominio trusted indicare il computer locale.  
  
 Le autorizzazioni assegnate tramite <xref:System.Messaging.MessageQueue.SetPermissions%2A> aggiungere diritti per l'elenco esistente. Per impostazione predefinita, l'autore di una coda pubblica o privata dispone del controllo completo e il gruppo di dominio, chiunque dispone dell'autorizzazione per ottenere le proprietà della coda, ottenere le autorizzazioni e scrivere nella coda. Quando si chiama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, le informazioni e le autorizzazioni utente viene aggiunto alla fine dell'elenco esistente.  
  
 Il sistema esamina ciascuna <xref:System.Messaging.AccessControlEntry> in sequenza, fino a quando non si verifica uno dei seguenti eventi:  
  
-   Un accesso negato <xref:System.Messaging.AccessControlEntry> nega esplicitamente il qualsiasi dei diritti di accesso richiesto a uno dei fiduciari elencati nel token di accesso del thread.  
  
-   Uno o più accesso consentiti <xref:System.Messaging.AccessControlEntry> voci per tutti i diritti di accesso richiesto di concedere fiduciari elencati nel token di accesso del thread in modo esplicito.  
  
-   Tutti i <xref:System.Messaging.AccessControlEntry> articoli sono stati verificati e vi è ancora almeno un diritto di accesso che non è stato esplicitamente concesso, nel qual caso, viene implicitamente negato l'accesso.  
  
 Quando si costruisce la `dacl` parametro, aggiungere <xref:System.Messaging.AccessControlEntry> istanze per il <xref:System.Messaging.AccessControlList> insieme. Quando si crea ogni voce di controllo di accesso, è possibile specificare i diritti di accesso generici o standard. I diritti a una coda possono essere qualsiasi combinazione delle operazioni seguenti:  
  
-   Eliminare  
  
-   Sicurezza di lettura  
  
-   Protezione da scrittura  
  
-   Sincronizzare  
  
-   Modifica proprietario  
  
-   Lettura  
  
-   Write  
  
-   Esegui  
  
-   Obbligatorio  
  
-   Tutti  
  
-   nessuno  
  
 Tali diritti sono un set di flag di bit che è possibile combinare utilizzando l'operatore OR bit per bit.  
  
-   Controllo completo  
  
-   Eliminare il messaggio  
  
-   Ricezione messaggio  
  
-   Visualizza messaggio  
  
-   Registrazione del messaggio  
  
-   Ottenere le proprietà della coda  
  
-   Impostare le proprietà della coda  
  
-   Ottenere le autorizzazioni  
  
-   Impostare le autorizzazioni  
  
-   Diventare proprietario della coda  
  
-   Scrittura del messaggio  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Oggetto <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> che specifica un utente, un tipo di accesso e un tipo di autorizzazione.</param>
        <summary>Assegna i diritti di accesso alla coda in base al contenuto di una voce di controllo di accesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per concedere, negare o revocare i diritti tramite una voce di controllo di accesso per specificare informazioni sui diritti e il dominio trusted.  
  
 Il trustee specificato quando si costruisce la `ace` parametro può essere un singolo utente, un gruppo di utenti o un computer. Se il dominio trusted è un singolo, utilizzare il formato `DOMAIN` \\ `user`. È possibile specificare "." per il dominio trusted indicare il computer locale.  
  
 Le autorizzazioni assegnate tramite <xref:System.Messaging.MessageQueue.SetPermissions%2A> aggiungere diritti per l'elenco esistente. Per impostazione predefinita, l'autore di una coda pubblica o privata dispone del controllo completo e il gruppo di dominio, chiunque dispone dell'autorizzazione per ottenere le proprietà della coda, ottenere le autorizzazioni e scrivere nella coda. Quando si chiama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, le informazioni e le autorizzazioni utente viene aggiunto alla fine dell'elenco esistente.  
  
 Il sistema esamina ciascuna <xref:System.Messaging.AccessControlEntry> in sequenza, fino a quando non si verifica uno dei seguenti eventi:  
  
-   Un accesso negato <xref:System.Messaging.AccessControlEntry> nega esplicitamente il qualsiasi dei diritti di accesso richiesto a uno dei fiduciari elencati nel token di accesso del thread.  
  
-   Uno o più accesso consentiti <xref:System.Messaging.AccessControlEntry> voci per tutti i diritti di accesso richiesto di concedere fiduciari elencati nel token di accesso del thread in modo esplicito.  
  
-   Tutti i <xref:System.Messaging.AccessControlEntry> articoli sono stati verificati e vi è ancora almeno un diritto di accesso che non è stato esplicitamente concesso, nel qual caso, viene implicitamente negato l'accesso.  
  
 I diritti a una coda, specificati nel `rights` parametro quando si costruisce la <xref:System.Messaging.MessageQueueAccessControlEntry>, può essere qualsiasi combinazione delle operazioni seguenti:  
  
-   Controllo completo  
  
-   Eliminare il messaggio  
  
-   Ricezione messaggio  
  
-   Visualizza messaggio  
  
-   Registrazione del messaggio  
  
-   Ottenere le proprietà della coda  
  
-   Impostare le proprietà della coda  
  
-   Ottenere le autorizzazioni  
  
-   Impostare le autorizzazioni  
  
-   Diventare proprietario della coda  
  
-   Scrittura del messaggio  
  
 Il `rights` parametro specificato nel costruttore per il `ace` parametro è un flag del <xref:System.Messaging.MessageQueueAccessRights> enumerazione. Rappresenta un set di flag di bit che è possibile combinare mediante l'operatore OR bit per bit o quando si compila il `rights` parametro.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Singolo utente, gruppo o computer che ottiene ulteriori diritti per la coda.</param>
        <param name="rights">Elemento <see cref="T:System.Messaging.MessageQueueAccessRights" /> che indica il set di diritti per la coda assegnati da Accodamento messaggi al parametro <c>user</c> passato.</param>
        <summary>Fornisce a un computer, a un gruppo o a un utente i diritti di accesso specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per concedere i diritti specificati per un singolo utente. L'utente può essere qualsiasi trustee valido, che include i singoli utenti, gruppi di utenti o un computer. Se l'utente è un singolo, utilizzare il formato `DOMAIN` \\ `user` per il `user` parametro. È possibile specificare "." per il `user` parametro per indicare il computer locale.  
  
 Le autorizzazioni assegnate tramite <xref:System.Messaging.MessageQueue.SetPermissions%2A> aggiungere diritti per l'elenco esistente. Per impostazione predefinita, l'autore di una coda pubblica o privata dispone del controllo completo e il gruppo di dominio, chiunque dispone dell'autorizzazione per ottenere le proprietà della coda, ottenere le autorizzazioni e scrivere nella coda. Quando si chiama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, le informazioni e le autorizzazioni utente viene aggiunto alla fine dell'elenco esistente.  
  
 Il sistema esamina ciascuna <xref:System.Messaging.AccessControlEntry> in sequenza, fino a quando non si verifica uno dei seguenti eventi:  
  
-   Un accesso negato <xref:System.Messaging.AccessControlEntry> nega esplicitamente il qualsiasi dei diritti di accesso richiesto a uno dei fiduciari elencati nel token di accesso del thread.  
  
-   Uno o più accesso consentiti <xref:System.Messaging.AccessControlEntry> voci per tutti i diritti di accesso richiesto di concedere fiduciari elencati nel token di accesso del thread in modo esplicito.  
  
-   Tutti i <xref:System.Messaging.AccessControlEntry> articoli sono stati verificati e vi è ancora almeno un diritto di accesso che non è stato esplicitamente concesso, nel qual caso, viene implicitamente negato l'accesso.  
  
 I diritti per una coda, specificati nel `rights` parametro, può essere qualsiasi combinazione dei valori seguenti:  
  
-   Controllo completo  
  
-   Eliminare il messaggio  
  
-   Ricezione messaggio  
  
-   Visualizza messaggio  
  
-   Registrazione del messaggio  
  
-   Ottenere le proprietà della coda  
  
-   Impostare le proprietà della coda  
  
-   Ottenere le autorizzazioni  
  
-   Impostare le autorizzazioni  
  
-   Diventare proprietario della coda  
  
-   Scrittura del messaggio  
  
 Il <xref:System.Messaging.MessageQueueAccessRights> enumerazione rappresenta un set di flag di bit che è possibile combinare l'utilizzo dell'operatore OR bit per bit o per compilare il `rights` parametro.  
  
 Con questo overload, è possibile concedere solo autorizzazioni. non è possibile revocare o negare loro. È necessario utilizzare un altro overload per concedere in modo esplicito qualsiasi <xref:System.Messaging.AccessControlEntryType> diverso da `Allow`.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'elemento <paramref name="user" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Singolo utente, gruppo o computer che ottiene ulteriori diritti per la coda.</param>
        <param name="rights">Elemento <see cref="T:System.Messaging.MessageQueueAccessRights" /> che indica il set di diritti per la coda assegnati da Accodamento messaggi al parametro <c>user</c> passato.</param>
        <param name="entryType">Elemento <see cref="T:System.Messaging.AccessControlEntryType" /> che specifica se concedere, negare o revocare le autorizzazioni specificate dal parametro <c>rights</c>.</param>
        <summary>Concede a un computer, a un utente o a un gruppo di utenti i diritti di accesso specificati con il tipo di controllo di accesso specificato (concessione, rifiuto, revoca o impostazione).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per concedere, negare o revocare i diritti specificati per un singolo utente. L'utente può essere qualsiasi trustee valido, che include i singoli utenti, gruppi di utenti o un computer. Se l'utente è un singolo, utilizzare il formato `DOMAIN` \\ `user` per il `user` parametro. È possibile specificare "." per il `user` parametro per indicare il computer locale.  
  
 Le autorizzazioni assegnate tramite <xref:System.Messaging.MessageQueue.SetPermissions%2A> aggiungere diritti per l'elenco esistente. Per impostazione predefinita, l'autore di una coda pubblica o privata dispone del controllo completo e il gruppo di dominio, chiunque dispone dell'autorizzazione per ottenere le proprietà della coda, ottenere le autorizzazioni e scrivere nella coda. Quando si chiama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, le informazioni e le autorizzazioni utente viene aggiunto alla fine dell'elenco esistente.  
  
 Il sistema esamina ciascuna <xref:System.Messaging.AccessControlEntry> in sequenza, fino a quando non si verifica uno dei seguenti eventi:  
  
-   Un accesso negato <xref:System.Messaging.AccessControlEntry> nega esplicitamente il qualsiasi dei diritti di accesso richiesto a uno dei fiduciari elencati nel token di accesso del thread.  
  
-   Uno o più accesso consentiti <xref:System.Messaging.AccessControlEntry> voci per tutti i diritti di accesso richiesto di concedere fiduciari elencati nel token di accesso del thread in modo esplicito.  
  
-   Tutti i <xref:System.Messaging.AccessControlEntry> articoli sono stati verificati e vi è ancora almeno un diritto di accesso che non è stato esplicitamente concesso, nel qual caso, viene implicitamente negato l'accesso.  
  
 I diritti per una coda, specificati nel `rights` parametro, può essere qualsiasi combinazione dei valori seguenti:  
  
-   Controllo completo  
  
-   Eliminare il messaggio  
  
-   Ricezione messaggio  
  
-   Visualizza messaggio  
  
-   Registrazione del messaggio  
  
-   Ottenere le proprietà della coda  
  
-   Impostare le proprietà della coda  
  
-   Ottenere le autorizzazioni  
  
-   Impostare le autorizzazioni  
  
-   Diventare proprietario della coda  
  
-   Scrittura del messaggio  
  
 Il <xref:System.Messaging.MessageQueueAccessRights> enumerazione rappresenta un set di flag di bit che è possibile combinare l'utilizzo dell'operatore OR bit per bit o per compilare il `rights` parametro.  
  
 Nella tabella seguente indica se questo metodo è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 L'esempio di codice seguente illustra l'uso di <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto utilizzato per effettuare il marshalling della chiamata al gestore eventi risultante da un evento <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> o <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />.</summary>
        <value>Oggetto <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> che rappresenta l'oggetto utilizzato per effettuare il marshalling della chiamata al gestore eventi risultante da un evento <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> o <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Messaging.MessageQueue.ReceiveCompleted> o <xref:System.Messaging.MessageQueue.PeekCompleted> evento risultati da un <xref:System.Messaging.MessageQueue.BeginReceive%2A> o <xref:System.Messaging.MessageQueue.BeginPeek%2A> richiedere, rispettivamente, a un thread specifico. In genere, il <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> viene impostata quando il relativo componente viene inserito all'interno di un controllo o un form, perché tali componenti sono associati a un thread specifico.  
  
 In genere, l'oggetto di sincronizzazione effettua il marshalling di una chiamata al metodo in un singolo thread.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la coda accetta solo transazioni.</summary>
        <value>
          <see langword="true" /> se la coda accetta solo messaggi inviati come parte di una transazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Messaggistica transazionale si intende la visualizzazione di più messaggi correlati in un'unica transazione. L'invio di messaggi come parte di una transazione garantisce che i messaggi vengano recapitati in ordine, recapitato una sola volta e recuperato dalla relativa coda di destinazione.  
  
 Se la coda è transazionale, accetta solo i messaggi vengono inviati come parte di una transazione. Tuttavia, un messaggio non transazionale può essere inviato o ricevuto da una coda di transazione locale senza in modo esplicito utilizzando transazionale <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, e <xref:System.Messaging.MessageQueueTransaction.Abort%2A> sintassi. Se un messaggio non transazionale viene inviato a una coda transazionale, questo componente crea una transazione singola dei messaggi, tranne nel caso di riferimento a una coda in un computer remoto utilizzando un nome di formato direct. In questo caso, se non si specifica un contesto di transazione quando si invia un messaggio, non ne viene creato automaticamente e il messaggio verrà inviato alla coda di messaggi non recapitabili.  
  
 Se si invia un messaggio non transazionale a una coda transazionale, non sarà in grado di eseguire il rollback del messaggio in caso di un'eccezione.  
  
 <xref:System.Messaging.MessageQueueTransaction> il threading apartment, pertanto se lo stato dell'apartment è `STA`, è possibile utilizzare la transazione in più thread. Visual Basic imposta lo stato del thread principale di `STA`, pertanto è necessario applicare il <xref:System.MTAThreadAttribute> nel `Main` subroutine. In caso contrario, l'invio di un messaggio transazionale mediante un altro thread genererà un'eccezione <xref:System.Messaging.MessageQueueException>. Si applica il <xref:System.MTAThreadAttribute> utilizzando il seguente frammento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.Transactional%2A> proprietà.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se i messaggi ricevuti vengono copiati nella coda del giornale di registrazione.</summary>
        <value>
          <see langword="true" /> se i messaggi ricevuti dalla coda vengono copiati nella relativa coda del journal; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando l'applicazione di Accodamento messaggi crea una nuova coda dell'applicazione, viene creato automaticamente una coda diario associata nello stesso percorso. Coda del diario usata per rilevare i messaggi rimossi da una coda. Impostazione di questa proprietà consente di modificare la coda di Accodamento messaggi. Pertanto, qualsiasi altro <xref:System.Messaging.MessageQueue> istanze sono interessate dalla modifica.  
  
 Coda del diario non vengono rilevati messaggi rimossi dalla coda, in quanto i timer per ricevuta scaduto, né tiene traccia dei messaggi eliminati dalla coda tramite un servizio di directory di Accodamento messaggi (archivio informazioni o Active Directory).  
  
 Applicazioni non è possibile inviare messaggi a code journal; sono limitati per l'accesso in sola lettura di queste code. Inoltre, Accodamento messaggi non rimuove i messaggi dalle code del journal. L'applicazione di utilizzare la coda è necessario cancellare questi messaggi vengano o eliminando la coda.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|No|  
  
   
  
## Examples  
 Esempio di codice seguente ottiene e imposta il valore di una coda di messaggi <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> proprietà.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Si è verificato un errore durante l'accesso a un metodo di Accodamento messaggi.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle nativo utilizzato per inviare messaggi alla coda di messaggi.</summary>
        <value>Handle all'oggetto coda nativo utilizzato per inviare messaggi alla coda.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Messaging.MessageQueue.WriteHandle%2A> fornisce un handle nativo di Windows per l'oggetto coda di messaggi utilizzato per l'invio di messaggi alla coda. Se si modifica il percorso della coda, l'handle è chiuso e riaperto con un nuovo valore.  
  
 Nella tabella seguente indica se questa proprietà è disponibile in diverse modalità gruppo di lavoro.  
  
|Modalità gruppo di lavoro|Disponibile|  
|--------------------|---------------|  
|Computer locale|Yes|  
|Computer locale e il nome di formato direct|Yes|  
|Computer remoto|No|  
|Computer remoto e il nome di formato direct|Yes|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">La coda di messaggi non è disponibile per la scrittura.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>