<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="618b69c9a4d91151391fe5e2c79054e0441f4aec" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530805" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Genera un evento dopo un intervallo specificato, con un'opzione per generare eventi ricorrenti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Timers.Timer> componente è un timer basate su server che genera un <xref:System.Timers.Timer.Elapsed> eventi dell'applicazione dopo il numero di millisecondi nel <xref:System.Timers.Timer.Interval%2A> proprietà che è trascorso. È possibile configurare il <xref:System.Timers.Timer> oggetto per generare l'evento solo una o più volte utilizzando la <xref:System.Timers.Timer.AutoReset%2A> proprietà. In genere, un <xref:System.Timers.Timer> oggetto viene dichiarato a livello di classe in modo che rimanga nell'ambito fino a quando necessario. È quindi possibile gestire il <xref:System.Timers.Timer.Elapsed> evento per fornire l'elaborazione normale. Ad esempio, si supponga un server critico che deve rimanere in esecuzione 24 ore su 24, 7 giorni a settimana. È possibile creare un servizio che utilizza un <xref:System.Timers.Timer> oggetto per verificare periodicamente il server e verificare che il sistema sia in esecuzione. Se il sistema non risponde, il servizio tenterà di riavviare il server o un amministratore di notifica.  
  
> [!IMPORTANT]
> Il <xref:System.Timers.Timer> classe non è disponibile per tutte le versioni, ad esempio .NET Standard 1.6 e versioni precedenti e le implementazioni di .NET.
> In questi casi, è possibile utilizzare il <xref:System.Threading.Timer?displayProperty=nameWithType> classe.
  
 Questo tipo implementa il <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 Basato su server <xref:System.Timers.Timer?displayProperty=nameWithType> classe è progettata per l'utilizzo con thread di lavoro in un ambiente con multithreading. Timer server possono spostarsi tra i thread per gestire l'eccezione generata <xref:System.Timers.Timer.Elapsed> evento, precisione maggiore dei timer di Windows nella generazione dell'evento nel tempo.  
  
 Il <xref:System.Timers.Timer?displayProperty=nameWithType> componente genera il <xref:System.Timers.Timer.Elapsed> evento, in base al valore (in millisecondi) del <xref:System.Timers.Timer.Interval%2A> proprietà. È possibile gestire questo evento per eseguire l'elaborazione che è necessario. Ad esempio, si supponga di disporre di un'applicazione di vendita online che inserisce continuamente ordini di vendita in un database. Il servizio che compila le istruzioni per la spedizione opera su un batch di ordini anziché elaborare individualmente ogni ordine. È possibile utilizzare un <xref:System.Timers.Timer> per avviare l'elaborazione di ogni 30 minuti del batch.  
  
> [!IMPORTANT]
>  La classe System.Timers.Timer ha la stessa risoluzione l'orologio di sistema. Ciò significa che il <xref:System.Timers.Timer.Elapsed> viene generato l'evento a un intervallo definito per la risoluzione del clock di sistema se la <xref:System.Timers.Timer.Interval%2A> proprietà è minore rispetto alla risoluzione del clock di sistema. Per altre informazioni, vedere la proprietà <xref:System.Timers.Timer.Interval%2A>.  
  
 Quando <xref:System.Timers.Timer.AutoReset%2A> è impostato su `false`, <xref:System.Timers.Timer?displayProperty=nameWithType> oggetto genera il <xref:System.Timers.Timer.Elapsed> evento una sola volta, dopo il primo <xref:System.Timers.Timer.Interval%2A> è trascorso. Per continuare a generare il <xref:System.Timers.Timer.Elapsed> eventi regolarmente in base all'intervallo definito dal <xref:System.Timers.Timer.Interval%2A>, impostare <xref:System.Timers.Timer.AutoReset%2A> a `true`, ovvero il valore predefinito.  
  
 Il <xref:System.Timers.Timer> componente intercetta ed Elimina tutte le eccezioni generate dai gestori eventi per il <xref:System.Timers.Timer.Elapsed> evento. Questo comportamento è soggetto a modifiche nelle versioni future di .NET Framework. Si noti tuttavia che ciò non vale per i gestori di eventi che eseguire in modo asincrono e includono il `await` (operatore) (in c#) o `Await` (operatore) (in Visual Basic). Le eccezioni generate in questi gestori eventi vengono propagate nel thread chiamante, come illustrato nell'esempio seguente. Per ulteriori informazioni sulle eccezioni generate nei metodi asincroni, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Se il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà `null`, <xref:System.Timers.Timer.Elapsed> evento viene generato in un <xref:System.Threading.ThreadPool> thread. Se l'elaborazione del <xref:System.Timers.Timer.Elapsed> evento ha una durata superiore <xref:System.Timers.Timer.Interval%2A>, l'evento potrebbe essere generato nuovamente in un altro <xref:System.Threading.ThreadPool> thread. In questo caso, il gestore dell'evento deve essere rientrante.  
  
> [!NOTE]
>  Il metodo di gestione degli eventi può essere eseguito su un singolo thread allo stesso tempo che un altro thread chiama il <xref:System.Timers.Timer.Stop%2A> metodo o imposta il <xref:System.Timers.Timer.Enabled%2A> proprietà `false`. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> dell'evento dopo l'arresto del timer. Nell'esempio di codice per il <xref:System.Timers.Timer.Stop%2A> metodo illustrato un modo per evitare la race condition.  
  
 Anche se <xref:System.Timers.Timer.SynchronizingObject%2A> non `null`, <xref:System.Timers.Timer.Elapsed> gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A> è impostata su `false`, poiché il segnale per generare il <xref:System.Timers.Timer.Elapsed> evento è sempre in coda per l'esecuzione in un pool di thread. Un modo per risolvere questa condizione di competizione consiste nell'impostare un flag che indica il gestore eventi per il <xref:System.Timers.Timer.Elapsed> evento ignori gli eventi successivi.  
  
 Se si utilizza il <xref:System.Timers.Timer?displayProperty=nameWithType> classe con un elemento dell'interfaccia utente, ad esempio un form o controllo, senza inserire il timer su tale elemento dell'interfaccia utente, assegnare il modulo che contiene il <xref:System.Timers.Timer> per il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà, in modo che l'evento è effettuare il marshalling al thread dell'interfaccia utente.  
  
 Per un elenco di valori predefiniti delle proprietà per un'istanza di <xref:System.Timers.Timer>, vedere il <xref:System.Timers.Timer.%23ctor%2A> costruttore.  
  
> [!TIP]
>  Tenere presente che .NET include quattro classi denominate `Timer`in ognuno dei quali offre diverse funzionalità:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (questo argomento): viene generato un evento a intervalli regolari. La classe è destinata all'utilizzo come basato su server o il componente del servizio in un ambiente con multithreading non dispone di alcuna interfaccia utente e non è visibile in fase di esecuzione.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: esegue un metodo di callback singolo in un pool di thread a intervalli regolari. Il metodo di callback viene definito quando il timer viene creata un'istanza e non può essere modificato. Ad esempio il <xref:System.Timers.Timer?displayProperty=nameWithType> (classe), questa classe è destinata all'utilizzo come un componente basato su server o servizio in un ambiente con multithreading, ma senza un'interfaccia utente e non è visibile in fase di esecuzione.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Solo in .NET framework): un componente di Windows Form che genera un evento a intervalli regolari. Il componente non dispone di alcuna interfaccia utente e viene progettato per l'uso in un ambiente a thread singolo.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Solo in .NET framework): un componente ASP.NET che esegue i postback asincroni o sincroni di pagina web a intervalli regolari.  

## Examples  
 Nell'esempio seguente viene creata un'istanza di un `System.Timers.Timer` oggetto che genera il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Qualsiasi pubblico <see langword="static" /> i membri di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Timers.Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Timers.Timer" /> e imposta tutte le proprietà sui rispettivi valori iniziali.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Timers.Timer>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 millisecondi|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Riferimento null (`Nothing` in Visual Basic).|  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza di un <xref:System.Timers.Timer> oggetto che genera il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">Tempo che intercorre tra gli eventi, in millisecondi. Il valore deve essere maggiore di zero e minore o uguale a <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Timers.Timer" /> e imposta la proprietà <see cref="P:System.Timers.Timer.Interval" /> sul numero di millisecondi specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore imposta la <xref:System.Timers.Timer.Interval%2A> proprietà della nuova istanza di timer, ma non abilita il timer.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza di un <xref:System.Timers.Timer> oggetto che genera il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore del parametro <paramref name="interval" /> è maggiore o uguale a zero oppure maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore booleano che indica se <see cref="T:System.Timers.Timer" /> deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" /> una sola volta (<see langword="false" />) o più volte (<see langword="true" />).</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Timers.Timer" /> deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" /> allo scadere di ogni intervallo; <see langword="false" /> se deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" /> solo una volta, in corrispondenza della prima scadenza dell'intervallo. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Timers.Timer> è già abilitata quando il <xref:System.Timers.Timer.Start%2A> metodo viene chiamato, l'intervallo viene reimpostato. Se <xref:System.Timers.Timer.AutoReset%2A> è `false`, <xref:System.Timers.Timer.Start%2A> metodo deve essere chiamato per riavviare il conteggio.  
  
 Reimpostare l'intervallo interessa quando il <xref:System.Timers.Timer.Elapsed> viene generato l'evento. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A> è impostata. Se l'intervallo viene reimpostato su 10 secondi quando il conteggio è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta 13 secondi dopo il <xref:System.Timers.Timer.Enabled%2A> è stata impostata su `true`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Timers.Timer> cui <xref:System.Timers.Timer.Elapsed> evento viene generato dopo 1,5 secondi. Quindi, il gestore eventi visualizza "Hello World!" Nella console.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia l'inizializzazione in fase di esecuzione di un oggetto <see cref="T:System.Timers.Timer" /> usato in un form o da un altro componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] ambiente di progettazione questo metodo per avviare l'inizializzazione di un componente che viene utilizzato in un form o da un altro componente. Il <xref:System.Timers.Timer.EndInit%2A> metodo termina l'inizializzazione. Utilizzo di <xref:System.Timers.Timer.BeginInit%2A> e <xref:System.Timers.Timer.EndInit%2A> metodi impedisce che venga utilizzato prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia le risorse usate da <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Timers.Timer.Close%2A> metodo chiama a sua volta il `Dispose` metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia tutte le risorse usate dall'oggetto <see cref="T:System.Timers.Timer" /> corrente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'intervallo scade.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Timers.Timer.Elapsed> evento viene generato se il <xref:System.Timers.Timer.Enabled%2A> proprietà `true` e l'intervallo di tempo (in millisecondi) definito dal <xref:System.Timers.Timer.Interval%2A> allo scadere di proprietà. Se il <xref:System.Timers.Timer.AutoReset%2A> proprietà `true`, l'evento viene generato ripetutamente in un intervallo definito dal <xref:System.Timers.Timer.Interval%2A> proprietà; in caso contrario, l'evento viene generato una sola volta, la prima volta il <xref:System.Timers.Timer.Interval%2A> valore allo scadere dell'intervallo.  
  
 Se <xref:System.Timers.Timer.Interval%2A> viene impostato dopo la <xref:System.Timers.Timer> è avviato, il conteggio viene reimpostato. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare <xref:System.Timers.Timer.Enabled%2A> a `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A> è impostata. Se l'intervallo viene reimpostato su 10 secondi quando count è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta 13 secondi dopo <xref:System.Timers.Timer.Enabled%2A> è stato impostato su `true`.  
  
 Se il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà `null`, <xref:System.Timers.Timer.Elapsed> evento viene generato in un <xref:System.Threading.ThreadPool> thread. Se l'elaborazione del <xref:System.Timers.Timer.Elapsed> evento ha una durata superiore <xref:System.Timers.Timer.Interval%2A>, l'evento potrebbe essere generato nuovamente in un altro <xref:System.Threading.ThreadPool> thread. In questo caso, il gestore dell'evento deve essere rientrante.  
  
> [!NOTE]
>  Il metodo di gestione degli eventi può essere eseguito su un singolo thread allo stesso tempo che un altro thread chiama il <xref:System.Timers.Timer.Stop%2A> metodo o imposta il <xref:System.Timers.Timer.Enabled%2A> proprietà `false`. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> dell'evento dopo l'arresto del timer. Nell'esempio di codice per il <xref:System.Timers.Timer.Stop%2A> metodo illustrato un modo per evitare la race condition.  
  
 Anche se <xref:System.Timers.Timer.SynchronizingObject%2A> non `null`, <xref:System.Timers.Timer.Elapsed> gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A> è impostata su `false`, poiché il segnale per generare il <xref:System.Timers.Timer.Elapsed> evento è sempre in coda per l'esecuzione in un pool di thread. Un modo per risolvere questa condizione di competizione consiste nell'impostare un flag che indica il gestore eventi per il <xref:System.Timers.Timer.Elapsed> evento ignori gli eventi successivi.  
  
 Il <xref:System.Timers.Timer> componente intercetta ed Elimina tutte le eccezioni generate dai gestori eventi per il <xref:System.Timers.Timer.Elapsed> evento. Questo comportamento è soggetto a modifiche nelle versioni future di .NET Framework.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza di un <xref:System.Timers.Timer> oggetto che genera il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se <see cref="T:System.Timers.Timer" /> deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" />.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Timers.Timer" /> deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" />; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostazione <xref:System.Timers.Timer.Enabled%2A> a `true` equivale a chiamare il metodo <xref:System.Timers.Timer.Start%2A>, mentre l'impostazione <xref:System.Timers.Timer.Enabled%2A> a `false` corrisponde a chiamare <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  Il segnale per generare il <xref:System.Timers.Timer.Elapsed> evento sempre in coda per l'esecuzione in un <xref:System.Threading.ThreadPool> thread. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> evento generato dopo il <xref:System.Timers.Timer.Enabled%2A> è impostata su `false`. L'esempio di codice per il <xref:System.Timers.Timer.Stop%2A> metodo illustrato un modo per aggirare questa race condition.  
  
 Se <xref:System.Timers.Timer.Enabled%2A> è impostato su `true` e <xref:System.Timers.Timer.AutoReset%2A> è impostato su `false`, <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> evento solo una volta, la prima volta l'intervallo scade.  
  
 Se l'intervallo viene impostato dopo la <xref:System.Timers.Timer> è avviato, il conteggio viene reimpostato. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A> è impostata. Se l'intervallo viene reimpostato su 10 secondi quando count è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta 13 secondi dopo <xref:System.Timers.Timer.Enabled%2A> è stato impostato su `true`.  
  
> [!NOTE]
>  Alcune finestre di progettazione, ad esempio quelle in Microsoft Visual Studio, impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà `true` durante l'inserimento di un nuovo <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza di un <xref:System.Timers.Timer> oggetto che genera il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Non è possibile impostare questa proprietà perché il timer è stato eliminato.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Timers.Timer.Interval" /> era impostata su un valore maggiore di <see cref="F:System.Int32.MaxValue" /> prima che sia stato abilitato il timer.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina l'inizializzazione in fase di esecuzione di un oggetto <see cref="T:System.Timers.Timer" /> usato in un form o da un altro componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] ambiente di progettazione questo metodo per terminare l'inizializzazione di un componente che viene utilizzato in un form o da un altro componente. Il <xref:System.Timers.Timer.BeginInit%2A> metodo avvia l'inizializzazione. Utilizzo di <xref:System.Timers.Timer.BeginInit%2A> e <xref:System.Timers.Timer.EndInit%2A> metodi impedisce che venga utilizzato prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'intervallo, espresso in millisecondi, in cui generare l'evento <see cref="E:System.Timers.Timer.Elapsed" />.</summary>
        <value>Tempo tra gli eventi <see cref="E:System.Timers.Timer.Elapsed" />, in millisecondi. Il valore deve essere maggiore di zero e minore o uguale a <see cref="F:System.Int32.MaxValue" />. Il valore predefinito è 100 millisecondi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Timers.Timer.Interval%2A> proprietà per determinare la frequenza con la quale il <xref:System.Timers.Timer.Elapsed> viene generato l'evento. Poiché la <xref:System.Timers.Timer> classe dipende dall'orologio di sistema, ha la stessa risoluzione l'orologio di sistema. Ciò significa che il <xref:System.Timers.Timer.Elapsed> viene generato l'evento a un intervallo definito per la risoluzione del clock di sistema se la <xref:System.Timers.Timer.Interval%2A> proprietà è minore rispetto alla risoluzione del clock di sistema. L'esempio seguente imposta la <xref:System.Timers.Timer.Interval%2A> proprietà 5 millisecondi. Quando viene eseguito un [!INCLUDE[win7](~/includes/win7-md.md)] sistema il cui orologio di sistema con una risoluzione di circa 15 millisecondi, viene generato l'evento circa ogni 15 millisecondi anziché ogni 5 millisecondi.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 È possibile utilizzare il codice seguente per determinare la risoluzione del clock di sistema nel sistema corrente:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Se l'applicazione richiede la risoluzione maggiore rispetto a quello offerto dal <xref:System.Timers.Timer> classe o l'orologio di sistema, utilizzare i timer multimediali ad alta risoluzione, vedere [procedura: utilizzare il Timer ad alta risoluzione](http://msdn.microsoft.com/library/aa964692.aspx).  
  
 Se l'intervallo viene impostato dopo la <xref:System.Timers.Timer> è avviato, il conteggio viene reimpostato. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A> è impostata. Se l'intervallo viene reimpostato su 10 secondi quando count è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta 13 secondi dopo <xref:System.Timers.Timer.Enabled%2A> è stato impostato su `true`.  
  
 Se <xref:System.Timers.Timer.Enabled%2A> è impostato su `true` e <xref:System.Timers.Timer.AutoReset%2A> è impostato su `false`, <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> evento solo una volta, la prima volta l'intervallo scade. <xref:System.Timers.Timer.Enabled%2A> viene quindi impostato su `false`.  
  
> [!NOTE]
>  Se <xref:System.Timers.Timer.Enabled%2A> e <xref:System.Timers.Timer.AutoReset%2A> sono impostati entrambi su `false`, e il timer è già stato abilitato, impostazione di <xref:System.Timers.Timer.Interval%2A> proprietà causa la <xref:System.Timers.Timer.Elapsed> dell'evento una volta, come se il <xref:System.Timers.Timer.Enabled%2A> proprietà è stata impostata in `true`. Per impostare l'intervallo senza la generazione dell'evento, è possibile impostare temporaneamente il <xref:System.Timers.Timer.Enabled%2A> proprietà `true`, impostare il <xref:System.Timers.Timer.Interval%2A> proprietà per l'intervallo di tempo desiderato, quindi impostare immediatamente il <xref:System.Timers.Timer.Enabled%2A> proprietà nuovamente a `false`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza di un <xref:System.Timers.Timer> oggetto che genera il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'intervallo è minore o uguale a zero.  
  
 oppure  
  
 L'intervallo è più grande di <see cref="F:System.Int32.MaxValue" />e il timer è attualmente attivato. Non viene generata alcuna eccezione finché il timer non viene abilitato.</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il sito che associa l'oggetto <see cref="T:System.Timers.Timer" /> al contenitore in modalità progettazione.</summary>
        <value>Interfaccia <see cref="T:System.ComponentModel.ISite" /> che rappresenta il sito che associa l'oggetto <see cref="T:System.Timers.Timer" /> al contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siti associano un <xref:System.ComponentModel.Component> per un <xref:System.ComponentModel.Container> e abilitare la comunicazione tra di essi, nonché fornendo un modo per il contenitore gestire i relativi componenti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia la generazione dell'evento <see cref="E:System.Timers.Timer.Elapsed" /> impostando <see cref="P:System.Timers.Timer.Enabled" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Timers.Timer.Start%2A> viene chiamato e <xref:System.Timers.Timer.AutoReset%2A> è impostato su `false`, <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> evento solo una volta, la prima volta l'intervallo scade. Se <xref:System.Timers.Timer.Start%2A> viene chiamato e <xref:System.Timers.Timer.AutoReset%2A> è `true`, <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> ora il primo evento, l'intervallo scade e continua a generare l'evento nell'intervallo specificato.  
  
 È inoltre possibile avviare intervallo impostando <xref:System.Timers.Timer.Enabled%2A> a `true`.  
  
> [!NOTE]
>  Se <xref:System.Timers.Timer.AutoReset%2A> è `false`, <xref:System.Timers.Timer.Start%2A> metodo deve essere chiamato per riavviare il conteggio.  
  
 Una chiamata al <xref:System.Timers.Timer.Start%2A> metodo quando è abilitato il timer non ha alcun effetto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'oggetto <see cref="T:System.Timers.Timer" /> viene creato con intervallo uguale o maggiore di <see cref="F:System.Int32.MaxValue" /> + 1 oppure viene impostato su un intervallo minore di zero.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arresta la generazione dell'evento <see cref="E:System.Timers.Timer.Elapsed" /> impostando <see cref="P:System.Timers.Timer.Enabled" /> su <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È anche possibile terminare la temporizzazione impostando <xref:System.Timers.Timer.Enabled%2A> a `false`.  
  
> [!NOTE]
>  Il segnale per generare il <xref:System.Timers.Timer.Elapsed> evento sempre in coda per l'esecuzione in un <xref:System.Threading.ThreadPool> thread, pertanto il metodo di gestione degli eventi può essere eseguito in un solo thread con lo stesso momento in cui una chiamata al <xref:System.Timers.Timer.Stop%2A> metodo viene eseguito in un altro thread. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> evento generato dopo il <xref:System.Timers.Timer.Stop%2A> metodo viene chiamato. Nell'esempio di codice nella sezione successiva viene illustrato un modo per aggirare questa race condition.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza di un `System.Timers.Timer` oggetto che genera il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato. Quando l'utente preme il tasto INVIO, l'applicazione chiama il <xref:System.Timers.Timer.Stop%2A> metodo prima di interrompere l'applicazione.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 Esempio di codice seguente viene illustrato un modo per evitare che il thread che chiama il <xref:System.Timers.Timer.Stop%2A> (metodo) non potrà continuare fino a quando in esecuzione <xref:System.Timers.Timer.Elapsed> evento termina e anche per evitare che due <xref:System.Timers.Timer.Elapsed> gli eventi di esecuzione del gestore eventi contemporaneamente ora (noto anche come reentrancy).  
  
 L'esempio esegue 100 esecuzioni dei test. Ogni volta che viene eseguito il test, il timer viene avviato con un intervallo di 150 millisecondi. Il gestore dell'evento viene utilizzato il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per simulare un'attività che varia in modo casuale di lunghezza compresa tra 50 e 200 millisecondi. Inoltre, il metodo di test avvia un thread di controllo che è in attesa di un secondo e quindi si arresta il timer. Se un evento gestito quando il thread del controllo si arresta il timer, il thread del controllo deve attendere fino al termine dell'evento prima di procedere.  
  
 Il <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> overload del metodo viene utilizzato per evitare la rientranza e impedire al thread del controllo proseguire fino al termine di un evento in esecuzione. Il gestore dell'evento viene utilizzato il <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> per impostare un controllo variabile su 1, ma solo se il valore è zero. Si tratta di un'operazione atomica. Se il valore restituito è zero, la variabile di controllo è stata impostata su 1 e continua il gestore dell'evento. Se il valore restituito è diverso da zero, l'evento viene semplicemente ignorato, per evitare la reentrancy. (Se fosse necessario eseguire tutti gli eventi, la <xref:System.Threading.Monitor> classe sarebbe un modo migliore per sincronizzare gli eventi.) Quando termina il gestore dell'evento, imposta la variabile di controllo torna a zero. Nell'esempio viene registrato il numero totale di eventi eseguiti, che sono stati scartati a causa della reentrancy, e che si sono verificati dopo il <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato.  
  
 Il thread del controllo utilizza il <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> metodo per impostare il controllo variabile su -1 (meno uno), ma solo se il valore è zero. Se l'operazione atomica positivo diverso da zero, un evento è attualmente in esecuzione. Il thread di controllo rimane in attesa e nuovo tentativo. Nell'esempio viene registrato il numero di volte in cui che il thread del controllo deve attendere un evento di completamento.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto usato per effettuare il marshalling delle chiamate del gestore eventi generate alla scadenza di un intervallo.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> che rappresenta l'oggetto usato per effettuare il marshalling delle chiamate del gestore eventi generate alla scadenza di un intervallo. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Timers.Timer.SynchronizingObject%2A> è `null`, il metodo che gestisce il <xref:System.Timers.Timer.Elapsed> eventi viene chiamato su un thread dal pool di thread del sistema. Per ulteriori informazioni sui pool di thread di sistema, vedere <xref:System.Threading.ThreadPool>.  
  
 Quando il <xref:System.Timers.Timer.Elapsed> evento è gestito da un componente di Windows Form visivo, ad esempio un pulsante, l'accesso al componente tramite il pool di thread del sistema potrebbe essere il risultato di un'eccezione o semplicemente potrebbero non funzionare. Per evitare questo effetto impostando <xref:System.Timers.Timer.SynchronizingObject%2A> su un componente di Windows Form, che chiama il metodo che gestisce il <xref:System.Timers.Timer.Elapsed> sullo stesso thread che il componente è stato creato l'evento.  
  
> [!NOTE]
>  Anche se il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà non è `null`, <xref:System.Timers.Timer.Elapsed> gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A> è impostata su `false`, poiché il segnale per generare il <xref:System.Timers.Timer.Elapsed> evento è sempre in coda per l'esecuzione in un pool di thread. Un modo per risolvere questa condizione di competizione consiste nell'impostare un flag che indica il gestore eventi per il <xref:System.Timers.Timer.Elapsed> evento ignori gli eventi successivi.  
  
 Se il <xref:System.Timers.Timer> viene utilizzata all'interno di Visual Studio in una finestra di progettazione Windows Form, <xref:System.Timers.Timer.SynchronizingObject%2A> viene impostata automaticamente al controllo che contiene il <xref:System.Timers.Timer>. Ad esempio, se si inserisce un <xref:System.Timers.Timer> in una finestra di progettazione per `Form1` (che eredita da <xref:System.Windows.Forms.Form>), il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà di <xref:System.Timers.Timer> è impostato per l'istanza di `Form1`.  
  
   
  
## Examples  
 Nell'esempio seguente è un'app di Windows Form che funge da un editor di file di testo molto semplice. Quando il testo nella casella di testo non è stato salvato, l'app viene chiesto all'utente a intervalli di un minuto se desidera salvare il contenuto della casella di testo.  A tale scopo, il <xref:System.Timers.Timer.Interval%2A> è impostata su 1 minuto (60000 millisecondi) e <xref:System.Timers.Timer.SynchronizingObject%2A> è impostata sul <xref:System.Windows.Forms.Form> oggetto.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 L'esempio è necessario aggiungere i seguenti controlli al form:  
  
-   Oggetto <xref:System.Windows.Forms.TextBox> controllo denominato `TextBox1` (nome predefinito).  
  
-   Oggetto <xref:System.Windows.Forms.Button> controllo denominato `Button1` (nome predefinito).  
  
-   Oggetto <xref:System.Windows.Forms.SaveFileDialog> controllo denominato `SaveSaveFileDialog1` (nome predefinito).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>