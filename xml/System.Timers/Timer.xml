<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b182ebe1139bd14d03ded417cddffca78808f4aa" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48747629" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Genera un evento dopo un intervallo specificato, con un'opzione per generare eventi ricorrenti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Timers.Timer> componente è un timer basate su server che genera una <xref:System.Timers.Timer.Elapsed> evento nell'applicazione dopo il numero di millisecondi nel <xref:System.Timers.Timer.Interval%2A> proprietà è trascorso. È possibile configurare il <xref:System.Timers.Timer> per generare l'evento utilizzando una sola volta o ripetutamente il <xref:System.Timers.Timer.AutoReset%2A> proprietà. In genere, un <xref:System.Timers.Timer> oggetto viene dichiarato a livello di classe in modo che rimanga nell'ambito fino a quando è necessaria. È possibile quindi gestire relativo <xref:System.Timers.Timer.Elapsed> eventi per garantire l'elaborazione normale. Ad esempio, si supponga di avere un server critico che deve rimanere in esecuzione 24 ore su 24, 7 giorni alla settimana. È possibile creare un servizio che utilizza un <xref:System.Timers.Timer> oggetto da verificare periodicamente il server e assicurarsi che il sistema sia attivo e in esecuzione. Se il sistema non risponde, il servizio potrebbe tentare di riavviare il server o notificare all'amministratore.  
  
> [!IMPORTANT]
> Il <xref:System.Timers.Timer> classe non è disponibile per tutte le implementazioni di .NET e le versioni, ad esempio .NET Standard 1.6 e versioni precedenti.
> In questi casi, è possibile usare il <xref:System.Threading.Timer?displayProperty=nameWithType> classe.
  
 Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare il tipo direttamente, chiamare relativi <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 Il server basate su <xref:System.Timers.Timer?displayProperty=nameWithType> classe è progettata per l'uso con thread di lavoro in un ambiente a thread multipli. I timer di server possono spostarsi tra i thread per gestire l'eccezione <xref:System.Timers.Timer.Elapsed> evento, con conseguente accuratezza maggiore i timer di Windows nella generazione dell'evento nel tempo.  
  
 Il <xref:System.Timers.Timer?displayProperty=nameWithType> componente genera il <xref:System.Timers.Timer.Elapsed> evento, in base al valore (in millisecondi) del <xref:System.Timers.Timer.Interval%2A> proprietà. È possibile gestire questo evento per eseguire l'elaborazione che è necessario. Ad esempio, si supponga di disporre di un'applicazione di vendita in linea che invia continuamente gli ordini di vendita in un database. Il servizio che consente di compilare le istruzioni per la spedizione opera su un batch di ordini, anziché elaborare individualmente ogni ordine. È possibile usare un <xref:System.Timers.Timer> per avviare il batch ogni 30 minuti di elaborazione.  
  
> [!IMPORTANT]
>  La classe Timer ha la stessa risoluzione come l'orologio di sistema. Ciò significa che il <xref:System.Timers.Timer.Elapsed> viene generato l'evento a un intervallo definito per la risoluzione del clock di sistema se la <xref:System.Timers.Timer.Interval%2A> proprietà è minore rispetto alla risoluzione del clock di sistema. Per altre informazioni, vedere la proprietà <xref:System.Timers.Timer.Interval%2A>.  
  
 Quando <xref:System.Timers.Timer.AutoReset%2A> è impostata su `false`, un <xref:System.Timers.Timer?displayProperty=nameWithType> oggetto genera il <xref:System.Timers.Timer.Elapsed> evento una sola volta, dopo il primo <xref:System.Timers.Timer.Interval%2A> è trascorso. Per continuare a generare il <xref:System.Timers.Timer.Elapsed> eventi regolarmente in base all'intervallo definito dal <xref:System.Timers.Timer.Interval%2A>, impostare <xref:System.Timers.Timer.AutoReset%2A> a `true`, ovvero il valore predefinito.  
  
 Il <xref:System.Timers.Timer> componente intercetta ed Elimina tutte le eccezioni generate dai gestori eventi per il <xref:System.Timers.Timer.Elapsed> evento. Questo comportamento è soggetta a modifiche nelle versioni future di .NET Framework. Si noti tuttavia che ciò non vale per i gestori di eventi che vengono eseguiti in modo asincrono e includeranno il `await` operatore (in c#) o `Await` operatore (in Visual Basic). Le eccezioni generate in questi gestori eventi vengono propagate nel thread chiamante, come illustrato nell'esempio seguente. Per altre informazioni sulle eccezioni generate nei metodi asincroni, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Se il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà viene `null`, il <xref:System.Timers.Timer.Elapsed> evento viene generato in un <xref:System.Threading.ThreadPool> thread. Se l'elaborazione del <xref:System.Timers.Timer.Elapsed> evento ha una durata superiore <xref:System.Timers.Timer.Interval%2A>, l'evento potrebbe essere generato nuovamente in un altro <xref:System.Threading.ThreadPool> thread. In questo caso, il gestore dell'evento deve essere rientrante.  
  
> [!NOTE]
>  Il metodo di gestione degli eventi può essere eseguito in un unico thread allo stesso tempo che un altro thread chiama il <xref:System.Timers.Timer.Stop%2A> metodo o il set di <xref:System.Timers.Timer.Enabled%2A> proprietà `false`. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> evento generato dopo che il timer è stato arrestato. Il codice di esempio per il <xref:System.Timers.Timer.Stop%2A> metodo illustra un modo per evitare questa race condition.  
  
 Anche se <xref:System.Timers.Timer.SynchronizingObject%2A> non è `null`, <xref:System.Timers.Timer.Elapsed> gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A> proprietà è stata impostata `false`, in quanto il segnale per generare il <xref:System.Timers.Timer.Elapsed> eventi sono sempre in coda per l'esecuzione in un pool di thread. Un modo per risolvere questa race condition consiste nell'impostare un flag che indica il gestore eventi per il <xref:System.Timers.Timer.Elapsed> evento ignori alcuni eventi successivi.  
  
 Se si usa la <xref:System.Timers.Timer?displayProperty=nameWithType> classe con un elemento dell'interfaccia utente, ad esempio un form o controllo, senza attivare il timer su tale elemento dell'interfaccia utente, assegnare il form o un controllo che contiene il <xref:System.Timers.Timer> per il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà, in modo che l'evento è il marshalling nel thread dell'interfaccia utente.  
  
 Per un elenco di valori di proprietà predefiniti per un'istanza di <xref:System.Timers.Timer>, vedere il <xref:System.Timers.Timer.%23ctor%2A> costruttore.  
  
> [!TIP]
>  Tenere presente che .NET include quattro classi denominate `Timer`, ognuno dei quali offre diverse funzionalità:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (questo argomento): genera un evento a intervalli regolari. La classe è destinata da utilizzare come un server basato su o componente del servizio in un ambiente a thread multipli; non dispone di alcuna interfaccia utente e non è visibile in fase di esecuzione.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: esegue un metodo di callback singolo in un pool di thread a intervalli regolari. Il metodo di callback viene definito quando il timer viene creata un'istanza e non può essere modificato. Ad esempio il <xref:System.Timers.Timer?displayProperty=nameWithType> (classe), questa classe è destinata all'utilizzo come un componente basato su server o del servizio in un ambiente multithreading, ma senza un'interfaccia utente e non è visibile in fase di esecuzione.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Solo .NET framework): un componente di Windows Form che genera un evento a intervalli regolari. Il componente non dispone di interfacce utente ed è progettato per l'uso in un ambiente a thread singolo.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Solo .NET framework): un componente ASP.NET che esegue postback asincroni o sincroni pagine web a intervalli regolari.  

## Examples  
 Nell'esempio seguente crea una `System.Timers.Timer` oggetto che viene attivato relativo <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventi ogni due secondi (2000 millisecondi), impostare un gestore eventi per l'evento e avvia il timer. Il gestore dell'evento Visualizza il valore della <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Qualsiasi membro pubblico <see langword="static" /> membri di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Timers.Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Timers.Timer" /> e imposta tutte le proprietà sui rispettivi valori iniziali.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente illustra i valori iniziali delle proprietà per un'istanza di <xref:System.Timers.Timer>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 millisecondi|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Riferimento null (`Nothing` in Visual Basic).|  
  
   
  
## Examples  
 Nell'esempio seguente crea una <xref:System.Timers.Timer> oggetto che viene attivato relativo <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventi ogni due secondi (2000 millisecondi), impostare un gestore eventi per l'evento e avvia il timer. Il gestore dell'evento Visualizza il valore della <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">Tempo che intercorre tra gli eventi, in millisecondi. Il valore deve essere maggiore di zero e minore o uguale a <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Timers.Timer" /> e imposta la proprietà <see cref="P:System.Timers.Timer.Interval" /> sul numero di millisecondi specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore imposta la <xref:System.Timers.Timer.Interval%2A> proprietà dell'istanza del nuovo timer, ma non abilita il timer.  
  
   
  
## Examples  
 Nell'esempio seguente crea una <xref:System.Timers.Timer> oggetto che viene attivato relativo <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventi ogni due secondi (2000 millisecondi), impostare un gestore eventi per l'evento e avvia il timer. Il gestore dell'evento Visualizza il valore della <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore del parametro <paramref name="interval" /> è maggiore o uguale a zero oppure maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerAutoReset")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore booleano che indica se <see cref="T:System.Timers.Timer" /> deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" /> una sola volta (<see langword="false" />) o più volte (<see langword="true" />).</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Timers.Timer" /> deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" /> allo scadere di ogni intervallo; <see langword="false" /> se deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" /> solo una volta, in corrispondenza della prima scadenza dell'intervallo. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Timers.Timer> è già abilitata quando il <xref:System.Timers.Timer.Start%2A> viene chiamato il metodo, l'intervallo viene reimpostato. Se <xref:System.Timers.Timer.AutoReset%2A> viene `false`, il <xref:System.Timers.Timer.Start%2A> necessario chiamare il metodo per avviare nuovamente il conteggio.  
  
 Reimpostare l'intervallo interessa quando il <xref:System.Timers.Timer.Elapsed> viene generato l'evento. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà `true`, il conteggio inizia all'ora <xref:System.Timers.Timer.Enabled%2A> è impostata. Se si reimposta l'intervallo su 10 secondi quando il conteggio è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta, 13 secondi dopo il <xref:System.Timers.Timer.Enabled%2A> è stata impostata su `true`.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Timers.Timer> cui <xref:System.Timers.Timer.Elapsed> viene generato l'evento dopo 1,5 secondi. Quindi, il relativo gestore eventi visualizza "Hello World!" Nella console.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia l'inizializzazione in fase di esecuzione di un oggetto <see cref="T:System.Timers.Timer" /> usato in un form o da un altro componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Progettazione ambiente Usa questo metodo per avviare l'inizializzazione di un componente che viene usato in un form o da un altro componente. Il <xref:System.Timers.Timer.EndInit%2A> metodo termina l'inizializzazione. Usando il <xref:System.Timers.Timer.BeginInit%2A> e <xref:System.Timers.Timer.EndInit%2A> metodi impedisce l'utilizzo prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia le risorse usate da <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Timers.Timer.Close%2A> metodo chiama a sua volta la `Dispose` (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia tutte le risorse usate dall'oggetto <see cref="T:System.Timers.Timer" /> corrente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerIntervalElapsed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'intervallo scade.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Timers.Timer.Elapsed> evento viene generato se il <xref:System.Timers.Timer.Enabled%2A> proprietà è `true` e l'intervallo di tempo (in millisecondi) definito dal <xref:System.Timers.Timer.Interval%2A> proprietà allo scadere dell'intervallo. Se il <xref:System.Timers.Timer.AutoReset%2A> proprietà è `true`, l'evento viene generato ripetutamente in base all'intervallo definito dalle <xref:System.Timers.Timer.Interval%2A> proprietà; in caso contrario, l'evento viene generato una sola volta, la prima volta il <xref:System.Timers.Timer.Interval%2A> valore allo scadere dell'intervallo.  
  
 Se <xref:System.Timers.Timer.Interval%2A> viene impostato dopo la <xref:System.Timers.Timer> è avviato, il conteggio viene reimpostato. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare <xref:System.Timers.Timer.Enabled%2A> al `true`, il conteggio inizia all'ora <xref:System.Timers.Timer.Enabled%2A> è impostata. Se si reimposta l'intervallo su 10 secondi quando il numero è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta dopo 13 secondi <xref:System.Timers.Timer.Enabled%2A> è stata impostata su `true`.  
  
 Se il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà viene `null`, il <xref:System.Timers.Timer.Elapsed> evento viene generato in un <xref:System.Threading.ThreadPool> thread. Se l'elaborazione dei <xref:System.Timers.Timer.Elapsed> evento ha una durata superiore <xref:System.Timers.Timer.Interval%2A>, l'evento potrebbe essere generato nuovamente in un altro <xref:System.Threading.ThreadPool> thread. In questo caso, il gestore dell'evento deve essere rientrante.  
  
> [!NOTE]
>  Il metodo di gestione degli eventi può essere eseguito in un unico thread allo stesso tempo che un altro thread chiama il <xref:System.Timers.Timer.Stop%2A> metodo o il set di <xref:System.Timers.Timer.Enabled%2A> proprietà `false`. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> evento generato dopo che il timer è stato arrestato. Il codice di esempio per il <xref:System.Timers.Timer.Stop%2A> metodo illustra un modo per evitare questa race condition.  
  
 Anche se <xref:System.Timers.Timer.SynchronizingObject%2A> non è `null`, <xref:System.Timers.Timer.Elapsed> gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A> proprietà è stata impostata `false`, in quanto il segnale per generare il <xref:System.Timers.Timer.Elapsed> eventi sono sempre in coda per l'esecuzione in un pool di thread. Un modo per risolvere questa race condition consiste nell'impostare un flag che indica il gestore eventi per il <xref:System.Timers.Timer.Elapsed> evento ignori alcuni eventi successivi.  
  
 Il <xref:System.Timers.Timer> componente intercetta ed Elimina tutte le eccezioni generate dai gestori eventi per il <xref:System.Timers.Timer.Elapsed> evento. Questo comportamento è soggetta a modifiche nelle versioni future di .NET Framework.  
  
   
  
## Examples  
 Nell'esempio seguente crea una <xref:System.Timers.Timer> oggetto che viene attivato relativo <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventi ogni due secondi (2000 millisecondi), impostare un gestore eventi per l'evento e avvia il timer. Il gestore dell'evento Visualizza il valore della <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerEnabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se <see cref="T:System.Timers.Timer" /> deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" />.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Timers.Timer" /> deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" />; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'impostazione <xref:System.Timers.Timer.Enabled%2A> al `true` è uguale alla chiamata al metodo <xref:System.Timers.Timer.Start%2A>, mentre l'impostazione <xref:System.Timers.Timer.Enabled%2A> al `false` è uguale alla chiamata al metodo <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  Il segnale per generare il <xref:System.Timers.Timer.Elapsed> eventi sempre in coda per l'esecuzione su un <xref:System.Threading.ThreadPool> thread. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> evento generato dopo il <xref:System.Timers.Timer.Enabled%2A> è impostata su `false`. L'esempio di codice per il <xref:System.Timers.Timer.Stop%2A> metodo illustra un modo per risolvere questa race condition.  
  
 Se <xref:System.Timers.Timer.Enabled%2A> è impostata su `true` e <xref:System.Timers.Timer.AutoReset%2A> è impostata su `false`, il <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> eventi solo una volta, la prima volta che l'intervallo scade.  
  
 Se l'intervallo viene impostato dopo la <xref:System.Timers.Timer> è avviato, il conteggio viene reimpostato. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà `true`, il conteggio inizia all'ora <xref:System.Timers.Timer.Enabled%2A> è impostata. Se si reimposta l'intervallo su 10 secondi quando il numero è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta dopo 13 secondi <xref:System.Timers.Timer.Enabled%2A> è stata impostata su `true`.  
  
> [!NOTE]
>  Alcune finestre di progettazione visiva, ad esempio quelli in Microsoft Visual Studio, impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà `true` durante l'inserimento di un nuovo <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 Nell'esempio seguente crea una <xref:System.Timers.Timer> oggetto che viene attivato relativo <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventi ogni due secondi (2000 millisecondi), impostare un gestore eventi per l'evento e avvia il timer. Il gestore dell'evento Visualizza il valore della <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Non è possibile impostare questa proprietà perché il timer è stato eliminato.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Timers.Timer.Interval" /> era impostata su un valore maggiore di <see cref="F:System.Int32.MaxValue" /> prima che sia stato abilitato il timer.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina l'inizializzazione in fase di esecuzione di un oggetto <see cref="T:System.Timers.Timer" /> usato in un form o da un altro componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Progettazione ambiente utilizza questo metodo per terminare l'inizializzazione di un componente che viene usato in un form o da un altro componente. Il <xref:System.Timers.Timer.BeginInit%2A> metodo avvia l'inizializzazione. Usando il <xref:System.Timers.Timer.BeginInit%2A> e <xref:System.Timers.Timer.EndInit%2A> metodi impedisce l'utilizzo prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerInterval")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'intervallo, espresso in millisecondi, in cui generare l'evento <see cref="E:System.Timers.Timer.Elapsed" />.</summary>
        <value>Tempo tra gli eventi <see cref="E:System.Timers.Timer.Elapsed" />, in millisecondi. Il valore deve essere maggiore di zero e minore o uguale a <see cref="F:System.Int32.MaxValue" />. Il valore predefinito è 100 millisecondi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si utilizza il <xref:System.Timers.Timer.Interval%2A> proprietà per determinare la frequenza con cui il <xref:System.Timers.Timer.Elapsed> evento. Poiché il <xref:System.Timers.Timer> classe dipende dall'orologio di sistema, ha la stessa risoluzione come l'orologio di sistema. Ciò significa che il <xref:System.Timers.Timer.Elapsed> viene generato l'evento a un intervallo definito per la risoluzione del clock di sistema se la <xref:System.Timers.Timer.Interval%2A> proprietà è minore rispetto alla risoluzione del clock di sistema. L'esempio seguente imposta il <xref:System.Timers.Timer.Interval%2A> proprietà 5 millisecondi. Quando viene eseguito un [!INCLUDE[win7](~/includes/win7-md.md)] sistema il cui clock di sistema ha una risoluzione di circa 15 millisecondi, viene generato l'evento circa ogni 15 millisecondi anziché ogni 5 millisecondi.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 È possibile usare il codice seguente per determinare la risoluzione dell'orologio di sistema nel sistema corrente:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Se l'app richiede una risoluzione maggiore rispetto a quello offerto dal <xref:System.Timers.Timer> classe o l'orologio di sistema, usare i timer multimediali ad alta risoluzione, vedere [procedura: utilizzare il Timer ad alta risoluzione](http://msdn.microsoft.com/library/aa964692.aspx).  
  
 Se l'intervallo viene impostato dopo la <xref:System.Timers.Timer> è avviato, il conteggio viene reimpostato. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà `true`, il conteggio inizia all'ora <xref:System.Timers.Timer.Enabled%2A> è impostata. Se si reimposta l'intervallo su 10 secondi quando il numero è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta dopo 13 secondi <xref:System.Timers.Timer.Enabled%2A> è stata impostata su `true`.  
  
 Se <xref:System.Timers.Timer.Enabled%2A> è impostata su `true` e <xref:System.Timers.Timer.AutoReset%2A> è impostata su `false`, il <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> eventi solo una volta, la prima volta che l'intervallo scade. <xref:System.Timers.Timer.Enabled%2A> viene quindi impostato su `false`.  
  
> [!NOTE]
>  Se <xref:System.Timers.Timer.Enabled%2A> e <xref:System.Timers.Timer.AutoReset%2A> sono entrambe impostate su `false`, e il timer in precedenza abilitato, impostando il <xref:System.Timers.Timer.Interval%2A> proprietà causa il <xref:System.Timers.Timer.Elapsed> dell'evento una volta, come se il <xref:System.Timers.Timer.Enabled%2A> proprietà è stata impostata su `true`. Per impostare l'intervallo senza generazione dell'evento, è possibile impostare temporaneamente i <xref:System.Timers.Timer.Enabled%2A> proprietà `true`, impostare il <xref:System.Timers.Timer.Interval%2A> proprietà per l'intervallo di tempo desiderato e quindi impostare immediatamente il <xref:System.Timers.Timer.Enabled%2A> proprietà verso `false`.  
  
   
  
## Examples  
 Nell'esempio seguente crea una <xref:System.Timers.Timer> oggetto che viene attivato relativo <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventi ogni due secondi (2000 millisecondi), impostare un gestore eventi per l'evento e avvia il timer. Il gestore dell'evento Visualizza il valore della <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'intervallo è minore o uguale a zero.  
  
oppure 
L'intervallo è più grande di <see cref="F:System.Int32.MaxValue" />e il timer è attualmente attivato. Non viene generata alcuna eccezione finché il timer non viene abilitato.</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il sito che associa l'oggetto <see cref="T:System.Timers.Timer" /> al contenitore in modalità progettazione.</summary>
        <value>Interfaccia <see cref="T:System.ComponentModel.ISite" /> che rappresenta il sito che associa l'oggetto <see cref="T:System.Timers.Timer" /> al contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Associano i siti di una <xref:System.ComponentModel.Component> a un <xref:System.ComponentModel.Container> e abilitare la comunicazione tra di essi, nonché fornendo un modo per il contenitore gestire i relativi componenti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia la generazione dell'evento <see cref="E:System.Timers.Timer.Elapsed" /> impostando <see cref="P:System.Timers.Timer.Enabled" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Timers.Timer.Start%2A> viene chiamato e <xref:System.Timers.Timer.AutoReset%2A> è impostata su `false`, il <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> eventi solo una volta, la prima volta che l'intervallo scade. Se <xref:System.Timers.Timer.Start%2A> viene chiamato e <xref:System.Timers.Timer.AutoReset%2A> viene `true`, il <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> ora dell'evento prima l'intervallo scade e continua a generare l'evento nell'intervallo specificato.  
  
 È anche possibile avviare temporizzazione impostando <xref:System.Timers.Timer.Enabled%2A> a `true`.  
  
> [!NOTE]
>  Se <xref:System.Timers.Timer.AutoReset%2A> viene `false`, il <xref:System.Timers.Timer.Start%2A> necessario chiamare il metodo per avviare nuovamente il conteggio.  
  
 Una chiamata al <xref:System.Timers.Timer.Start%2A> metodo quando è abilitato il timer non ha alcun effetto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'oggetto <see cref="T:System.Timers.Timer" /> viene creato con intervallo uguale o maggiore di <see cref="F:System.Int32.MaxValue" /> + 1 oppure viene impostato su un intervallo minore di zero.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arresta la generazione dell'evento <see cref="E:System.Timers.Timer.Elapsed" /> impostando <see cref="P:System.Timers.Timer.Enabled" /> su <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È anche possibile arrestare temporizzazione impostando <xref:System.Timers.Timer.Enabled%2A> a `false`.  
  
> [!NOTE]
>  Il segnale per generare il <xref:System.Timers.Timer.Elapsed> eventi sempre in coda per l'esecuzione in un <xref:System.Threading.ThreadPool> thread, in modo che il metodo di gestione degli eventi può essere eseguito in un unico thread allo stesso tempo che una chiamata al <xref:System.Timers.Timer.Stop%2A> metodo viene eseguito in un altro thread. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> evento generato dopo il <xref:System.Timers.Timer.Stop%2A> viene chiamato il metodo. L'esempio di codice nella sezione successiva illustra un modo per risolvere questa race condition.  
  
   
  
## Examples  
 Nell'esempio seguente crea una `System.Timers.Timer` oggetto che viene attivato relativo <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventi ogni due secondi (2000 millisecondi), impostare un gestore eventi per l'evento e avvia il timer. Il gestore dell'evento Visualizza il valore della <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato. Quando l'utente preme il tasto INVIO, l'applicazione chiama il <xref:System.Timers.Timer.Stop%2A> metodo prima di terminare l'applicazione.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 Esempio di codice seguente illustra un modo per evitare che il thread che chiama il <xref:System.Timers.Timer.Stop%2A> metodo non potrà continuare fino a un attualmente in esecuzione <xref:System.Timers.Timer.Elapsed> termina evento e anche per evitare che due <xref:System.Timers.Timer.Elapsed> gli eventi di esecuzione del gestore di evento allo stesso ora (noto anche come reentrancy).  
  
 L'esempio esegue 100 esecuzioni dei test. Ogni volta che viene eseguito il test, il timer viene avviato con un intervallo di 150 millisecondi. Il gestore eventi Usa le <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo da simulare un'attività che varia in modo casuale di lunghezza compresa tra 50 e 200 millisecondi. Inoltre, il metodo di test avvia un thread di controllo che è in attesa di un secondo e quindi si arresta il timer. Se viene gestito un evento quando il thread di controllo si arresta il timer, il thread di controllo deve attendere fino al termine dell'evento prima di procedere.  
  
 Il <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> overload del metodo viene usato per evitare la reentrancy e impedire al thread di controllo proseguire fino alla fine di un evento in esecuzione. Il gestore eventi Usa le <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> metodo per impostare un controllo, variabili su 1, ma solo se il valore attualmente è zero. Si tratta di un'operazione atomica. Se il valore restituito è zero, la variabile di controllo è stata impostata su 1 e consente di passare il gestore dell'evento. Se il valore restituito è diverso da zero, l'evento viene semplicemente ignorato, per evitare la reentrancy. (Se fosse necessario eseguire tutti gli eventi, il <xref:System.Threading.Monitor> classe sarebbe un modo migliore per sincronizzare gli eventi.) Quando termina il gestore dell'evento, imposta la variabile di controllo nuovamente su zero. L'esempio registra il numero totale di eventi eseguiti, che sono stati scartati a causa della reentrancy e che si sono verificati dopo il <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato.  
  
 Il thread di controllo Usa il <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> metodo per impostare il controllo di variabili per -1 (meno uno), ma solo se il valore attualmente è zero. Se l'operazione atomica positivo diverso da zero, un evento è in esecuzione. Il thread di controllo rimane in attesa e nuovo tentativo. L'esempio registra il numero di volte in cui che il thread di controllo era necessario attendere un evento di completamento.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto usato per effettuare il marshalling delle chiamate del gestore eventi generate alla scadenza di un intervallo.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> che rappresenta l'oggetto usato per effettuare il marshalling delle chiamate del gestore eventi generate alla scadenza di un intervallo. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Timers.Timer.SynchronizingObject%2A> viene `null`, il metodo che gestisce il <xref:System.Timers.Timer.Elapsed> eventi viene chiamato su un thread dal pool di thread del sistema. Per altre informazioni sui pool di thread del sistema, vedere <xref:System.Threading.ThreadPool>.  
  
 Quando il <xref:System.Timers.Timer.Elapsed> evento è gestito da un componente di Windows Form visual, ad esempio un pulsante, l'accesso al componente tramite il pool di thread del sistema potrebbe essere il risultato di un'eccezione o semplicemente potrebbero non funzionare. Per evitare questo effetto impostando <xref:System.Timers.Timer.SynchronizingObject%2A> a un componente di Windows Form, in modo che il metodo che gestisce il <xref:System.Timers.Timer.Elapsed> eventi da chiamare sullo stesso thread che il componente è stato creato.  
  
> [!NOTE]
>  Anche se il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà non è `null`, <xref:System.Timers.Timer.Elapsed> gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato o dopo la <xref:System.Timers.Timer.Enabled%2A> proprietà è stata impostata `false`, in quanto il segnale per generare il <xref:System.Timers.Timer.Elapsed> eventi sono sempre in coda per l'esecuzione in un pool di thread. Un modo per risolvere questa race condition consiste nell'impostare un flag che indica il gestore eventi per il <xref:System.Timers.Timer.Elapsed> evento ignori alcuni eventi successivi.  
  
 Se il <xref:System.Timers.Timer> viene usato all'interno di Visual Studio in una finestra di progettazione Windows Form <xref:System.Timers.Timer.SynchronizingObject%2A> viene impostato automaticamente al controllo che contiene il <xref:System.Timers.Timer>. Ad esempio, se si inserisce un <xref:System.Timers.Timer> in una finestra di progettazione per `Form1` (che eredita dalla classe <xref:System.Windows.Forms.Form>), il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà di <xref:System.Timers.Timer> è impostato per l'istanza di `Form1`.  
  
   
  
## Examples  
 L'esempio seguente è un'app di Windows Form che funge da un editor di file di testo molto semplice. Quando il testo nella casella di testo non è stato salvato, l'app chiede all'utente a intervalli di un minuto se desidera salvare il contenuto della casella di testo.  A tale scopo, il <xref:System.Timers.Timer.Interval%2A> è impostata su 1 minuto (60000 millisecondi) e il <xref:System.Timers.Timer.SynchronizingObject%2A> è impostata sul <xref:System.Windows.Forms.Form> oggetto.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 L'esempio è necessario aggiungere i seguenti controlli al form:  
  
-   Oggetto <xref:System.Windows.Forms.TextBox> controllo denominato `TextBox1` (nome predefinito).  
  
-   Oggetto <xref:System.Windows.Forms.Button> controllo denominato `Button1` (nome predefinito).  
  
-   Oggetto <xref:System.Windows.Forms.SaveFileDialog> controllo denominato `SaveSaveFileDialog1` (nome predefinito).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>