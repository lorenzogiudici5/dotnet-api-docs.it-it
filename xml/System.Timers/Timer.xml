<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fcc0e5e5a3656054b36a6ed93ec6732ed26646c9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36406580" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Generates an event after a set interval, with an option to generate recurring events.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Timers.Timer> componente è un timer basate su server che genera un <xref:System.Timers.Timer.Elapsed> eventi dell'applicazione dopo il numero di millisecondi nel <xref:System.Timers.Timer.Interval%2A> proprietà che è trascorso. È possibile configurare il <xref:System.Timers.Timer> oggetto per generare l'evento solo una o più volte utilizzando la <xref:System.Timers.Timer.AutoReset%2A> proprietà. In genere, un <xref:System.Timers.Timer> oggetto viene dichiarato a livello di classe in modo che rimanga nell'ambito fino a quando è necessaria. È possibile quindi gestire relativo <xref:System.Timers.Timer.Elapsed> eventi per garantire l'elaborazione regolare. Ad esempio, si supponga un server critico che deve rimanere in esecuzione 24 ore su 24, 7 giorni a settimana. È possibile creare un servizio che utilizza un <xref:System.Timers.Timer> oggetto per verificare periodicamente il server e verificare che il sistema sia attivo e in esecuzione. Se il sistema non risponde, il servizio potrebbe tentare di riavviare il server o notificare a un amministratore.  
  
> [!IMPORTANT]
> Il <xref:System.Timers.Timer> classe non è disponibile per tutte le versioni, ad esempio .NET Standard 1.6 e versioni precedenti e le implementazioni di .NET.
> In questi casi, è possibile utilizzare il <xref:System.Threading.Timer?displayProperty=nameWithType> classe.
  
 Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 Basate su server <xref:System.Timers.Timer?displayProperty=nameWithType> classe è progettata per l'utilizzo con thread di lavoro in un ambiente a thread multipli. Timer server possono spostarsi tra i thread per gestire l'eccezione generata <xref:System.Timers.Timer.Elapsed> evento, precisione maggiore dei timer di Windows nella generazione dell'evento nel tempo.  
  
 Il <xref:System.Timers.Timer?displayProperty=nameWithType> componente genera il <xref:System.Timers.Timer.Elapsed> evento, in base al valore (in millisecondi) del <xref:System.Timers.Timer.Interval%2A> proprietà. È possibile gestire questo evento per eseguire l'elaborazione che è necessario. Ad esempio, si supponga di avere un'applicazione di vendita online che inserisce continuamente gli ordini di vendita in un database. Il servizio che consente di compilare le istruzioni per la spedizione opera su un batch di ordini anziché elaborare individualmente ogni ordine. È possibile utilizzare un <xref:System.Timers.Timer> per avviare il batch l'elaborazione di ogni 30 minuti.  
  
> [!IMPORTANT]
>  La classe System.Timers.Timer ha la stessa risoluzione l'orologio di sistema. Ciò significa che il <xref:System.Timers.Timer.Elapsed> evento verrà generato a un intervallo definito dalla risoluzione del clock di sistema se la <xref:System.Timers.Timer.Interval%2A> proprietà è minore rispetto alla risoluzione del clock di sistema. Per altre informazioni, vedere la proprietà <xref:System.Timers.Timer.Interval%2A>.  
  
 Quando si <xref:System.Timers.Timer.AutoReset%2A> è impostata su `false`, un <xref:System.Timers.Timer?displayProperty=nameWithType> oggetto genera il <xref:System.Timers.Timer.Elapsed> evento una sola volta, dopo il primo <xref:System.Timers.Timer.Interval%2A> è trascorso. Per continuare a generare il <xref:System.Timers.Timer.Elapsed> eventi regolarmente in base all'intervallo definito dal <xref:System.Timers.Timer.Interval%2A>, impostare <xref:System.Timers.Timer.AutoReset%2A> a `true`, ovvero il valore predefinito.  
  
 Il <xref:System.Timers.Timer> componente intercetta ed Elimina tutte le eccezioni generate dai gestori eventi per il <xref:System.Timers.Timer.Elapsed> evento. Questo comportamento è soggetto a modifiche nelle versioni future di .NET Framework. Si noti, tuttavia, che ciò non vale per i gestori di eventi che vengono eseguiti in modo asincrono e includeranno il `await` operatore (in c#) o `Await` operatore (in Visual Basic). Le eccezioni generate in questi gestori eventi vengono propagate nel thread chiamante, come illustrato nell'esempio seguente. Per ulteriori informazioni sulle eccezioni generate nei metodi asincroni, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Se il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà è `null`, la <xref:System.Timers.Timer.Elapsed> evento viene generato in un <xref:System.Threading.ThreadPool> thread. Se l'elaborazione dei <xref:System.Timers.Timer.Elapsed> evento ha una durata superiore <xref:System.Timers.Timer.Interval%2A>, l'evento potrebbe essere generato nuovamente in un altro <xref:System.Threading.ThreadPool> thread. In questo caso, il gestore dell'evento deve essere rientrante.  
  
> [!NOTE]
>  Il metodo di gestione degli eventi può essere eseguito in un unico thread allo stesso tempo che un altro thread chiama il <xref:System.Timers.Timer.Stop%2A> metodo o imposta il <xref:System.Timers.Timer.Enabled%2A> proprietà `false`. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> evento generato dopo che il timer è stato arrestato. Nell'esempio di codice per il <xref:System.Timers.Timer.Stop%2A> metodo illustrato un modo per evitare la race condition.  
  
 Anche se <xref:System.Timers.Timer.SynchronizingObject%2A> non è `null`, <xref:System.Timers.Timer.Elapsed> gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A> proprietà è stata impostata su `false`, poiché il segnale per generare il <xref:System.Timers.Timer.Elapsed> evento è sempre in coda per l'esecuzione in un pool di thread. Per evitare la race condition consiste nell'impostare un flag che indica il gestore dell'evento per il <xref:System.Timers.Timer.Elapsed> evento ignori alcuni eventi successivi.  
  
 Se si utilizza il <xref:System.Timers.Timer?displayProperty=nameWithType> classe con un elemento dell'interfaccia utente, ad esempio un form o controllo, senza inserire il timer su tale elemento dell'interfaccia utente, assegnare il form o un controllo che contiene il <xref:System.Timers.Timer> per il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà, in modo che l'evento è effettuare il marshalling al thread dell'interfaccia utente.  
  
 Per un elenco di valori predefiniti delle proprietà per un'istanza di <xref:System.Timers.Timer>, vedere il <xref:System.Timers.Timer.%23ctor%2A> costruttore.  
  
> [!TIP]
>  Tenere presente che .NET include quattro classi denominate `Timer`in ognuno dei quali offre diverse funzionalità:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (questo argomento): viene generato un evento a intervalli regolari. La classe è destinata utilizzato come un server basato su o componente del servizio in un ambiente con multithreading; non dispone di alcuna interfaccia utente e non è visibile in fase di esecuzione.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: esegue un metodo di callback singola in un pool di thread a intervalli regolari. Il metodo di callback viene definito quando il timer viene creata un'istanza e non può essere modificato. Ad esempio il <xref:System.Timers.Timer?displayProperty=nameWithType> (classe), questa classe è destinata a essere utilizzata come un componente basato su server o servizio in un ambiente con multithreading, ma non dispone di alcuna interfaccia utente e non è visibile in fase di esecuzione.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Solo in .NET framework): un componente di Windows Form che genera un evento a intervalli regolari. Il componente non dispone di alcuna interfaccia utente e viene progettato per l'uso in un ambiente a thread singolo.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Solo in .NET framework): un componente ASP.NET che esegue i postback asincroni o sincroni di pagina web a intervalli regolari.  

## Examples  
 Nell'esempio seguente viene creata un'istanza una `System.Timers.Timer` oggetto che attiva il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Qualsiasi pubblico <see langword="static" /> i membri di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Timers.Timer" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Timers.Timer" /> class, and sets all the properties to their initial values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente illustra i valori di proprietà iniziali per un'istanza di <xref:System.Timers.Timer>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 millisecondi|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Riferimento null (`Nothing` in Visual Basic).|  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza una <xref:System.Timers.Timer> oggetto che attiva il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">The time, in milliseconds, between events. The value must be greater than zero and less than or equal to <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Timers.Timer" /> class, and sets the <see cref="P:System.Timers.Timer.Interval" /> property to the specified number of milliseconds.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore imposta la <xref:System.Timers.Timer.Interval%2A> proprietà della nuova istanza di timer, ma non abilita il timer.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza una <xref:System.Timers.Timer> oggetto che attiva il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value of the <paramref name="interval" /> parameter is less than or equal to zero, or greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a Boolean indicating whether the <see cref="T:System.Timers.Timer" /> should raise the <see cref="E:System.Timers.Timer.Elapsed" /> event only once (<see langword="false" />) or repeatedly (<see langword="true" />).</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Timers.Timer" /> deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" /> allo scadere di ogni intervallo; <see langword="false" /> se deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" /> solo una volta, in corrispondenza della prima scadenza dell'intervallo. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Timers.Timer> è già abilitata quando il <xref:System.Timers.Timer.Start%2A> metodo viene chiamato, l'intervallo viene reimpostato. Se <xref:System.Timers.Timer.AutoReset%2A> viene `false`, il <xref:System.Timers.Timer.Start%2A> metodo deve essere chiamato per avviare nuovamente il conteggio.  
  
 Reimpostare l'intervallo interessa quando il <xref:System.Timers.Timer.Elapsed> evento viene generato. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà da `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A> è impostata. Se l'intervallo viene reimpostato su 10 secondi quando il conteggio è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta 13 secondi dopo che il <xref:System.Timers.Timer.Enabled%2A> è stata impostata su `true`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Timers.Timer> cui <xref:System.Timers.Timer.Elapsed> evento viene generato dopo 1,5 secondi. Quindi, il gestore eventi visualizza "Hello World!" Nella console.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins the run-time initialization of a <see cref="T:System.Timers.Timer" /> that is used on a form or by another component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Progettazione ambiente utilizza questo metodo per avviare l'inizializzazione di un componente che viene utilizzato in un form o da un altro componente. Il <xref:System.Timers.Timer.EndInit%2A> metodo termina l'inizializzazione. Utilizzando il <xref:System.Timers.Timer.BeginInit%2A> e <xref:System.Timers.Timer.EndInit%2A> metodi impedisce il controllo venga utilizzato prima che il completamento dell'inizializzazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the resources used by the <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Timers.Timer.Close%2A> metodo chiama a sua volta il `Dispose` metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases all resources used by the current <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the interval elapses.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Timers.Timer.Elapsed> evento viene generato se il <xref:System.Timers.Timer.Enabled%2A> proprietà `true` e l'intervallo di tempo (in millisecondi) definito dal <xref:System.Timers.Timer.Interval%2A> allo scadere di proprietà. Se il <xref:System.Timers.Timer.AutoReset%2A> proprietà è `true`, l'evento viene generato ripetutamente in un intervallo definito dal <xref:System.Timers.Timer.Interval%2A> proprietà; in caso contrario, l'evento viene generato una sola volta, la prima volta il <xref:System.Timers.Timer.Interval%2A> valore di questo intervallo.  
  
 Se <xref:System.Timers.Timer.Interval%2A> viene impostato dopo la <xref:System.Timers.Timer> è avviato, il conteggio viene reimpostato. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare <xref:System.Timers.Timer.Enabled%2A> al `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A> è impostata. Se l'intervallo viene reimpostato su 10 secondi quando il conteggio è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta 13 secondi dopo che <xref:System.Timers.Timer.Enabled%2A> è stato impostato su `true`.  
  
 Se il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà è `null`, la <xref:System.Timers.Timer.Elapsed> evento viene generato in un <xref:System.Threading.ThreadPool> thread. Se l'elaborazione del <xref:System.Timers.Timer.Elapsed> evento ha una durata superiore <xref:System.Timers.Timer.Interval%2A>, l'evento potrebbe essere generato nuovamente in un altro <xref:System.Threading.ThreadPool> thread. In questo caso, il gestore dell'evento deve essere rientrante.  
  
> [!NOTE]
>  Il metodo di gestione degli eventi può essere eseguito in un unico thread allo stesso tempo che un altro thread chiama il <xref:System.Timers.Timer.Stop%2A> metodo o imposta il <xref:System.Timers.Timer.Enabled%2A> proprietà `false`. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> evento generato dopo che il timer è stato arrestato. Nell'esempio di codice per il <xref:System.Timers.Timer.Stop%2A> metodo illustrato un modo per evitare la race condition.  
  
 Anche se <xref:System.Timers.Timer.SynchronizingObject%2A> non è `null`, <xref:System.Timers.Timer.Elapsed> gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A> proprietà è stata impostata su `false`, poiché il segnale per generare il <xref:System.Timers.Timer.Elapsed> evento è sempre in coda per l'esecuzione in un pool di thread. Per evitare la race condition consiste nell'impostare un flag che indica il gestore dell'evento per il <xref:System.Timers.Timer.Elapsed> evento ignori alcuni eventi successivi.  
  
 Il <xref:System.Timers.Timer> componente intercetta ed Elimina tutte le eccezioni generate dai gestori eventi per il <xref:System.Timers.Timer.Elapsed> evento. Questo comportamento è soggetto a modifiche nelle versioni future di .NET Framework.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza una <xref:System.Timers.Timer> oggetto che attiva il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the <see cref="T:System.Timers.Timer" /> should raise the <see cref="E:System.Timers.Timer.Elapsed" /> event.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Timers.Timer" /> deve generare l'evento <see cref="E:System.Timers.Timer.Elapsed" />; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'impostazione <xref:System.Timers.Timer.Enabled%2A> per `true` è uguale a chiamare <xref:System.Timers.Timer.Start%2A>, mentre l'impostazione <xref:System.Timers.Timer.Enabled%2A> a `false` corrisponde a chiamare <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  Il segnale per generare il <xref:System.Timers.Timer.Elapsed> evento sempre in coda per l'esecuzione in un <xref:System.Threading.ThreadPool> thread. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> evento generato dopo il <xref:System.Timers.Timer.Enabled%2A> è impostata su `false`. L'esempio di codice per il <xref:System.Timers.Timer.Stop%2A> metodo illustrato un modo per aggirare questa race condition.  
  
 Se <xref:System.Timers.Timer.Enabled%2A> è impostata su `true` e <xref:System.Timers.Timer.AutoReset%2A> è impostata su `false`, il <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> evento solo una volta, la prima volta l'intervallo scade.  
  
 Se l'intervallo viene impostato dopo la <xref:System.Timers.Timer> è avviato, il conteggio viene reimpostato. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà da `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A> è impostata. Se l'intervallo viene reimpostato su 10 secondi quando il conteggio è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta 13 secondi dopo che <xref:System.Timers.Timer.Enabled%2A> è stato impostato su `true`.  
  
> [!NOTE]
>  Alcune finestre di progettazione visiva, come quelle presenti in Microsoft Visual Studio, impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà da `true` durante l'inserimento di un nuovo <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza una <xref:System.Timers.Timer> oggetto che attiva il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">This property cannot be set because the timer has been disposed.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Timers.Timer.Interval" /> property was set to a value greater than <see cref="F:System.Int32.MaxValue" /> before the timer was enabled.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends the run-time initialization of a <see cref="T:System.Timers.Timer" /> that is used on a form or by another component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Progettazione ambiente utilizza questo metodo per terminare l'inizializzazione di un componente che viene utilizzato in un form o da un altro componente. Il <xref:System.Timers.Timer.BeginInit%2A> metodo avvia l'inizializzazione. Utilizzando il <xref:System.Timers.Timer.BeginInit%2A> e <xref:System.Timers.Timer.EndInit%2A> metodi impedisce il controllo venga utilizzato prima che il completamento dell'inizializzazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the interval, expressed in milliseconds, at which to raise the <see cref="E:System.Timers.Timer.Elapsed" /> event.</summary>
        <value>Tempo tra gli eventi <see cref="E:System.Timers.Timer.Elapsed" />, in millisecondi. Il valore deve essere maggiore di zero e minore o uguale a <see cref="F:System.Int32.MaxValue" />. Il valore predefinito è 100 millisecondi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la <xref:System.Timers.Timer.Interval%2A> proprietà per determinare la frequenza con la quale il <xref:System.Timers.Timer.Elapsed> viene generato l'evento. Poiché il <xref:System.Timers.Timer> classe dipende dall'orologio di sistema, ha la stessa risoluzione l'orologio di sistema. Ciò significa che il <xref:System.Timers.Timer.Elapsed> evento verrà generato a un intervallo definito dalla risoluzione del clock di sistema se la <xref:System.Timers.Timer.Interval%2A> proprietà è minore rispetto alla risoluzione del clock di sistema. Nell'esempio seguente il <xref:System.Timers.Timer.Interval%2A> proprietà viene impostata su 5 millisecondi. Quando viene eseguito un [!INCLUDE[win7](~/includes/win7-md.md)] sistema cui orologio di sistema ha una risoluzione di circa 15 millisecondi, viene generato l'evento circa ogni 15 millisecondi anziché ogni 5 millisecondi.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 È possibile utilizzare il codice seguente per determinare la risoluzione del clock di sistema nel sistema corrente:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Se l'app richiede una risoluzione maggiori rispetto a quello offerto il <xref:System.Timers.Timer> classe o l'orologio di sistema, utilizzare i timer multimediali ad alta risoluzione, vedere [procedura: utilizzare il Timer ad alta risoluzione](http://msdn.microsoft.com/library/aa964692.aspx).  
  
 Se l'intervallo viene impostato dopo la <xref:System.Timers.Timer> è avviato, il conteggio viene reimpostato. Ad esempio, se si imposta l'intervallo di 5 secondi e quindi impostare il <xref:System.Timers.Timer.Enabled%2A> proprietà da `true`, il conteggio inizia al momento <xref:System.Timers.Timer.Enabled%2A> è impostata. Se l'intervallo viene reimpostato su 10 secondi quando il conteggio è 3 secondi, il <xref:System.Timers.Timer.Elapsed> evento viene generato per la prima volta 13 secondi dopo che <xref:System.Timers.Timer.Enabled%2A> è stato impostato su `true`.  
  
 Se <xref:System.Timers.Timer.Enabled%2A> è impostata su `true` e <xref:System.Timers.Timer.AutoReset%2A> è impostata su `false`, il <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> evento solo una volta, la prima volta l'intervallo scade. <xref:System.Timers.Timer.Enabled%2A> viene quindi impostato su `false`.  
  
> [!NOTE]
>  Se <xref:System.Timers.Timer.Enabled%2A> e <xref:System.Timers.Timer.AutoReset%2A> sono impostati entrambi su `false`, e il timer è già stato abilitato, impostazione il <xref:System.Timers.Timer.Interval%2A> proprietà causa la <xref:System.Timers.Timer.Elapsed> dell'evento una volta, come se il <xref:System.Timers.Timer.Enabled%2A> era impostata su `true`. Per impostare l'intervallo senza generazione dell'evento, è possibile impostare temporaneamente il <xref:System.Timers.Timer.Enabled%2A> proprietà da `true`, impostare il <xref:System.Timers.Timer.Interval%2A> proprietà per l'intervallo di tempo desiderato, quindi impostare immediatamente il <xref:System.Timers.Timer.Enabled%2A> proprietà nuovamente a `false`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza una <xref:System.Timers.Timer> oggetto che attiva il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The interval is less than or equal to zero.  -or-  The interval is greater than <see cref="F:System.Int32.MaxValue" />, and the timer is currently enabled. (If the timer is not currently enabled, no exception is thrown until it becomes enabled.)</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the site that binds the <see cref="T:System.Timers.Timer" /> to its container in design mode.</summary>
        <value>Interfaccia <see cref="T:System.ComponentModel.ISite" /> che rappresenta il sito che associa l'oggetto <see cref="T:System.Timers.Timer" /> al contenitore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siti associano un <xref:System.ComponentModel.Component> a un <xref:System.ComponentModel.Container> e abilitare la comunicazione fra di esse, nonché fornendo un modo per il contenitore gestire i relativi componenti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts raising the <see cref="E:System.Timers.Timer.Elapsed" /> event by setting <see cref="P:System.Timers.Timer.Enabled" /> to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Timers.Timer.Start%2A> viene chiamato e <xref:System.Timers.Timer.AutoReset%2A> è impostata su `false`, il <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> evento solo una volta, la prima volta l'intervallo scade. Se <xref:System.Timers.Timer.Start%2A> viene chiamato e <xref:System.Timers.Timer.AutoReset%2A> viene `true`, il <xref:System.Timers.Timer> genera il <xref:System.Timers.Timer.Elapsed> ora dell'evento prima l'intervallo scade e continua a generare l'evento nell'intervallo specificato.  
  
 È inoltre possibile avviare temporizzazione impostando <xref:System.Timers.Timer.Enabled%2A> a `true`.  
  
> [!NOTE]
>  Se <xref:System.Timers.Timer.AutoReset%2A> viene `false`, il <xref:System.Timers.Timer.Start%2A> metodo deve essere chiamato per avviare nuovamente il conteggio.  
  
 Una chiamata al <xref:System.Timers.Timer.Start%2A> metodo quando il timer viene abilitato non ha alcun effetto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <see cref="T:System.Timers.Timer" /> is created with an interval equal to or greater than <see cref="F:System.Int32.MaxValue" /> + 1, or set to an interval less than zero.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops raising the <see cref="E:System.Timers.Timer.Elapsed" /> event by setting <see cref="P:System.Timers.Timer.Enabled" /> to <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È anche possibile arrestare temporizzazione impostando <xref:System.Timers.Timer.Enabled%2A> a `false`.  
  
> [!NOTE]
>  Il segnale per generare il <xref:System.Timers.Timer.Elapsed> evento sempre in coda per l'esecuzione in un <xref:System.Threading.ThreadPool> thread, pertanto il metodo di gestione degli eventi può essere eseguito in un unico thread allo stesso tempo che una chiamata al <xref:System.Timers.Timer.Stop%2A> metodo viene eseguito in un altro thread. Ciò potrebbe comportare il <xref:System.Timers.Timer.Elapsed> evento generato dopo il <xref:System.Timers.Timer.Stop%2A> metodo viene chiamato. Nell'esempio di codice nella sezione successiva viene illustrato un modo per aggirare questa race condition.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza una `System.Timers.Timer` oggetto che attiva il <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento ogni due secondi (2000 millisecondi), consente di impostare un gestore eventi per l'evento e avvia il timer. Il gestore eventi visualizza il valore di <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> proprietà ogni volta che viene generato. Quando l'utente preme il tasto INVIO, l'applicazione chiama il <xref:System.Timers.Timer.Stop%2A> metodo prima di interrompere l'applicazione.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 Esempio di codice seguente viene illustrato un modo per evitare che il thread che chiama la <xref:System.Timers.Timer.Stop%2A> metodo non potrà continuare fino a un attualmente in esecuzione <xref:System.Timers.Timer.Elapsed> evento termina e anche per evitare che due <xref:System.Timers.Timer.Elapsed> eventi dall'esecuzione del gestore eventi contemporaneamente ora (noto anche come reentrancy).  
  
 L'esempio esegue 100 esecuzioni dei test. Ogni volta che viene eseguito il test, il timer viene avviato con un intervallo di 150 millisecondi. Il gestore dell'evento viene utilizzato il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo da simulare un'attività che varia in modo casuale di lunghezza compresa tra 50 e 200 millisecondi. Inoltre, il metodo di test avvia un thread di controllo che è in attesa di un secondo e quindi si arresta il timer. Se viene gestito un evento quando il thread del controllo si arresta il timer, il thread del controllo deve attendere fino al termine dell'evento prima di procedere.  
  
 Il <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> overload del metodo viene utilizzato per evitare la reentrancy e impedire al thread del controllo proseguire fino alla fine di un evento in esecuzione. Il gestore dell'evento viene utilizzato il <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> metodo per impostare un controllo variabile su 1, ma solo se il valore è zero. Si tratta di un'operazione atomica. Se il valore restituito è zero, la variabile di controllo è stata impostata su 1 e consente di passare il gestore dell'evento. Se il valore restituito è diverso da zero, l'evento viene semplicemente eliminato per evitare reentrancy. (Se fosse necessario eseguire ogni evento, il <xref:System.Threading.Monitor> classe sarebbe un modo migliore per sincronizzare gli eventi.) Quando termina, il gestore dell'evento imposta la variabile di controllo torna a zero. Nell'esempio viene registrato il numero totale di eventi eseguiti, che sono stati scartati a causa della reentrancy, e che si sono verificati dopo il <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato.  
  
 Il thread del controllo utilizza il <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> metodo per impostare il controllo variabile su -1 (meno uno), ma solo se il valore è zero. Se l'operazione atomica positivo diverso da zero, un evento è in esecuzione. Il thread di controllo rimane in attesa e nuovo tentativo. Nell'esempio viene registrato il numero di volte in cui che il thread di controllo era necessario attendere il completamento di un evento.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object used to marshal event-handler calls that are issued when an interval has elapsed.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> che rappresenta l'oggetto usato per effettuare il marshalling delle chiamate del gestore eventi generate alla scadenza di un intervallo. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si <xref:System.Timers.Timer.SynchronizingObject%2A> viene `null`, il metodo che gestisce il <xref:System.Timers.Timer.Elapsed> eventi viene chiamato su un thread dal pool di thread del sistema. Per ulteriori informazioni sui pool di thread del sistema, vedere <xref:System.Threading.ThreadPool>.  
  
 Quando il <xref:System.Timers.Timer.Elapsed> evento è gestito da un componente di Windows Form visivo, ad esempio un pulsante, l'accesso a un componente il pool di thread del sistema potrebbe essere il risultato di un'eccezione o semplicemente potrebbero non funzionare. Per evitare questo effetto impostando <xref:System.Timers.Timer.SynchronizingObject%2A> a un componente di Windows Form, che fa sì che il metodo che gestisce il <xref:System.Timers.Timer.Elapsed> evento sia chiamato sullo stesso thread in cui il componente è stato creato.  
  
> [!NOTE]
>  Anche se il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà non è `null`, <xref:System.Timers.Timer.Elapsed> gli eventi possono verificarsi dopo il <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> metodo è stato chiamato o dopo il <xref:System.Timers.Timer.Enabled%2A> proprietà è stata impostata su `false`, poiché il segnale per generare il <xref:System.Timers.Timer.Elapsed> evento è sempre in coda per l'esecuzione in un pool di thread. Per evitare la race condition consiste nell'impostare un flag che indica il gestore dell'evento per il <xref:System.Timers.Timer.Elapsed> evento ignori alcuni eventi successivi.  
  
 Se il <xref:System.Timers.Timer> viene utilizzata all'interno di Visual Studio in una finestra di progettazione Windows Form <xref:System.Timers.Timer.SynchronizingObject%2A> viene impostato automaticamente al controllo che contiene il <xref:System.Timers.Timer>. Ad esempio, se si inserisce una <xref:System.Timers.Timer> in una finestra di progettazione per `Form1` (che eredita dalla classe <xref:System.Windows.Forms.Form>), il <xref:System.Timers.Timer.SynchronizingObject%2A> proprietà di <xref:System.Timers.Timer> è impostato per l'istanza di `Form1`.  
  
   
  
## Examples  
 Nell'esempio seguente è un'app di Windows Form che funge da un editor di file di testo molto semplice. Quando il testo nella casella di testo non è stato salvato, l'applicazione chiede all'utente a intervalli di un minuto se desidera salvare il contenuto della casella di testo.  A tale scopo, il <xref:System.Timers.Timer.Interval%2A> è impostata su 1 minuto (60000 millisecondi) e il <xref:System.Timers.Timer.SynchronizingObject%2A> è impostata sul <xref:System.Windows.Forms.Form> oggetto.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 Nell'esempio è necessario aggiungere i seguenti controlli al form:  
  
-   Un <xref:System.Windows.Forms.TextBox> controllo denominato `TextBox1` (nome predefinito).  
  
-   Un <xref:System.Windows.Forms.Button> controllo denominato `Button1` (nome predefinito).  
  
-   Un <xref:System.Windows.Forms.SaveFileDialog> controllo denominato `SaveSaveFileDialog1` (nome predefinito).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>