<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3dee45f1f612e06eeda3bbc4d49ae2828aed0329" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51912674" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Rappresenta un contenitore che può archiviare più oggetti dati.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> è una classe astratta che può essere utilizzata per organizzare gli oggetti in una singola entità di un formato fisico definito per la portabilità e accesso efficiente.  
  
 Un file ZIP è il formato fisico primario per il <xref:System.IO.Packaging.Package>.  Altri <xref:System.IO.Packaging.Package> implementazioni potrebbero usare altri formati, ad esempio un documento XML, un database, fisici o un servizio Web.  
  
 Ad esempio un file system, gli elementi contenuti in un <xref:System.IO.Packaging.Package> viene fatto riferimento in un'organizzazione gerarchica delle cartelle e file.  
  
 Sebbene <xref:System.IO.Packaging.Package> stesso è una classe astratta, il <xref:System.IO.Packaging.ZipPackage> classe derivata viene usata come impostazione predefinita il <xref:System.IO.Packaging.Package.Open%2A> (metodo).  
  
 Oggetto <xref:System.IO.Packaging.PackagePart> ("parte") è la classe astratta che rappresenta un oggetto che viene archiviato in un <xref:System.IO.Packaging.Package>.  
  
 Oggetto <xref:System.IO.Packaging.PackageRelationship> ("relazione") definisce un'associazione tra un'origine <xref:System.IO.Packaging.Package> o <xref:System.IO.Packaging.PackagePart> e un oggetto di destinazione.  Oggetto <xref:System.IO.Packaging.PackageRelationship> può essere uno dei due tipi, ognuno dei quali può essere uno dei due formati:  
  
-   Una relazione a livello di pacchetto (creato dal <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> metodo) è correlato un <xref:System.IO.Packaging.Package> a uno:  
  
    -   Una parte di destinazione nel pacchetto.  
  
    -   Una risorsa di destinazione all'esterno del pacchetto.  
  
-   Una relazione a livello di parte (creato dal <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> metodo) mette in correlazione <xref:System.IO.Packaging.PackagePart> a uno:  
  
    -   Un'altra parte di destinazione nel pacchetto.  
  
    -   Una risorsa di destinazione all'esterno del pacchetto.  
  
 Origine della relazione <xref:System.IO.Packaging.Package> o origine <xref:System.IO.Packaging.PackagePart> viene considerato il "proprietario" della relazione.  Quando viene eliminato l'oggetto di origine, vengono eliminate anche tutte le relazioni possedute dall'oggetto di origine.  Il processo di creazione o eliminazione di una relazione di non modificare gli oggetti di origine o di destinazione in alcun modo fisicamente.  
  
 Oggetto <xref:System.IO.Packaging.PackageDigitalSignature> ("firma digitale") è una composizione di parti e relazioni che rappresenta una firma digitale inclusa in un <xref:System.IO.Packaging.Package>.  La firma digitale identifica il mittente e convalida che le parti firmate e le relazioni contenute nel <xref:System.IO.Packaging.Package> non sono stati modificati.  
  
 I pacchetti supportano anche Digital Rights Management (DRM) che consente agli elementi contenuti in un <xref:System.IO.Packaging.Package> deve essere crittografato con diritti di accesso specifici consentiti ai soli utenti autorizzati.  
  
 In base il <xref:System.IO.Packaging.Package> architettura, un' <xref:System.Windows.Xps.Packaging.XpsDocument> è un tipo di pacchetto progettato per archiviare i documenti in base all'apertura [XML Paper Specification (XPS)](https://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework Usa i pacchetti per archiviare contenuti, risorse e le relazioni per le pagine e documenti usando un file con estensione ZIP standard per impostazione predefinita. Come con qualsiasi file con estensione ZIP, è possibile usare l'applicazione di <xref:System.IO.Packaging> classi per archiviare e, facoltativamente, proteggere qualsiasi tipo o il numero di file di dati in un singolo contenitore ad accesso efficiente.  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 L'esempio seguente illustra i passaggi di base per la creazione di un <xref:System.IO.Packaging.Package>.  In questo esempio viene creato un pacchetto che contenga un documento con un'immagine grafica che viene visualizzato come parte del documento.  (È simile al caso in cui un file HTML ha un \<IMG > tag che fa riferimento a un file di immagine esterni.)  Due <xref:System.IO.Packaging.PackageRelationship> sono inclusi anche elementi nel pacchetto.  Il primo, una relazione "a livello di pacchetto", definisce la parte del documento come elemento radice del pacchetto.  Una relazione in secondo luogo, "a livello di parte" definisce l'associazione tra la parte del documento ("origine" della relazione a livello di parte) e l'uso della parte di immagine (il "target" della relazione a livello di parte).  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Aprire creazione del pacchetto specifica Conventions (OPC)</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=74494">Framework di Open Packaging Conventions firma digitale</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Packaging.Package" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Il file l'autorizzazioni IO per il pacchetto.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.Packaging.Package" /> tramite <see cref="T:System.IO.FileAccess" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> rappresenta un costruttore protetto del <xref:System.IO.Packaging.Package> classe base astratta. Quando viene chiamato in una classe derivata, il <xref:System.IO.Packaging.Package.%23ctor%2A> costruttore inizializza una nuova istanza della classe derivata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="openFileAccess" /> non è valido.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Il file l'autorizzazioni IO per il pacchetto.</param>
        <param name="streaming">
          <see langword="true" /> per aprire il pacchetto del flusso; in caso contrario <see langword="false" />.</param>
        <summary>Inizializza un'istanza nuova della classe <see cref="T:System.IO.Packaging.Package" /> che utilizza <see cref="T:System.IO.FileAccess" /> specificato e un'opzione di flusso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> rappresenta un costruttore protetto del <xref:System.IO.Packaging.Package> classe base astratta di base astratta. Quando viene chiamato in una classe derivata, il <xref:System.IO.Packaging.Package.%23ctor%2A> costruttore inizializza una nuova istanza della classe derivata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="openFileAccess" /> non è valido.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva e chiude il pacchetto più tutti i flussi della parte sottostanti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per il <xref:System.IO.Packaging.Package> classe <xref:System.IO.Packaging.Package.Close%2A> e <xref:System.IO.Packaging.Package.Dispose%2A> eseguire la stessa operazione, ovvero non c'è nessun motivo per chiamare <xref:System.IO.Packaging.Package.Dispose%2A> se si chiama <xref:System.IO.Packaging.Package.Close%2A>, o viceversa.  
  
 <xref:System.IO.Packaging.Package.Close%2A> e <xref:System.IO.Packaging.Package.Dispose%2A> internamente chiamate <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  Il `using` istruzione (diverso dal `using` direttiva dello spazio dei nomi) è il modo consigliato per <xref:System.IO.Packaging.Package.Close%2A> e <xref:System.IO.Packaging.Package.Dispose%2A> un pacchetto.  [La scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055) e [la lettura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160034) viene illustrato come chiudere ed eliminare un pacchetto usando la `using` istruzione.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una parte del pacchetto nuova.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Inizializza un oggetto vuoto <xref:System.IO.Stream> della nuova parte.  Il <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> metodo può essere utilizzato per ottenere un riferimento all'istanza del flusso associato alla parte.  
  
 Per altre informazioni sulle parti del pacchetto, vedere sezione 1.1 della specifica Open Packaging Conventions (OPC) disponibile per il download all'indirizzo [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un nuovo <xref:System.IO.Packaging.PackagePart> e quindi archiviare i dati nella parte.  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> chiama internamente la classe derivata <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> metodo per creare effettivamente la parte in base al formato fisico, implementato nella classe derivata.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">Elemento [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] della nuova parte.</param>
        <param name="contentType">Il tipo di contenuto del flusso di dati.</param>
        <summary>Crea una parte non compressa nuova con un URI specificato e un tipo di contenuto.</summary>
        <returns>La nuova parte creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Inizializza un oggetto vuoto <xref:System.IO.Stream> della nuova parte.  Il <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> metodo può essere utilizzato per ottenere un riferimento all'istanza del flusso associato alla parte.  
  
 La parte <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> è <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>.  
  
 Per altre informazioni sulle parti del pacchetto, vedere sezione 1.1 la specifica Open Packaging Conventions (OPC) disponibile per il download all'indirizzo [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un nuovo <xref:System.IO.Packaging.PackagePart> e quindi archiviare i dati nella parte.  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> o <paramref name="contentType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> non è un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] di <see cref="T:System.IO.Packaging.PackagePart" /> valido.</exception>
        <exception cref="T:System.InvalidOperationException">Una parte con <paramref name="partUri" /> specificato è già presente nel pacchetto.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola lettura (impossibile aggiungere una parte nuova).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> chiama internamente la classe derivata <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> metodo per creare effettivamente la parte in base al formato fisico, implementato nella classe derivata.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">Elemento [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] della nuova parte.</param>
        <param name="contentType">Il tipo di contenuto del flusso di dati.</param>
        <param name="compressionOption">L'opzione di compressione per il flusso di dati, compressione <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> o <see cref="F:System.IO.Packaging.CompressionOption.Normal" />.</param>
        <summary>Crea una parte nuova con un URI specificato, un tipo di contenuto e un'opzione di compressione.</summary>
        <returns>La nuova parte creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita <xref:System.IO.Packaging.ZipPackage> classe, derivata il <xref:System.IO.Packaging.Package.CreatePart%2A> metodo supporta solo due `compressionOption` valori <xref:System.IO.Packaging.CompressionOption.NotCompressed> o <xref:System.IO.Packaging.CompressionOption.Normal> compressione.  Altri <xref:System.IO.Packaging.CompressionOption> valori di <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, o <xref:System.IO.Packaging.CompressionOption.SuperFast> usare <xref:System.IO.Packaging.CompressionOption.Normal> la compressione.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Crea un oggetto vuoto <xref:System.IO.Stream> della nuova parte.  Il <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> metodo può essere utilizzato per ottenere un riferimento all'istanza del flusso associato alla parte.  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un nuovo <xref:System.IO.Packaging.PackagePart> e quindi archiviare i dati nella parte.  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> o <paramref name="contentType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> non è un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] di <see cref="T:System.IO.Packaging.PackagePart" /> valido.</exception>
        <exception cref="T:System.InvalidOperationException">Una parte con <paramref name="partUri" /> specificato è già presente nel pacchetto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore <paramref name="compressionOption" /> non è valido.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola lettura (impossibile aggiungere una parte nuova).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> chiama internamente la classe derivata <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> metodo per creare effettivamente la parte in base al formato fisico, implementato nella classe derivata.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">L'[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] per la parte da creare.</param>
        <param name="contentType">Il tipo di contenuto del flusso di dati.</param>
        <param name="compressionOption">L'opzione di compressione per il flusso di dati.</param>
        <summary>Quando è sottoposto a override in una classe derivata, crea una parte nuova nel pacchetto.</summary>
        <returns>Parte creata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il derivato <xref:System.IO.Packaging.Package.CreatePartCore%2A> metodo viene chiamato dal <xref:System.IO.Packaging.Package.CreatePart%2A> metodo per creare una parte basato sul formato di fisica implementato nella classe derivata.  
  
 Per impostazione predefinita, un <xref:System.IO.Packaging.ZipPackage> classe di implementazione della classe astratta derivata <xref:System.IO.Packaging.Package> viene fornita e usata.  Nell'operazione di impostazione predefinita <xref:System.IO.Packaging.Package.CreatePart%2A> chiama internamente <xref:System.IO.Packaging.Package.CreatePartCore%2A> del <xref:System.IO.Packaging.ZipPackage> classe per creare una nuova parte in un file ZIP.  
  
 Per impostazione predefinita <xref:System.IO.Packaging.ZipPackage> classe, derivata il <xref:System.IO.Packaging.Package.CreatePartCore%2A> metodo supporta solo due `compressionOption` valori <xref:System.IO.Packaging.CompressionOption.NotCompressed> o <xref:System.IO.Packaging.CompressionOption.Normal> compressione.  Altri <xref:System.IO.Packaging.CompressionOption> valori di <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, o <xref:System.IO.Packaging.CompressionOption.SuperFast> usare <xref:System.IO.Packaging.CompressionOption.Normal> la compressione.  
  
 Per altre informazioni sul modello di pacchetto e parti del pacchetto, vedere il capitolo 1 della specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Derivato <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> l'implementazione non deve formulare alcuna ipotesi sull'ordine o operazioni eseguite dal <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> metodo che lo chiama.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una relazione a livello di pacchetto con una parte specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relazione a livello di pacchetto definisce un'associazione tra il pacchetto e una parte di destinazione associato o risorsa.  Una relazione a livello di pacchetto può essere uno dei due formati.  
  
-   Tra un <xref:System.IO.Packaging.Package> a una destinazione <xref:System.IO.Packaging.PackagePart> all'interno del pacchetto.  
  
-   Tra un <xref:System.IO.Packaging.Package> a una risorsa di destinazione all'esterno del pacchetto.  
  
 In una relazione di pacchetto, il pacchetto viene considerato il "proprietario" della relazione.  Quando viene eliminato il pacchetto, vengono eliminate anche tutte le relazioni possedute dal pacchetto.  Il processo di creazione o eliminazione della relazione non altera fisicamente la parte di destinazione o la risorsa in alcun modo.  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 L'esempio seguente illustra la creazione di un <xref:System.IO.Packaging.PackageRelationship> tra una <xref:System.IO.Packaging.Package> e una parte del documento radice.  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">Elemento [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] della parte di destinazione.</param>
        <param name="targetMode">Indica se la parte di destinazione è <see cref="F:System.IO.Packaging.TargetMode.Internal" /> o <see cref="F:System.IO.Packaging.TargetMode.External" /> al pacchetto.</param>
        <param name="relationshipType">Un URI che definisce in modo univoco il ruolo della relazione.</param>
        <summary>Crea una relazione a livello di pacchetto con una parte con un URI specificato, un modalità di destinazione e un tipo di relazione.</summary>
        <returns>La relazione a livello di pacchetto con la parte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relazione a livello di pacchetto definisce un'associazione tra il pacchetto e una parte di destinazione associato o risorsa.  Una relazione a livello di pacchetto può essere uno dei due formati.  
  
-   Tra un <xref:System.IO.Packaging.Package> a una parte di destinazione nel pacchetto.  
  
-   Tra un <xref:System.IO.Packaging.Package> a una risorsa di destinazione all'esterno del pacchetto.  
  
 In una relazione di pacchetto, il pacchetto viene considerato il "proprietario" della relazione.  Quando viene eliminato il pacchetto, vengono eliminate anche tutte le relazioni possedute dal pacchetto.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> modifica fisicamente la parte di destinazione o la risorsa in alcun modo.  
  
 La destinazione di una relazione non può essere un'altra relazione.  
  
 Se `targetMode` viene specificato come <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` deve essere un URI relativo è formato in base al [RFC 3986](http://tools.ietf.org/html/rfc3986) specifica della sintassi generica Uniform Resource Identifier (URI).  L'URI relativo interno può essere un percorso assoluto che inizia con una barra rovesciata ("/") carattere, ad esempio "/ page1.xaml" o "/ /images/picture4.jpg", o un percorso relativo, ad esempio ".. / /imagespicture1.jpg "che viene risolto con la radice del pacchetto ("/ ") come URI di base.  
  
 Se `targetMode` viene specificato come <xref:System.IO.Packaging.TargetMode.External>, `targetUri` possono essere entrambi assoluto o relativo URI corretto in base al [RFC 3986](http://tools.ietf.org/html/rfc3986) specifica della sintassi generica Uniform Resource Identifier (URI).  "http://www.microsoft.com/page2.xml" è un esempio di un URI assoluto che fa riferimento a una risorsa di destinazione esterno "Page2".  "images/picture1.jpg" è un esempio di un URI relativo che fa riferimento anche a una destinazione esterna resource "1.jpg" ma che viene risolta rispetto all'URI del pacchetto stesso.  
  
 `relationshipType` deve essere un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] che è costituito in base al [RFC 3986](http://tools.ietf.org/html/rfc3986) specifica della sintassi generica Uniform Resource Identifier (URI).  La tabella seguente mostra il livello di pacchetto `relationshipType` URI definito dalla specifica Open Packaging Conventions (OPC).  
  
|Relazione a livello di pacchetto|URI del tipo di relazione|  
|---------------------------------|---------------------------|  
|Proprietà principali|http://schemas.openxmlformats.org/package/2006/relationships/meta dati/core-proprietà|  
|Firma digitale|http://schemas.openxmlformats.org/package/2006/relationships/digit al-signature/signature|  
|Certificato di firma digitale|http://schemas.openxmlformats.org/package/2006/relationships/digit / certificato di firma al|  
|Origine della firma digitale|http://schemas.openxmlformats.org/package/2006/relationships/digit al-/ origine della firma|  
|Anteprima|http://schemas.openxmlformats.org/package/2006/relationships/meta dati/anteprima|  
  
 Per altre informazioni sulla creazione di pacchetti e le relazioni dei pacchetti, vedere sezione 1.3 della specifica Open Packaging Conventions (OPC) disponibile per il download all'indirizzo [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 L'esempio seguente illustra come usare <xref:System.IO.Packaging.Package.CreateRelationship%2A> per creare un <xref:System.IO.Packaging.PackageRelationship> tra un <xref:System.IO.Packaging.Package> e una parte del documento radice.  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> o <paramref name="relationshipType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La parte <paramref name="targetUri" /> è <see cref="T:System.IO.Packaging.PackageRelationship" />, o <paramref name="targetMode" /> è <see cref="F:System.IO.Packaging.TargetMode.Internal" /> e <paramref name="targetUri" /> è un URI assoluto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="targetMode" /> non è valido.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola lettura.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">Elemento [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] della parte di destinazione.</param>
        <param name="targetMode">Indica se la parte di destinazione è <see cref="F:System.IO.Packaging.TargetMode.Internal" /> o <see cref="F:System.IO.Packaging.TargetMode.External" /> al pacchetto.</param>
        <param name="relationshipType">Un URI che definisce in modo univoco il ruolo della relazione.</param>
        <param name="id">Identificatore XML univoco.</param>
        <summary>Crea una relazione a livello di pacchetto con una parte con un URI specificato, un modalità di destinazione, un tipo di relazione e [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>La relazione a livello di pacchetto con la parte specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relazione a livello di pacchetto definisce un'associazione tra il pacchetto e una parte di destinazione associato o risorsa.  Una relazione a livello di pacchetto può essere uno dei due formati.  
  
-   Tra un <xref:System.IO.Packaging.Package> a una parte di destinazione nel pacchetto.  
  
-   Tra un <xref:System.IO.Packaging.Package> a una risorsa di destinazione all'esterno del pacchetto.  
  
 In una relazione di pacchetto, il pacchetto viene considerato il "proprietario" della relazione.  Quando viene eliminato il pacchetto, vengono eliminate anche tutte le relazioni possedute dal pacchetto.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> modifica fisicamente la parte di destinazione o la risorsa in alcun modo.  
  
 La destinazione di una relazione non può essere un'altra relazione.  
  
 `id` Deve essere un identificatore XML valido.  Il `id` è xsd: ID di tipo e deve seguire le convenzioni di denominazione indicate in XML Schema Part 2: Datatypes specifica (vedere [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Se `id` viene specificato come `null` verrà generato automaticamente un ID univoco.  Un `id` specificato da un oggetto vuoto stringa non è valida.  
  
 Se `targetMode` viene specificato come <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` deve essere un URI relativo è formato in base al [RFC 3986](http://tools.ietf.org/html/rfc3986) specifica della sintassi generica Uniform Resource Identifier (URI).  L'URI relativo interno può essere un percorso assoluto che inizia con una barra rovesciata ("/") carattere, ad esempio "/ page1.xaml" o "/ /images/picture4.jpg", o un percorso relativo, ad esempio ".. / /imagespicture1.jpg "che viene risolto con la radice del pacchetto ("/ ") come URI di base.  
  
 Se `targetMode` viene specificato come <xref:System.IO.Packaging.TargetMode.External>, `targetUri` possono essere entrambi assoluto o relativo URI corretto in base al [RFC 3986](http://tools.ietf.org/html/rfc3986) specifica della sintassi generica Uniform Resource Identifier (URI).  "http://www.microsoft.com/page2.xml" è un esempio di un URI assoluto che fa riferimento a una risorsa di destinazione esterno "Page2".  "images/picture1.jpg" è un esempio di un URI relativo che fa riferimento anche a una destinazione esterna resource "1.jpg" ma che viene risolta rispetto all'URI del pacchetto stesso.  
  
 `relationshipType` deve essere un URI che è formato in base al [RFC 3986](http://tools.ietf.org/html/rfc3986) specifica della sintassi generica Uniform Resource Identifier (URI).  La tabella seguente mostra il livello di pacchetto `relationshipType` URI definito dalla specifica Open Packaging Conventions (OPC).  
  
|Relazione a livello di pacchetto|URI del tipo di relazione|  
|---------------------------------|---------------------------|  
|Proprietà principali|http://schemas.openxmlformats.org/package/2006/relationships/meta dati/core-proprietà|  
|Firma digitale|http://schemas.openxmlformats.org/package/2006/relationships/digit al-signature/signature|  
|Certificato di firma digitale|http://schemas.openxmlformats.org/package/2006/relationships/digit / certificato di firma al|  
|Origine della firma digitale|http://schemas.openxmlformats.org/package/2006/relationships/digit al-/ origine della firma|  
|Anteprima|http://schemas.openxmlformats.org/package/2006/relationships/meta dati/anteprima|  
  
 Per altre informazioni sulla creazione di pacchetti e le relazioni dei pacchetti, vedere sezione 1.3 della specifica Open Packaging Conventions (OPC) disponibile per il download all'indirizzo [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 L'esempio seguente illustra come usare <xref:System.IO.Packaging.Package.CreateRelationship%2A> per creare un <xref:System.IO.Packaging.PackageRelationship> tra un <xref:System.IO.Packaging.Package> e una parte del documento radice.  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> o <paramref name="relationshipType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La parte <paramref name="targetUri" /> è <see cref="T:System.IO.Packaging.PackageRelationship" />, o <paramref name="targetMode" /> è <see cref="F:System.IO.Packaging.TargetMode.Internal" /> e <paramref name="targetUri" /> è un URI assoluto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="targetMode" /> non è valido.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola lettura.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> non è un identificatore XML valido; o è gia presente nel pacchetto una parte con <paramref name="id" /> specificato.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] della parte da eliminare.</param>
        <summary>Elimina una parte con un URI specificato dal pacchetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` deve essere un URI relativo che è costituito da un percorso assoluto che inizia con una barra rovesciata ("/") caratteri.  Il percorso assoluto è relativo alla radice del pacchetto ed è formato in base al [RFC 3986](http://tools.ietf.org/html/rfc3986) specifica della sintassi generica Uniform Resource Identifier (URI).  "/ page1.xaml" e "/ /images/picture4.jpg" sono riportati alcuni esempi di URI di parte valido.  
  
 Se una parte con il parametro specificato, viene generata alcuna eccezione `partUri` non è incluso nel pacchetto.  (È possibile usare la <xref:System.IO.Packaging.Package.PartExists%2A> metodo per determinare se una parte con un determinato `partUri` è contenuto nel pacchetto.)  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> non è un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] di <see cref="T:System.IO.Packaging.PackagePart" /> valido.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola lettura.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> chiama internamente la classe derivata <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> metodo elimina effettivamente la parte basato sul formato di fisica implementato nella classe derivata.</para>
        </block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">
          <see cref="P:System.IO.Packaging.PackagePart.Uri" /> di <see cref="T:System.IO.Packaging.PackagePart" /> da eliminare.</param>
        <summary>Quando è sottoposto a override in una classe derivata, elimina una parte con un URI specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, un <xref:System.IO.Packaging.ZipPackage> classe di implementazione della classe astratta derivata <xref:System.IO.Packaging.Package> viene fornita e usata.  Nell'operazione di impostazione predefinita <xref:System.IO.Packaging.Package.DeletePart%2A> chiama internamente <xref:System.IO.Packaging.Package.DeletePartCore%2A> del <xref:System.IO.Packaging.ZipPackage> classe per eseguire l'effettiva operazione di eliminazione in base al formato fisico, implementato nella classe derivata.  
  
 Per altre informazioni sul modello di pacchetto e parti del pacchetto, vedere il capitolo 1 della specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La classe derivata <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> implementazione viene chiamata dal <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> metodo per la parte specificata basato sul formato di fisica implementato nella classe derivata.  
  
Derivato <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> l'implementazione non deve formulare alcuna ipotesi sull'ordine o operazioni eseguite dal <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> metodo che lo chiama.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> di <see cref="T:System.IO.Packaging.PackageRelationship" /> da eliminare.</param>
        <summary>Elimina una relazione a livello di pacchetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relazione a livello di pacchetto definisce un'associazione tra il pacchetto e una parte di destinazione associato o risorsa.  Una relazione a livello di pacchetto può essere uno dei due formati.  
  
-   Tra un <xref:System.IO.Packaging.Package> a una parte di destinazione nel pacchetto.  
  
-   Tra un <xref:System.IO.Packaging.Package> a una risorsa di destinazione all'esterno del pacchetto.  
  
 In una relazione di pacchetto, il pacchetto viene considerato il "proprietario" della relazione.  Quando viene eliminato il pacchetto, vengono eliminate anche tutte le relazioni possedute dal pacchetto.  
  
 Se una relazione con l'oggetto specificato, viene generata alcuna eccezione `id` non è incluso nel pacchetto.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> non modifica la parte di destinazione in alcun modo fisicamente.  
  
 Per altre informazioni sulle relazioni tra pacchetto, vedere sezione 1.3 della specifica Open Packaging Conventions (OPC) disponibile per il download all'indirizzo [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola lettura.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> non è un identificatore XML valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Svuota e salva il contenuto di tutte le parti e le relazioni, chiude il pacchetto e rilascia tutte le risorse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per assicurarsi che tutte le modifiche sono state salvate correttamente, <xref:System.IO.Packaging.Package.Dispose%2A> anche finalizza, scarica e chiude tutte le parti e le relazioni contenute nel pacchetto.  
  
 Per il <xref:System.IO.Packaging.Package> (classe), <xref:System.IO.Packaging.Package.Dispose%2A> e <xref:System.IO.Packaging.Package.Close%2A> eseguire la stessa operazione: non è necessario chiamare <xref:System.IO.Packaging.Package.Dispose%2A> se si chiama <xref:System.IO.Packaging.Package.Close%2A>, o viceversa.  
  
 <xref:System.IO.Packaging.Package.Close%2A> e <xref:System.IO.Packaging.Package.Dispose%2A> internamente chiamate <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Le classi derivate che assegnano e gestiscono le risorse di memoria non devono eseguire l'override di questo metodo per rilasciare le risorse quando <xref:System.IO.Packaging.Package.Dispose%2A> viene chiamato. Esegue l'override della classe derivata devono anche chiamare <xref:System.IO.Packaging.Package.Flush%2A> e la classe base <xref:System.IO.Packaging.Package.Dispose%2A> metodo per assicurarsi che la pulizia della classe di base viene sempre eseguita.  
  
> [!NOTE]
>  Il `using` istruzione (diverso dal `using` direttiva dello spazio dei nomi) è il modo consigliato per <xref:System.IO.Packaging.Package.Close%2A> e <xref:System.IO.Packaging.Package.Dispose%2A> un pacchetto. [La scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055) viene illustrato come chiudere ed eliminare un pacchetto usando la `using` istruzione.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'impostazione di accesso ai file per il pacchetto.</summary>
        <value>Uno dei valori dell'oggetto <see cref="T:System.IO.FileAccess" />: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> o <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La proprietà <xref:System.IO.Packaging.Package.FileOpenAccess%2A> non ha alcun valore predefinito.  L'impostazione di accesso file è specificato nella <xref:System.IO.Packaging.Package.%23ctor%2A> costruttore chiamare quando si crea un nuovo pacchetto o nel <xref:System.IO.Packaging.Package.Open%2A> chiamare quando si apre un pacchetto esistente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva il contenuto di tutte le parti e le relazioni contenute nel pacchetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> chiama internamente la classe derivata <xref:System.IO.Packaging.Package.FlushCore%2A> attività di implementazione per eseguire l'effettiva operazione di scaricamento specifici del formato.  La classe derivata <xref:System.IO.Packaging.Package.FlushCore%2A> metodo è responsabile in realtà viene salvato il contenuto di parti e relazioni per l'implementazione della classe derivata fisico specifico.  
  
 Per impostazione predefinita, un <xref:System.IO.Packaging.ZipPackage> implementazione della classe astratta derivata <xref:System.IO.Packaging.Package> classe di base viene fornita e utilizzata. Nell'operazione di impostazione predefinita <xref:System.IO.Packaging.Package.Flush%2A> chiama internamente <xref:System.IO.Packaging.Package.FlushCore%2A> salvare parti e relazioni in un pacchetto di file con estensione ZIP.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> viene chiamato automaticamente dal <xref:System.IO.Packaging.Package.Close%2A> e <xref:System.IO.Packaging.Package.Dispose%2A> metodi.  Quando <xref:System.IO.Packaging.Package.Close%2A> oppure <xref:System.IO.Packaging.Package.Dispose%2A> viene chiamato non è necessario chiamare <xref:System.IO.Packaging.Package.Flush%2A> separatamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il package è di sola lettura e non è possibile modificarlo.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> chiama internamente la classe derivata <see cref="M:System.IO.Packaging.Package.FlushCore" /> metodo effettivamente lo scaricamento della parte basato sul formato di fisica implementato nella classe derivata.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando è sottoposto a override in una classe derivata, salva il contenuto di tutte le parti e le relazioni nell'archivio della classe derivata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> viene chiamato dal <xref:System.IO.Packaging.Package.Flush%2A> metodo per eseguire l'operazione di scaricamento effettiva basato sul formato di fisica implementato nella classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Derivato <see cref="M:System.IO.Packaging.Package.FlushCore" /> implementazione non deve fare supposizioni relative all'ordine o operazioni eseguite dal <see cref="M:System.IO.Packaging.Package.Flush" /> metodo che lo chiama.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] della parte da restituire.</param>
        <summary>Restituisce la parte con un URI specificato.</summary>
        <returns>La parte con <paramref name="partUri" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un' <xref:System.InvalidOperationException> viene generata se una parte con la proprietà specificata `partUri` non esiste.  
  
 Il <xref:System.IO.Packaging.Package.PartExists%2A> metodo può essere utilizzato per determinare se `partUri` fa riferimento a una parte esistente.  
  
 Per impostazione predefinita, un <xref:System.IO.Packaging.ZipPackage> implementazione della classe astratta derivata <xref:System.IO.Packaging.Package> classe di base viene fornita e utilizzata.  Nell'operazione di impostazione predefinita <xref:System.IO.Packaging.Package.GetPart%2A> chiama internamente <xref:System.IO.Packaging.Package.GetPartCore%2A> del <xref:System.IO.Packaging.ZipPackage> classe per restituire una parte richiesta da un file con estensione ZIP.  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come individuare, recuperare e leggere parti contenute in un pacchetto.  Per l'esempio completo, vedere [lettura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> non è un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] di <see cref="T:System.IO.Packaging.PackagePart" /> valido.</exception>
        <exception cref="T:System.InvalidOperationException">Una parte con <paramref name="partUri" /> specificato non è nel pacchetto.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola scrittura.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> chiama internamente la classe derivata <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> metodo effettivamente lo scaricamento della parte basato sul formato di fisica implementato nella classe derivata.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] della parte da recuperare.</param>
        <summary>Quando è sottoposto a override in una classe derivata, restituisce la parte alla quale fa riferimento un URI specificato.</summary>
        <returns>La parte richiesta; o <see langword="null" />, se una parte con <paramref name="partUri" /> specificato non è nel pacchetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, un <xref:System.IO.Packaging.ZipPackage> implementazione della classe astratta derivata <xref:System.IO.Packaging.Package> viene fornita e usata.  Nell'operazione di impostazione predefinita <xref:System.IO.Packaging.Package.GetPart%2A> chiama internamente <xref:System.IO.Packaging.Package.GetPartCore%2A> del <xref:System.IO.Packaging.ZipPackage> classe da cui recuperare una parte da un file con estensione ZIP.  
  
 Per altre informazioni sul modello di pacchetto e parti del pacchetto, vedere il capitolo 1 della specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La classe derivata <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> implementazione viene chiamata dal <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> metodo per accedere e restituire la parte specificata in base al formato fisico, implementato nella classe derivata.  
  
Derivato <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> l'implementazione non deve formulare alcuna ipotesi sull'ordine o operazioni eseguite dal <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> metodo che lo chiama.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un insieme di tutte le parti nel pacchetto.</summary>
        <returns>Un insieme di tutti gli elementi <see cref="T:System.IO.Packaging.PackagePart" /> contenuti nel pacchetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> Restituisce una raccolta di tutte le parti contenute nel pacchetto incluse <xref:System.IO.Packaging.PackageRelationship> parti.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> non restituiranno mai `null`; tuttavia, la raccolta restituita conterrà zero elementi se il pacchetto non contiene parti.  
  
 Per impostazione predefinita, un <xref:System.IO.Packaging.ZipPackage> implementazione della classe astratta derivata <xref:System.IO.Packaging.Package> classe di base viene fornita e utilizzata.  Nell'operazione di impostazione predefinita, <xref:System.IO.Packaging.Package.GetParts%2A> chiama il <xref:System.IO.Packaging.Package.GetPartsCore%2A> metodo il <xref:System.IO.Packaging.ZipPackage> classe per restituire le parti da un file ZIP.  
  
 Per altre informazioni sui pacchetti e parti del pacchetto, vedere sezione 1.1 della specifica Open Packaging Conventions (OPC) disponibile per il download all'indirizzo [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.IO.Packaging.Package.GetParts%2A> metodo per ottenere una raccolta delle parti contenute in un <xref:System.IO.Packaging.Package>.  Per il codice sorgente del programma completo, vedere [creazione di un pacchetto con un esempio di firma digitale](https://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola scrittura.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> chiama internamente la classe derivata <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> metodo effettivamente lo scaricamento della parte basato sul formato di fisica implementato nella classe derivata.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando è sottoposto a override in una classe derivata, restituisce una matrice di tutte le parti nel pacchetto.</summary>
        <returns>Una matrice di tutte le parti contenute nel pacchetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe derivata <xref:System.IO.Packaging.Package.GetPartsCore%2A> implementazione viene chiamata dal <xref:System.IO.Packaging.Package.GetParts%2A> metodo per accedere e restituire la matrice delle parti basato sul formato di fisica implementato nella classe derivata.  
  
 Per impostazione predefinita, un <xref:System.IO.Packaging.ZipPackage> implementazione della classe astratta derivata <xref:System.IO.Packaging.Package> viene fornita e usata.  Nell'operazione di impostazione predefinita <xref:System.IO.Packaging.Package.GetParts%2A> chiama internamente <xref:System.IO.Packaging.Package.GetPartCore%2A> del <xref:System.IO.Packaging.ZipPackage> classe da cui recuperare le parti da un file con estensione ZIP.  
  
 Per altre informazioni sul modello di pacchetto e parti del pacchetto, vedere il capitolo 1 della specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Derivato <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> l'implementazione non deve formulare alcuna ipotesi sull'ordine o operazioni eseguite dal <see cref="M:System.IO.Packaging.Package.GetParts" /> metodo che lo chiama.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> della relazione da restituire.</param>
        <summary>Restituisce la relazione a livello di pacchetto con un identificatore specificato.</summary>
        <returns>La relazione a livello di pacchetto con <paramref name="id" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Deve essere un identificatore XML valido.  Il `id` è xsd: ID di tipo e deve seguire le convenzioni di denominazione indicate in XML Schema Part 2: Datatypes specifica (vedere [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Per altre informazioni sulla creazione di pacchetti e le relazioni dei pacchetti, vedere sezione 1.3 della specifica Open Packaging Conventions (OPC) disponibile per il download all'indirizzo [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> non è un identificatore XML valido.</exception>
        <exception cref="T:System.InvalidOperationException">Una relazione con <paramref name="id" /> specificato non è nel pacchetto.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola scrittura.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un insieme di tutte le relazioni a livello di pacchetto.</summary>
        <returns>Un insieme di tutte le relazioni a livello di pacchetto contenute nel pacchetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> non restituiranno mai `null`; tuttavia, la raccolta restituita può contenere zero elementi se il pacchetto non contiene alcuna relazione a livello di pacchetto.  
  
 Una relazione a livello di pacchetto definisce un'associazione tra il pacchetto e una parte di destinazione associato o risorsa.  Una relazione a livello di pacchetto può essere uno dei due formati.  
  
-   Tra un <xref:System.IO.Packaging.Package> a una parte di destinazione nel pacchetto.  
  
-   Tra un <xref:System.IO.Packaging.Package> a una risorsa di destinazione all'esterno del pacchetto.  
  
 In una relazione di pacchetto, il pacchetto viene considerato il "proprietario" della relazione.  Quando viene eliminato il pacchetto, vengono eliminate anche tutte le relazioni possedute dal pacchetto.  Il processo di creazione o eliminazione della relazione non altera fisicamente la parte di destinazione o la risorsa in alcun modo.  
  
 Per altre informazioni sulla creazione di pacchetti e le relazioni dei pacchetti, vedere sezione 1.3 della specifica Open Packaging Conventions (OPC) disponibile per il download all'indirizzo [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola scrittura.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">Oggetto <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> al quale corrispondere e da restituire nella raccolta.</param>
        <summary>Restituisce un insieme di tutte le relazioni a livello di pacchetto che corrispondono a <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> specificato.</summary>
        <returns>Un insieme di relazioni a livello di pacchetto che corrispondono a <paramref name="relationshipType" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> non restituisce mai `null`; tuttavia, la raccolta restituita può contenere zero elementi se non sono presenti relazioni a livello di pacchetto che corrispondono alla stringa `relationshipType`.  
  
 La tabella seguente mostra il livello di pacchetto `relationshipType` URI definito dalla specifica Open Packaging Conventions (OPC).  
  
|Relazione a livello di pacchetto|URI del tipo di relazione|  
|---------------------------------|---------------------------|  
|Proprietà principali|http://schemas.openxmlformats.org/package/2006/relationships/meta dati/core-proprietà|  
|Firma digitale|http://schemas.openxmlformats.org/package/2006/relationships/digit al-signature/signature|  
|Certificato di firma digitale|http://schemas.openxmlformats.org/package/2006/relationships/digit / certificato di firma al|  
|Origine della firma digitale|http://schemas.openxmlformats.org/package/2006/relationships/digit al-/ origine della firma|  
|Anteprima|http://schemas.openxmlformats.org/package/2006/relationships/meta dati/anteprima|  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come recuperare le relazioni che sono state definite per il pacchetto.  Per l'esempio completo, vedere [lettura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="relationshipType" /> è una stringa vuota.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola scrittura.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un pacchetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> è il tipo di pacchetto predefinito usato dal <xref:System.IO.Packaging.Package.Open%2A> (metodo).  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare una nuova <xref:System.IO.Packaging.Package> che incorpora <xref:System.IO.Packaging.PackageRelationship> e <xref:System.IO.Packaging.PackagePart> elementi insieme ai dati archiviati.  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Il flusso di IO sul quale aprire il pacchetto.</param>
        <summary>Apre un pacchetto su un flusso di IO specificato.</summary>
        <returns>Il pacchetto aperto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> è il tipo di pacchetto predefinito usato dal <xref:System.IO.Packaging.Package.Open%2A> (metodo).  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto da aprire richiede autorizzazione di lettura o di lettura e scrittura e l'oggetto <paramref name="stream" /> specificato è di sola scrittura; oppure il pacchetto da aprire richiede autorizzazione di scrittura o di lettura e scrittura e l'oggetto <paramref name="stream" /> specificato è di sola lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Il nome e il percorso del file del pacchetto. </param>
        <summary>Apre un pacchetto in un percorso e con nome file specificati.</summary>
        <returns>Il pacchetto aperto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> è il tipo di pacchetto predefinito usato dal <xref:System.IO.Packaging.Package.Open%2A> (metodo).  
  
 Ciò <xref:System.IO.Packaging.Package.Open%2A> metodo apre il pacchetto con gli attributi predefiniti <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, e <xref:System.IO.FileShare.None> (per specificare diversi attributi che utilizzano uno degli altri overload del metodo Open).  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare una nuova <xref:System.IO.Packaging.Package> che incorpora <xref:System.IO.Packaging.PackageRelationship> e <xref:System.IO.Packaging.PackagePart> elementi insieme ai dati archiviati.  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">Il flusso di IO sul quale aprire il pacchetto.</param>
        <param name="packageMode">La modalità file nella quale aprire il pacchetto.</param>
        <summary>Apre un pacchetto con un flusso di IO e modalità file specificati.</summary>
        <returns>Il pacchetto aperto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> è il tipo di pacchetto predefinito usato dal <xref:System.IO.Packaging.Package.Open%2A> (metodo).  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore <paramref name="packageMode" /> non è valido.</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto da aprire richiede autorizzazione di lettura o di lettura e scrittura e l'oggetto <paramref name="stream" /> specificato è di sola scrittura; oppure il pacchetto da aprire richiede autorizzazione di scrittura o di lettura e scrittura e l'oggetto <paramref name="stream" /> specificato è di sola lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Il nome e il percorso del file del pacchetto. </param>
        <param name="packageMode">La modalità file nella quale aprire il pacchetto.</param>
        <summary>Apre un pacchetto in un percorso specificato utilizzando una modalità di file specificata.</summary>
        <returns>Il pacchetto aperto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> è il tipo di pacchetto predefinito usato dal <xref:System.IO.Packaging.Package.Open%2A> (metodo).  
  
 Ciò <xref:System.IO.Packaging.Package.Open%2A> metodo apre il pacchetto con gli attributi predefiniti <xref:System.IO.FileAccess.ReadWrite> e <xref:System.IO.FileShare.None> (per specificare diversi attributi che utilizzano uno degli altri overload del metodo Open).  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare una nuova <xref:System.IO.Packaging.Package> che incorpora <xref:System.IO.Packaging.PackageRelationship> e <xref:System.IO.Packaging.PackagePart> elementi insieme ai dati archiviati.  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="packageMode" /> non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">Il flusso di IO sul quale aprire il pacchetto.</param>
        <param name="packageMode">La modalità file nella quale aprire il pacchetto.</param>
        <param name="packageAccess">L'accesso ai file con il quale aprire il pacchetto.</param>
        <summary>Apre un pacchetto con un'impostazione specificata di flusso di IO, modalità file e accesso ai file.</summary>
        <returns>Il pacchetto aperto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> è il tipo di pacchetto predefinito usato dal <xref:System.IO.Packaging.Package.Open%2A> (metodo).  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="packageMode" /> o <paramref name="packageAccess" />  non è valido.</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto da aprire richiede autorizzazione di lettura o di lettura e scrittura e l'oggetto <paramref name="stream" /> specificato è di sola scrittura; oppure il pacchetto da aprire richiede autorizzazione di scrittura o di lettura e scrittura e l'oggetto <paramref name="stream" /> specificato è di sola lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Il nome e il percorso del file del pacchetto. </param>
        <param name="packageMode">La modalità file nella quale aprire il pacchetto.</param>
        <param name="packageAccess">L'accesso ai file con il quale aprire il pacchetto.</param>
        <summary>Apre un pacchetto in un percorso specificato utilizzando un'impostazione specificato di modalità file e accesso ai file.</summary>
        <returns>Il pacchetto aperto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> è il tipo di pacchetto predefinito usato dal <xref:System.IO.Packaging.Package.Open%2A> (metodo).  
  
 Ciò <xref:System.IO.Packaging.Package.Open%2A> metodo apre il pacchetto con un valore predefinito <xref:System.IO.FileShare.None> attributo (per specificare un attributo diverso, utilizzare il <xref:System.IO.Packaging.Package.Open%2A> overload del metodo).  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aprire e leggere un <xref:System.IO.Packaging.Package> che contiene <xref:System.IO.Packaging.PackageRelationship> e <xref:System.IO.Packaging.PackagePart> elementi insieme ai dati archiviati.  Per l'esempio completo, vedere [lettura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="packageMode" /> o <paramref name="packageAccess" /> non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Il nome e il percorso del file del pacchetto. </param>
        <param name="packageMode">La modalità file nella quale aprire il pacchetto.</param>
        <param name="packageAccess">L'accesso ai file con il quale aprire il pacchetto.</param>
        <param name="packageShare">La modalità di condivisione file nella quale aprire il pacchetto.</param>
        <summary>Apre un pacchetto in un percorso specificato utilizzando un'impostazione specificata di modalità file, accesso ai file e condivisione file.</summary>
        <returns>Il pacchetto aperto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> è il tipo di pacchetto predefinito usato dal <xref:System.IO.Packaging.Package.Open%2A> (metodo).  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare una nuova <xref:System.IO.Packaging.Package> che incorpora <xref:System.IO.Packaging.PackageRelationship> e <xref:System.IO.Packaging.PackagePart> elementi insieme ai dati archiviati.  Per l'esempio completo, vedere [scrittura di un pacchetto di esempio](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="packageMode" />, <paramref name="packageAccess" />, o <paramref name="packageShare" /> non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le proprietà principali del pacchetto.</summary>
        <value>Le proprietà principali del pacchetto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni sulle proprietà di un pacchetto di base, vedere la sezione 3.1 la specifica Open Packaging Conventions (OPC) disponibile per il download al [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">L'oggetto <see cref="T:System.Uri" /> della parte da verificare.</param>
        <summary>Indica se una parte con un URI specificato è nel pacchetto.</summary>
        <returns>
          <see langword="true" /> se una parte con <paramref name="partUri" /> specificato è nel pacchetto; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `partUri` deve iniziare con un carattere barra "/" e deve essere assoluto dalla radice del pacchetto.  
  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> non è un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] di <see cref="T:System.IO.Packaging.PackagePart" /> valido.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola scrittura (impossibile leggere le informazioni).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Oggetto <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> della relazione da verificare.</param>
        <summary>Indica se una relazione a livello di pacchetto con un ID specificato è contenuta nel pacchetto.</summary>
        <returns>
          <see langword="true" /> se una relazione a livello di pacchetto con  <paramref name="id" /> specificato è nel pacchetto; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni, vedere la specifica Open Packaging Conventions (OPC) disponibile per il download nel [ http://go.microsoft.com/fwlink/?LinkID=71255 ](https://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> non è un identificatore XML valido.</exception>
        <exception cref="T:System.ObjectDisposedException">Il pacchetto non è aperto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> è stato chiamato).</exception>
        <exception cref="T:System.IO.IOException">Il pacchetto è di sola scrittura.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Questo membro supporta l'infrastruttura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e non è destinato all'utilizzo nell'applicazione.  Usare invece il metodo <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> indipendente dai tipi.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>