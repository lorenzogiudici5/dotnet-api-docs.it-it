<Type Name="SqlCommandBuilder" FullName="System.Data.SqlClient.SqlCommandBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f98e8b8a8201db8545a634c3df54306e188ae9f9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36680172" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlCommandBuilder : System.Data.Common.DbCommandBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlCommandBuilder extends System.Data.Common.DbCommandBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlClient.SqlCommandBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlCommandBuilder&#xA;Inherits DbCommandBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlCommandBuilder sealed : System::Data::Common::DbCommandBuilder" />
  <TypeSignature Language="F#" Value="type SqlCommandBuilder = class&#xA;    inherit DbCommandBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbCommandBuilder</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Consente la generazione automatica di comandi di tabella singola per risolvere le modifiche apportate a un oggetto <see cref="T:System.Data.DataSet" /> con il database SQL Server associato. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.SqlClient.SqlDataAdapter> non genera automaticamente le istruzioni Transact-SQL necessarie per risolvere le differenze tra le modifiche apportate a un <xref:System.Data.DataSet> con l'istanza associata di SQL Server. Tuttavia, è possibile creare una <xref:System.Data.SqlClient.SqlCommandBuilder> oggetto per generare automaticamente le istruzioni Transact-SQL per gli aggiornamenti a tabella singola se si imposta la <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> proprietà del <xref:System.Data.SqlClient.SqlDataAdapter>. Successivamente, vengono generate istruzioni Transact-SQL aggiuntive che non si imposta dal <xref:System.Data.SqlClient.SqlCommandBuilder>.  
  
 Il <xref:System.Data.SqlClient.SqlCommandBuilder> registra se stesso come un listener per <xref:System.Data.SqlClient.SqlDataAdapter.RowUpdating> eventi ogni volta che si imposta la <xref:System.Data.SqlClient.SqlCommandBuilder.DataAdapter%2A> proprietà. È possibile associare solo uno <xref:System.Data.SqlClient.SqlDataAdapter> o <xref:System.Data.SqlClient.SqlCommandBuilder> oggetto tra loro in una sola volta.  
  
 Per generare istruzioni INSERT, UPDATE o DELETE, il <xref:System.Data.SqlClient.SqlCommandBuilder> utilizza il <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> proprietà da recuperare automaticamente un set di metadati richiesto. Se si modifica il <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> dopo aver recuperato i metadati, ad esempio dopo il primo aggiornamento, è necessario chiamare il <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> metodo per aggiornare i metadati.  
  
 È inoltre necessario che `SelectCommand` restituisca almeno una chiave primaria o una colonna univoca. Se non è presente, un' **InvalidOperation** viene generata l'eccezione e i comandi non vengono generati.  
  
 Il <xref:System.Data.SqlClient.SqlCommandBuilder> utilizza inoltre il <xref:System.Data.SqlClient.SqlCommand.Connection%2A>, <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A>, e <xref:System.Data.SqlClient.SqlCommand.Transaction%2A> proprietà fa riferimento il <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A>. L'utente deve chiamare <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> se uno o più di queste proprietà vengono modificati o se il <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> stessa viene sostituita. In caso contrario, il <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A>, <xref:System.Data.SqlClient.SqlDataAdapter.UpdateCommand%2A>, e <xref:System.Data.SqlClient.SqlDataAdapter.DeleteCommand%2A> proprietà mantengono i valori precedenti.  
  
 Se si chiama <xref:System.ComponentModel.Component.Dispose%2A>, il <xref:System.Data.SqlClient.SqlCommandBuilder> dissociato dal <xref:System.Data.SqlClient.SqlDataAdapter>, e i comandi generati non vengono più utilizzati.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la <xref:System.Data.SqlClient.SqlCommand>, assieme <xref:System.Data.SqlClient.SqlDataAdapter> e <xref:System.Data.SqlClient.SqlConnection>, selezionare le righe da un'origine dati. Nell'esempio viene passata una stringa di connessione, una stringa di query che rappresenta un'istruzione Transact-SQL SELECT e una stringa che rappresenta il nome della tabella di database. L'esempio crea quindi un <xref:System.Data.SqlClient.SqlCommandBuilder>.  
  
 [!code-csharp[Classic WebData SqlCommandBuilder#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlCommandBuilder/CS/Source.cs#1)]
 [!code-vb[Classic WebData SqlCommandBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlCommandBuilder/VB/Source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlCommandBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlCommandBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlCommandBuilder (System.Data.SqlClient.SqlDataAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.SqlClient.SqlDataAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.#ctor(System.Data.SqlClient.SqlDataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (adapter As SqlDataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlCommandBuilder(System::Data::SqlClient::SqlDataAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="new System.Data.SqlClient.SqlCommandBuilder : System.Data.SqlClient.SqlDataAdapter -&gt; System.Data.SqlClient.SqlCommandBuilder" Usage="new System.Data.SqlClient.SqlCommandBuilder adapter" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="adapter" Type="System.Data.SqlClient.SqlDataAdapter" />
      </Parameters>
      <Docs>
        <param name="adapter">Nome di <see cref="T:System.Data.SqlClient.SqlDataAdapter" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.SqlClient.SqlCommandBuilder" /> con l'oggetto <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.SqlClient.SqlCommandBuilder> registra se stesso come un listener per <xref:System.Data.SqlClient.SqlDataAdapter.RowUpdating> gli eventi generati dal <xref:System.Data.SqlClient.SqlDataAdapter> specificato in questa proprietà.  
  
 Quando si crea una nuova istanza della <xref:System.Data.SqlClient.SqlCommandBuilder>, qualsiasi esistente <xref:System.Data.SqlClient.SqlCommandBuilder> associato a questo <xref:System.Data.SqlClient.SqlDataAdapter> viene rilasciato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyParameterInfo">
      <MemberSignature Language="C#" Value="protected override void ApplyParameterInfo (System.Data.Common.DbParameter parameter, System.Data.DataRow datarow, System.Data.StatementType statementType, bool whereClause);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ApplyParameterInfo(class System.Data.Common.DbParameter parameter, class System.Data.DataRow datarow, valuetype System.Data.StatementType statementType, bool whereClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.ApplyParameterInfo(System.Data.Common.DbParameter,System.Data.DataRow,System.Data.StatementType,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ApplyParameterInfo(System::Data::Common::DbParameter ^ parameter, System::Data::DataRow ^ datarow, System::Data::StatementType statementType, bool whereClause);" />
      <MemberSignature Language="F#" Value="override this.ApplyParameterInfo : System.Data.Common.DbParameter * System.Data.DataRow * System.Data.StatementType * bool -&gt; unit" Usage="sqlCommandBuilder.ApplyParameterInfo (parameter, datarow, statementType, whereClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Data.Common.DbParameter" />
        <Parameter Name="datarow" Type="System.Data.DataRow" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="whereClause" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parameter">To be added.</param>
        <param name="datarow">To be added.</param>
        <param name="statementType">To be added.</param>
        <param name="whereClause">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogLocation">
      <MemberSignature Language="C#" Value="public override System.Data.Common.CatalogLocation CatalogLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.Common.CatalogLocation CatalogLocation" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.CatalogLocation" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property CatalogLocation As CatalogLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::Common::CatalogLocation CatalogLocation { System::Data::Common::CatalogLocation get(); void set(System::Data::Common::CatalogLocation value); };" />
      <MemberSignature Language="F#" Value="member this.CatalogLocation : System.Data.Common.CatalogLocation with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.CatalogLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.CatalogLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Data.Common.CatalogLocation" /> per un'istanza della classe <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />.</summary>
        <value>Un oggetto <see cref="T:System.Data.Common.CatalogLocation" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogSeparator">
      <MemberSignature Language="C#" Value="public override string CatalogSeparator { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CatalogSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.CatalogSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property CatalogSeparator As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CatalogSeparator { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CatalogSeparator : string with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.CatalogSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una stringa utilizzata come separatore di catalogo per un'istanza della classe <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />.</summary>
        <value>Stringa che indica il separatore di catalogo da utilizzare da utilizzare con un'istanza della classe <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataAdapter">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlDataAdapter DataAdapter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.SqlClient.SqlDataAdapter DataAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.DataAdapter" />
      <MemberSignature Language="VB.NET" Value="Public Property DataAdapter As SqlDataAdapter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SqlClient::SqlDataAdapter ^ DataAdapter { System::Data::SqlClient::SqlDataAdapter ^ get(); void set(System::Data::SqlClient::SqlDataAdapter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataAdapter : System.Data.SqlClient.SqlDataAdapter with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.DataAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlDataAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> per il quale sono generate automaticamente istruzioni Transact-SQL.</summary>
        <value>Un oggetto <see cref="T:System.Data.SqlClient.SqlDataAdapter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Data.SqlClient.SqlCommandBuilder> registra se stesso come un listener per <xref:System.Data.SqlClient.SqlDataAdapter.RowUpdating> gli eventi generati dal <xref:System.Data.SqlClient.SqlDataAdapter> specificato in questa proprietà.  
  
 Quando si crea una nuova istanza della <xref:System.Data.SqlClient.SqlCommandBuilder>, qualsiasi esistente <xref:System.Data.SqlClient.SqlCommandBuilder> associato a questo <xref:System.Data.SqlClient.SqlDataAdapter> viene rilasciato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveParameters">
      <MemberSignature Language="C#" Value="public static void DeriveParameters (System.Data.SqlClient.SqlCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeriveParameters(class System.Data.SqlClient.SqlCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.DeriveParameters(System.Data.SqlClient.SqlCommand)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeriveParameters (command As SqlCommand)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeriveParameters(System::Data::SqlClient::SqlCommand ^ command);" />
      <MemberSignature Language="F#" Value="static member DeriveParameters : System.Data.SqlClient.SqlCommand -&gt; unit" Usage="System.Data.SqlClient.SqlCommandBuilder.DeriveParameters command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.SqlClient.SqlCommand" />
      </Parameters>
      <Docs>
        <param name="command">Classe <see cref="T:System.Data.SqlClient.SqlCommand" /> che fa riferimento alla stored procedure da cui è necessario derivare le informazioni sui parametri. I parametri derivati vengono aggiunti all'insieme <see cref="P:System.Data.SqlClient.SqlCommand.Parameters" /> della classe <see cref="T:System.Data.SqlClient.SqlCommand" />.</param>
        <summary>Recupera le informazioni sui parametri dalla stored procedure specificata nella classe <see cref="T:System.Data.SqlClient.SqlCommand" /> e compila l'insieme <see cref="P:System.Data.SqlClient.SqlCommand.Parameters" /> dell'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DeriveParameters` sovrascrive qualsiasi informazione esistente sui parametri per il `SqlDbCommand`.  
  
 `DeriveParameters` richiede una chiamata aggiuntiva al database per ottenere le informazioni. Se le informazioni sui parametri è noto in anticipo, risulta più efficiente per popolare la raccolta di parametri impostando le informazioni in modo esplicito.  
  
 È possibile utilizzare solo `DeriveParameters` con le stored procedure. Non è possibile utilizzare `DeriveParameters` con le stored procedure estese. Non è possibile utilizzare `DeriveParameters` per popolare il <xref:System.Data.SqlClient.SqlParameterCollection> con le istruzioni Transact-SQL arbitrarie, ad esempio un'istruzione SELECT con parametri.  
  
 Per altre informazioni, vedere [configurazione dei parametri e tipi di dati di parametro](~/docs/framework/data/adonet/configuring-parameters-and-parameter-data-types.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il testo del comando non è un nome di stored procedure valido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDeleteCommand">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire le operazioni di eliminazione nel database.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può utilizzare il <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> metodo informativi o di risoluzione dei problemi relativi a scopo perché restituisce il <xref:System.Data.SqlClient.SqlCommand> oggetto da eseguire.  
  
 È anche possibile usare <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> come base di un comando modificato. Ad esempio, è possibile chiamare <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> e modificare il <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> valore e quindi impostare in modo esplicito nel <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Dopo l'istruzione SQL è stata generata, l'applicazione deve chiamare in modo esplicito <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> se viene modificato l'istruzione in alcun modo. In caso contrario, il <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> continuerà a utilizzare le informazioni incluse nell'istruzione precedente, che potrebbe non essere corretto. Le istruzioni SQL vengono generate quando l'applicazione chiama uno <xref:System.Data.Common.DbDataAdapter.Update%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A>.  
  
 Per altre informazioni, vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDeleteCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetDeleteCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetDeleteCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeleteCommand () As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetDeleteCommand();" />
      <MemberSignature Language="F#" Value="override this.GetDeleteCommand : unit -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetDeleteCommand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire le operazioni di eliminazione nel database.</summary>
        <returns>L'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente richiesto per eseguire le operazioni di eliminazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può utilizzare il <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> metodo informativi o di risoluzione dei problemi relativi a scopo perché restituisce il <xref:System.Data.SqlClient.SqlCommand> oggetto da eseguire.  
  
 È anche possibile usare <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> come base di un comando modificato. Ad esempio, è possibile chiamare <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> e modificare il <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> valore e quindi impostare in modo esplicito nel <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Dopo l'istruzione SQL è stata generata, l'applicazione deve chiamare in modo esplicito <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> se viene modificato l'istruzione in alcun modo. In caso contrario, il <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> continuerà a utilizzare le informazioni incluse nell'istruzione precedente, che potrebbe non essere corretto. Le istruzioni SQL vengono generate quando l'applicazione chiama uno <xref:System.Data.Common.DbDataAdapter.Update%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A>.  
  
 Per altre informazioni, vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeleteCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetDeleteCommand (bool useColumnsForParameterNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetDeleteCommand(bool useColumnsForParameterNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeleteCommand (useColumnsForParameterNames As Boolean) As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetDeleteCommand(bool useColumnsForParameterNames);" />
      <MemberSignature Language="F#" Value="override this.GetDeleteCommand : bool -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetDeleteCommand useColumnsForParameterNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useColumnsForParameterNames" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useColumnsForParameterNames">Se <see langword="true" />, genera i nomi dei parametri dai nomi delle colonne, se possibile. Se <see langword="false" />, genera @p1, @p2 e così via.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire le operazioni di eliminazione nel database.</summary>
        <returns>Oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire  operazioni di eliminazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può utilizzare il <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> metodo informativi o di risoluzione dei problemi relativi a scopo perché restituisce il <xref:System.Data.SqlClient.SqlCommand> oggetto da eseguire.  
  
 È anche possibile usare <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> come base di un comando modificato. Ad esempio, è possibile chiamare <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> e modificare il <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> valore e quindi impostare in modo esplicito nel <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Dopo l'istruzione SQL è stata generata, l'applicazione deve chiamare in modo esplicito <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> se viene modificato l'istruzione in alcun modo. In caso contrario, il <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> continuerà a utilizzare le informazioni incluse nell'istruzione precedente, che potrebbe non essere corretto. Le istruzioni SQL vengono generate quando l'applicazione chiama uno <xref:System.Data.Common.DbDataAdapter.Update%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A>.  
  
 Il comportamento predefinito, la generazione di nomi di parametro, consiste nell'utilizzare @p1, @p2, e così via per i diversi parametri. Passando `true` per il `useColumnsForParameterNames` parametro consente di forzare il <xref:System.Data.OleDb.OleDbCommandBuilder> per generare i parametri in base invece i nomi delle colonne. Ciò ha esito positivo solo se vengono soddisfatte le condizioni seguenti:  
  
-   Il <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNameMaxLength> restituito dal **GetSchema** metodo chiamare e trovato nel <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> raccolta è stata specificata e la sua lunghezza è uguale o maggiore rispetto al nome di parametro generato.  
  
-   Il nome di parametro generato soddisfa i criteri specificati nel <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNamePattern> restituito dal **GetSchema** metodo chiamare e trovato nel <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> espressioni regolari di raccolta.  
  
-   A <xref:System.Data.Common.DbMetaDataColumnNames.ParameterMarkerFormat> restituito dal **GetSchema** metodo chiamare e trovato nel <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> raccolta specificata.  
  
 Per altre informazioni, vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInsertCommand">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire le operazioni di inserimento nel database.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può utilizzare il <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> metodo informativi o di risoluzione dei problemi relativi a scopo perché restituisce il <xref:System.Data.SqlClient.SqlCommand> oggetto da eseguire.  
  
 È anche possibile usare <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> come base di un comando modificato. Ad esempio, è possibile chiamare <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> e modificare il <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> valore e quindi impostare in modo esplicito nel <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Dopo aver generato l'istruzione Transact-SQL, l'applicazione deve chiamare in modo esplicito <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> se viene modificato l'istruzione in alcun modo. In caso contrario, il <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> continuerà a utilizzare le informazioni incluse nell'istruzione precedente, che potrebbe non essere corretto. Le istruzioni Transact-SQL vengono generate quando l'applicazione chiama uno <xref:System.Data.Common.DbDataAdapter.Update%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A>.  
  
 Per altre informazioni, vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInsertCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetInsertCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetInsertCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertCommand () As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetInsertCommand();" />
      <MemberSignature Language="F#" Value="override this.GetInsertCommand : unit -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetInsertCommand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire le operazioni di inserimento nel database.</summary>
        <returns>Oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire le operazioni di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può utilizzare il <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> metodo informativi o di risoluzione dei problemi relativi a scopo perché restituisce il <xref:System.Data.SqlClient.SqlCommand> oggetto da eseguire.  
  
 È anche possibile usare <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> come base di un comando modificato. Ad esempio, è possibile chiamare <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> e modificare il <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> valore e quindi impostare in modo esplicito nel <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Dopo aver generato l'istruzione Transact-SQL, l'applicazione deve chiamare in modo esplicito <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> se viene modificato l'istruzione in alcun modo. In caso contrario, il <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> continuerà a utilizzare le informazioni incluse nell'istruzione precedente, che potrebbe non essere corretto. Le istruzioni Transact-SQL vengono generate quando l'applicazione chiama uno <xref:System.Data.Common.DbDataAdapter.Update%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A>.  
  
 Per altre informazioni, vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInsertCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetInsertCommand (bool useColumnsForParameterNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetInsertCommand(bool useColumnsForParameterNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertCommand (useColumnsForParameterNames As Boolean) As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetInsertCommand(bool useColumnsForParameterNames);" />
      <MemberSignature Language="F#" Value="override this.GetInsertCommand : bool -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetInsertCommand useColumnsForParameterNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useColumnsForParameterNames" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useColumnsForParameterNames">Se <see langword="true" />, genera i nomi dei parametri dai nomi delle colonne, se possibile. Se <see langword="false" />, genera @p1, @p2 e così via.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire le operazioni di inserimento nel database.</summary>
        <returns>Oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente richiesto per eseguire le operazioni di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può utilizzare il <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> metodo informativi o di risoluzione dei problemi relativi a scopo perché restituisce il <xref:System.Data.SqlClient.SqlCommand> oggetto da eseguire.  
  
 È anche possibile usare <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> come base di un comando modificato. Ad esempio, è possibile chiamare <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> e modificare il <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> valore e quindi impostare in modo esplicito nel <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Dopo aver generato l'istruzione Transact-SQL, l'applicazione deve chiamare in modo esplicito <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> se viene modificato l'istruzione in alcun modo. In caso contrario, il <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> continuerà a utilizzare le informazioni incluse nell'istruzione precedente, che potrebbe non essere corretto. Le istruzioni Transact-SQL vengono generate quando l'applicazione chiama uno <xref:System.Data.Common.DbDataAdapter.Update%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A>.  
  
 Il comportamento predefinito, la generazione di nomi di parametro, consiste nell'utilizzare @p1, @p2, e così via per i diversi parametri. Passando `true` per il `useColumnsForParameterNames` parametro consente di forzare il <xref:System.Data.OleDb.OleDbCommandBuilder> per generare i parametri in base invece i nomi delle colonne. Ciò ha esito positivo solo se vengono soddisfatte le condizioni seguenti:  
  
-   Il <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNameMaxLength> restituito dal **GetSchema** metodo chiamare e trovato nel <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> raccolta è stata specificata e la sua lunghezza è uguale o maggiore rispetto al nome di parametro generato.  
  
-   Il nome di parametro generato soddisfa i criteri specificati nel <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNamePattern> restituito dal **GetSchema** metodo chiamare e trovato nel <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> espressioni regolari di raccolta.  
  
-   A <xref:System.Data.Common.DbMetaDataColumnNames.ParameterMarkerFormat> restituito dal **GetSchema** metodo chiamare e trovato nel <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> raccolta specificata.  
  
 Per altre informazioni, vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameterName">
      <MemberSignature Language="C#" Value="protected override string GetParameterName (int parameterOrdinal);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string GetParameterName(int32 parameterOrdinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetParameterName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetParameterName (parameterOrdinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::String ^ GetParameterName(int parameterOrdinal);" />
      <MemberSignature Language="F#" Value="override this.GetParameterName : int -&gt; string" Usage="sqlCommandBuilder.GetParameterName parameterOrdinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterOrdinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterOrdinal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameterName">
      <MemberSignature Language="C#" Value="protected override string GetParameterName (string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string GetParameterName(string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetParameterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetParameterName (parameterName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::String ^ GetParameterName(System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="override this.GetParameterName : string -&gt; string" Usage="sqlCommandBuilder.GetParameterName parameterName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parameterName">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameterPlaceholder">
      <MemberSignature Language="C#" Value="protected override string GetParameterPlaceholder (int parameterOrdinal);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string GetParameterPlaceholder(int32 parameterOrdinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetParameterPlaceholder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetParameterPlaceholder (parameterOrdinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::String ^ GetParameterPlaceholder(int parameterOrdinal);" />
      <MemberSignature Language="F#" Value="override this.GetParameterPlaceholder : int -&gt; string" Usage="sqlCommandBuilder.GetParameterPlaceholder parameterOrdinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterOrdinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterOrdinal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaTable">
      <MemberSignature Language="C#" Value="protected override System.Data.DataTable GetSchemaTable (System.Data.Common.DbCommand srcCommand);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.DataTable GetSchemaTable(class System.Data.Common.DbCommand srcCommand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetSchemaTable(System.Data.Common.DbCommand)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetSchemaTable (srcCommand As DbCommand) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::DataTable ^ GetSchemaTable(System::Data::Common::DbCommand ^ srcCommand);" />
      <MemberSignature Language="F#" Value="override this.GetSchemaTable : System.Data.Common.DbCommand -&gt; System.Data.DataTable" Usage="sqlCommandBuilder.GetSchemaTable srcCommand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcCommand" Type="System.Data.Common.DbCommand" />
      </Parameters>
      <Docs>
        <param name="srcCommand">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetUpdateCommand">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire le operazioni di aggiornamento nel database.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può utilizzare il <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> metodo informativi o di risoluzione dei problemi relativi a scopo perché restituisce il <xref:System.Data.SqlClient.SqlCommand> oggetto da eseguire.  
  
 È anche possibile usare <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> come base di un comando modificato. Ad esempio, è possibile chiamare <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> e modificare il <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> valore e quindi impostare in modo esplicito nel <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Dopo aver generato l'istruzione Transact-SQL, l'applicazione deve chiamare in modo esplicito <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> se viene modificato l'istruzione in alcun modo. In caso contrario, il <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> continuerà a utilizzare le informazioni incluse nell'istruzione precedente, che potrebbe non essere corretto. Le istruzioni Transact-SQL vengono generate quando l'applicazione chiama uno <xref:System.Data.Common.DbDataAdapter.Update%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A>.  
  
 Per altre informazioni, vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetUpdateCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetUpdateCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetUpdateCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpdateCommand () As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetUpdateCommand();" />
      <MemberSignature Language="F#" Value="override this.GetUpdateCommand : unit -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetUpdateCommand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire le operazioni di aggiornamento nel database.</summary>
        <returns>Oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente richiesto per eseguire le operazioni di aggiornamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può utilizzare il <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> metodo informativi o di risoluzione dei problemi relativi a scopo perché restituisce il <xref:System.Data.SqlClient.SqlCommand> oggetto da eseguire.  
  
 È anche possibile usare <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> come base di un comando modificato. Ad esempio, è possibile chiamare <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> e modificare il <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> valore e quindi impostare in modo esplicito nel <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Dopo aver generato l'istruzione Transact-SQL, l'applicazione deve chiamare in modo esplicito <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> se viene modificato l'istruzione in alcun modo. In caso contrario, il <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> continuerà a utilizzare le informazioni incluse nell'istruzione precedente, che potrebbe non essere corretto. Le istruzioni Transact-SQL vengono generate quando l'applicazione chiama uno <xref:System.Data.Common.DbDataAdapter.Update%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A>.  
  
 Per altre informazioni, vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUpdateCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetUpdateCommand (bool useColumnsForParameterNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetUpdateCommand(bool useColumnsForParameterNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpdateCommand (useColumnsForParameterNames As Boolean) As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetUpdateCommand(bool useColumnsForParameterNames);" />
      <MemberSignature Language="F#" Value="override this.GetUpdateCommand : bool -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetUpdateCommand useColumnsForParameterNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useColumnsForParameterNames" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useColumnsForParameterNames">Se <see langword="true" />, genera i nomi dei parametri dai nomi delle colonne, se possibile. Se <see langword="false" />, genera @p1, @p2 e così via.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente, richiesto per eseguire le operazioni di aggiornamento nel database.</summary>
        <returns>L'oggetto <see cref="T:System.Data.SqlClient.SqlCommand" /> generato automaticamente richiesto per eseguire le operazioni di aggiornamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può utilizzare il <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> metodo informativi o di risoluzione dei problemi relativi a scopo perché restituisce il <xref:System.Data.SqlClient.SqlCommand> oggetto da eseguire.  
  
 È anche possibile usare <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> come base di un comando modificato. Ad esempio, è possibile chiamare <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> e modificare il <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> valore e quindi impostare in modo esplicito nel <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Dopo aver generato l'istruzione Transact-SQL, l'applicazione deve chiamare in modo esplicito <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> se viene modificato l'istruzione in alcun modo. In caso contrario, il <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> continuerà a utilizzare le informazioni incluse nell'istruzione precedente, che potrebbe non essere corretto. Le istruzioni Transact-SQL vengono generate quando l'applicazione chiama uno <xref:System.Data.Common.DbDataAdapter.Update%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A>.  
  
 Il comportamento predefinito, la generazione di nomi di parametro, consiste nell'utilizzare @p1, @p2, e così via per i diversi parametri. Passando `true` per il `useColumnsForParameterNames` parametro consente di forzare il <xref:System.Data.OleDb.OleDbCommandBuilder> per generare i parametri in base invece i nomi delle colonne. Ciò ha esito positivo solo se vengono soddisfatte le condizioni seguenti:  
  
-   Il <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNameMaxLength> restituito dal **GetSchema** metodo chiamare e trovato nel <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> raccolta è stata specificata e la sua lunghezza è uguale o maggiore rispetto al nome di parametro generato.  
  
-   Il nome di parametro generato soddisfa i criteri specificati nel <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNamePattern> restituito dal **GetSchema** metodo chiamare e trovato nel <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> espressioni regolari di raccolta.  
  
-   A <xref:System.Data.Common.DbMetaDataColumnNames.ParameterMarkerFormat> restituito dal **GetSchema** metodo chiamare e trovato nel <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> raccolta specificata.  
  
 Per altre informazioni, vedere [la generazione di comandi tramite commandbuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeCommand">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbCommand InitializeCommand (System.Data.Common.DbCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbCommand InitializeCommand(class System.Data.Common.DbCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.InitializeCommand(System.Data.Common.DbCommand)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function InitializeCommand (command As DbCommand) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbCommand ^ InitializeCommand(System::Data::Common::DbCommand ^ command);" />
      <MemberSignature Language="F#" Value="override this.InitializeCommand : System.Data.Common.DbCommand -&gt; System.Data.Common.DbCommand" Usage="sqlCommandBuilder.InitializeCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.Common.DbCommand" />
      </Parameters>
      <Docs>
        <param name="command">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QuoteIdentifier">
      <MemberSignature Language="C#" Value="public override string QuoteIdentifier (string unquotedIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string QuoteIdentifier(string unquotedIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.QuoteIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function QuoteIdentifier (unquotedIdentifier As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ QuoteIdentifier(System::String ^ unquotedIdentifier);" />
      <MemberSignature Language="F#" Value="override this.QuoteIdentifier : string -&gt; string" Usage="sqlCommandBuilder.QuoteIdentifier unquotedIdentifier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unquotedIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unquotedIdentifier">Identificatore originale non racchiuso tra virgolette.</param>
        <summary>Un identificatore senza virgolette con la lettera maiuscola o minuscola corretta per il catalogo, restituisce il form con virgolette corretto dell'identificatore. Ciò implica il sottoporre a escape in modo corretto eventuali virgolette nell'identificatore.</summary>
        <returns>Versione dell'identificatore racchiuso tra virgolette. L'operazione di escape delle virgolette incorporate nell'identificatore ha esito positivo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QuotePrefix">
      <MemberSignature Language="C#" Value="public override string QuotePrefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QuotePrefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.QuotePrefix" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property QuotePrefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ QuotePrefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QuotePrefix : string with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.QuotePrefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il carattere o i caratteri iniziali da utilizzare quando si specificano oggetti di database SQL Server, ad esempio tabelle o colonne, i cui nomi contengono caratteri quali spazi o token riservati.</summary>
        <value>Carattere o caratteri iniziali da utilizzare. Il valore predefinito è una stringa vuota.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Anche se non è possibile modificare il <xref:System.Data.SqlClient.SqlCommandBuilder.QuotePrefix%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.QuoteSuffix%2A> proprietà dopo che un'istruzione insert, update o delete comando è stato generato, è possibile modificare le impostazioni dopo la chiamata di `Update` metodo di un oggetto DataAdapter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è possibile modificare questa proprietà dopo la generazione di un comando INSERT, UPDATE o DELETE.</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteSuffix">
      <MemberSignature Language="C#" Value="public override string QuoteSuffix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QuoteSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.QuoteSuffix" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property QuoteSuffix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ QuoteSuffix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QuoteSuffix : string with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.QuoteSuffix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il carattere o i caratteri finali da utilizzare quando si specificano oggetti di database SQL Server, ad esempio tabelle o colonne, i cui nomi contengono caratteri quali spazi o token riservati.</summary>
        <value>Carattere o caratteri finali da utilizzare. Il valore predefinito è una stringa vuota.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Anche se non è possibile modificare il <xref:System.Data.SqlClient.SqlCommandBuilder.QuotePrefix%2A> o <xref:System.Data.SqlClient.SqlCommandBuilder.QuoteSuffix%2A> proprietà dopo che un'operazione di inserimento, aggiornamento o eliminazione è stata generata l'operazione, è possibile modificare le impostazioni dopo la chiamata di `Update` metodo di un oggetto DataAdapter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è possibile modificare la proprietà dopo che è stato generato un comando di inserimento, aggiornamento o eliminazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemaSeparator">
      <MemberSignature Language="C#" Value="public override string SchemaSeparator { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SchemaSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.SchemaSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SchemaSeparator As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SchemaSeparator { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSeparator : string with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.SchemaSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il carattere da utilizzare come separatore tra l'identificatore di schema e altri identificatori.</summary>
        <value>Carattere da utilizzare come separatore di schema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, i server di database indicano lo schema per un identificatore separando il nome dello schema dall'identificatore con un carattere. Ad esempio, SQL Server utilizza un periodo, creando identificatori completi, ad esempio Person. CustomerName, dove "Person" è il nome dello schema e "CustomerName" è l'identificatore. Impostazione di questa proprietà consente agli sviluppatori di modificare questo comportamento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRowUpdatingHandler">
      <MemberSignature Language="C#" Value="protected override void SetRowUpdatingHandler (System.Data.Common.DbDataAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetRowUpdatingHandler(class System.Data.Common.DbDataAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.SetRowUpdatingHandler(System.Data.Common.DbDataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetRowUpdatingHandler (adapter As DbDataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetRowUpdatingHandler(System::Data::Common::DbDataAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="override this.SetRowUpdatingHandler : System.Data.Common.DbDataAdapter -&gt; unit" Usage="sqlCommandBuilder.SetRowUpdatingHandler adapter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="adapter" Type="System.Data.Common.DbDataAdapter" />
      </Parameters>
      <Docs>
        <param name="adapter">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnquoteIdentifier">
      <MemberSignature Language="C#" Value="public override string UnquoteIdentifier (string quotedIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string UnquoteIdentifier(string quotedIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.UnquoteIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function UnquoteIdentifier (quotedIdentifier As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ UnquoteIdentifier(System::String ^ quotedIdentifier);" />
      <MemberSignature Language="F#" Value="override this.UnquoteIdentifier : string -&gt; string" Usage="sqlCommandBuilder.UnquoteIdentifier quotedIdentifier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="quotedIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="quotedIdentifier">Identificatore dal quale rimuovere le virgolette incorporate.</param>
        <summary>Un identificatore con virgolette, restituisce il form senza virgolette corretto relativo all'identificatore. 	In tal modo viene inoltre ripristinata in modo corretto la condizione precedente di virgolette eventualmente presenti nell'identificatore sottoposte a escape.</summary>
        <returns>Identificatore senza virgolette con le virgolette incorporate già sottoposte a escape riportate correttamente alla loro condizione precedente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>