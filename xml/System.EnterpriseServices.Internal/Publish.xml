<Type Name="Publish" FullName="System.EnterpriseServices.Internal.Publish">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d35f198a40d02b4db5247591990a6baf3a363ab" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39972598" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Publish : System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Publish extends System.Object implements class System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.Publish" />
  <TypeSignature Language="VB.NET" Value="Public Class Publish&#xA;Implements IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Publish : System::EnterpriseServices::Internal::IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type Publish = class&#xA;    interface IComSoapPublisher" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.EnterpriseServices.Internal.IComSoapPublisher</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eef-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Pubblica interfacce COM per applicazioni COM + abilitate per SOAP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish> viene utilizzata internamente da .NET Framework. Non occorre usarlo direttamente nel codice.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Publish ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Publish();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.EnterpriseServices.Internal.Publish" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string *  *  *  *  -&gt; unit&#xA;override this.CreateMailBox : string * string *  *  *  *  -&gt; unit" Usage="publish.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String,System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String" RefType="out" />
        <Parameter Name="Domain" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">URL relativo al server di posta radice.</param>
        <param name="MailBox">Cassetta postale da creare.</param>
        <param name="SmtpName">Quando il metodo termina, questo parametro contiene il nome del server SMTP (Simple Mail Transfer Protocol) con la cassetta postale.</param>
        <param name="Domain">Quando il metodo termina, questo parametro contiene il dominio del server SMTP.</param>
        <param name="PhysicalPath">Quando il metodo termina, questo parametro contiene il percorso del file system per la cassetta postale.</param>
        <param name="Error">Quando il metodo termina, questo parametro contiene un messaggio di errore in caso di rilevamento di un problema.</param>
        <summary>Crea una cassetta postale per un'applicazione COM+ abilitata per SOAP in un URL specificato. Non implementato completamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non completamente implementato; non creare una cassetta postale. Restituisce il messaggio di errore "COM+ SOAP servizi pubblicazione SMTP non è supportato".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string *  *  *  *  -&gt; unit&#xA;override this.CreateVirtualRoot : string * string *  *  *  *  -&gt; unit" Usage="publish.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String,System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">Operazione da eseguire.</param>
        <param name="FullUrl">Indirizzo URL completo per la radice virtuale.</param>
        <param name="BaseUrl">Quando il metodo termina, questo parametro contiene l'indirizzo URL di base.</param>
        <param name="VirtualRoot">Quando il metodo termina, questo parametro contiene il nome della radice virtuale.</param>
        <param name="PhysicalPath">Quando il metodo termina, questo parametro contiene il percorso della radice virtuale.</param>
        <param name="Error">Quando il metodo termina, questo parametro contiene un messaggio di errore in caso di rilevamento di un problema.</param>
        <summary>Crea una radice virtuale di applicazioni COM+ abilitate per SOAP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È consigliabile <xref:System.EnterpriseServices.Internal.SoapServerVRoot.CreateVirtualRootEx%2A> anziché <xref:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.  
  
oppure 
Il chiamante non dispone delle autorizzazioni per accedere alle informazioni DNS.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore nella risoluzione del nome host locale.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> è vuoto.  
  
oppure 
Lo schema specificato in <paramref name="FullUrl" /> non è valido.  
  
oppure 
 <paramref name="FullUrl" /> contiene più di due barre consecutive.  
  
oppure 
La password specificata in <paramref name="FullUrl" /> non è valida.  
  
oppure 
Il nome host specificato in <paramref name="FullUrl" /> non è valido.  
  
oppure 
Il nome file specificato in <paramref name="FullUrl" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per la configurazione dell'infrastruttura .NET remoting. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string *  -&gt; unit&#xA;override this.DeleteMailBox : string * string *  -&gt; unit" Usage="publish.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">URL relativo al server di posta radice.</param>
        <param name="MailBox">Cassetta postale da eliminare.</param>
        <param name="Error">Quando il metodo termina, questo parametro contiene un messaggio di errore in caso di rilevamento di un problema.</param>
        <summary>Elimina una cassetta postale per un'applicazione COM+ abilitata per SOAP in un URL specificato. Non implementato completamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è completamente implementato, non comporta l'eliminazione della cassetta postale. Restituisce il messaggio di errore "COM+ SOAP servizi pubblicazione SMTP non è supportato".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string *  -&gt; unit&#xA;override this.DeleteVirtualRoot : string * string *  -&gt; unit" Usage="publish.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">Server Web radice.</param>
        <param name="FullUrl">Indirizzo URL completo per la radice virtuale.</param>
        <param name="Error">Quando il metodo termina, questo parametro contiene un messaggio di errore in caso di rilevamento di un problema.</param>
        <summary>Elimina una radice virtuale di applicazioni COM+ abilitate per SOAP. Non implementato completamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La funzionalità per <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> non è ancora disponibile.  
  
> [!CAUTION]
>  Il metodo restituisce attualmente senza errori, ma non viene eliminata la radice virtuale.  
  
 Quando la funzionalità sarà disponibile, il metodo consigliato è <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit&#xA;override this.GacInstall : string -&gt; unit" Usage="publish.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Percorso del file system dell'assembly.</param>
        <summary>Installa un assembly nella Global Assembly Cache.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit&#xA;override this.GacRemove : string -&gt; unit" Usage="publish.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Percorso del file system dell'assembly.</param>
        <summary>Rimuove un assembly dalla Global Assembly Cache.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.  
  
oppure 
Il chiamante non ha l'autorizzazione per l'individuazione del percorso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="AssemblyPath" /> è vuoto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> non trovata.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> non è un assembly valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string *  -&gt; unit&#xA;override this.GetAssemblyNameForCache : string *  -&gt; unit" Usage="publish.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">Percorso del file contenente la libreria dei tipi.</param>
        <param name="CachePath">Quando il metodo termina, questo parametro contiene il nome della directory SoapCache.</param>
        <summary>Restituisce il percorso completo di un assembly generato con firma con nome sicuro nella directory SoapCache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un componente COM+ non gestito da pubblicare tramite i servizi remoti .NET come un endpoint SOAP, un proxy deve essere generato per rendere disponibili i componenti non gestiti a .NET Framework. Questa operazione viene eseguita mediante l'esecuzione a livello di programmazione gli stessi passaggi come tipo di libreria Tlbimp.exe Utilità di importazione (), il [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)] strumento che consente di convertire le librerie dei tipi non gestite COM+ in assembly di metadati di proxy. Per l'attivazione di client tramite SOAP venga eseguita correttamente, tuttavia, computer client e server devono condividere gli stessi metadati firmati con nome sicuro di proxy. Per questo motivo, quando viene generato un assembly gestito proxy per un componente COM+ non gestito, una chiave con nome sicuro viene anche generata e usata per firmare l'assembly proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="TypeLibPath" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ArgumentException">Il nome file è vuoto, contiene solo spazi o contiene caratteri non validi.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Accesso a <paramref name="TypeLibPath" /> negato.</exception>
        <exception cref="T:System.IO.PathTooLongException">Il percorso specificato, il nome file o entrambi superano la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="TypeLibPath" /> contiene i due punti (:) all'interno della stringa.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura dei file. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetClientPhysicalPath">
      <MemberSignature Language="C#" Value="public static string GetClientPhysicalPath (bool CreateDir);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClientPhysicalPath(bool CreateDir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClientPhysicalPath (CreateDir As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClientPhysicalPath(bool CreateDir);" />
      <MemberSignature Language="F#" Value="static member GetClientPhysicalPath : bool -&gt; string" Usage="System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath CreateDir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="CreateDir" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="CreateDir">
          <see langword="true" /> per creare la directory oppure <see langword="false" /> per restituire il percorso senza creare la directory.</param>
        <summary>Restituisce il percorso della directory per la memorizzazione dei file di configurazione del client.</summary>
        <returns>Percorso della directory per la memorizzazione dei file di configurazione del client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea le directory "\com\SOAPAssembly\\" nella directory di sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string&#xA;override this.GetTypeNameFromProgId : string * string -&gt; string" Usage="publish.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Percorso del file system dell'assembly.</param>
        <param name="ProgId">Identificatore a livello di codice della classe.</param>
        <summary>Si riflette su un assembly e restituisce il nome del tipo che corrisponde al ProgID.</summary>
        <returns>Nome del tipo che corrisponde al ProgID.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ParseUrl">
      <MemberSignature Language="C#" Value="public static void ParseUrl (string FullUrl, out string BaseUrl, out string VirtualRoot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ParseUrl(string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ParseUrl(System.String,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ParseUrl (FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ParseUrl(System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot);" />
      <MemberSignature Language="F#" Value="static member ParseUrl : string *  *  -&gt; unit" Usage="System.EnterpriseServices.Internal.Publish.ParseUrl (FullUrl, BaseUrl, VirtualRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="FullUrl">Indirizzo URL completo per la radice virtuale.</param>
        <param name="BaseUrl">Quando il metodo termina, questo parametro contiene l'indirizzo URL di base.</param>
        <param name="VirtualRoot">Quando il metodo termina, questo parametro contiene il nome della radice virtuale.</param>
        <summary>Analizza un URL e restituisce parti dell'URL di base e della radice virtuale.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Si è verificato un errore nella risoluzione del nome host locale.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone delle autorizzazioni per accedere alle informazioni DNS.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> è vuoto.  
  
oppure 
Lo schema specificato in <paramref name="FullUrl" /> non è valido.  
  
oppure 
 <paramref name="FullUrl" /> contiene troppe barre.  
  
oppure 
La password specificata in <paramref name="FullUrl" /> non è valida.  
  
oppure 
Il nome host specificato in <paramref name="FullUrl" /> non è valido.  
  
oppure 
Il nome file specificato in <paramref name="FullUrl" /> non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit&#xA;override this.ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit" Usage="publish.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identificatore a livello di codice della classe.</param>
        <param name="SrcTlbPath">Percorso del file contenente la libreria dei tipi.</param>
        <param name="PhysicalPath">Directory dell'applicazione Web.</param>
        <param name="VRoot">Nome della radice virtuale.</param>
        <param name="BaseUrl">URL di base che contiene la radice virtuale.</param>
        <param name="Mode">Modalità di attivazione.</param>
        <param name="Transport">Non usato. Specificare <see langword="null" /> per questo parametro.</param>
        <param name="AssemblyName">Quando il metodo termina, questo parametro contiene il nome visualizzato dell'assembly.</param>
        <param name="TypeName">Quando il metodo termina, questo parametro contiene il nome di tipo completo dell'assembly.</param>
        <param name="Error">Quando il metodo termina, questo parametro contiene un messaggio di errore in caso di rilevamento di un problema.</param>
        <summary>Elabora una libreria dei tipi del client, creando un file di configurazione sul client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato in un'importazione di proxy client per generare un file di configurazione .NET remoting.  
  
 Se il `Mode` parametro è "wellknownobject" o una stringa vuota (""), si presuppone che un oggetto noto; in caso contrario, verrà utilizzata l'attivazione di client.  
  
 È consigliabile <xref:System.EnterpriseServices.Internal.SoapClientImport.ProcessClientTlbEx%2A> anziché <xref:System.EnterpriseServices.Internal.Publish.ProcessClientTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string strAssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; strAssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef strAssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % strAssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit&#xA;override this.ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit" Usage="publish.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, strAssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="strAssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identificatore a livello di codice della classe.</param>
        <param name="SrcTlbPath">Percorso del file contenente la libreria dei tipi.</param>
        <param name="PhysicalPath">Directory dell'applicazione Web.</param>
        <param name="Operation">Operazione da eseguire.</param>
        <param name="strAssemblyName">Quando il metodo termina, questo parametro contiene il nome visualizzato dell'assembly.</param>
        <param name="TypeName">Quando il metodo termina, questo parametro contiene il nome di tipo completo dell'assembly.</param>
        <param name="Error">Quando il metodo termina, questo parametro contiene un messaggio di errore in caso di rilevamento di un problema.</param>
        <summary>Elabora una libreria dei tipi del server, aggiungendo o eliminando le voci corrispondenti ai componenti nei file Web.config e Default.disco. Genera un proxy se necessario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A> Aggiunge una voce al file di individuazione e il file Web. config per i componenti della libreria dei tipi e genera l'errore o copia di un proxy per i componenti non gestiti nella directory bin. Se `Operation` uguale a "delete", quindi le voci di componente vengono rimosse dai file Web. config e default.  
  
 È consigliabile <xref:System.EnterpriseServices.Internal.SoapServerTlb.AddServerTlb%2A> e <xref:System.EnterpriseServices.Internal.SoapServerTlb.DeleteServerTlb%2A> utilizzabile al posto di <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException">Se il parametro <paramref name="SrcTlbPath" /> fa riferimento a scrobj.dll, la pubblicazione SOAP dei componenti script non è supportata.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit&#xA;override this.RegisterAssembly : string -&gt; unit" Usage="publish.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Percorso del file system dell'assembly.</param>
        <summary>Registra un assembly per l'interoperabilità COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.RegisterAssembly%2A> Usa lo strumento di registrazione dell'Assembly (Regasm.exe) per registrare le classi nell'assembly. Per altre informazioni, vedere [Regasm.exe (strumento di registrazione di Assembly)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">L'assembly di input non dispone di un nome sicuro.</exception>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.  
  
oppure 
È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> non è stato trovato oppure non è stata specificata un'estensione nel nome file.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> non è un assembly valido.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due diverse evidenze oppure la lunghezza del nome dell'assembly supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Un metodo contrassegnato con la classe <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> non è <see langword="static" />.  
  
oppure 
Esistono più metodi contrassegnati con la classe <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> a un livello specifico della gerarchia.  
  
oppure 
La firma del metodo contrassegnato con la classe <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> non è valida.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">per la possibilità di accedere al registro. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per determinare la directory corrente. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit&#xA;override this.UnRegisterAssembly : string -&gt; unit" Usage="publish.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Percorso del file system dell'assembly.</param>
        <summary>Annulla la registrazione di un assembly di interoperabilità COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly%2A> Usa Regasm.exe per annullare la registrazione di classi nell'assembly. Per altre informazioni, vedere [Regasm.exe (strumento di registrazione di Assembly)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un chiamante nella catena di chiamate non dispone dell'autorizzazione all'accesso a codice non gestito.  
  
oppure 
È stata specificata una base di codici che non inizia con "file://" senza la classe <see cref="T:System.Net.WebPermission" /> richiesta.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> non è stato trovato oppure non è stata specificata un'estensione di file.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> non è un assembly valido.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due diverse evidenze oppure la lunghezza del nome dell'assembly supera la lunghezza massima definita dal sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Un metodo contrassegnato con la classe <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> non è <see langword="static" />.  
  
oppure 
Esistono più metodi contrassegnati con la classe <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> a un livello specifico della gerarchia.  
  
oppure 
La firma del metodo contrassegnato con la classe <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> non è valida.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">per la possibilità di accedere al registro. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per determinare la directory corrente. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per la lettura di un URI che inizia con "file://". Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
      </Docs>
    </Member>
  </Members>
</Type>