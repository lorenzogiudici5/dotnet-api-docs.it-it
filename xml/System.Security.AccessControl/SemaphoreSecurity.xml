<Type Name="SemaphoreSecurity" FullName="System.Security.AccessControl.SemaphoreSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cf74fdf1f4a43eacad816a18a03655f75c6c45d5" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39955224" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SemaphoreSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.SemaphoreSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SemaphoreSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type SemaphoreSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta la sicurezza del controllo di accesso di Windows per un semaforo denominato. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto specifica i diritti di accesso per un semaforo di sistema denominato e specifica anche il modo in cui vengono controllati i tentativi di accesso. Diritti di accesso per il semaforo vengono espresse come regole, con ogni regola di accesso rappresentato da un <xref:System.Security.AccessControl.SemaphoreAccessRule> oggetto. Ogni regola di controllo è rappresentato da un <xref:System.Security.AccessControl.SemaphoreAuditRule> oggetto.  
  
 Questa situazione rispecchia il sistema di sicurezza di Windows sottostante, in cui ogni oggetto a protezione diretta è al massimo un accesso discrezionale controllo elenco (DACL) che controlla l'accesso per l'oggetto protetto e al massimo un accesso elenco di controllo sistema (SACL) che specifica che l'accesso vengono controllati i tentativi. Gli elenchi DACL e un SACL vengono ordinati gli elenchi di voci di controllo di accesso (ACE) che specificano l'accesso e controllo per gli utenti e gruppi. Oggetto <xref:System.Security.AccessControl.SemaphoreAccessRule> o <xref:System.Security.AccessControl.SemaphoreAuditRule> oggetto può rappresentare più di una voce ACE.  
  
> [!NOTE]
>  Oggetto <xref:System.Threading.Semaphore> oggetto può rappresentare un semaforo locale o un semaforo di sistema denominato. Controllo di accesso di Windows è significativa solo per i semafori denominati di sistema.  
  
 Il <xref:System.Security.AccessControl.SemaphoreSecurity>, <xref:System.Security.AccessControl.SemaphoreAccessRule>, e <xref:System.Security.AccessControl.SemaphoreAuditRule> classi nascondono i dettagli di implementazione degli elenchi ACL e le voci ACE. Consentono di ignorare i diversi tipi di voce ACE diciassette e la complessità della gestione corretta di ereditarietà e propagazione di diritti di accesso. Questi oggetti sono progettati anche per evitare gli errori di controllo accesso comuni seguenti:  
  
-   Creazione di un descrittore di sicurezza con un elenco DACL. Un riferimento null a un DACL consente agli utenti di aggiungere le regole di accesso a un oggetto, potenzialmente la creazione di un attacco denial of service. Un nuovo <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto inizia sempre con un DACL vuoto, che nega tutti gli accessi per tutti gli utenti.  
  
-   Violazione dell'ordine canonico delle voci ACE. Se l'elenco di voci ACE nell'elenco DACL non viene mantenuto nell'ordine canonico, potrebbe essere involontariamente concesso l'accesso all'oggetto protetto. Ad esempio, i diritti di accesso negato devono essere sempre visualizzate prima dei diritti di accesso consentito. <xref:System.Security.AccessControl.SemaphoreSecurity> gli oggetti mantengono internamente l'ordine corretto.  
  
-   Modifica flag del descrittore di sicurezza, che deve essere eseguita solo il controllo di gestione risorse.  
  
-   Creazione di combinazioni di flag ACE non valide.  
  
-   Modifica di voci ACE ereditate. Ereditarietà e propagazione vengono gestite da Gestione risorse, in risposta alle modifiche apportate alle regole di accesso e controllo.  
  
-   Inserimento di voci ACE privo di significato in ACL.  
  
 Le uniche funzionalità non supportate dagli oggetti di sicurezza di .NET sono attività pericolosa che sarebbe opportuno evitare per la maggior parte degli sviluppatori di applicazioni, ad esempio:  
  
-   Attività di basso livello che vengono normalmente eseguite da Gestione risorse.  
  
-   Aggiunta o rimozione di voci di controllo di accesso in modi che non mantengono l'ordinamento di canonico.  
  
 Per la modifica del controllo di accesso di Windows per un semaforo denominato, usare il <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> metodo per ottenere il <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto. Modificare l'oggetto di sicurezza aggiungendo e rimuovendo le regole e quindi usare il <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> metodo per collegarlo.  
  
> [!IMPORTANT]
>  Le modifiche apportate a un <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto non influiscono sui livelli di accesso del semaforo denominato finché non si chiama il <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> metodo a cui assegnare l'oggetto di sicurezza modificato per il semaforo denominato.  
  
 Per copiare la sicurezza del controllo di accesso da un semaforo a un'altra, usare il <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> metodo per ottenere un <xref:System.Security.AccessControl.SemaphoreSecurity> dell'oggetto che rappresenta le regole di accesso e controllo per il semaforo prima e quindi usare il <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> metodo o un costruttore che accetta un <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto, assegnare le regole per il semaforo di secondo.  
  
 Gli utenti con un investimento in sicurezza descriptor definition language (SDDL) possono usare la <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> per impostare le regole di accesso per un semaforo denominato e il <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metodo per ottenere una stringa che rappresenta le regole di accesso nel formato SDDL. Questa operazione è sconsigliata per i nuovi sviluppi.  
  
> [!NOTE]
>  Sicurezza per gli oggetti di sincronizzazione non è supportata per Windows 98 o Windows Millennium Edition.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra la separazione tra <xref:System.Security.AccessControl.AccessControlType.Allow> regole e <xref:System.Security.AccessControl.AccessControlType.Deny> regole e Visualizza la combinazione di diritti regole compatibili. Nell'esempio viene creato un <xref:System.Security.AccessControl.SemaphoreSecurity> , vengono aggiunti regole per consentano e negano diritti diversi per l'utente corrente e Visualizza la coppia di regole risultante. Nell'esempio viene quindi consente nuovi diritti per l'utente corrente e visualizza il risultato, che mostra che i nuovi diritti vengono uniti con l'oggetto esistente <xref:System.Security.AccessControl.AccessControlType.Allow> regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.Semaphore> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.SemaphoreAccessRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreAuditRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreRights" />
    <altmember cref="M:System.Threading.Semaphore.GetAccessControl" />
    <altmember cref="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> con i valori predefiniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nuovo <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto inizia sempre con un elenco vuoto di accesso discrezionale (DACL), che nega tutti gli accessi per tutti gli utenti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Questa classe non è supportata in Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, includeSections As AccessControlSections)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity(System::String ^ name, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.SemaphoreSecurity : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="new System.Security.AccessControl.SemaphoreSecurity (name, includeSections)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">Nome del semaforo di sistema di cui verranno recuperate le regole di sicurezza del controllo di accesso.</param>
        <param name="includeSections">Combinazione di flag <see cref="T:System.Security.AccessControl.AccessControlSections" /> che specificano le sezioni da recuperare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> con le sezioni specificate delle regole di sicurezza del controllo di accesso relative al semaforo di sistema con il nome specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore consente di ottenere la sicurezza del controllo di accesso per un semaforo di sistema denominato senza dover prima creare un <xref:System.Threading.Semaphore> oggetto.  
  
 Occorre prestare attenzione quando si lavora con gli oggetti di sistema denominato. Se è presente un oggetto di sistema denominato `name` che non è un semaforo, la sicurezza del controllo di accesso potrebbe essere recuperata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Questa classe non è supportata in Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'enumerazione utilizzata dalla classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> per rappresentare i diritti di accesso.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta l'enumerazione <see cref="T:System.Security.AccessControl.SemaphoreRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe override la <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> proprietà e restituire il tipo utilizzato per rappresentare i diritti di accesso. Quando si lavora con le matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile usare questa proprietà per determinare il tipo di enumerazione corretto da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="abstract member AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule&#xA;override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="semaphoreSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Classe <see cref="T:System.Security.Principal.IdentityReference" /> che identifica l'utente o il gruppo a cui viene applicata la regola.</param>
        <param name="accessMask">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.SemaphoreRights" /> che specificano i diritti di accesso da concedere o negare, per effettuare il cast in un intero.</param>
        <param name="isInherited">Non significativo per i semafori denominati, perché non hanno gerarchia.</param>
        <param name="inheritanceFlags">Non significativo per i semafori denominati, perché non hanno gerarchia.</param>
        <param name="propagationFlags">Non significativo per i semafori denominati, perché non hanno gerarchia.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Security.AccessControl.AccessControlType" /> che specificano se i diritti sono concessi o negati.</param>
        <summary>Crea una nuova regola di controllo di accesso per l'utente specificato, con i diritti di accesso, il controllo di accesso e i flag specificati.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> che rappresenta i diritti specificati per l'utente specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo consigliato per creare le regole di controllo di accesso consiste nell'utilizzare i costruttori del <xref:System.Security.AccessControl.SemaphoreAccessRule> classe.  
  
> [!NOTE]
>  Anche se i flag di ereditarietà e propagazione sono significativi per i semafori denominati, è comunque possibile specificarle che non è consigliabile, perché inutilmente complica la gestione delle regole, ad esempio tramite interferenza con la combinazione di regole in caso contrario sarebbe compatibile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="type" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> è <see langword="null" />.  
  
oppure 
 <paramref name="accessMask" /> è zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> non è di tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> né di un tipo quale <see cref="T:System.Security.Principal.NTAccount" /> convertibile nel tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo utilizzato dalla classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> per rappresentare le regole di accesso.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta la classe <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe override la <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> proprietà e restituire il tipo utilizzato per rappresentare le regole di accesso. Quando si lavora con le matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile usare questa proprietà per determinare il tipo di regola di accesso corretti da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Regola di controllo di accesso da aggiungere.</param>
        <summary>Cerca una regola corrispondente a cui è possibile unire la nuova regola. Se non viene trovata alcuna regola, viene aggiunta la nuova regola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A> metodo cerca le regole con lo stesso utente o gruppo e lo stesso <xref:System.Security.AccessControl.AccessControlType> come `rule`. Se non vengono rilevate, `rule` viene aggiunto. Se viene trovata una regola corrisponda, i diritti in `rule` vengono unite con la regola esistente.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra la separazione tra <xref:System.Security.AccessControl.AccessControlType.Allow> regole e <xref:System.Security.AccessControl.AccessControlType.Deny> regole e Visualizza la combinazione di diritti regole compatibili. Nell'esempio viene creato un <xref:System.Security.AccessControl.SemaphoreSecurity> , vengono aggiunti regole per consentano e negano diritti diversi per l'utente corrente e Visualizza la coppia di regole risultante. Nell'esempio viene quindi consente nuovi diritti per l'utente corrente e visualizza il risultato, che mostra che i nuovi diritti vengono uniti con l'oggetto esistente <xref:System.Security.AccessControl.AccessControlType.Allow> regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.Semaphore> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Regola di controllo da aggiungere. L'utente specificato dalla regola determina la ricerca.</param>
        <summary>Cerca una regola di controllo a cui è possibile unire la nuova regola. Se non viene trovata alcuna regola, viene aggiunta la nuova regola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A> il metodo di ricerca per le regole con lo stesso utente o gruppo come `rule`. Se non vengono rilevate, `rule` viene aggiunto. Se viene trovata una regola corrisponda, il flag in `rule` vengono unite alla regola esistente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="abstract member AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule&#xA;override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="semaphoreSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Classe <see cref="T:System.Security.Principal.IdentityReference" /> che identifica l'utente o il gruppo a cui viene applicata la regola.</param>
        <param name="accessMask">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.SemaphoreRights" /> che specificano i diritti di accesso da controllare, per effettuare il cast in un intero.</param>
        <param name="isInherited">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="inheritanceFlags">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="propagationFlags">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="flags">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.AuditFlags" /> che specificano se controllare l'accesso riuscito, l'accesso non riuscito o entrambi.</param>
        <summary>Crea una nuova regola di controllo che specifica l'utente a cui viene applicata la regola, i diritti di accesso da controllare e il risultato che attiva la regola di controllo.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> che rappresenta la regola di controllo specificata per l'utente specificato. Il tipo restituito del metodo è la classe base, <see cref="T:System.Security.AccessControl.AuditRule" />, ma è possibile effettuare in maniera sicura il cast del valore restituito nella classe derivata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo consigliato per creare le regole di controllo è usare i costruttori del <xref:System.Security.AccessControl.SemaphoreAuditRule> classe.  
  
> [!NOTE]
>  Anche se i flag di ereditarietà e propagazione sono significativi per i semafori denominati, è comunque possibile specificarli. Ciò non è consigliabile, perché inutilmente complica la gestione delle regole, ad esempio tramite interferenza con la combinazione di regole che altrimenti sarebbero compatibili.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="flags" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> è <see langword="null" />.  
  
oppure 
 <paramref name="accessMask" /> è zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> non è di tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> né di un tipo quale <see cref="T:System.Security.Principal.NTAccount" /> convertibile nel tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo utilizzato dalla classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> per rappresentare le regole di controllo.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta la classe <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe override la <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> proprietà e restituire il tipo utilizzato per rappresentare i diritti di controllo. Quando si lavora con le matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile usare questa proprietà per determinare il tipo di regola di controllo corretti da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As SemaphoreAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; bool" Usage="semaphoreSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> che specifica l'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> da ricercare, nonché un insieme di flag di ereditarietà e propagazione con cui deve essere compatibile una regola corrispondente, se trovata. Specifica i diritti da rimuovere dalla regola compatibile, se trovati.</param>
        <summary>Cerca una regola di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola specificata e con i flag di ereditarietà e propagazione compatibili. Se viene trovata una regola simile, i diritti contenuti nella regola di accesso specificata vengono rimossi da essa.</summary>
        <returns>
          <see langword="true" /> se viene trovata una regola compatibile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto corrente <xref:System.Security.AccessControl.SemaphoreSecurity> viene eseguita la ricerca per una regola con lo stesso utente e lo stesso <xref:System.Security.AccessControl.AccessControlType> valore `rule`. Se non viene trovata alcuna regola simile, viene eseguita alcuna azione e il metodo restituisce `false`. Se vengono trovate le regole di corrispondenza, vengono controllati i flag di ereditarietà e compatibilità per garantire la compatibilità con i flag specificati nella `rule`. Se viene trovata alcuna regola compatibile, viene eseguita alcuna azione e il metodo restituisce `false`. Se viene trovata una regola con flag compatibili, i diritti specificati nel `rule` vengono rimosse dalla regola compatibile, e il metodo restituisce `true`. Se `rule` specifica i diritti non contenuti nella regola compatibile, viene eseguita alcuna azione rispetto a tali diritti. Se tutti i diritti vengono rimossi dalla regola compatibile, l'intera regola viene rimosso dall'insieme corrente <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto.  
  
> [!IMPORTANT]
>  Sebbene sia possibile specificare i flag di ereditarietà e propagazione per le regole di accesso semaforo creandoli con la <xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A> metodo, non è consigliato. Ereditarietà e propagazione non hanno alcun significato per i semafori denominati e rendono più complessa la gestione delle regole di accesso.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> metodo per rimuovere diritti da un' <xref:System.Security.AccessControl.AccessControlType.Allow> regola in un <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto. Indica inoltre che gli altri diritti in `rule` vengono ignorati.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.SemaphoreSecurity> dell'oggetto e aggiunge le regole che consentono la negano di diritti diversi per l'utente corrente. I diritti concessi sono <xref:System.Security.AccessControl.SemaphoreRights.Modify>, <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>, e <xref:System.Security.AccessControl.SemaphoreRights.Synchronize>. L'esempio crea quindi una nuova regola per l'utente corrente, inclusi <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> e <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> diritti e utilizza tale regola con la <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> metodo per rimuovere <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> dal <xref:System.Security.AccessControl.AccessControlType.Allow> regola nel <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto. L'estranei <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> a destra nel `rule` viene ignorato.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.Semaphore> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleAll : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> che specifica l'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> da ricercare. Qualsiasi diritto specificato da questa regola viene ignorato.</param>
        <summary>Cerca tutte le regole di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola specificata e, se trovate, le rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto corrente <xref:System.Security.AccessControl.SemaphoreSecurity> viene eseguita la ricerca di oggetti per le regole che hanno lo stesso nome utente e lo stesso <xref:System.Security.AccessControl.AccessControlType> valore `rule`. Qualsiasi diritto specificato da `rule` vengono ignorati quando si esegue la ricerca. Se non è stata trovata alcuna corrispondenza alle regole, viene eseguita alcuna azione.  
  
   
  
## Examples  
 Esempio di codice seguente mostra che il <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A> metodo rimuove tutte le regole che corrispondono a utente e <xref:System.Security.AccessControl.AccessControlType>, ignorando i diritti.  
  
 Nell'esempio viene creata una <xref:System.Security.AccessControl.SemaphoreSecurity> , vengono aggiunti regole per consentano e negano diritti diversi per l'utente corrente e quindi unisce i diritti aggiuntivi nel <xref:System.Security.AccessControl.AccessControlType.Allow> regola. L'esempio crea quindi una nuova regola che consente all'utente corrente acquisire la proprietà e tale regola viene utilizzata per rimuovere il <xref:System.Security.AccessControl.AccessControlType.Allow> regola dal <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.Semaphore> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleSpecific : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> da rimuovere.</param>
        <summary>Cerca una regola di controllo di accesso che corrisponde esattamente alla regola specificata e, se trovata, la rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regola viene rimosso solo se corrisponde esattamente a `rule` in tutti i dettagli, ad esempio i flag. Altre regole con lo stesso utente e <xref:System.Security.AccessControl.AccessControlType> rimangono invariate.  
  
> [!IMPORTANT]
>  Una regola rappresenta uno o più voci di controllo di accesso (ACE) sottostante e queste voci sono suddivise o combinate, se necessario, quando si modificano le regole di sicurezza di accesso per un utente. Di conseguenza, una regola non esiste più nel formato specifico si trovava al momento è stato aggiunto e in tal caso il <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> (metodo) non è possibile rimuoverlo.  
  
   
  
## Examples  
 Esempio di codice seguente mostra che il <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> metodo richiede una corrispondenza esatta per rimuovere una regola e che le regole per consentire o negare i diritti sono indipendenti tra loro.  
  
 Nell'esempio viene creata una <xref:System.Security.AccessControl.SemaphoreSecurity> , vengono aggiunti regole per consentano e negano diritti diversi per l'utente corrente e quindi unisce i diritti aggiuntivi nel <xref:System.Security.AccessControl.AccessControlType.Allow> regola di accesso. Viene quindi passato originale <xref:System.Security.AccessControl.AccessControlType.Allow> regola per il <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> metodo e consente di visualizzare i risultati, mostrando che nulla venga eliminato. L'esempio genera quindi una regola che corrisponde il <xref:System.Security.AccessControl.AccessControlType.Allow> regola nel <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto e, correttamente, viene utilizzato il <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> metodo per rimuovere la regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.Semaphore> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As SemaphoreAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; bool" Usage="semaphoreSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> che specifica l'utente da ricercare e un insieme di flag di ereditarietà e propagazione con cui deve essere compatibile una regola corrispondente, se trovata. Specifica i diritti da rimuovere dalla regola compatibile, se trovati.</param>
        <summary>Cerca una regola di controllo con lo stesso utente della regola specificata e con i flag di ereditarietà e propagazione compatibili. Se viene trovata una regola simile, i diritti contenuti nella regola specificata vengono rimossi da essa.</summary>
        <returns>
          <see langword="true" /> se viene trovata una regola compatibile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto corrente <xref:System.Security.AccessControl.SemaphoreSecurity> viene eseguita la ricerca per una regola di controllo che ha lo stesso utente `rule`. Se non viene trovata alcuna regola simile, viene eseguita alcuna azione e il metodo restituisce `false`. Se vengono trovate le regole di corrispondenza, vengono controllati i flag di ereditarietà e compatibilità per garantire la compatibilità con i flag specificati nella `rule`. Se viene trovata alcuna regola compatibile, viene eseguita alcuna azione e il metodo restituisce `false`. Se viene trovata una regola con flag compatibili, i diritti specificati nel `rule` vengono rimosse dalla regola compatibile, e il metodo restituisce `true`. Se `rule` specifica i diritti non contenuti nella regola compatibile, viene eseguita alcuna azione rispetto a tali diritti. Se tutti i diritti vengono rimossi dalla regola compatibile, l'intera regola viene rimosso dall'insieme corrente <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto.  
  
> [!IMPORTANT]
>  Sebbene sia possibile specificare i flag di ereditarietà e propagazione per le regole di controllo di semaforo, creandoli con la <xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A> metodo, non è consigliato. Ereditarietà e propagazione non hanno alcun significato per i semafori denominati e rendono più complessa la gestione delle regole di controllo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleAll : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> che specifica l'utente da ricercare. Qualsiasi diritto specificato da questa regola viene ignorato.</param>
        <summary>Cerca tutte le regole di controllo in cui l'utente sia identico a quello della regola specificata e rimuove le regole trovate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto corrente <xref:System.Security.AccessControl.SemaphoreSecurity> viene eseguita la ricerca per le regole di controllo contenenti lo stesso utente `rule`. Qualsiasi diritto specificato da `rule` vengono ignorati quando si esegue la ricerca. Vengono rimosse tutte le regole di corrispondenza. Se non è stata trovata alcuna corrispondenza alle regole, viene eseguita alcuna azione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleSpecific : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> da rimuovere.</param>
        <summary>Cerca una regola di controllo che corrisponde esattamente alla regola specificata e, se trovata, la rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regola viene rimosso solo se corrisponde esattamente a `rule` in tutti i dettagli, ad esempio i flag. Altre regole di controllo per lo stesso utente non sono interessate.  
  
> [!IMPORTANT]
>  Una regola rappresenta uno o più voci di controllo di accesso (ACE) sottostante e queste voci sono suddivise o combinate, se necessario, quando si modificano le regole di sicurezza di controllo per un utente. Di conseguenza, una regola non esiste più nel formato specifico si trovava al momento è stato aggiunto e in tal caso il <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A> (metodo) non è possibile rimuoverlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.ResetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> da aggiungere. L'utente specificato dalla regola determina le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo di accesso con lo stesso utente della regola specificata, a prescindere dalla classe <see cref="T:System.Security.AccessControl.AccessControlType" />, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti regole di accesso della regola specificata, corrisponde a cui utente `rule` viene aggiunto.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come il <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> metodo sostituisce tutte le regole per l'utente corrispondente con la regola specificata per la corrispondenza.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.SemaphoreSecurity> dell'oggetto e aggiunge le regole che consentono la negano di diritti diversi per l'utente corrente. L'esempio crea quindi una nuova regola che consente il controllo completo all'utente corrente e Usa il <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> metodo sostituire entrambe le regole esistenti con la nuova regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.Semaphore> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> da aggiungere. L'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> della regola determinano le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola specificata, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la regola specificata dispone <xref:System.Security.AccessControl.AccessControlType.Allow>, l'effetto di questo metodo consiste nel rimuovere tutto <xref:System.Security.AccessControl.AccessControlType.Allow> regole per l'utente specificato, sostituirli con la regola specificata. Se la regola specificata dispone <xref:System.Security.AccessControl.AccessControlType.Deny>, tutti i <xref:System.Security.AccessControl.AccessControlType.Deny> regole per l'utente specificato vengono sostituite con la regola specificata.  
  
 Se non sono presenti regole il cui utente e <xref:System.Security.AccessControl.AccessControlType> corrispondono alla regola specificata, `rule` viene aggiunto.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come la <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> metodo rimuove tutte le regole che corrispondono all'utente e il <xref:System.Security.AccessControl.AccessControlType> dei `rule`, sostituirli con `rule`.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.SemaphoreSecurity> dell'oggetto e aggiunge le regole che consentono la negano di diritti diversi per l'utente corrente. L'esempio crea quindi una nuova regola che consente il controllo completo all'utente corrente e Usa il <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> regola con la nuova regola di assenso metodo sostituire l'oggetto. La regola che neghi l'accesso non è interessata.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.Semaphore> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> da aggiungere. L'utente specificato dalla regola determina le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo con lo stesso utente della regola specificata, a prescindere dal valore di <see cref="T:System.Security.AccessControl.AuditFlags" />, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti regole di controllo il cui utente corrispondente alla regola specificata, `rule` viene aggiunto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>