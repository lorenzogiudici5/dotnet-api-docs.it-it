<Type Name="RegistrySecurity" FullName="System.Security.AccessControl.RegistrySecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e52f3b248c05ba047d59c24d923733a12bfa7839" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30490735" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistrySecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistrySecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistrySecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Rappresenta la sicurezza del controllo di accesso di Windows per una chiave del Registro di sistema. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Security.AccessControl.RegistrySecurity> oggetto specifica i diritti di accesso per una chiave del Registro di sistema e inoltre specifica come vengono controllati i tentativi di accesso. Diritti di accesso alla chiave del Registro di sistema sono espressi come regole, con ogni regola di accesso rappresentato da un <xref:System.Security.AccessControl.RegistryAccessRule> oggetto. Ogni regola di controllo è rappresentato da un <xref:System.Security.AccessControl.RegistryAuditRule> oggetto.  
  
 Questa situazione rispecchia il sistema di sicurezza di Windows sottostante, in cui ogni oggetto a protezione diretta dispone al massimo un controllo di accesso discrezionale elenco di controllo (DACL) che controlla l'accesso per l'oggetto protetto e al massimo un accesso elenco di controllo sistema (SACL) che specifica che l'accesso vengono controllati i tentativi. Gli elenchi DACL e SACL sono elenchi ordinati di voci di controllo di accesso (ACE) che specificano l'accesso e controllo per utenti e gruppi. Oggetto <xref:System.Security.AccessControl.RegistryAccessRule> o <xref:System.Security.AccessControl.RegistryAuditRule> oggetto potrebbe rappresentare più di una voce ACE.  
  
> [!NOTE]
>  Controllo di accesso di Windows è applicabile solo alle chiavi del Registro di sistema. Non può essere applicato alle coppie chiave/valore singoli archiviate in una chiave.  
  
 Il <xref:System.Security.AccessControl.RegistrySecurity>, <xref:System.Security.AccessControl.RegistryAccessRule>, e <xref:System.Security.AccessControl.RegistryAuditRule> classi nascondono i dettagli di implementazione degli elenchi ACL e ACE. Consentono di ignorare i diversi tipi ACE diciassette e la complessità della gestione corretta di ereditarietà e propagazione di diritti di accesso. Questi oggetti sono progettati anche per evitare gli errori di controllo accesso comuni seguenti:  
  
-   Creazione di un descrittore di sicurezza con un elenco DACL. Un riferimento null a un elenco DACL consente agli utenti di aggiungere le regole di accesso a un oggetto, potenzialmente la creazione di un attacco denial of service. Un nuovo <xref:System.Security.AccessControl.RegistrySecurity> oggetto inizia sempre con un elenco DACL vuoto, con cui viene negato l'accesso per tutti gli utenti.  
  
-   Violazione dell'ordine canonico delle voci ACE. Se l'elenco di voci ACE nell'elenco DACL non viene mantenuta in ordine canonico, potrebbe essere inavvertitamente concesso l'accesso all'oggetto protetto. Ad esempio, i diritti di accesso negato devono trovarsi sempre prima diritti di accesso consentito. <xref:System.Security.AccessControl.RegistrySecurity> gli oggetti mantengono l'ordine corretto internamente.  
  
-   La manipolazione dei flag del descrittore di sicurezza, che deve essere controllata resource manager solo.  
  
-   Creazione di combinazioni di flag ACE non valide.  
  
-   Modifica di voci ACE ereditate. Ereditarietà e propagazione vengono gestiti dal gestore delle risorse, in risposta alle modifiche apportate alle regole di accesso e controllo.  
  
-   Inserimento di voci ACE non significative in ACL.  
  
 Le uniche funzionalità non supportate dagli oggetti di sicurezza .NET sono le attività pericolose che dovrebbero essere evitate dalla maggior parte degli sviluppatori di applicazioni, ad esempio le operazioni seguenti:  
  
-   Attività di basso livello che sono in genere eseguita dal gestore delle risorse.  
  
-   Aggiunta o rimozione di voci di controllo di accesso in modo che non manutenzione l'ordinamento canonico.  
  
 Per modificare il controllo di accesso di Windows per una chiave del Registro di sistema, usare il <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> metodo per ottenere il <xref:System.Security.AccessControl.RegistrySecurity> oggetto. Modificare l'oggetto di sicurezza aggiungendo e rimuovendo le regole e quindi utilizzare il <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> metodo per collegarlo.  
  
> [!IMPORTANT]
>  Le modifiche apportate a un <xref:System.Security.AccessControl.RegistrySecurity> oggetto non influiscono sui livelli di accesso della chiave del Registro di sistema finché non si chiama il <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> metodo a cui assegnare l'oggetto di sicurezza modificato alla chiave del Registro di sistema.  
  
 Per copiare la sicurezza del controllo di accesso da una chiave del registro a altro, utilizzare il <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> metodo per ottenere un <xref:System.Security.AccessControl.RegistrySecurity> oggetto che rappresenta le regole di accesso e controllo per la prima chiave del Registro di sistema e quindi utilizzare il <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> metodo a cui assegnare tali regole per il seconda chiave del Registro di sistema. È inoltre possibile assegnare le regole a una seconda chiave del Registro di sistema con un <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType> o <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType> metodo che accetta un <xref:System.Security.AccessControl.RegistrySecurity> parametro dell'oggetto.  
  
 Gli utenti con un investimento nel linguaggio di definizione descrittore di sicurezza (SDDL) possono usare il <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> per impostare le regole di accesso per una chiave del Registro di sistema e <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metodo per ottenere una stringa che rappresenta le regole di accesso in formato SDDL. Questa operazione è sconsigliata per i nuovi sviluppi.  
  
   
  
## Examples  
 In questa sezione contiene due esempi di codice. Nel primo esempio viene illustrato come compatibile merge regole quando aggiunte e rimosse e il secondo mostra come flag di ereditarietà e propagazione sull'aggiunta e l'eliminazione di regole.  
  
 Esempio 1  
  
 Nell'esempio di codice riportato di seguito viene illustrato come la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> metodo rimuove i diritti da una regola compatibile e come <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> metodo unisce i diritti alle regole compatibili.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.RegistrySecurity> dell'oggetto e aggiunge una regola che consente all'utente corrente <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> diritti. Nell'esempio viene quindi creata una regola che concede all'utente <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, con la stessa ereditarietà diritti e propagazione prima regola e viene utilizzato il <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> per questa nuova regola da rimuovere il <xref:System.Security.AccessControl.RegistrySecurity> oggetto. <xref:System.Security.AccessControl.RegistryRights.SetValue> è un componente di <xref:System.Security.AccessControl.RegistryRights.ReadKey>, viene rimosso dalla regola compatibile. Le regole di <xref:System.Security.AccessControl.RegistrySecurity> oggetto sono visualizzate, con i componenti rimanenti del <xref:System.Security.AccessControl.RegistryRights.ReadKey>.  
  
 Nell'esempio di codice chiama quindi il <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> metodo per unire il <xref:System.Security.AccessControl.RegistryRights.SetValue> destro del mouse in una regola nel <xref:System.Security.AccessControl.RegistrySecurity> oggetto.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:Microsoft.Win32.RegistryKey> oggetto. Nel secondo esempio in questa sezione viene collegato a un oggetto di sicurezza e quindi eseguire gli esempi <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> e <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 Esempio 2  
  
 Esempio di codice riportato di seguito viene illustrato come le regole di accesso con ereditarietà e propagazione. Nell'esempio viene creato un <xref:System.Security.AccessControl.RegistrySecurity> dell'oggetto, quindi crea e aggiunge due regole che dispongono di <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> flag. La prima regola non dispone di alcun flag di propagazione, mentre la seconda dispone <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> e <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>.  
  
 Il programma visualizza le regole di <xref:System.Security.AccessControl.RegistrySecurity> oggetto e quindi viene utilizzato il <xref:System.Security.AccessControl.RegistrySecurity> oggetto per creare una sottochiave. Il programma crea un elemento figlio sottochiave e una sottochiave nipote, quindi Visualizza la sicurezza per ogni sottochiave. Infine, il programma Elimina le chiavi di prova.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistrySecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistrySecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> con i valori predefiniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nuovo <xref:System.Security.AccessControl.RegistrySecurity> oggetto inizia sempre con un elenco vuoto di accesso discrezionale (DACL), che nega l'accesso per tutti gli utenti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo di enumerazione utilizzato dalla classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> per rappresentare i diritti di accesso.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta l'enumerazione <see cref="T:System.Security.AccessControl.RegistryRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe sostituzione il <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> proprietà e restituiscono il tipo utilizzato per rappresentare i diritti di accesso. Quando si utilizzano matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile utilizzare questa proprietà per determinare il tipo di enumerazione appropriata da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Classe <see cref="T:System.Security.Principal.IdentityReference" /> che identifica l'utente o il gruppo a cui viene applicata la regola.</param>
        <param name="accessMask">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.RegistryRights" /> che specificano i diritti di accesso da concedere o negare, per effettuare il cast in un intero.</param>
        <param name="isInherited">Valore Boolean che specifica se la regola è ereditata.</param>
        <param name="inheritanceFlags">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.InheritanceFlags" /> che specificano come la regola viene ereditata dalle sottochiavi.</param>
        <param name="propagationFlags">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.PropagationFlags" /> che modificano il modo in cui la regola viene ereditata dalle sottochiavi. Non è significativa se il valore di <c>inheritanceFlags</c> è <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Security.AccessControl.AccessControlType" /> che specificano se i diritti sono concessi o negati.</param>
        <summary>Crea una nuova regola di controllo di accesso per l'utente specificato, con i diritti di accesso, il controllo di accesso e i flag specificati.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> che rappresenta i diritti specificati per l'utente specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo consigliato per creare le regole di controllo di accesso consiste nell'utilizzare i costruttori del <xref:System.Security.AccessControl.RegistryAccessRule> classe.  
  
> [!NOTE]
>  Sebbene sia possibile specificare il <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> flag, è presente alcun punto a tale scopo. Ai fini di controllo di accesso, le coppie nome/valore in una sottochiave non sono oggetti separati. Diritti di accesso alle coppie nome/valore sono controllati dai diritti della sottochiave. Inoltre, poiché tutte le sottochiavi sono contenitori (vale a dire può contenere altre sottochiavi), non sono influenzati dal <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flag. Infine, se si specifica il <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flag inutilmente complica la gestione delle regole, perché interferisce con la combinazione normale di regole compatibili.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="type" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="accessMask" /> è zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> non è di tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> né di un tipo quale <see cref="T:System.Security.Principal.NTAccount" /> convertibile nel tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo utilizzato dalla classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> per rappresentare le regole di accesso.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta la classe <see cref="T:System.Security.AccessControl.RegistryAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe sostituzione il <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> proprietà e restituiscono il tipo utilizzato per rappresentare le regole di accesso. Quando si utilizzano matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile utilizzare questa proprietà per determinare il tipo di regola di accesso corretto da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Regola di controllo di accesso da aggiungere.</param>
        <summary>Cerca un controllo di accesso corrispondente al quale è possibile unire la nuova regola. Se non viene trovata alcuna regola, viene aggiunta la nuova regola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> metodo cerca le regole con lo stesso utente o gruppo e lo stesso <xref:System.Security.AccessControl.AccessControlType> come `rule`. Se non vengono rilevati, `rule` viene aggiunto. Se una regola di corrispondenza viene trovato, i diritti in `rule` vengono unite con la regola esistente.  
  
 Regole non possono essere unite se dispongono di flag di ereditarietà diversi. Ad esempio, se un utente è consentito l'accesso in lettura con alcun flag, ereditarietà e <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> viene utilizzato per aggiungere una regola che concede l'accesso in scrittura con ereditarietà per le sottochiavi utente (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), non è possibile unire le due regole.  
  
 Le regole con diversi <xref:System.Security.AccessControl.AccessControlType> valori non vengono mai uniti.  
  
 Le regole esprimono i diritti in modo più economico. Ad esempio, se un utente ha <xref:System.Security.AccessControl.RegistryRights.QueryValues>, <xref:System.Security.AccessControl.RegistryRights.Notify> e <xref:System.Security.AccessControl.RegistryRights.ReadPermissions> diritti e si aggiunge una regola che concede <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> diritti, l'utente ha tutte le parti costitutive di <xref:System.Security.AccessControl.RegistryRights.ReadKey> diritti. Se si esegue una query dei diritti dell'utente, si noterà una regola contenente <xref:System.Security.AccessControl.RegistryRights.ReadKey> diritti. Analogamente, se si rimuove <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> diritti, gli altri componenti del <xref:System.Security.AccessControl.RegistryRights.ReadKey> diritti verranno visualizzato nuovamente.  
  
   
  
## Examples  
 Esempio di codice seguente crea le regole di accesso del Registro di sistema e li aggiunge a un <xref:System.Security.AccessControl.RegistrySecurity> oggetto, mostrando come regole che consentono la negano di diritti restano separate, mentre le regole compatibili dello stesso tipo viene unita.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:Microsoft.Win32.RegistryKey> oggetto. Esempi di oggetti di sicurezza possono essere individuati <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> e <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 Un esempio di codice che illustra i flag di ereditarietà e propagazione, vedere la <xref:System.Security.AccessControl.RegistryAccessRule> classe.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Regola di controllo da aggiungere. L'utente specificato dalla regola determina la ricerca.</param>
        <summary>Cerca una regola di controllo a cui è possibile unire la nuova regola. Se non viene trovata alcuna regola, viene aggiunta la nuova regola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> il metodo di ricerca per le regole con lo stesso utente o gruppo come `rule`. Se non vengono rilevati, `rule` viene aggiunto. Se una regola di corrispondenza viene trovato, il flag in `rule` vengono unite alla regola esistente.  
  
 Regole non possono essere unite se dispongono di flag di ereditarietà diversi. Ad esempio, se i tentativi di scrivere in una chiave non vengono controllati per un determinato utente senza flag di ereditarietà e <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> viene utilizzato per aggiungere una regola che specifica che devono essere controllate per lo stesso utente, ma con ereditarietà per tentativi non riusciti per modificare le autorizzazioni le sottochiavi (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), non è possibile unire le due regole.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Classe <see cref="T:System.Security.Principal.IdentityReference" /> che identifica l'utente o il gruppo a cui viene applicata la regola.</param>
        <param name="accessMask">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.RegistryRights" /> che specificano i diritti di accesso da controllare, per effettuare il cast in un intero.</param>
        <param name="isInherited">Valore Boolean che specifica se la regola è ereditata.</param>
        <param name="inheritanceFlags">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.InheritanceFlags" /> che specificano come la regola viene ereditata dalle sottochiavi.</param>
        <param name="propagationFlags">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.PropagationFlags" /> che modificano il modo in cui la regola viene ereditata dalle sottochiavi. Non è significativa se il valore di <c>inheritanceFlags</c> è <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="flags">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.AuditFlags" /> che specificano se controllare l'accesso riuscito, l'accesso non riuscito o entrambi.</param>
        <summary>Crea una nuova regola di controllo che specifica l'utente a cui viene applicata la regola, i diritti di accesso da controllare, l'ereditarietà e la propagazione della regola e il risultato che attiva la regola.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> che rappresenta la regola di controllo specificata per l'utente specificato, con i flag indicati. Il tipo restituito del metodo è la classe base, <see cref="T:System.Security.AccessControl.AuditRule" />, ma è possibile effettuare in maniera sicura il cast del valore restituito nella classe derivata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo consigliato per creare regole di controllo consiste nell'utilizzare i costruttori del <xref:System.Security.AccessControl.RegistryAuditRule> classe.  
  
> [!NOTE]
>  Sebbene sia possibile specificare il <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> flag, è presente alcun punto a tale scopo. Per motivi di controllo, le coppie nome/valore in una sottochiave non sono oggetti separati. I diritti di controllo per coppie nome/valore sono controllati dai diritti della sottochiave. Inoltre, poiché tutte le sottochiavi sono contenitori (vale a dire può contenere altre sottochiavi), non sono influenzati dal <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flag. Infine, se si specifica il <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flag inutilmente complica la gestione delle regole, perché interferisce con la combinazione normale di regole compatibili.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="flags" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="accessMask" /> è zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> non è di tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> né di un tipo quale <see cref="T:System.Security.Principal.NTAccount" /> convertibile nel tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo utilizzato dalla classe <see cref="T:System.Security.AccessControl.RegistrySecurity" /> per rappresentare le regole di controllo.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta la classe <see cref="T:System.Security.AccessControl.RegistryAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe sostituzione il <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> proprietà e restituiscono il tipo utilizzato per rappresentare i diritti di controllo. Quando si utilizzano matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile utilizzare questa proprietà per determinare il tipo di regola di controllo appropriata da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As RegistryAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> che specifica l'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> da ricercare, nonché un insieme di flag di ereditarietà e propagazione con cui deve essere compatibile una regola corrispondente, se trovata. Specifica i diritti da rimuovere dalla regola compatibile, se trovati.</param>
        <summary>Cerca una regola di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola di accesso specificata e con i flag di ereditarietà e propagazione compatibili. Se viene trovata una regola simile, i diritti contenuti nella regola di accesso specificata vengono rimossi da essa.</summary>
        <returns>
          <see langword="true" /> se viene trovata una regola compatibile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Security.AccessControl.RegistrySecurity> viene cercata una regola con lo stesso utente e la stessa <xref:System.Security.AccessControl.AccessControlType> valore come `rule`. Se non viene trovata alcuna tale regola viene eseguita alcuna azione e il metodo restituisce `false`. Se vengono rilevate le regole di corrispondenza, ereditarietà e compatibilità vengono controllati per garantire la compatibilità con i flag specificati in `rule`. Se viene trovata alcuna regola compatibile, viene eseguita alcuna azione e il metodo restituisce `false`. Se viene trovata una regola con flag compatibili, i diritti specificati `rule` vengono rimossi dalla regola compatibile, e il metodo restituisce `true`. Se `rule` specifica i diritti non contenuti nella regola compatibile, viene eseguita alcuna azione relativamente a tali diritti. Se tutti i diritti vengono rimossi dalla regola compatibile, l'intera regola viene rimosso dall'oggetto corrente <xref:System.Security.AccessControl.RegistrySecurity> oggetto.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> metodo rimuove i diritti da una regola compatibile e come <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> metodo unisce i diritti alle regole compatibili.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.RegistrySecurity> dell'oggetto e aggiunge una regola che consente all'utente corrente <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> diritti. Nell'esempio viene quindi creata una regola che concede all'utente <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, con la stessa ereditarietà diritti e propagazione prima regola e viene utilizzato il <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> per questa nuova regola da rimuovere il <xref:System.Security.AccessControl.RegistrySecurity> oggetto. <xref:System.Security.AccessControl.RegistryRights.SetValue> è un componente di <xref:System.Security.AccessControl.RegistryRights.ReadKey>, viene rimosso dalla regola compatibile. Le regole di <xref:System.Security.AccessControl.RegistrySecurity> oggetto sono visualizzate, con i componenti rimanenti del <xref:System.Security.AccessControl.RegistryRights.ReadKey>.  
  
 Nell'esempio di codice chiama quindi il <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> metodo per unire il <xref:System.Security.AccessControl.RegistryRights.SetValue> destro del mouse in una regola nel <xref:System.Security.AccessControl.RegistrySecurity> oggetto.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:Microsoft.Win32.RegistryKey> oggetto. Nel secondo esempio in questa sezione viene collegato a un oggetto di sicurezza e quindi eseguire gli esempi <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> che specifica l'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> da ricercare. Tutti i diritti, i flag di ereditarietà o di propagazione specificati da questa regola verranno ignorati.</param>
        <summary>Cerca tutte le regole di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola specificata e, se trovate, le rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Security.AccessControl.RegistrySecurity> viene eseguita la ricerca per le regole che presentano lo stesso utente e lo stesso <xref:System.Security.AccessControl.AccessControlType> valore come `rule`. Eventuali diritti, i flag di ereditarietà o flag di propagazione specificato da `rule` vengono ignorati quando si esegue la ricerca. Se non è stata trovata alcuna regola corrispondente, viene eseguita alcuna azione.  
  
 Ad esempio, se un utente dispone di più regole che concedono diritti diversi con ereditarietà diversa e i flag di propagazione, è possibile rimuovere tutte queste regole creando un <xref:System.Security.AccessControl.RegistryAccessRule> oggetto che specifica l'utente e <xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>, con eventuali diritti e flag arbitrari, e passare tale regola per il <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente mostra che il <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> metodo rimuove tutte le regole che corrispondono a utente e <xref:System.Security.AccessControl.AccessControlType>, ignorando diritti e flag.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.RegistrySecurity> dell'oggetto e aggiunge le regole che concedono e negano diversi diritti per l'utente corrente, con diversi contrassegni di ereditarietà e propagazione. Nell'esempio viene quindi creata una nuova regola che consente all'utente di assumere la proprietà corrente e passa a questa regola di <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> metodo per rimuovere le due regole che consentono l'accesso.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:Microsoft.Win32.RegistryKey> oggetto. Vedere il <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (metodo) e <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> metodo.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> da rimuovere.</param>
        <summary>Cerca una regola di controllo di accesso che corrisponde esattamente alla regola specificata e, se trovata, la rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regola viene rimosso solo se corrisponde esattamente a `rule` in tutti i dettagli, compresi i flag. Le altre regole con lo stesso utente e <xref:System.Security.AccessControl.AccessControlType> non sono interessate.  
  
> [!IMPORTANT]
>  Una regola rappresenta uno o più voci di controllo di accesso (ACE) sottostanti e tali voci vengono suddivise o combinate necessarie quando si modificano le regole di sicurezza di accesso per un utente. Di conseguenza, una regola potrebbe non esistere più nel formato che aveva al momento dell'aggiunta e in tal caso il <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> (metodo) non è possibile rimuoverlo.  
  
   
  
## Examples  
 Esempio di codice seguente mostra che il <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> metodo rimuove una regola solo se corrisponde esattamente.  
  
 L'esempio crea due regole che concedono diritti diversi. Le regole sono flag di ereditarietà e propagazione compatibili, pertanto quando viene aggiunto alla seconda regola consente di unire con il primo. Nell'esempio viene chiamato il <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> metodo, specificando la prima regola, ma poiché le regole sono unite non esiste alcuna regola corrispondente. Nell'esempio viene quindi chiamato il <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> metodo per rimuovere la seconda regola dalla regola unita e infine chiama la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> metodo per rimuovere la prima regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:Microsoft.Win32.RegistryKey> oggetto. Vedere il <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (metodo) e <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> metodo.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As RegistryAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> che specifica l'utente da ricercare e un insieme di flag di ereditarietà e propagazione con cui deve essere compatibile una regola corrispondente, se trovata. Specifica i diritti da rimuovere dalla regola compatibile, se trovati.</param>
        <summary>Cerca una regola di controllo con lo stesso utente della regola specificata e con i flag di ereditarietà e propagazione compatibili. Se viene trovata una regola simile, i diritti contenuti nella regola specificata vengono rimossi da essa.</summary>
        <returns>
          <see langword="true" /> se viene trovata una regola compatibile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Security.AccessControl.RegistrySecurity> viene cercata una regola di controllo con lo stesso utente `rule`. Se non viene trovata alcuna tale regola viene eseguita alcuna azione e il metodo restituisce `false`. Se vengono rilevate le regole di corrispondenza, ereditarietà e compatibilità vengono controllati per garantire la compatibilità con i flag specificati in `rule`. Se viene trovata alcuna regola compatibile, viene eseguita alcuna azione e il metodo restituisce `false`. Se viene trovata una regola con flag compatibili, i diritti specificati `rule` vengono rimossi dalla regola compatibile, e il metodo restituisce `true`. Se `rule` specifica i diritti non contenuti nella regola compatibile, viene eseguita alcuna azione relativamente a tali diritti. Se tutti i diritti vengono rimossi dalla regola compatibile, l'intera regola viene rimosso dall'oggetto corrente <xref:System.Security.AccessControl.RegistrySecurity> oggetto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> che specifica l'utente da ricercare. Tutti i diritti, i flag di ereditarietà o di propagazione specificati da questa regola verranno ignorati.</param>
        <summary>Cerca tutte le regole di controllo in cui l'utente sia identico a quello della regola specificata e rimuove le regole trovate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Security.AccessControl.RegistrySecurity> viene eseguita la ricerca per le regole di controllo con lo stesso utente `rule`. Eventuali diritti, i flag di ereditarietà o flag di propagazione specificato da `rule` vengono ignorati quando si esegue la ricerca. Se non è stata trovata alcuna regola corrispondente, viene eseguita alcuna azione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> da rimuovere.</param>
        <summary>Cerca una regola di controllo che corrisponde esattamente alla regola specificata e, se trovata, la rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regola viene rimosso solo se corrisponde esattamente a `rule` in tutti i dettagli, compresi i flag. Altre regole di controllo per lo stesso utente non sono interessate.  
  
> [!IMPORTANT]
>  Una regola rappresenta uno o più voci di controllo di accesso (ACE) sottostanti e tali voci vengono suddivise o combinate necessarie quando si modificano le regole di sicurezza di controllo per un utente. Di conseguenza, una regola potrebbe non esistere più nel formato che aveva al momento dell'aggiunta e in tal caso il <xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A> (metodo) non è possibile rimuoverlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> da aggiungere. L'utente specificato dalla regola determina le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo di accesso con lo stesso utente della regola specificata, a prescindere dalla classe <see cref="T:System.Security.AccessControl.AccessControlType" />, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti regole di accesso il cui utente corrisponde a quello della regola specificata, `rule` viene aggiunto.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come la <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> metodo sostituisce tutte le regole per l'utente corrispondente con la regola specificata per la corrispondenza.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.RegistrySecurity> dell'oggetto e aggiunge le regole che concedono e negano diversi diritti per l'utente corrente, con diversi contrassegni di ereditarietà e propagazione. Nell'esempio viene quindi creata una nuova regola che consente all'utente solo di leggere la chiave corrente e utilizza il <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> metodo per rimuovere tutte le regole per l'utente e sostituirli con la nuova regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:Microsoft.Win32.RegistryKey> oggetto. Vedere il <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (metodo) e <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> metodo.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> da aggiungere. L'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> della regola determinano le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola specificata, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la regola specificata è <xref:System.Security.AccessControl.AccessControlType.Allow>, l'effetto di questo metodo consiste nel rimuovere tutti <xref:System.Security.AccessControl.AccessControlType.Allow> regole per l'utente specificato, sostituirli con la regola specificata. Se la regola specificata è <xref:System.Security.AccessControl.AccessControlType.Deny>tutti <xref:System.Security.AccessControl.AccessControlType.Deny> vengono sostituite le regole per l'utente specificato con la regola specificata.  
  
 Se non esistono regole il cui utente e <xref:System.Security.AccessControl.AccessControlType> corrispondono alla regola specificata, `rule` viene aggiunto.  
  
   
  
## Examples  
 Esempio di codice seguente mostra che il <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> metodo rimuove tutte le regole che corrispondono all'utente e la <xref:System.Security.AccessControl.AccessControlType> di `rule`, ignorando diritti e flag e li sostituisce con `rule`.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.RegistrySecurity> dell'oggetto e aggiunge le regole che concedono e negano diversi diritti per l'utente corrente, con diversi contrassegni di ereditarietà e propagazione. Nell'esempio viene quindi creata una nuova regola che consente all'utente solo di leggere la chiave corrente e utilizza il <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> metodo per rimuovere le due regole che consentono l'accesso e sostituirli con la nuova regola. La regola che nega l'accesso non è stata interessata.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:Microsoft.Win32.RegistryKey> oggetto. Vedere il <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> (metodo) e <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> metodo.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> da aggiungere. L'utente specificato dalla regola determina le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo con lo stesso utente della regola specificata, a prescindere dal valore di <see cref="T:System.Security.AccessControl.AuditFlags" />, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti regole di controllo il cui utente corrisponde a quello della regola specificata, `rule` viene aggiunto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>