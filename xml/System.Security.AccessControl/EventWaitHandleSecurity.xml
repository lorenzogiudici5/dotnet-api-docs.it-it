<Type Name="EventWaitHandleSecurity" FullName="System.Security.AccessControl.EventWaitHandleSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="552d1bbce19f1c94b3fc43ff75cb4f46a5379a82" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30490475" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class EventWaitHandleSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit EventWaitHandleSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.EventWaitHandleSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EventWaitHandleSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandleSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Rappresenta la sicurezza del controllo di accesso di Windows applicata a un handle di attesa del sistema denominato. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto specifica l'accesso i diritti per l'handle di attesa di un sistema denominato e specifica inoltre il modo in cui vengono controllati i tentativi di accesso. Diritti di accesso per l'handle di attesa sono espressi come regole, con ogni regola di accesso rappresentato da un <xref:System.Security.AccessControl.EventWaitHandleAccessRule> oggetto. Ogni regola di controllo è rappresentato da un <xref:System.Security.AccessControl.EventWaitHandleAuditRule> oggetto.  
  
 Questa situazione rispecchia il sistema di sicurezza di Windows sottostante, in cui ogni oggetto a protezione diretta dispone al massimo un controllo di accesso discrezionale elenco di controllo (DACL) che controlla l'accesso per l'oggetto protetto e al massimo un accesso elenco di controllo sistema (SACL) che specifica che l'accesso vengono controllati i tentativi. Gli elenchi DACL e SACL sono elenchi ordinati di voci di controllo di accesso (ACE) che specificano l'accesso e controllo per utenti e gruppi. Un <xref:System.Security.AccessControl.EventWaitHandleAccessRule> o <xref:System.Security.AccessControl.EventWaitHandleAuditRule> oggetto potrebbe rappresentare più di una voce ACE.  
  
> [!NOTE]
>  Un <xref:System.Threading.EventWaitHandle> oggetto può rappresentare un handle di attesa locale o l'handle di attesa di un sistema denominato. Controllo di accesso di Windows è significativo solo per gli handle di attesa di sistema denominato.  
  
 Il <xref:System.Security.AccessControl.EventWaitHandleSecurity>, <xref:System.Security.AccessControl.EventWaitHandleAccessRule>, e <xref:System.Security.AccessControl.EventWaitHandleAuditRule> classi nascondono i dettagli di implementazione degli elenchi ACL e ACE. Consentono di ignorare i diversi tipi ACE diciassette e la complessità della gestione corretta di ereditarietà e propagazione di diritti di accesso. Questi oggetti sono progettati anche per evitare gli errori di controllo accesso comuni seguenti:  
  
-   Creazione di un descrittore di sicurezza con un elenco DACL. Un riferimento null a un elenco DACL consente agli utenti di aggiungere le regole di accesso a un oggetto, potenzialmente la creazione di un attacco denial of service. Un nuovo <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto inizia sempre con un elenco DACL vuoto, con cui viene negato l'accesso per tutti gli utenti.  
  
-   Violazione dell'ordine canonico delle voci ACE. Se l'elenco di voci ACE nell'elenco DACL non viene mantenuta in ordine canonico, potrebbe essere inavvertitamente concesso l'accesso all'oggetto protetto. Ad esempio, i diritti di accesso negato devono trovarsi sempre prima diritti di accesso consentito. <xref:System.Security.AccessControl.EventWaitHandleSecurity> gli oggetti mantengono l'ordine corretto internamente.  
  
-   La manipolazione dei flag del descrittore di sicurezza, che deve essere controllata resource manager solo.  
  
-   Creazione di combinazioni di flag ACE non valide.  
  
-   Modifica di voci ACE ereditate. Ereditarietà e propagazione vengono gestiti dal gestore delle risorse, in risposta alle modifiche apportate alle regole di accesso e controllo.  
  
-   Inserimento di voci ACE non significative in ACL.  
  
 Le uniche funzionalità non supportate dagli oggetti di sicurezza .NET sono le attività pericolose che dovrebbero essere evitate dalla maggior parte degli sviluppatori di applicazioni, ad esempio le operazioni seguenti:  
  
-   Attività di basso livello che sono in genere eseguita dal gestore delle risorse.  
  
-   Aggiunta o rimozione di voci di controllo di accesso in modo che non manutenzione l'ordinamento canonico.  
  
 Per modificare il controllo di accesso di Windows per un handle di attesa denominato, usare il <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> metodo per ottenere il <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto. Modificare l'oggetto di sicurezza aggiungendo e rimuovendo le regole e quindi utilizzare il <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType> metodo per collegarlo.  
  
> [!IMPORTANT]
>  Le modifiche apportate a un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto non influiscono sui livelli di accesso dell'handle di attesa denominato finché non si chiama il <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType> metodo a cui assegnare l'oggetto di sicurezza modificato all'handle di attesa denominato.  
  
 Per copiare del controllo di accesso da un handle di attesa in un altro, utilizzare il <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> metodo per ottenere un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto che rappresenta le regole di accesso e controllo per l'handle di attesa prima e quindi utilizzare il <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType> metodo o un costruttore che accetta un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto, per assegnare tali regole al secondo handle di attesa.  
  
 Gli utenti con un investimento nel linguaggio di definizione descrittore di sicurezza (SDDL) possono usare il <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> per impostare le regole di accesso per un handle di attesa denominato e il <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metodo per ottenere una stringa che rappresenta le regole di accesso in formato SDDL. Questa operazione è sconsigliata per i nuovi sviluppi.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra la separazione tra <xref:System.Security.AccessControl.AccessControlType.Allow> regole e <xref:System.Security.AccessControl.AccessControlType.Deny> regole e Mostra la combinazione di diritti nelle regole compatibili. Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto, vengono aggiunte regole che concedono e negano diversi diritti per l'utente corrente e consente di visualizzare la coppia di regole risultante. Nell'esempio viene quindi concessi nuovi diritti per l'utente corrente e viene visualizzato il risultato, che mostra i nuovi diritti vengono uniti con esistente <xref:System.Security.AccessControl.AccessControlType.Allow> regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" />
    <altmember cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" />
    <altmember cref="T:System.Security.AccessControl.EventWaitHandleRights" />
    <altmember cref="M:System.Threading.EventWaitHandle.GetAccessControl" />
    <altmember cref="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandleSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandleSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> con i valori predefiniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nuovo <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto inizia sempre con un elenco vuoto di accesso discrezionale (DACL), che nega l'accesso per tutti gli utenti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Questa classe non è supportata in Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.EventWaitHandleSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo di enumerazione utilizzato dalla classe <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> per rappresentare i diritti di accesso.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta l'enumerazione <see cref="T:System.Security.AccessControl.EventWaitHandleRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe sostituzione il <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> proprietà e restituiscono il tipo utilizzato per rappresentare i diritti di accesso. Quando si utilizzano matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile utilizzare questa proprietà per determinare il tipo di enumerazione appropriata da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Classe <see cref="T:System.Security.Principal.IdentityReference" /> che identifica l'utente o il gruppo a cui viene applicata la regola.</param>
        <param name="accessMask">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.EventWaitHandleRights" /> che specificano i diritti di accesso da concedere o negare, per effettuare il cast in un intero.</param>
        <param name="isInherited">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="inheritanceFlags">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="propagationFlags">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Security.AccessControl.AccessControlType" /> che specificano se i diritti sono concessi o negati.</param>
        <summary>Crea una nuova regola di controllo di accesso per l'utente specificato, con i diritti di accesso, il controllo di accesso e i flag specificati.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> che rappresenta i diritti specificati per l'utente specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo consigliato per creare le regole di controllo di accesso consiste nell'utilizzare i costruttori del <xref:System.Security.AccessControl.EventWaitHandleAccessRule> classe.  
  
> [!NOTE]
>  Anche se i flag di ereditarietà e propagazione sono significativi per gli eventi denominati, è comunque possibile specificarli. Questa opzione non è consigliata perché complica inutilmente la gestione delle regole, ad esempio da interferire con la combinazione di regole che verrebbero altrimenti compatibili.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="type" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="accessMask" /> è zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> non è di tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> né di un tipo quale <see cref="T:System.Security.Principal.NTAccount" /> convertibile nel tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo utilizzato dalla classe <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> per rappresentare le regole di accesso.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta la classe <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe sostituzione il <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> proprietà e restituiscono il tipo utilizzato per rappresentare le regole di accesso. Quando si utilizzano matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile utilizzare questa proprietà per determinare il tipo di regola di accesso corretto da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Regola di controllo di accesso da aggiungere.</param>
        <summary>Cerca una regola di controllo di accesso corrispondente a cui è possibile unire la nuova regola. Se non viene trovata alcuna regola, viene aggiunta la nuova regola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule%2A> metodo cerca le regole con lo stesso utente o gruppo e lo stesso <xref:System.Security.AccessControl.AccessControlType> come `rule`. Se non vengono rilevati, `rule` viene aggiunto. Se una regola di corrispondenza viene trovato, i diritti in `rule` vengono unite con la regola esistente.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra la separazione tra <xref:System.Security.AccessControl.AccessControlType.Allow> regole e <xref:System.Security.AccessControl.AccessControlType.Deny> regole e Mostra la combinazione di diritti nelle regole compatibili. Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto, vengono aggiunte regole che concedono e negano diversi diritti per l'utente corrente e consente di visualizzare la coppia di regole risultante. Nell'esempio viene quindi concessi nuovi diritti per l'utente corrente e viene visualizzato il risultato, che mostra i nuovi diritti vengono uniti con esistente <xref:System.Security.AccessControl.AccessControlType.Allow> regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AddAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Regola di controllo da aggiungere. L'utente specificato dalla regola determina la ricerca.</param>
        <summary>Cerca una regola di controllo a cui è possibile unire la nuova regola. Se non viene trovata alcuna regola, viene aggiunta la nuova regola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.AccessControl.EventWaitHandleSecurity.AddAuditRule%2A> il metodo di ricerca per le regole con lo stesso utente o gruppo come `rule`. Se non vengono rilevati, `rule` viene aggiunto. Se una regola di corrispondenza viene trovato, il flag in `rule` vengono unite alla regola esistente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Classe <see cref="T:System.Security.Principal.IdentityReference" /> che identifica l'utente o il gruppo a cui viene applicata la regola.</param>
        <param name="accessMask">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.EventWaitHandleRights" /> che specificano i diritti di accesso da controllare, per effettuare il cast in un intero.</param>
        <param name="isInherited">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="inheritanceFlags">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="propagationFlags">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="flags">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.AuditFlags" /> che specificano se controllare l'accesso riuscito, l'accesso non riuscito o entrambi.</param>
        <summary>Crea una nuova regola di controllo che specifica l'utente a cui viene applicata la regola, i diritti di accesso da controllare e il risultato che attiva la regola di controllo.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> che rappresenta la regola di controllo specificata per l'utente specificato. Il tipo restituito del metodo è la classe base, <see cref="T:System.Security.AccessControl.AuditRule" />, ma è possibile effettuare in maniera sicura il cast del valore restituito nella classe derivata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo consigliato per creare regole di controllo consiste nell'utilizzare i costruttori del <xref:System.Security.AccessControl.EventWaitHandleAuditRule> classe.  
  
> [!NOTE]
>  Anche se i flag di ereditarietà e propagazione sono significativi per gli eventi denominati, è comunque possibile specificarli. Questa opzione non è consigliata perché complica inutilmente la gestione delle regole, ad esempio da interferire con la combinazione di regole che verrebbero altrimenti compatibili.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="flags" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="accessMask" /> è zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> non è di tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> né di un tipo quale <see cref="T:System.Security.Principal.NTAccount" /> convertibile nel tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo utilizzato dalla classe <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> per rappresentare le regole di controllo.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta la classe <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe sostituzione il <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> proprietà e restituiscono il tipo utilizzato per rappresentare i diritti di controllo. Quando si utilizzano matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile utilizzare questa proprietà per determinare il tipo di regola di controllo appropriata da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As EventWaitHandleAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> che specifica l'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> da ricercare, nonché un insieme di flag di ereditarietà e propagazione con cui deve essere compatibile una regola corrispondente, se trovata. Specifica i diritti da rimuovere dalla regola compatibile, se trovati.</param>
        <summary>Cerca una regola di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola di accesso specificata e con i flag di ereditarietà e propagazione compatibili. Se viene trovata una regola simile, i diritti contenuti nella regola di accesso specificata vengono rimossi da essa.</summary>
        <returns>
          <see langword="true" /> se viene trovata una regola compatibile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> viene cercata una regola con lo stesso utente e la stessa <xref:System.Security.AccessControl.AccessControlType> valore come `rule`. Se non viene trovata alcuna tale regola viene eseguita alcuna azione e il metodo restituisce `false`. Se vengono rilevate le regole di corrispondenza, ereditarietà e compatibilità vengono controllati per garantire la compatibilità con i flag specificati in `rule`. Se viene trovata alcuna regola compatibile, viene eseguita alcuna azione e il metodo restituisce `false`. Se viene trovata una regola con flag compatibili, i diritti specificati `rule` vengono rimossi dalla regola compatibile, e il metodo restituisce `true`. Se `rule` specifica i diritti non contenuti nella regola compatibile, viene eseguita alcuna azione relativamente a tali diritti. Se tutti i diritti vengono rimossi dalla regola compatibile, l'intera regola viene rimosso dall'oggetto corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto.  
  
> [!IMPORTANT]
>  Sebbene sia possibile specificare flag di ereditarietà e propagazione per le regole di accesso eventi creandoli con il <xref:System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleFactory%2A> (metodo), questa operazione è sconsigliata. Ereditarietà e propagazione non hanno alcun significato per eventi denominati e rendono più complessa la gestione delle regole di accesso.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule%2A> metodo per rimuovere diritti da un <xref:System.Security.AccessControl.AccessControlType.Allow> regola in un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto. Viene inoltre illustrato che gli altri diritti in `rule` vengono ignorati.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> dell'oggetto e aggiunge le regole che concedono e negano diversi diritti per l'utente corrente. I diritti concessi sono <xref:System.Security.AccessControl.EventWaitHandleRights.Modify>, <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions>, e <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize>. Nell'esempio viene quindi creata una nuova regola per l'utente corrente, inclusi <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions> e <xref:System.Security.AccessControl.EventWaitHandleRights.TakeOwnership> diritti e utilizzata con la <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule%2A> metodo per rimuovere <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions> dal <xref:System.Security.AccessControl.AccessControlType.Allow> regola nel <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto. Il <xref:System.Security.AccessControl.EventWaitHandleRights.TakeOwnership> direttamente in `rule` viene ignorato.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> che specifica l'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> da ricercare. Qualsiasi diritto specificato da questa regola viene ignorato.</param>
        <summary>Cerca tutte le regole di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola specificata e, se trovate, le rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> viene eseguita la ricerca per le regole che presentano lo stesso utente e lo stesso <xref:System.Security.AccessControl.AccessControlType> valore come `rule`. Qualsiasi diritto specificato da `rule` vengono ignorati quando si esegue la ricerca. Tutte le regole corrispondenti vengono rimossi. Se non è stata trovata alcuna regola corrispondente, viene eseguita alcuna azione.  
  
   
  
## Examples  
 Esempio di codice seguente mostra che il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll%2A> metodo rimuove tutte le regole che corrispondono a utente e <xref:System.Security.AccessControl.AccessControlType>, ignorando i diritti.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto, vengono aggiunte regole che concedono e negano diversi diritti per l'utente corrente e quindi unisce diritti aggiuntivi nel <xref:System.Security.AccessControl.AccessControlType.Allow> regola. Nell'esempio viene quindi creata una nuova regola che consente all'utente di assumere la proprietà corrente e tale regola viene utilizzata per rimuovere il <xref:System.Security.AccessControl.AccessControlType.Allow> regola dal <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> da rimuovere.</param>
        <summary>Cerca una regola di controllo di accesso che corrisponde esattamente alla regola specificata e, se trovata, la rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regola viene rimosso solo se corrisponde esattamente a `rule` in tutti i dettagli, compresi i flag. Le altre regole con lo stesso utente e <xref:System.Security.AccessControl.AccessControlType> non sono interessate.  
  
> [!IMPORTANT]
>  Una regola rappresenta uno o più voci di controllo di accesso (ACE) sottostanti e tali voci vengono suddivise o combinate necessarie quando si modificano le regole di sicurezza di accesso per un utente. Di conseguenza, una regola potrebbe non esistere più nel formato che aveva al momento dell'aggiunta e in tal caso il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> (metodo) non è possibile rimuoverlo.  
  
   
  
## Examples  
 Esempio di codice seguente mostra che il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> metodo richiede una corrispondenza esatta per rimuovere una regola, e che le regole per consentire e negare i diritti sono indipendenti tra loro.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto, vengono aggiunte regole che concedono e negano diversi diritti per l'utente corrente e quindi unisce diritti aggiuntivi nel <xref:System.Security.AccessControl.AccessControlType.Allow> regola di accesso. Nell'esempio viene quindi passato originale <xref:System.Security.AccessControl.AccessControlType.Allow> regola per il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> metodo e consente di visualizzare i risultati, che mostra che non viene eliminato. L'esempio crea quindi una regola che corrisponde il <xref:System.Security.AccessControl.AccessControlType.Allow> regola nel <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto e, completato, viene utilizzato il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> metodo per rimuovere la regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As EventWaitHandleAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> che specifica l'utente da ricercare e un insieme di flag di ereditarietà e propagazione con cui deve essere compatibile una regola corrispondente, se trovata. Specifica i diritti da rimuovere dalla regola compatibile, se trovati.</param>
        <summary>Cerca una regola di controllo con lo stesso utente della regola specificata e con i flag di ereditarietà e propagazione compatibili. Se viene trovata una regola simile, i diritti contenuti nella regola specificata vengono rimossi da essa.</summary>
        <returns>
          <see langword="true" /> se viene trovata una regola compatibile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> viene cercata una regola di controllo con lo stesso utente `rule`. Se non viene trovata alcuna tale regola viene eseguita alcuna azione e il metodo restituisce `false`. Se vengono rilevate le regole di corrispondenza, ereditarietà e compatibilità vengono controllati per garantire la compatibilità con i flag specificati in `rule`. Se viene trovata alcuna regola compatibile, viene eseguita alcuna azione e il metodo restituisce `false`. Se viene trovata una regola con flag compatibili, i diritti specificati `rule` vengono rimossi dalla regola compatibile, e il metodo restituisce `true`. Se `rule` specifica i diritti non contenuti nella regola compatibile, viene eseguita alcuna azione relativamente a tali diritti. Se tutti i diritti vengono rimossi dalla regola compatibile, l'intera regola viene rimosso dall'oggetto corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto.  
  
> [!IMPORTANT]
>  Sebbene sia possibile specificare flag di ereditarietà e propagazione per le regole di controllo degli eventi creandoli con il <xref:System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleFactory%2A> (metodo), questa operazione è sconsigliata. Ereditarietà e propagazione non hanno alcun significato per eventi denominati e rendono più complessa la gestione delle regole di controllo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRuleAll(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> che specifica l'utente da ricercare. Qualsiasi diritto specificato da questa regola viene ignorato.</param>
        <summary>Cerca tutte le regole di controllo in cui l'utente sia identico a quello della regola specificata e rimuove le regole trovate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> viene eseguita la ricerca per le regole di controllo con lo stesso utente `rule`. Qualsiasi diritto specificato da `rule` vengono ignorati quando si esegue la ricerca. Tutte le regole corrispondenti vengono rimossi. Se non è stata trovata alcuna regola corrispondente, viene eseguita alcuna azione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> da rimuovere.</param>
        <summary>Cerca una regola di controllo che corrisponde esattamente alla regola specificata e, se trovata, la rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regola viene rimosso solo se corrisponde esattamente a `rule` in tutti i dettagli, compresi i flag. Altre regole di controllo per lo stesso utente non sono interessate.  
  
> [!IMPORTANT]
>  Una regola rappresenta uno o più voci di controllo di accesso (ACE) sottostanti e tali voci vengono suddivise o combinate necessarie quando si modificano le regole di sicurezza di controllo per un utente. Di conseguenza, una regola potrebbe non esistere più nel formato che aveva al momento dell'aggiunta e in tal caso il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRuleSpecific%2A> (metodo) non è possibile rimuoverlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> da aggiungere. L'utente specificato dalla regola determina le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo di accesso con lo stesso utente della regola specificata, a prescindere dalla classe <see cref="T:System.Security.AccessControl.AccessControlType" />, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti regole di accesso il cui utente corrisponde a quello della regola specificata, `rule` viene aggiunto.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come la <xref:System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule%2A> metodo sostituisce tutte le regole per l'utente corrispondente con la regola specificata per la corrispondenza.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> dell'oggetto e aggiunge le regole che concedono e negano diversi diritti per l'utente corrente. Nell'esempio viene quindi creata una nuova regola che consente il controllo completo all'utente corrente e viene utilizzato il <xref:System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule%2A> metodo per sostituire le regole esistenti con la nuova regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> da aggiungere. L'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> della regola determinano le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola specificata, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la regola specificata è <xref:System.Security.AccessControl.AccessControlType.Allow>, l'effetto di questo metodo consiste nel rimuovere tutti <xref:System.Security.AccessControl.AccessControlType.Allow> regole per l'utente specificato, sostituirli con la regola specificata. Se la regola specificata è <xref:System.Security.AccessControl.AccessControlType.Deny>tutti <xref:System.Security.AccessControl.AccessControlType.Deny> vengono sostituite le regole per l'utente specificato con la regola specificata.  
  
 Se non esistono regole il cui utente e <xref:System.Security.AccessControl.AccessControlType> corrispondono alla regola specificata, `rule` viene aggiunto.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come la <xref:System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule%2A> metodo rimuove tutte le regole che corrispondono all'utente e la <xref:System.Security.AccessControl.AccessControlType> di `rule`, sostituirli con `rule`.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> dell'oggetto e aggiunge le regole che concedono e negano diversi diritti per l'utente corrente. Nell'esempio viene quindi creata una nuova regola che consente il controllo completo all'utente corrente e viene utilizzato il <xref:System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule%2A> metodo sostituire <xref:System.Security.AccessControl.AccessControlType.Allow> regola con la nuova regola. La regola che nega l'accesso non è stata interessata.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.SetAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> da aggiungere. L'utente specificato dalla regola determina le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo con lo stesso utente della regola specificata, a prescindere dal valore di <see cref="T:System.Security.AccessControl.AuditFlags" />, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti regole di controllo il cui utente corrisponde a quello della regola specificata, `rule` viene aggiunto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>