<Type Name="EventWaitHandleSecurity" FullName="System.Security.AccessControl.EventWaitHandleSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c67d45ebdb8737154529777f52874349f3035c48" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39955084" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class EventWaitHandleSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit EventWaitHandleSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.EventWaitHandleSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EventWaitHandleSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandleSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type EventWaitHandleSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta la sicurezza del controllo di accesso di Windows applicata a un handle di attesa del sistema denominato. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto specifica l'accesso i diritti per l'handle di attesa di un sistema denominato e specifica anche il modo in cui vengono controllati i tentativi di accesso. Diritti di accesso per l'handle di attesa sono espressi come regole, con ogni regola di accesso rappresentato da un <xref:System.Security.AccessControl.EventWaitHandleAccessRule> oggetto. Ogni regola di controllo è rappresentato da un <xref:System.Security.AccessControl.EventWaitHandleAuditRule> oggetto.  
  
 Questa situazione rispecchia il sistema di sicurezza di Windows sottostante, in cui ogni oggetto a protezione diretta è al massimo un accesso discrezionale controllo elenco (DACL) che controlla l'accesso per l'oggetto protetto e al massimo un accesso elenco di controllo sistema (SACL) che specifica che l'accesso vengono controllati i tentativi. Gli elenchi DACL e un SACL vengono ordinati gli elenchi di voci di controllo di accesso (ACE) che specificano l'accesso e controllo per gli utenti e gruppi. Un' <xref:System.Security.AccessControl.EventWaitHandleAccessRule> o <xref:System.Security.AccessControl.EventWaitHandleAuditRule> oggetto può rappresentare più di una voce ACE.  
  
> [!NOTE]
>  Un <xref:System.Threading.EventWaitHandle> oggetto può rappresentare un handle di attesa locale o handle di attesa di un sistema denominato. Controllo di accesso di Windows è significativo solo per gli handle di attesa di sistema denominato.  
  
 Il <xref:System.Security.AccessControl.EventWaitHandleSecurity>, <xref:System.Security.AccessControl.EventWaitHandleAccessRule>, e <xref:System.Security.AccessControl.EventWaitHandleAuditRule> classi nascondono i dettagli di implementazione degli elenchi ACL e le voci ACE. Consentono di ignorare i diversi tipi di voce ACE diciassette e la complessità della gestione corretta di ereditarietà e propagazione di diritti di accesso. Questi oggetti sono progettati anche per evitare gli errori di controllo accesso comuni seguenti:  
  
-   Creazione di un descrittore di sicurezza con un elenco DACL. Un riferimento null a un DACL consente agli utenti di aggiungere le regole di accesso a un oggetto, potenzialmente la creazione di un attacco denial of service. Un nuovo <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto inizia sempre con un DACL vuoto, che nega tutti gli accessi per tutti gli utenti.  
  
-   Violazione dell'ordine canonico delle voci ACE. Se l'elenco di voci ACE nell'elenco DACL non viene mantenuto nell'ordine canonico, potrebbe essere involontariamente concesso l'accesso all'oggetto protetto. Ad esempio, i diritti di accesso negato devono essere sempre visualizzate prima dei diritti di accesso consentito. <xref:System.Security.AccessControl.EventWaitHandleSecurity> gli oggetti mantengono internamente l'ordine corretto.  
  
-   Modifica flag del descrittore di sicurezza, che deve essere eseguita solo il controllo di gestione risorse.  
  
-   Creazione di combinazioni di flag ACE non valide.  
  
-   Modifica di voci ACE ereditate. Ereditarietà e propagazione vengono gestite da Gestione risorse, in risposta alle modifiche apportate alle regole di accesso e controllo.  
  
-   Inserimento di voci ACE privo di significato in ACL.  
  
 Le uniche funzionalità non supportate dagli oggetti di sicurezza di .NET sono attività pericolosa che sarebbe opportuno evitare per la maggior parte degli sviluppatori di applicazioni, ad esempio:  
  
-   Attività di basso livello che vengono normalmente eseguite da Gestione risorse.  
  
-   Aggiunta o rimozione di voci di controllo di accesso in modi che non mantengono l'ordinamento di canonico.  
  
 Per la modifica del controllo di accesso di Windows per un handle di attesa denominati, usare il <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> metodo per ottenere il <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto. Modificare l'oggetto di sicurezza aggiungendo e rimuovendo le regole e quindi usare il <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType> metodo per collegarlo.  
  
> [!IMPORTANT]
>  Le modifiche apportate a un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto non influiscono sui livelli di accesso dell'handle di attesa denominati finché non si chiama il <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType> metodo a cui assegnare l'oggetto di sicurezza modificato per l'handle di attesa denominati.  
  
 Per copiare del controllo di accesso da un handle di attesa in un altro, usare il <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> metodo per ottenere un <xref:System.Security.AccessControl.EventWaitHandleSecurity> che rappresenta le regole di accesso e controllo per l'handle di attesa prima dell'oggetto e quindi usare il <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType> metodo o un costruttore che accetta un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto, assegnare le regole per l'handle di attesa secondo.  
  
 Gli utenti con un investimento in sicurezza descriptor definition language (SDDL) possono usare la <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> per impostare le regole di accesso per un handle di attesa denominati e il <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metodo per ottenere una stringa che rappresenta le regole di accesso nel formato SDDL. Questa operazione è sconsigliata per i nuovi sviluppi.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra la separazione tra <xref:System.Security.AccessControl.AccessControlType.Allow> regole e <xref:System.Security.AccessControl.AccessControlType.Deny> regole e Visualizza la combinazione di diritti regole compatibili. Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> , vengono aggiunti regole per consentano e negano diritti diversi per l'utente corrente e Visualizza la coppia di regole risultante. Nell'esempio viene quindi consente nuovi diritti per l'utente corrente e visualizza il risultato, che mostra che i nuovi diritti vengono uniti con l'oggetto esistente <xref:System.Security.AccessControl.AccessControlType.Allow> regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" />
    <altmember cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" />
    <altmember cref="T:System.Security.AccessControl.EventWaitHandleRights" />
    <altmember cref="M:System.Threading.EventWaitHandle.GetAccessControl" />
    <altmember cref="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandleSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandleSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> con i valori predefiniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nuovo <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto inizia sempre con un elenco vuoto di accesso discrezionale (DACL), che nega tutti gli accessi per tutti gli utenti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Questa classe non è supportata in Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.EventWaitHandleSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.EventWaitHandleSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo di enumerazione utilizzato dalla classe <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> per rappresentare i diritti di accesso.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta l'enumerazione <see cref="T:System.Security.AccessControl.EventWaitHandleRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe override la <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> proprietà e restituire il tipo utilizzato per rappresentare i diritti di accesso. Quando si lavora con le matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile usare questa proprietà per determinare il tipo di enumerazione corretto da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="eventWaitHandleSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Classe <see cref="T:System.Security.Principal.IdentityReference" /> che identifica l'utente o il gruppo a cui viene applicata la regola.</param>
        <param name="accessMask">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.EventWaitHandleRights" /> che specificano i diritti di accesso da concedere o negare, per effettuare il cast in un intero.</param>
        <param name="isInherited">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="inheritanceFlags">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="propagationFlags">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Security.AccessControl.AccessControlType" /> che specificano se i diritti sono concessi o negati.</param>
        <summary>Crea una nuova regola di controllo di accesso per l'utente specificato, con i diritti di accesso, il controllo di accesso e i flag specificati.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> che rappresenta i diritti specificati per l'utente specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo consigliato per creare le regole di controllo di accesso consiste nell'utilizzare i costruttori del <xref:System.Security.AccessControl.EventWaitHandleAccessRule> classe.  
  
> [!NOTE]
>  Anche se i flag di ereditarietà e propagazione sono significativi per gli eventi denominati, è comunque possibile specificarli. Ciò non è consigliabile, perché inutilmente complica la gestione delle regole, ad esempio tramite interferenza con la combinazione di regole che altrimenti sarebbero compatibili.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="type" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> è <see langword="null" />.  
  
oppure 
 <paramref name="accessMask" /> è zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> non è di tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> né di un tipo quale <see cref="T:System.Security.Principal.NTAccount" /> convertibile nel tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo utilizzato dalla classe <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> per rappresentare le regole di accesso.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta la classe <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe override la <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> proprietà e restituire il tipo utilizzato per rappresentare le regole di accesso. Quando si lavora con le matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile usare questa proprietà per determinare il tipo di regola di accesso corretti da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAccessRule : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; unit" Usage="eventWaitHandleSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Regola di controllo di accesso da aggiungere.</param>
        <summary>Cerca una regola di controllo di accesso corrispondente a cui è possibile unire la nuova regola. Se non viene trovata alcuna regola, viene aggiunta la nuova regola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule%2A> metodo cerca le regole con lo stesso utente o gruppo e lo stesso <xref:System.Security.AccessControl.AccessControlType> come `rule`. Se non vengono rilevate, `rule` viene aggiunto. Se viene trovata una regola corrisponda, i diritti in `rule` vengono unite con la regola esistente.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra la separazione tra <xref:System.Security.AccessControl.AccessControlType.Allow> regole e <xref:System.Security.AccessControl.AccessControlType.Deny> regole e Visualizza la combinazione di diritti regole compatibili. Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> , vengono aggiunti regole per consentano e negano diritti diversi per l'utente corrente e Visualizza la coppia di regole risultante. Nell'esempio viene quindi consente nuovi diritti per l'utente corrente e visualizza il risultato, che mostra che i nuovi diritti vengono uniti con l'oggetto esistente <xref:System.Security.AccessControl.AccessControlType.Allow> regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AddAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAuditRule : System.Security.AccessControl.EventWaitHandleAuditRule -&gt; unit" Usage="eventWaitHandleSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Regola di controllo da aggiungere. L'utente specificato dalla regola determina la ricerca.</param>
        <summary>Cerca una regola di controllo a cui è possibile unire la nuova regola. Se non viene trovata alcuna regola, viene aggiunta la nuova regola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.AccessControl.EventWaitHandleSecurity.AddAuditRule%2A> il metodo di ricerca per le regole con lo stesso utente o gruppo come `rule`. Se non vengono rilevate, `rule` viene aggiunto. Se viene trovata una regola corrisponda, il flag in `rule` vengono unite alla regola esistente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="eventWaitHandleSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Classe <see cref="T:System.Security.Principal.IdentityReference" /> che identifica l'utente o il gruppo a cui viene applicata la regola.</param>
        <param name="accessMask">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.EventWaitHandleRights" /> che specificano i diritti di accesso da controllare, per effettuare il cast in un intero.</param>
        <param name="isInherited">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="inheritanceFlags">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="propagationFlags">Non significativo per gli handle di attesa denominati, perché non hanno gerarchia.</param>
        <param name="flags">Combinazione bit per bit di valori <see cref="T:System.Security.AccessControl.AuditFlags" /> che specificano se controllare l'accesso riuscito, l'accesso non riuscito o entrambi.</param>
        <summary>Crea una nuova regola di controllo che specifica l'utente a cui viene applicata la regola, i diritti di accesso da controllare e il risultato che attiva la regola di controllo.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> che rappresenta la regola di controllo specificata per l'utente specificato. Il tipo restituito del metodo è la classe base, <see cref="T:System.Security.AccessControl.AuditRule" />, ma è possibile effettuare in maniera sicura il cast del valore restituito nella classe derivata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo consigliato per creare le regole di controllo è usare i costruttori del <xref:System.Security.AccessControl.EventWaitHandleAuditRule> classe.  
  
> [!NOTE]
>  Anche se i flag di ereditarietà e propagazione sono significativi per gli eventi denominati, è comunque possibile specificarli. Ciò non è consigliabile, perché inutilmente complica la gestione delle regole, ad esempio tramite interferenza con la combinazione di regole che altrimenti sarebbero compatibili.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="flags" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> è <see langword="null" />.  
  
oppure 
 <paramref name="accessMask" /> è zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> non è di tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> né di un tipo quale <see cref="T:System.Security.Principal.NTAccount" /> convertibile nel tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo utilizzato dalla classe <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> per rappresentare le regole di controllo.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta la classe <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che derivano dal <xref:System.Security.AccessControl.ObjectSecurity> classe override la <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> proprietà e restituire il tipo utilizzato per rappresentare i diritti di controllo. Quando si lavora con le matrici o raccolte che contengono più tipi di oggetti di sicurezza, è possibile usare questa proprietà per determinare il tipo di regola di controllo corretti da utilizzare con ogni oggetto di sicurezza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As EventWaitHandleAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRule : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; bool" Usage="eventWaitHandleSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> che specifica l'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> da ricercare, nonché un insieme di flag di ereditarietà e propagazione con cui deve essere compatibile una regola corrispondente, se trovata. Specifica i diritti da rimuovere dalla regola compatibile, se trovati.</param>
        <summary>Cerca una regola di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola di accesso specificata e con i flag di ereditarietà e propagazione compatibili. Se viene trovata una regola simile, i diritti contenuti nella regola di accesso specificata vengono rimossi da essa.</summary>
        <returns>
          <see langword="true" /> se viene trovata una regola compatibile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> viene eseguita la ricerca per una regola con lo stesso utente e lo stesso <xref:System.Security.AccessControl.AccessControlType> valore `rule`. Se non viene trovata alcuna regola simile, viene eseguita alcuna azione e il metodo restituisce `false`. Se vengono trovate le regole di corrispondenza, vengono controllati i flag di ereditarietà e compatibilità per garantire la compatibilità con i flag specificati nella `rule`. Se viene trovata alcuna regola compatibile, viene eseguita alcuna azione e il metodo restituisce `false`. Se viene trovata una regola con flag compatibili, i diritti specificati nel `rule` vengono rimosse dalla regola compatibile, e il metodo restituisce `true`. Se `rule` specifica i diritti non contenuti nella regola compatibile, viene eseguita alcuna azione rispetto a tali diritti. Se tutti i diritti vengono rimossi dalla regola compatibile, l'intera regola viene rimosso dall'insieme corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto.  
  
> [!IMPORTANT]
>  Sebbene sia possibile specificare i flag di ereditarietà e propagazione per le regole di accesso eventi, creando con il <xref:System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleFactory%2A> metodo, non è consigliato. Ereditarietà e propagazione non hanno alcun significato per gli eventi denominati e rendono più complessa la gestione delle regole di accesso.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule%2A> metodo per rimuovere diritti da un' <xref:System.Security.AccessControl.AccessControlType.Allow> regola in un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto. Indica inoltre che gli altri diritti in `rule` vengono ignorati.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> dell'oggetto e aggiunge le regole che consentono la negano di diritti diversi per l'utente corrente. I diritti concessi sono <xref:System.Security.AccessControl.EventWaitHandleRights.Modify>, <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions>, e <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize>. L'esempio crea quindi una nuova regola per l'utente corrente, inclusi <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions> e <xref:System.Security.AccessControl.EventWaitHandleRights.TakeOwnership> diritti e utilizza tale regola con la <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule%2A> metodo per rimuovere <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions> dal <xref:System.Security.AccessControl.AccessControlType.Allow> regola nel <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto. Il <xref:System.Security.AccessControl.EventWaitHandleRights.TakeOwnership> a destra nel `rule` viene ignorato.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleAll : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; unit" Usage="eventWaitHandleSecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> che specifica l'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> da ricercare. Qualsiasi diritto specificato da questa regola viene ignorato.</param>
        <summary>Cerca tutte le regole di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola specificata e, se trovate, le rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> viene eseguita la ricerca per le regole che hanno lo stesso nome utente e lo stesso <xref:System.Security.AccessControl.AccessControlType> valore `rule`. Qualsiasi diritto specificato da `rule` vengono ignorati quando si esegue la ricerca. Vengono rimosse tutte le regole di corrispondenza. Se non è stata trovata alcuna corrispondenza alle regole, viene eseguita alcuna azione.  
  
   
  
## Examples  
 Esempio di codice seguente mostra che il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll%2A> metodo rimuove tutte le regole che corrispondono a utente e <xref:System.Security.AccessControl.AccessControlType>, ignorando i diritti.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> , vengono aggiunti regole per consentano e negano diritti diversi per l'utente corrente e quindi unisce i diritti aggiuntivi nel <xref:System.Security.AccessControl.AccessControlType.Allow> regola. L'esempio crea quindi una nuova regola che consente all'utente corrente acquisire la proprietà e tale regola viene utilizzata per rimuovere il <xref:System.Security.AccessControl.AccessControlType.Allow> regola dal <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleSpecific : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; unit" Usage="eventWaitHandleSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> da rimuovere.</param>
        <summary>Cerca una regola di controllo di accesso che corrisponde esattamente alla regola specificata e, se trovata, la rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regola viene rimosso solo se corrisponde esattamente a `rule` in tutti i dettagli, ad esempio i flag. Altre regole con lo stesso utente e <xref:System.Security.AccessControl.AccessControlType> rimangono invariate.  
  
> [!IMPORTANT]
>  Una regola rappresenta uno o più voci di controllo di accesso (ACE) sottostante e queste voci sono suddivise o combinate, se necessario, quando si modificano le regole di sicurezza di accesso per un utente. Di conseguenza, una regola non esiste più nel formato specifico si trovava al momento è stato aggiunto e in tal caso il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> (metodo) non è possibile rimuoverlo.  
  
   
  
## Examples  
 Esempio di codice seguente mostra che il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> metodo richiede una corrispondenza esatta per rimuovere una regola e che le regole per consentire o negare i diritti sono indipendenti tra loro.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> , vengono aggiunti regole per consentano e negano diritti diversi per l'utente corrente e quindi unisce i diritti aggiuntivi nel <xref:System.Security.AccessControl.AccessControlType.Allow> regola di accesso. Viene quindi passato originale <xref:System.Security.AccessControl.AccessControlType.Allow> regola per il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> metodo e consente di visualizzare i risultati, mostrando che nulla venga eliminato. L'esempio genera quindi una regola che corrisponde il <xref:System.Security.AccessControl.AccessControlType.Allow> regola nel <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto e, correttamente, viene utilizzato il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> metodo per rimuovere la regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As EventWaitHandleAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRule : System.Security.AccessControl.EventWaitHandleAuditRule -&gt; bool" Usage="eventWaitHandleSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> che specifica l'utente da ricercare e un insieme di flag di ereditarietà e propagazione con cui deve essere compatibile una regola corrispondente, se trovata. Specifica i diritti da rimuovere dalla regola compatibile, se trovati.</param>
        <summary>Cerca una regola di controllo con lo stesso utente della regola specificata e con i flag di ereditarietà e propagazione compatibili. Se viene trovata una regola simile, i diritti contenuti nella regola specificata vengono rimossi da essa.</summary>
        <returns>
          <see langword="true" /> se viene trovata una regola compatibile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> viene eseguita la ricerca per una regola di controllo che ha lo stesso utente `rule`. Se non viene trovata alcuna regola simile, viene eseguita alcuna azione e il metodo restituisce `false`. Se vengono trovate le regole di corrispondenza, vengono controllati i flag di ereditarietà e compatibilità per garantire la compatibilità con i flag specificati nella `rule`. Se viene trovata alcuna regola compatibile, viene eseguita alcuna azione e il metodo restituisce `false`. Se viene trovata una regola con flag compatibili, i diritti specificati nel `rule` vengono rimosse dalla regola compatibile, e il metodo restituisce `true`. Se `rule` specifica i diritti non contenuti nella regola compatibile, viene eseguita alcuna azione rispetto a tali diritti. Se tutti i diritti vengono rimossi dalla regola compatibile, l'intera regola viene rimosso dall'insieme corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto.  
  
> [!IMPORTANT]
>  Sebbene sia possibile specificare i flag di ereditarietà e propagazione per le regole di controllo degli eventi tramite la creazione con il <xref:System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleFactory%2A> metodo, non è consigliato. Ereditarietà e propagazione non hanno alcun significato per gli eventi denominati e rendono più complessa la gestione delle regole di controllo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRuleAll(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleAll : System.Security.AccessControl.EventWaitHandleAuditRule -&gt; unit" Usage="eventWaitHandleSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Classe <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> che specifica l'utente da ricercare. Qualsiasi diritto specificato da questa regola viene ignorato.</param>
        <summary>Cerca tutte le regole di controllo in cui l'utente sia identico a quello della regola specificata e rimuove le regole trovate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto corrente <xref:System.Security.AccessControl.EventWaitHandleSecurity> viene eseguita la ricerca per le regole di controllo contenenti lo stesso utente `rule`. Qualsiasi diritto specificato da `rule` vengono ignorati quando si esegue la ricerca. Vengono rimosse tutte le regole di corrispondenza. Se non è stata trovata alcuna corrispondenza alle regole, viene eseguita alcuna azione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleSpecific : System.Security.AccessControl.EventWaitHandleAuditRule -&gt; unit" Usage="eventWaitHandleSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> da rimuovere.</param>
        <summary>Cerca una regola di controllo che corrisponde esattamente alla regola specificata e, se trovata, la rimuove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regola viene rimosso solo se corrisponde esattamente a `rule` in tutti i dettagli, ad esempio i flag. Altre regole di controllo per lo stesso utente non sono interessate.  
  
> [!IMPORTANT]
>  Una regola rappresenta uno o più voci di controllo di accesso (ACE) sottostante e queste voci sono suddivise o combinate, se necessario, quando si modificano le regole di sicurezza di controllo per un utente. Di conseguenza, una regola non esiste più nel formato specifico si trovava al momento è stato aggiunto e in tal caso il <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRuleSpecific%2A> (metodo) non è possibile rimuoverlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.ResetAccessRule : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; unit" Usage="eventWaitHandleSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> da aggiungere. L'utente specificato dalla regola determina le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo di accesso con lo stesso utente della regola specificata, a prescindere dalla classe <see cref="T:System.Security.AccessControl.AccessControlType" />, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti regole di accesso della regola specificata, corrisponde a cui utente `rule` viene aggiunto.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come il <xref:System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule%2A> metodo sostituisce tutte le regole per l'utente corrispondente con la regola specificata per la corrispondenza.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> dell'oggetto e aggiunge le regole che consentono la negano di diritti diversi per l'utente corrente. L'esempio crea quindi una nuova regola che consente il controllo completo all'utente corrente e Usa il <xref:System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule%2A> metodo sostituire entrambe le regole esistenti con la nuova regola.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAccessRule : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; unit" Usage="eventWaitHandleSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> da aggiungere. L'utente e la classe <see cref="T:System.Security.AccessControl.AccessControlType" /> della regola determinano le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo di accesso con lo stesso utente e la stessa classe <see cref="T:System.Security.AccessControl.AccessControlType" /> (consenso o negazione) della regola specificata, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la regola specificata dispone <xref:System.Security.AccessControl.AccessControlType.Allow>, l'effetto di questo metodo consiste nel rimuovere tutto <xref:System.Security.AccessControl.AccessControlType.Allow> regole per l'utente specificato, sostituirli con la regola specificata. Se la regola specificata dispone <xref:System.Security.AccessControl.AccessControlType.Deny>, tutti i <xref:System.Security.AccessControl.AccessControlType.Deny> regole per l'utente specificato vengono sostituite con la regola specificata.  
  
 Se non sono presenti regole il cui utente e <xref:System.Security.AccessControl.AccessControlType> corrispondono alla regola specificata, `rule` viene aggiunto.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come la <xref:System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule%2A> metodo rimuove tutte le regole che corrispondono all'utente e il <xref:System.Security.AccessControl.AccessControlType> dei `rule`, sostituirli con `rule`.  
  
 Nell'esempio viene creato un <xref:System.Security.AccessControl.EventWaitHandleSecurity> dell'oggetto e aggiunge le regole che consentono la negano di diritti diversi per l'utente corrente. L'esempio crea quindi una nuova regola che consente il controllo completo all'utente corrente e Usa il <xref:System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule%2A> metodo per sostituire il <xref:System.Security.AccessControl.AccessControlType.Allow> regola con la nuova regola. La regola che neghi l'accesso non è interessata.  
  
> [!NOTE]
>  Questo esempio non viene associato l'oggetto di sicurezza per un <xref:System.Threading.EventWaitHandle> oggetto. Esempi di associazione di oggetti di sicurezza possono essere individuati <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.SetAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAuditRule : System.Security.AccessControl.EventWaitHandleAuditRule -&gt; unit" Usage="eventWaitHandleSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> da aggiungere. L'utente specificato dalla regola determina le regole da rimuovere prima di aggiungere questa regola.</param>
        <summary>Rimuove tutte le regole di controllo con lo stesso utente della regola specificata, a prescindere dal valore di <see cref="T:System.Security.AccessControl.AuditFlags" />, quindi aggiunge la regola specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non sono presenti regole di controllo il cui utente corrispondente alla regola specificata, `rule` viene aggiunto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>