<Type Name="BlockingCollection&lt;T&gt;" FullName="System.Collections.Concurrent.BlockingCollection&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="aafb963db3ad1d2c7bc939adda5b3530efaeedd7" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51307999" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BlockingCollection&lt;T&gt; : IDisposable, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BlockingCollection`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.BlockingCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public Class BlockingCollection(Of T)&#xA;Implements ICollection, IDisposable, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class BlockingCollection : IDisposable, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BlockingCollection&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IDisposable&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}, Type = {m_collection}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Tipo di elementi contenuti nella raccolta.</typeparam>
    <summary>Fornisce funzionalità di blocco e limitazione per le raccolte thread-safe che implementano <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Concurrent.BlockingCollection%601> è una classe di raccolta thread-safe che offre quanto segue:  
  
-   Un'implementazione del modello produttore/consumer; <xref:System.Collections.Concurrent.BlockingCollection%601> è un wrapper per il <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interfaccia.  
  
-   Simultanea aggiunta e rimozione di elementi da più thread con il <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> e <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> metodi.  
  
-   Una raccolta limitata che consente di bloccare <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> e <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> operazioni quando la raccolta è full o empty.  
  
-   Annullamento del <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> o <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> operazioni con un <xref:System.Threading.CancellationToken> dell'oggetto nel <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> o <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> (metodo).  
  
> [!IMPORTANT]
>  Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare il tipo direttamente, chiamare relativi <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia. Si noti inoltre che il <xref:System.Collections.Concurrent.BlockingCollection%601.Dispose> (metodo) non è thread-safe. Tutti gli altri membri pubblici e protetti della <xref:System.Collections.Concurrent.BlockingCollection%601> sono thread-safe e possono essere utilizzati contemporaneamente da più thread.  
  
 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> rappresenta una raccolta che consente di aggiungere thread-safe e rimozione dei dati. <xref:System.Collections.Concurrent.BlockingCollection%601> viene usata come wrapper per un <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> dell'istanza e consente tentativi di rimozione dalla raccolta bloccare fino a quando non sono disponibili dati per essere rimosso. Analogamente, è possibile creare un <xref:System.Collections.Concurrent.BlockingCollection%601> per imporre un limite massimo per il numero di elementi di dati consentiti nella <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>; i tentativi di aggiunta alla raccolta possono quindi si bloccano fino a quando non è disponibile spazio per archiviare gli elementi aggiunti. In questo modo <xref:System.Collections.Concurrent.BlockingCollection%601> è simile a una struttura dei dati di coda di blocco tradizionali, ad eccezione del fatto che il meccanismo di archiviazione dati sottostante è astratta come un <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601> supporta delimitazione e blocco. Rettangolo di selezione significa che è possibile impostare la capacità massima della raccolta. Delimitazione è importante in determinati scenari poiché consente di controllare la dimensione massima della raccolta in memoria e impedisce il thread producer di spostarsi troppo oltre i thread consumer. Più thread o attività possono aggiungere contemporaneamente elementi alla raccolta e se la raccolta raggiunge la capacità massima specificata, il thread producer si bloccano fino a quando non viene rimosso un elemento. Più Consumer possono rimuovere contemporaneamente elementi e quando la raccolta diventa vuota, i thread Consumer si bloccano fino a quando un Producer aggiunge un elemento. Un thread producer può chiamare il <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> metodo per indicare che nessun ulteriore elemento verrà aggiunto. I Consumer monitorano la proprietà <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> per sapere quando la raccolta è vuota e non verranno aggiunti altri elementi.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> e <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> operazioni vengono in genere eseguite in un ciclo. È possibile annullare un ciclo passando un <xref:System.Threading.CancellationToken> dell'oggetto per il <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> oppure <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> (metodo) e quindi controllando il valore del token di <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> proprietà a ogni iterazione. Se il valore è `true`, è responsabilità dell'utente per rispondere alla richiesta di annullamento cancellando tutte le risorse e uscendo dal ciclo.  
  
 Quando si crea un <xref:System.Collections.Concurrent.BlockingCollection%601> oggetto, è possibile specificare non solo la capacità delimitata ma anche il tipo di raccolta da usare. Ad esempio, è possibile specificare un oggetto <xref:System.Collections.Concurrent.ConcurrentQueue%601> per il comportamento FIFO (First In, First Out) o un oggetto <xref:System.Collections.Concurrent.ConcurrentStack%601> per il comportamento LIFO (Last In, First Out). È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Il tipo di raccolta predefinito per <xref:System.Collections.Concurrent.BlockingCollection%601> è <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 Non modificare direttamente la raccolta sottostante. Usare <xref:System.Collections.Concurrent.BlockingCollection%601> metodi per aggiungere o rimuovere elementi. Il <xref:System.Collections.Concurrent.BlockingCollection%601> oggetto può risultare danneggiato se si modifica direttamente la raccolta sottostante.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere e rimuovere elementi contemporaneamente da una raccolta di blocco:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#1)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Il metodo Dispose non è thread-safe. Tutti gli altri membri pubblici e protetti della <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sono thread-safe e possono essere utilizzati contemporaneamente da più thread.</threadsafe>
    <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
    <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
    <related type="Article" href="http://msdn.microsoft.com/library/4c2492de-3876-4873-b5a1-000bb404d770">Procedura: aggiunta di delimitazione e blocco di funzionalità a una classe di raccolta</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> senza un limite superiore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> senza un limite superiore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'impostazione predefinita insieme sottostante è un <xref:System.Collections.Concurrent.ConcurrentQueue%601> oggetto, che fornisce innanzitutto in, first-out (FIFO) comportamento.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Raccolta da usare come archivio dati sottostante.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> senza un limite superiore e usando l'oggetto <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> fornito come archivio dati sottostante.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collection" /> è Null.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; boundedCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="boundedCapacity">Dimensione delimitata della raccolta.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> con il limite superiore specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'impostazione predefinita insieme sottostante è un <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="boundedCapacity" /> non è un valore positivo.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection, int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection, int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T), boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection, int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; * int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; (collection, boundedCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collection">Raccolta da usare come archivio dati sottostante.</param>
        <param name="boundedCapacity">Dimensione delimitata della raccolta.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> con il limite superiore specificato e usando l'oggetto <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> fornito come archivio dati sottostante.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collection" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="boundedCapacity" /> non è un valore positivo.</exception>
        <exception cref="T:System.ArgumentException">L'elemento <paramref name="collection" /> contiene più valori rispetto a quelli consentiti da <paramref name="boundedCapacity" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge l'elemento all'oggetto <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T -&gt; unit" Usage="blockingCollection.Add item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da aggiungere alla raccolta. Il valore può essere un riferimento Null.</param>
        <summary>Aggiunge l'elemento all'oggetto <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è stata specificata una capacità delimitata quando questa istanza di <xref:System.Collections.Concurrent.BlockingCollection%601> è stata inizializzata, una chiamata al metodo Add potrebbe bloccare fino a quando non è disponibile spazio per archiviare l'elemento fornito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato contrassegnato come completo in relazione alle aggiunte.  
  
oppure 
La raccolta sottostante non ha accettato l'elemento.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T * System.Threading.CancellationToken -&gt; unit" Usage="blockingCollection.Add (item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da aggiungere alla raccolta. Il valore può essere un riferimento Null.</param>
        <param name="cancellationToken">Token di annullamento da osservare.</param>
        <summary>Aggiunge l'elemento all'oggetto <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è stata specificata una capacità delimitata quando questa istanza di <xref:System.Collections.Concurrent.BlockingCollection%601> è stata inizializzata, una chiamata a <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> potrebbe bloccare fino a quando non è disponibile spazio per archiviare l'elemento fornito.  
  
 Questo metodo può restituire all'inizio con un <xref:System.OperationCanceledException> se il `cancellationToken` viene annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se <see cref="T:System.Threading.CancellationToken" /> viene annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">È stato eliminato <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> oppure <see cref="T:System.Threading.CancellationTokenSource" /> proprietario di <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato contrassegnato come completo in relazione alle aggiunte.  
  
oppure 
La raccolta sottostante non ha accettato l'elemento.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge l'elemento specificato a una qualsiasi delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> specificate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento da aggiungere a una delle raccolte.</param>
        <summary>Aggiunge l'elemento specificato a una qualsiasi delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> specificate.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> cui è stato aggiunto l'elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è stata specificata una capacità delimitata quando tutti i <xref:System.Collections.Concurrent.BlockingCollection%601> istanze sono state inizializzate, una chiamata a AddToAny venga potrebbe bloccare fino a quando non è disponibile spazio in una delle raccolte per archiviare l'elemento specificato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno un insieme sottostante non ha accettato l'elemento.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento da aggiungere a una delle raccolte.</param>
        <param name="cancellationToken">Token di annullamento da osservare.</param>
        <summary>Aggiunge l'elemento specificato a una qualsiasi delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> specificate.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> cui è stato aggiunto l'elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è stata specificata una capacità delimitata quando tutti i <xref:System.Collections.Concurrent.BlockingCollection%601> istanze sono state inizializzate, una chiamata a AddToAny venga potrebbe bloccare fino a quando non è disponibile spazio in una delle raccolte per archiviare l'elemento specificato. Questo metodo può restituire prima che l'elemento viene aggiunto a qualsiasi raccolta se la `cancellationToken` viene annullata prima che sia disponibile spazio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se <see cref="T:System.Threading.CancellationToken" /> viene annullato.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno un insieme sottostante non ha accettato l'elemento.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</exception>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata oppure l'istanza <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="BoundedCapacity">
      <MemberSignature Language="C#" Value="public int BoundedCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BoundedCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BoundedCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BoundedCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BoundedCapacity : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.BoundedCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica la capacità delimitata di questa istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <value>Capacità delimitata di questa raccolta, o int.MaxValue se non è stato fornito alcun limite.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="CompleteAdding">
      <MemberSignature Language="C#" Value="public void CompleteAdding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CompleteAdding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" />
      <MemberSignature Language="VB.NET" Value="Public Sub CompleteAdding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CompleteAdding();" />
      <MemberSignature Language="F#" Value="member this.CompleteAdding : unit -&gt; unit" Usage="blockingCollection.CompleteAdding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Contrassegna le istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> per non accettare più alcuna aggiunta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo una raccolta è stata contrassegnata come completo per l'aggiunta, aggiunta alla raccolta non è consentita e tenta di rimuovere dalla raccolta non attenderanno il completamento quando la raccolta è vuota.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="blockingCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale che è la destinazione degli elementi copiati dall'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. La matrice deve avere un'indicizzazione in base zero.</param>
        <param name="index">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia tutti gli elementi dell'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> in una matrice unidimensionale compatibile, a partire dall'indice specificato della matrice di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 CopyTo rappresenta uno snapshot della raccolta in un momento preciso momento. Se altri thread è aggiungono o rimuovono elementi durante l'esecuzione di CopyTo, gli elementi restituiti da CopyTo potrebbero non rappresentare lo stato della raccolta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="array" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="index" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="index" /> è uguale a o più grande della lunghezza di <paramref name="array" />.  
  
La matrice di destinazione è troppo piccola per contenere tutti gli elementi BlockingCcollection.  
  
Il numero di dimensioni della matrice non corrisponde.  
  
Il tipo di matrice non è compatibile con il tipo degli elementi BlockingCollection.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di elementi contenuti nella classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <value>Numero di elementi contenuti in <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se qualsiasi metodo nell'oggetto BlockingCollection è in esecuzione mentre la proprietà Count viene effettuato un accesso alla, il valore restituito è approssimativo. Conteggio potrebbe riflettere un numero che può essere maggiore o minore rispetto al numero effettivo di elementi BlockingCollection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="blockingCollection.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Dispose` (metodo) non è thread-safe.  
  
 Chiamare il metodo `Dispose` dopo aver terminato di utilizzare l'oggetto <xref:System.Collections.Concurrent.BlockingCollection%601>. Il metodo `Dispose` lascia l'oggetto <xref:System.Collections.Concurrent.BlockingCollection%601> in una condizione di inutilizzabilità. Dopo la chiamata `Dispose`, è necessario rilasciare tutti i riferimenti per il <xref:System.Collections.Concurrent.BlockingCollection%601> in modo che il garbage collector di recuperare la memoria che il <xref:System.Collections.Concurrent.BlockingCollection%601> occupata.  
  
 Per altre informazioni, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementa un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Chiamare sempre il metodo `Dispose` prima di rilasciare l'ultimo riferimento a <xref:System.Collections.Concurrent.BlockingCollection%601>. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Collections.Concurrent.BlockingCollection%601> dell'oggetto `Finalize` non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="blockingCollection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Se eliminato in modo esplicito (true) o destinato a un finalizzatore (false).</param>
        <summary>Rilascia risorse usate dall'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConsumingEnumerable">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fornisce un oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> usato per gli elementi nella raccolta.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConsumingEnumerable () As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable();" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : unit -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornisce un oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> usato per gli elementi nella raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> che rimuove e restituisce elementi dalla raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> metodo:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#4)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : System.Threading.CancellationToken -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.BlockingCollection`1/&lt;GetConsumingEnumerable&gt;d__2))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.BlockingCollection`1/&lt;GetConsumingEnumerable&gt;d__68))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token di annullamento da osservare.</param>
        <summary>Fornisce un oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> usato per gli elementi nella raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> che rimuove e restituisce elementi dalla raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente al codice client di rimuovere gli elementi dalla raccolta tramite un ciclo foreach (per ogni in Visual Basic), o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> o una query PLINQ. L'enumeratore continuerà a fornire gli elementi (se presenti) fino alla <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> restituisce true e, se <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> è false il ciclo si interrompe fino a quando non diventa disponibile un elemento o finché il <xref:System.Threading.CancellationToken> è stata annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se <see cref="T:System.Threading.CancellationToken" /> viene annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato eliminato o è stato eliminato l'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che aveva creato <paramref name="cancellationToken" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="IsAddingCompleted">
      <MemberSignature Language="C#" Value="public bool IsAddingCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAddingCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAddingCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAddingCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAddingCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsAddingCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se questo oggetto <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato contrassegnato come completo per l'aggiunta.</summary>
        <value>Viene indicato se questa raccolta è stata contrassegnata come completa per l'aggiunta.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se questo oggetto <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato contrassegnato come completo per l'aggiunta ed è vuoto.</summary>
        <value>Viene indicato se questa raccolta è stata contrassegnata come completa per l'aggiunta ed è vuota.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornisce un oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> per gli elementi nella raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.IEnumerator`1" /> per gli elementi nella raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A>, <xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType> restituisce un enumeratore standard che non modifica la raccolta sottostante. Se altri thread è aggiungono o rimuovono elementi contemporaneamente quando viene chiamato GetEnumerator, gli elementi restituiti dall'enumeratore potrebbero non rappresentare lo stato corrente della raccolta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale che è la destinazione degli elementi copiati dall'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. La matrice deve avere un'indicizzazione in base zero.</param>
        <param name="index">Indice in base zero in <c>array</c> in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia tutti gli elementi dell'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> in una matrice unidimensionale compatibile, a partire dall'indice specificato della matrice di destinazione.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="array" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="index" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="index" /> è uguale a o più grande della lunghezza di <paramref name="array" />, la matrice è multidimensionale o non può essere eseguito automaticamente il cast al tipo della matrice di destinazione del parametro di tipo per l'insieme.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso all'interfaccia <see cref="T:System.Collections.ICollection" /> è sincronizzato.</summary>
        <value>Restituisce sempre false.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Collections.ICollection" />. Questa proprietà non è supportata.</summary>
        <value>Restituisce null.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">La proprietà SyncRoot non è supportata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornisce un oggetto <see cref="T:System.Collections.IEnumerator" /> per gli elementi nella raccolta.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IEnumerator" /> per gli elementi nella raccolta.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Take">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rimuove un elemento da <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take" />
      <MemberSignature Language="VB.NET" Value="Public Function Take () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take();" />
      <MemberSignature Language="F#" Value="member this.Take : unit -&gt; 'T" Usage="blockingCollection.Take " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove un elemento da <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Elemento rimosso dalla raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una chiamata a <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> potrebbe bloccare fino a quando non è disponibile per essere rimosso un elemento.  
  
 L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <xref:System.Collections.Concurrent.BlockingCollection%601>. Quando si crea un oggetto <xref:System.Collections.Concurrent.BlockingCollection%601>, è possibile specificare il tipo di raccolta da utilizzare. Ad esempio, è possibile specificare un oggetto <xref:System.Collections.Concurrent.ConcurrentQueue%601> per il comportamento FIFO (First In, First Out) o un oggetto <xref:System.Collections.Concurrent.ConcurrentStack%601> per il comportamento LIFO (Last In, First Out). È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Il tipo di raccolta predefinito per <xref:System.Collections.Concurrent.BlockingCollection%601> è <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.InvalidOperationException">L'insieme sottostante è stato modificato all'esterno di questa istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> o <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è vuoto e l'insieme è stato contrassegnato come completo per l'aggiunta.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Take : System.Threading.CancellationToken -&gt; 'T" Usage="blockingCollection.Take cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Oggetto che può essere usato per annullare l'operazione di prelevamento.</param>
        <summary>Rimuove un elemento da <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Elemento rimosso dalla raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una chiamata a <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> potrebbe bloccare fino a quando non è disponibile per essere rimosso un elemento o il token viene annullato.  
  
 L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <xref:System.Collections.Concurrent.BlockingCollection%601>. Quando si crea un oggetto <xref:System.Collections.Concurrent.BlockingCollection%601>, è possibile specificare il tipo di raccolta da utilizzare. Ad esempio, è possibile specificare un oggetto <xref:System.Collections.Concurrent.ConcurrentQueue%601> per il comportamento FIFO (First In, First Out) o un oggetto <xref:System.Collections.Concurrent.ConcurrentStack%601> per il comportamento LIFO (Last In, First Out). È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Il tipo di raccolta predefinito per <xref:System.Collections.Concurrent.BlockingCollection%601> è <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> viene annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato eliminato o è stato annullato l'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che aveva creato il token.</exception>
        <exception cref="T:System.InvalidOperationException">L'insieme sottostante è stato modificato al di fuori di questa istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> o BlockingCollection è contrassegnato come completo per l'aggiunta o <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è vuoto.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preleva un elemento da una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> specificate.</summary>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento rimosso da una delle raccolte.</param>
        <summary>Preleva un elemento da una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> specificate.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> da cui è stato rimosso l'elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una chiamata a con potrebbe bloccare fino a quando non è disponibile per essere rimosso un elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 o contiene un elemento null o <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> è stato chiamato nell'insieme.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento rimosso da una delle raccolte.</param>
        <param name="cancellationToken">Token di annullamento da osservare.</param>
        <summary>Preleva un elemento da una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> specificate considerando il token di annullamento specificato.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> da cui è stato rimosso l'elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una chiamata a con potrebbe bloccare fino a quando non è disponibile per essere rimosso un elemento. Il metodo restituirà all'inizio con un oggetto OperationCanceledException se il token viene annullato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se <see cref="T:System.Threading.CancellationToken" /> viene annullato.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 o contiene un elemento null o <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> è stato chiamato nell'insieme.</exception>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="blockingCollection.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia gli elementi dall'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> in una nuova matrice.</summary>
        <returns>Matrice che contiene copie degli elementi della raccolta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi copiati non vengono rimossi dalla raccolta.  
  
 Se qualsiasi metodo nell'oggetto BlockingCollection è in esecuzione mentre il metodo ToArray viene eseguito, il valore restituito è approssimativo. ToArray potrebbe includere gli elementi che sono già stati rimossi o escludere gli elementi che sono già stati inseriti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAdd">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova ad aggiungere l'elemento specificato a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T -&gt; bool" Usage="blockingCollection.TryAdd item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da aggiungere alla raccolta.</param>
        <summary>Prova ad aggiungere l'elemento specificato a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>true se è possibile aggiungere <paramref name="item" />; in caso contrario, false. Se l'elemento è un duplicato e la raccolta sottostante non accetta elementi duplicati, viene generato un oggetto <see cref="T:System.InvalidOperationException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la raccolta è un insieme delimitato ed è completa, questo metodo restituisce immediatamente false senza aggiungere l'elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato contrassegnato come completo in relazione alle aggiunte.  
  
oppure 
La raccolta sottostante non ha accettato l'elemento.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da aggiungere alla raccolta.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Prova ad aggiungere l'elemento specificato a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> nel periodo di tempo specificato.</summary>
        <returns>true se è stato possibile aggiungere <paramref name="item" /> alla raccolta entro il tempo specificato; in caso contrario, false. Se l'elemento è un duplicato e la raccolta sottostante non accetta elementi duplicati, viene generato un oggetto <see cref="T:System.InvalidOperationException" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato contrassegnato come completo in relazione alle aggiunte.  
  
oppure 
La raccolta sottostante non ha accettato l'elemento.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * TimeSpan -&gt; bool" Usage="blockingCollection.TryAdd (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da aggiungere alla raccolta.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Prova ad aggiungere l'elemento specificato a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>true se è stato possibile aggiungere <paramref name="item" /> alla raccolta nell'intervallo di tempo specificato; in caso contrario, false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato contrassegnato come completo in relazione alle aggiunte.  
  
oppure 
La raccolta sottostante non ha accettato l'elemento.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da aggiungere alla raccolta.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="cancellationToken">Token di annullamento da osservare.</param>
        <summary>Prova ad aggiungere l'elemento specificato a <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> nel periodo di tempo specificato, considerando un token di annullamento.</summary>
        <returns>true se è stato possibile aggiungere <paramref name="item" /> alla raccolta entro il tempo specificato; in caso contrario, false. Se l'elemento è un duplicato e la raccolta sottostante non accetta elementi duplicati, viene generato un oggetto <see cref="T:System.InvalidOperationException" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se <see cref="T:System.Threading.CancellationToken" /> viene annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato eliminato o l'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> sottostante è stato eliminato.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato contrassegnato come completo in relazione alle aggiunte.  
  
oppure 
La raccolta sottostante non ha accettato l'elemento.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova ad aggiungere l'elemento specificato a una delle istanze specifiche di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento da aggiungere a una delle raccolte.</param>
        <summary>Prova ad aggiungere l'elemento specificato a una delle istanze specifiche di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> cui è stato aggiunto l'elemento o -1 se non è stato possibile aggiungere l'elemento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno un insieme sottostante non ha accettato l'elemento.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento da aggiungere a una delle raccolte.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Prova ad aggiungere l'elemento specificato a una delle istanze specifiche di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> cui è stato aggiunto l'elemento o -1 se non è stato possibile aggiungere l'elemento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito. 
oppure 
Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno un insieme sottostante non ha accettato l'elemento.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento da aggiungere a una delle raccolte.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Prova ad aggiungere l'elemento specificato a una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> specificate considerando il token di annullamento specificato.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> cui è stato aggiunto l'elemento o -1 se non è stato possibile aggiungere l'elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può restituire all'inizio se l'oggetto cancellationToken viene annullato prima lo spazio disponibile per l'operazione di aggiunta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> o <see cref="T:System.Threading.CancellationTokenSource" /> che hanno creato <paramref name="cancellationToken" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <see cref="F:System.Int32.MaxValue" />.  
  
oppure 
Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno un insieme sottostante non ha accettato l'elemento.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento da aggiungere a una delle raccolte.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="cancellationToken">Token di annullamento da osservare.</param>
        <summary>Prova ad aggiungere l'elemento specificato a una delle istanze specifiche di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> cui è stato aggiunto l'elemento o -1 se non è stato possibile aggiungere l'elemento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se <see cref="T:System.Threading.CancellationToken" /> viene annullato.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno un insieme sottostante non ha accettato l'elemento.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito. 
oppure 
Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</exception>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTake">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova a rimuovere un elemento da <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il metodo <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A>.  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#2)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  -&gt; bool" Usage="blockingCollection.TryTake item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da rimuovere dalla raccolta.</param>
        <summary>Prova a rimuovere un elemento da <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>
          <see langword="true" /> se è stato possibile rimuovere un elemento. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la raccolta è vuota, questo metodo restituisce immediatamente false.  
  
 L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <xref:System.Collections.Concurrent.BlockingCollection%601>. Quando si crea un oggetto <xref:System.Collections.Concurrent.BlockingCollection%601>, è possibile specificare il tipo di raccolta da utilizzare. Ad esempio, è possibile specificare un oggetto <xref:System.Collections.Concurrent.ConcurrentQueue%601> per il comportamento FIFO (First In, First Out) o un oggetto <xref:System.Collections.Concurrent.ConcurrentStack%601> per il comportamento LIFO (Last In, First Out). È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Il tipo di raccolta predefinito per <xref:System.Collections.Concurrent.BlockingCollection%601> è <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.InvalidOperationException">La raccolta sottostante è stata modificata all'esterno di questa istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da rimuovere dalla raccolta.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Prova rimuovere un elemento da <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> entro il periodo di tempo specificato.</summary>
        <returns>
          <see langword="true" /> se è stato possibile rimuovere un elemento dalla raccolta entro il tempo specificato. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <xref:System.Collections.Concurrent.BlockingCollection%601>. Quando si crea un <xref:System.Collections.Concurrent.BlockingCollection%601>, è possibile specificare il tipo di raccolta da utilizzare. Ad esempio, è possibile specificare un oggetto <xref:System.Collections.Concurrent.ConcurrentQueue%601> per il comportamento FIFO (First In, First Out) o un oggetto <xref:System.Collections.Concurrent.ConcurrentStack%601> per il comportamento LIFO (Last In, First Out). È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Il tipo di raccolta predefinito per <xref:System.Collections.Concurrent.BlockingCollection%601> è <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.InvalidOperationException">La raccolta sottostante è stata modificata all'esterno di questa istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * TimeSpan -&gt; bool" Usage="blockingCollection.TryTake (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da rimuovere dalla raccolta.</param>
        <param name="timeout">Oggetto che rappresenta il numero di millisecondi di attesa oppure un oggetto che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Prova rimuovere un elemento da <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> entro il periodo di tempo specificato.</summary>
        <returns>
          <see langword="true" /> se è stato possibile rimuovere un elemento dalla raccolta entro il tempo specificato. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <xref:System.Collections.Concurrent.BlockingCollection%601>. Quando si crea un oggetto <xref:System.Collections.Concurrent.BlockingCollection%601>, è possibile specificare il tipo di raccolta da utilizzare. Ad esempio, è possibile specificare un oggetto <xref:System.Collections.Concurrent.ConcurrentQueue%601> per il comportamento FIFO (First In, First Out) o un oggetto <xref:System.Collections.Concurrent.ConcurrentStack%601> per il comportamento LIFO (Last In, First Out). È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Il tipo di raccolta predefinito per <xref:System.Collections.Concurrent.BlockingCollection%601> è <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito. 
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">La raccolta sottostante è stata modificata all'esterno di questa istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da rimuovere dalla raccolta.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="cancellationToken">Token di annullamento da osservare.</param>
        <summary>Prova a rimuovere un elemento da <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> nel periodo di tempo specificato, considerando un token di annullamento.</summary>
        <returns>
          <see langword="true" /> se è stato possibile rimuovere un elemento dalla raccolta entro il tempo specificato. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <xref:System.Collections.Concurrent.BlockingCollection%601>. Quando si crea un oggetto <xref:System.Collections.Concurrent.BlockingCollection%601>, è possibile specificare il tipo di raccolta da utilizzare. Ad esempio, è possibile specificare un oggetto <xref:System.Collections.Concurrent.ConcurrentQueue%601> per il comportamento FIFO (First In, First Out) o un oggetto <xref:System.Collections.Concurrent.ConcurrentStack%601> per il comportamento LIFO (Last In, First Out). È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Il tipo di raccolta predefinito per <xref:System.Collections.Concurrent.BlockingCollection%601> è <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> è stato annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stato eliminato o l'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> sottostante è stato eliminato.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.InvalidOperationException">La raccolta sottostante è stata modificata all'esterno dell'istanza <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova a rimuovere un elemento da una delle istanze specifiche di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento rimosso da una delle raccolte.</param>
        <summary>Prova a rimuovere un elemento da una delle istanze specifiche di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> da cui è stato rimosso l'elemento o -1 se non è stato possibile rimuovere un elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una chiamata al metodo TryTakeFromAny con potrebbe bloccare fino a quando non è disponibile per essere rimosso un elemento.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType> metodo:  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#3)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 matrice o contiene un elemento null.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento rimosso da una delle raccolte.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Prova a rimuovere un elemento da una delle istanze specifiche di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> da cui è stato rimosso l'elemento o -1 se non è stato possibile rimuovere un elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una chiamata al metodo TryTakeFromAny con potrebbe bloccare fino a quando non è disponibile per essere rimosso un elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito. 
oppure 
Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 matrice o contiene un elemento null.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento rimosso da una delle raccolte.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Prova a rimuovere un elemento da una delle istanze specifiche di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> da cui è stato rimosso l'elemento o -1 se non è stato possibile rimuovere un elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una chiamata al metodo TryTakeFromAny con potrebbe bloccare fino a quando non è disponibile per essere rimosso un elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <see cref="F:System.Int32.MaxValue" />.  
  
oppure 
Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 matrice o contiene un elemento null.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Matrice di raccolte.</param>
        <param name="item">Elemento rimosso da una delle raccolte.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="cancellationToken">Token di annullamento da osservare.</param>
        <summary>Prova a rimuovere un elemento da una delle istanze specifiche di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Indice della raccolta nella matrice <paramref name="collections" /> da cui è stato rimosso l'elemento o -1 se non è stato possibile rimuovere un elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una chiamata al metodo TryTakeFromAny con potrebbe bloccare fino a quando non è disponibile per essere rimosso un elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se <see cref="T:System.Threading.CancellationToken" /> viene annullato.</exception>
        <exception cref="T:System.InvalidOperationException">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="collections" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito. 
oppure 
Il conteggio di <paramref name="collections" /> è più grande della dimensione massima di 62 per STA e 63 per MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="collections" /> è una matrice di lunghezza 0 matrice o contiene un elemento null.</exception>
        <exception cref="T:System.ObjectDisposedException">Almeno una delle istanze di <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> è stata eliminata.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Raccolte thread-safe</related>
        <related type="Article" href="http://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Panoramica di BlockingCollection</related>
      </Docs>
    </Member>
  </Members>
</Type>