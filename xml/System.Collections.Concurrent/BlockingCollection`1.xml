<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="BlockingCollection`1.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac50df771ecf34f5bb842d4f014e7a03bea934d6866.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0df771ecf34f5bb842d4f014e7a03bea934d6866</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The type of elements in the collection.</source>
          <target state="translated">Tipo di elementi contenuti nella raccolta.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Provides blocking and bounding capabilities for thread-safe collections that implement <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph>.</source>
          <target state="translated">Fornisce funzionalità di blocco e limitazione per le raccolte thread-safe che implementano <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is a thread-safe collection class that provides the following:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è una classe di raccolta thread-safe che fornisce le funzionalità seguenti:</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>An implementation of the producer/consumer pattern; <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is a wrapper for the <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">Un'implementazione del modello di tipo produttore/consumer; <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è un wrapper per il <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Concurrent addition and removal of items from multiple threads with the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> and  <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> methods.</source>
          <target state="translated">Simultanea aggiunta e rimozione di elementi da più thread, con la <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>A bounded collection that blocks <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operations when the collection is full or empty.</source>
          <target state="translated">Una raccolta limitata che blocca <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operazioni quando la raccolta è vuota o completo.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Cancellation of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operations by using a <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> object in the  <ph id="ph4">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> method.</source>
          <target state="translated">Annullamento di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operazioni utilizzando un <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> oggetto di <ph id="ph4">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> o <ph id="ph5">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Questo tipo implementa il <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Per eliminare direttamente il tipo, chiamare il relativo <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> metodo in un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio <ph id="ph1">`using`</ph> in C# o <ph id="ph2">`Using`</ph> in Visual Basic.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> argomento relativo all'interfaccia.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Also, note that the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Dispose&gt;</ph> method is not thread-safe.</source>
          <target state="translated">Si noti inoltre che il <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Dispose&gt;</ph> (metodo) non è thread-safe.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>All other public and protected members of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> are thread-safe and may be used concurrently from multiple threads.</source>
          <target state="translated">Tutti gli altri membri pubblici e protetti di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> sono thread-safe e possono essere utilizzate contemporaneamente da più thread.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> represents a collection that allows for thread-safe adding and removal of data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> rappresenta una raccolta che consente di thread-safe aggiunta e rimozione di dati.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is used as a wrapper for an <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> instance, and allows removal attempts from the collection to block until data is available to be removed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> viene utilizzato come wrapper per un <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> istanza e consente di tentativi di rimozione dalla raccolta il blocco finché non diventano disponibili da rimuovere.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Similarly, you can create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> to enforce an upper bound on the number of data elements allowed in the <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>; addition attempts to the collection may then block until space is available to store the added items.</source>
          <target state="translated">Analogamente, è possibile creare un <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> per imporre un limite superiore al numero di elementi di dati consentiti nella <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>; i tentativi di aggiunta alla raccolta possono essere bloccati fino a quando non è disponibile spazio per archiviare gli elementi aggiunti.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>In this manner, <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is similar to a traditional blocking queue data structure, except that the underlying data storage mechanism is abstracted away as an <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</source>
          <target state="translated">In questo modo, <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è simile a una struttura di dati coda blocco tradizionali, ad eccezione del fatto che il meccanismo di archiviazione dati sottostante viene estratto come un <ph id="ph2">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> supports bounding and blocking.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> supporta delimitazione e blocco.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Bounding means that you can set the maximum capacity of the collection.</source>
          <target state="translated">La limitazione che è possibile impostare la capacità massima della raccolta.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</source>
          <target state="translated">La limitazione è importante in determinati scenari poiché consente di controllare la dimensione massima della raccolta in memoria, impedisce il primo thread di spostamento troppo precedono i thread consumer. Più thread o attività possono aggiungere contemporaneamente gli elementi alla raccolta e se la raccolta raggiunge la capacità massima specificata, il primo thread verrà bloccata finché non viene rimosso un elemento.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</source>
          <target state="translated">Più Consumer possono rimuovere contemporaneamente elementi e quando la raccolta diventa vuota, i thread Consumer si bloccano fino a quando un Producer aggiunge un elemento.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>A producing thread can call the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A&gt;</ph> method to indicate that no more items will be added.</source>
          <target state="translated">Un primo thread può chiamare il <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A&gt;</ph> metodo per indicare che nessun ulteriore elemento verrà aggiunto.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Consumers monitor the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> property to know when the collection is empty and no more items will be added.</source>
          <target state="translated">I Consumer monitorano la proprietà <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> per sapere quando la raccolta è vuota e non verranno aggiunti altri elementi.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operations are typically performed in a loop.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> operazioni vengono in genere eseguite in un ciclo.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>You can cancel a loop by passing in a <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> method, and then checking the value of the token's <ph id="ph4">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property on each iteration.</source>
          <target state="translated">È possibile annullare un ciclo tramite il passaggio di un <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> dell'oggetto per il <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> (metodo) e quindi controllare il valore del token di <ph id="ph4">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> proprietà in ogni iterazione.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>If the value is <ph id="ph1">`true`</ph>, it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</source>
          <target state="translated">Se il valore è <ph id="ph1">`true`</ph>, è responsabilità dell'utente di rispondere la richiesta di annullamento tramite Pulitura di tutte le risorse e di uscire dal ciclo.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify not only the bounded capacity but also the type of collection to use.</source>
          <target state="translated">Quando si crea un <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> oggetto, è possibile specificare non solo la capacità delimitata ma anche il tipo di raccolta da utilizzare.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Ad esempio, è possibile specificare un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> per il comportamento FIFO (First In, First Out) o un oggetto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> per il comportamento LIFO (Last In, First Out).</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">Il tipo di raccolta predefinito per <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Do not modify the underlying collection directly.</source>
          <target state="translated">Non modificare direttamente la raccolta sottostante.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Use <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> methods to add or remove elements.</source>
          <target state="translated">Utilizzare <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> metodi per aggiungere o rimuovere elementi.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object can become corrupted if you change the underlying collection directly.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> oggetto può risultare danneggiato se si modifica direttamente la raccolta sottostante.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The following example shows how to add and take items concurrently from a blocking collection:</source>
          <target state="translated">Nell'esempio seguente viene illustrato come aggiungere e rimuovere elementi contemporaneamente da una raccolta di blocco:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The Dispose method is not thread-safe.</source>
          <target state="translated">Il metodo Dispose non è thread-safe.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>All other public and protected members of <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> are thread-safe and may be used concurrently from multiple threads.</source>
          <target state="translated">Tutti gli altri membri pubblici e protetti di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> sono thread-safe e possono essere utilizzate contemporaneamente da più thread.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class without an upper-bound.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> senza un limite superiore.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class without an upper-bound.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> senza un limite superiore.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
          <source>The default underlying collection is a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object, which provides first in, first out (FIFO) behavior.</source>
          <target state="translated">Il valore predefinito insieme sottostante è un <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> oggetto che fornisce innanzitutto in, first-out (FIFO) comportamento.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
          <source>The collection to use as the underlying data store.</source>
          <target state="translated">Raccolta da usare come archivio dati sottostante.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class without an upper-bound and using the provided <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> as its underlying data store.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> senza un limite superiore e usando l'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> fornito come archivio dati sottostante.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
          <source>The <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>The bounded size of the collection.</source>
          <target state="translated">Dimensione delimitata della raccolta.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class with the specified upper-bound.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> con il limite superiore specificato.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>The default underlying collection is a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">Il valore predefinito insieme sottostante è un <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> is not a positive value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> non è un valore positivo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The collection to use as the underlying data store.</source>
          <target state="translated">Raccolta da usare come archivio dati sottostante.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The bounded size of the collection.</source>
          <target state="translated">Dimensione delimitata della raccolta.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class with the specified upper-bound and using the provided <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> as its underlying data store.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> con il limite superiore specificato e usando l'oggetto <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /&gt;</ph> fornito come archivio dati sottostante.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> is not a positive value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="boundedCapacity" /&gt;</ph> non è un valore positivo.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
          <source>The supplied <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> contains more values than is permitted by <ph id="ph2">&lt;paramref name="boundedCapacity" /&gt;</ph>.</source>
          <target state="translated">L'elemento <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> contiene più valori rispetto a quelli consentiti da <ph id="ph2">&lt;paramref name="boundedCapacity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Adds the item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Aggiunge l'elemento all'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento da aggiungere alla raccolta.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The value can be a null reference.</source>
          <target state="translated">Il valore può essere un riferimento Null.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>Adds the item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Aggiunge l'elemento all'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>If a bounded capacity was specified when this instance of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> was initialized, a call to Add may block until space is available to store the provided item.</source>
          <target state="translated">Se è stata specificata una capacità limitata quando questa istanza di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è stato inizializzato, una chiamata al metodo Add venga bloccata finché non è disponibile spazio per archiviare l'elemento fornito.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stato contrassegnato come completo in relazione alle aggiunte.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La raccolta sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento da aggiungere alla raccolta.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The value can be a null reference.</source>
          <target state="translated">Il valore può essere un riferimento Null.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token di annullamento da osservare.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>Adds the item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Aggiunge l'elemento all'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>If a bounded capacity was specified when this instance of <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> was initialized, a call to <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> may block until space is available to store the provided item.</source>
          <target state="translated">Se è stata specificata una capacità limitata quando questa istanza di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è stata inizializzata, una chiamata a <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A&gt;</ph> venga bloccata finché non è disponibile spazio per archiviare l'elemento fornito.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>This method can return early with an <ph id="ph1">&lt;xref:System.OperationCanceledException&gt;</ph> if the <ph id="ph2">`cancellationToken`</ph> is canceled.</source>
          <target state="translated">Questo metodo può restituire all'inizio con un <ph id="ph1">&lt;xref:System.OperationCanceledException&gt;</ph> se il <ph id="ph2">`cancellationToken`</ph> viene annullata.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> viene annullato.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that owns <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed.</source>
          <target state="translated">È stato eliminato <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> oppure <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> proprietario di <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stato contrassegnato come completo in relazione alle aggiunte.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La raccolta sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Adds the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Aggiunge l'elemento specificato a una qualsiasi delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> specificate.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento da aggiungere a una delle raccolte.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>Adds the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Aggiunge l'elemento specificato a una qualsiasi delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> specificate.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> cui è stato aggiunto l'elemento.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>If a bounded capacity was specified when all of the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instances were initialized, a call to AddToAny may block until space is available in one of the collections to store the provided item.</source>
          <target state="translated">Se è stata specificata una capacità limitata quando tutti i <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> istanze sono state inizializzate, che una chiamata ad AddToAny venga bloccata fino a quando non è disponibile spazio in una delle raccolte per archiviare l'elemento specificato.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Almeno una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Almeno un insieme sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento da aggiungere a una delle raccolte.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token di annullamento da osservare.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>Adds the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Aggiunge l'elemento specificato a una qualsiasi delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> specificate.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> cui è stato aggiunto l'elemento.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>If a bounded capacity was specified when all of the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instances were initialized, a call to AddToAny may block until space is available in one of the collections to store the provided item.</source>
          <target state="translated">Se è stata specificata una capacità limitata quando tutti i <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> istanze sono state inizializzate, che una chiamata ad AddToAny venga bloccata fino a quando non è disponibile spazio in una delle raccolte per archiviare l'elemento specificato.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>This method may return before the item is added to any collection if the <ph id="ph1">`cancellationToken`</ph> is canceled before space is available.</source>
          <target state="translated">Questo metodo può restituire prima che l'elemento viene aggiunto a qualsiasi raccolta se il <ph id="ph1">`cancellationToken`</ph> viene annullata prima che sia disponibile spazio.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> viene annullato.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Almeno un insieme sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed, or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed.</source>
          <target state="translated">Almeno una delle istanze <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata oppure l'istanza <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> che ha creato <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
          <source>Gets the bounded capacity of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Ottiene un valore che indica la capacità delimitata di questa istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
          <source>The bounded capacity of this collection, or int.MaxValue if no bound was supplied.</source>
          <target state="translated">Capacità delimitata di questa raccolta, o int.MaxValue se non è stato fornito alcun limite.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
          <source>Marks the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances as not accepting any more additions.</source>
          <target state="translated">Contrassegna le istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> per non accettare più alcuna aggiunta.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
          <source>After a collection has been marked as complete for adding, adding to the collection is not permitted and attempts to remove from the collection will not wait when the collection is empty.</source>
          <target state="translated">Dopo una raccolta è stata contrassegnata come completo per l'aggiunta, aggiunta alla raccolta non è consentita e tenta di rimuovere dalla raccolta non attenderà durante la raccolta è vuota.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Matrice unidimensionale che è la destinazione degli elementi copiati dall'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">La matrice deve avere un'indicizzazione in base zero.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Indice in base zero in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> in corrispondenza del quale ha inizio la copia.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>Copies all of the items in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance to a compatible one-dimensional array, starting at the specified index of the target array.</source>
          <target state="translated">Copia tutti gli elementi dell'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in una matrice unidimensionale compatibile, a partire dall'indice specificato della matrice di destinazione.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>CopyTo represents a snapshot of the collection at a precise point in time.</source>
          <target state="translated">CopyTo rappresenta uno snapshot della raccolta in un momento preciso momento.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>If other threads are adding or removing items while CopyTo is executing, then the elements returned by CopyTo might not represent the state of the collection.</source>
          <target state="translated">Se altri thread aggiungono o rimuovono elementi mentre è in esecuzione CopyTo, quindi gli elementi restituiti da CopyTo potrebbero non rappresentare lo stato della raccolta.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="array" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="array" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is less than zero.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is equal to or greater than the length of the <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> è uguale a o più grande della lunghezza di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The destination array is too small to hold all of the BlockingCcollection elements.</source>
          <target state="translated">La matrice di destinazione è troppo piccola per contenere tutti gli elementi BlockingCcollection.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The array rank doesn't match.</source>
          <target state="translated">Il numero di dimensioni della matrice non corrisponde.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
          <source>The array type is incompatible with the type of the BlockingCollection elements.</source>
          <target state="translated">Il tipo di matrice non è compatibile con il tipo degli elementi BlockingCollection.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>Gets the number of items contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Ottiene il numero di elementi contenuti nella classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>The number of items contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Numero di elementi contenuti in <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>If any method in BlockingCollection is executing while the Count property is being accessd, the return value is approximate.</source>
          <target state="translated">Se tutti i metodi BlockingCollection sono in esecuzione mentre la proprietà Count viene effettuato un accesso alla, il valore restituito è approssimativo.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>Count may reflect a number that is either greater than or less than the actual number of items in the BlockingCollection.</source>
          <target state="translated">Conteggio può riflettere un numero che può essere maggiore o minore del numero effettivo di elementi in BlockingCollection.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.Count">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class.</source>
          <target state="translated">Rilascia tutte le risorse usate dall'istanza corrente della classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> class.</source>
          <target state="translated">Rilascia tutte le risorse usate dall'istanza corrente della classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method is not thread-safe.</source>
          <target state="translated">Il <ph id="ph1">`Dispose`</ph> (metodo) non è thread-safe.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Call <ph id="ph1">`Dispose`</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</source>
          <target state="translated">Chiamare il metodo <ph id="ph1">`Dispose`</ph> dopo aver terminato di utilizzare l'oggetto <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method leaves the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> in an unusable state.</source>
          <target state="translated">Il metodo <ph id="ph1">`Dispose`</ph> lascia l'oggetto <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> in una condizione di inutilizzabilità.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>After calling <ph id="ph1">`Dispose`</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> was occupying.</source>
          <target state="translated">Dopo la chiamata <ph id="ph1">`Dispose`</ph>, è necessario rilasciare tutti i riferimenti al <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> in modo che il garbage collector può recuperare la memoria che di <ph id="ph3">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> occupata.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>la pulizia di risorse non gestite<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> e <bpt id="p2">[</bpt>implementazione di un metodo Dispose<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Always call <ph id="ph1">`Dispose`</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</source>
          <target state="translated">Chiamare sempre il metodo <ph id="ph1">`Dispose`</ph> prima di rilasciare l'ultimo riferimento a <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object's <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> dell'oggetto <ph id="ph2">`Finalize`</ph> non viene richiamato dal Garbage Collector.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
          <source>Whether being disposed explicitly (true) or due to a finalizer (false).</source>
          <target state="translated">Se eliminato in modo esplicito (true) o destinato a un finalizzatore (false).</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
          <source>Releases resources used by the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Rilascia risorse usate dall'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Provides a consuming <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Fornisce un oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> usato per gli elementi nella raccolta.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>Provides a consuming <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Fornisce un oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> usato per gli elementi nella raccolta.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> that removes and returns items from the collection.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> che rimuove e restituisce elementi dalla raccolta.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph> method:</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph> metodo:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token di annullamento da osservare.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>Provides a consuming <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Fornisce un oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> usato per gli elementi nella raccolta.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> that removes and returns items from the collection.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> che rimuove e restituisce elementi dalla raccolta.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>This method enables client code to remove items from the collection by using a foreach loop (For Each in Visual Basic), or <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> or a PLINQ query.</source>
          <target state="translated">Questo metodo consente al codice client rimuovere gli elementi dalla raccolta utilizzando un ciclo foreach (per ogni in Visual Basic), o <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> o una query PLINQ.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>The enumerator will continue to provide items (if any exist) until <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> returns true, and if <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> is false the loop blocks until an item becomes available or until the <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> is cancelled.</source>
          <target state="translated">L'enumeratore continuerà a fornire elementi (se presenti) fino alla <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> restituisce true e se <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A&gt;</ph> è false i blocchi di ciclo fino a quando un elemento diventa disponibile o fino a quando il <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> è stata annullata.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> viene annullato.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stato eliminato o è stato eliminato l'oggetto <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> che aveva creato <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete for adding.</source>
          <target state="translated">Ottiene un valore che indica se questo oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stato contrassegnato come completo per l'aggiunta.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
          <source>Whether this collection has been marked as complete for adding.</source>
          <target state="translated">Viene indicato se questa raccolta è stata contrassegnata come completa per l'aggiunta.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete for adding and is empty.</source>
          <target state="translated">Ottiene un valore che indica se questo oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stato contrassegnato come completo per l'aggiunta ed è vuoto.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
          <source>Whether this collection has been marked as complete for adding and is empty.</source>
          <target state="translated">Viene indicato se questa raccolta è stata contrassegnata come completa per l'aggiunta ed è vuota.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Provides an <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Fornisce un oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> per gli elementi nella raccolta.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> for the items in the collection.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> per gli elementi nella raccolta.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Unlike <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> returns a standard enumerator that does not modify the underlying collection.</source>
          <target state="translated">A differenza di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> restituisce un enumeratore standard che non modifica la raccolta sottostante.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If other threads are adding or removing elements concurrently when GetEnumerator is called, then the elements returned by the enumerator might not represent the current state of the collection.</source>
          <target state="translated">Se viene aggiunti altri thread o rimozione di elementi simultaneamente quando viene chiamato GetEnumerator, quindi gli elementi restituiti dall'enumeratore potrebbero non rappresentare lo stato corrente della raccolta.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Matrice unidimensionale che è la destinazione degli elementi copiati dall'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">La matrice deve avere un'indicizzazione in base zero.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Indice in base zero in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> in corrispondenza del quale ha inizio la copia.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>Copies all of the items in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance to a compatible one-dimensional array, starting at the specified index of the target array.</source>
          <target state="translated">Copia tutti gli elementi dell'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in una matrice unidimensionale compatibile, a partire dall'indice specificato della matrice di destinazione.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="array" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="array" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is less than zero.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="index" /&gt;</ph> argument is equal to or greater than the length of the <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, the array is multidimensional, or the type parameter for the collection cannot be cast automatically to the type of the destination array.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="index" /&gt;</ph> è uguale a o più grande della lunghezza di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, la matrice è multidimensionale o non può essere eseguito automaticamente il cast al tipo della matrice di destinazione del parametro di tipo per l'insieme.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> is synchronized.</source>
          <target state="translated">Ottiene un valore che indica se l'accesso all'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> è sincronizzato.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
          <source>always returns false.</source>
          <target state="translated">Restituisce sempre false.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</source>
          <target state="translated">Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>This property is not supported.</source>
          <target state="translated">Questa proprietà non è supportata.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>returns null.</source>
          <target state="translated">Restituisce null.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
          <source>The SyncRoot property is not supported.</source>
          <target state="translated">La proprietà SyncRoot non è supportata.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Provides an <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for items in the collection.</source>
          <target state="translated">Fornisce un oggetto <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> per gli elementi nella raccolta.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the items in the collection.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> per gli elementi nella raccolta.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Removes an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Rimuove un elemento da <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>Removes  an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Rimuove un elemento da <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The item removed from the collection.</source>
          <target state="translated">Elemento rimosso dalla raccolta.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>A call to <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> may block until an item is available to be removed.</source>
          <target state="translated">Una chiamata a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> venga bloccata finché non è disponibile un elemento da rimuovere.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Quando si crea un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, è possibile specificare il tipo di raccolta da utilizzare.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Ad esempio, è possibile specificare un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> per il comportamento FIFO (First In, First Out) o un oggetto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> per il comportamento LIFO (Last In, First Out).</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">Il tipo di raccolta predefinito per <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance, or the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> is empty and the collection has been marked as complete for adding.</source>
          <target state="translated">L'insieme sottostante è stato modificato all'esterno di questa istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> o <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è vuoto e l'insieme è stato contrassegnato come completo per l'aggiunta.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>Object that can be used to cancel the take operation.</source>
          <target state="translated">Oggetto che può essere usato per annullare l'operazione di prelevamento.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>Removes an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Rimuove un elemento da <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The item removed from the collection.</source>
          <target state="translated">Elemento rimosso dalla raccolta.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>A call to <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> may block until an item is available to be removed or the token is canceled.</source>
          <target state="translated">Una chiamata a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A&gt;</ph> venga bloccata finché non è disponibile per essere rimosso un elemento o il token viene annullato.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Quando si crea un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, è possibile specificare il tipo di raccolta da utilizzare.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Ad esempio, è possibile specificare un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> per il comportamento FIFO (First In, First Out) o un oggetto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> per il comportamento LIFO (Last In, First Out).</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">Il tipo di raccolta predefinito per <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> viene annullato.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token was canceled.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stato eliminato o è stato annullato l'oggetto <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> che aveva creato il token.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance or the BlockingCollection is marked as complete for adding, or the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> is empty.</source>
          <target state="translated">L'insieme sottostante è stato modificato al di fuori di questa istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> o BlockingCollection è contrassegnato come completo per l'aggiunta o <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è vuoto.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Takes an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Preleva un elemento da una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> specificate.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento rimosso da una delle raccolte.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>Takes an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Preleva un elemento da una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> specificate.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da cui è stato rimosso l'elemento.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>A call to TakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una chiamata a TakeFromAny venga venga bloccata finché non è disponibile un elemento da rimuovere.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Almeno una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element or <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> has been called on the collection.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 o contiene un elemento null o <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> è stato chiamato nell'insieme.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento rimosso da una delle raccolte.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token di annullamento da osservare.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>Takes an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances while observing the specified cancellation token.</source>
          <target state="translated">Preleva un elemento da una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> specificate considerando il token di annullamento specificato.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da cui è stato rimosso l'elemento.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>A call to TakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una chiamata a TakeFromAny venga venga bloccata finché non è disponibile un elemento da rimuovere.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The method will return early with an OperationCanceledException if the token is canceled.</source>
          <target state="translated">Il metodo restituirà all'inizio con un oggetto OperationCanceledException se il token viene annullato.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> viene annullato.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> has been called on the collection.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 o contiene un elemento null o <ph id="ph2">&lt;see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /&gt;</ph> è stato chiamato nell'insieme.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Almeno una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>Copies the items from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance into a new array.</source>
          <target state="translated">Copia gli elementi dall'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in una nuova matrice.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>An array containing copies of the elements of the collection.</source>
          <target state="translated">Matrice che contiene copie degli elementi della raccolta.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>The copied elements are not removed from the collection.</source>
          <target state="translated">Gli elementi copiati non vengono rimossi dalla raccolta.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>If any method in BlockingCollection is executing while the ToArray method executes, the return value is approximate.</source>
          <target state="translated">Se tutti i metodi BlockingCollection sono in esecuzione mentre il metodo ToArray, il valore restituito è approssimativo.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>ToArray  may include items that have already been removed, or exclude items that have already been inserted.</source>
          <target state="translated">ToArray può includere elementi che sono già stati rimossi o escludere gli elementi che sono già stati inseriti.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Prova ad aggiungere l'elemento specificato a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento da aggiungere alla raccolta.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Prova ad aggiungere l'elemento specificato a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>true if <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added; otherwise false.</source>
          <target state="translated">true se è possibile aggiungere <ph id="ph1">&lt;paramref name="item" /&gt;</ph>; in caso contrario, false.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>If the item is a duplicate, and the underlying collection does not accept duplicate items, then an <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> is thrown.</source>
          <target state="translated">Se l'elemento è un duplicato e la raccolta sottostante non accetta elementi duplicati, viene generato un oggetto <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>If the collection is a bounded collection, and is full, this method immediately returns false without adding the item.</source>
          <target state="translated">Se la raccolta è una raccolta limitata ed è completa, questo metodo restituisce immediatamente false senza aggiungere l'elemento.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stato contrassegnato come completo in relazione alle aggiunte.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La raccolta sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento da aggiungere alla raccolta.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> within the specified time period.</source>
          <target state="translated">Prova ad aggiungere l'elemento specificato a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> nel periodo di tempo specificato.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>true if the <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added to the collection within the specified time; otherwise, false.</source>
          <target state="translated">true se è stato possibile aggiungere <ph id="ph1">&lt;paramref name="item" /&gt;</ph> alla raccolta entro il tempo specificato; in caso contrario, false.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>If the item is a duplicate, and the underlying collection does not accept duplicate items, then an <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> is thrown.</source>
          <target state="translated">Se l'elemento è un duplicato e la raccolta sottostante non accetta elementi duplicati, viene generato un oggetto <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stato contrassegnato come completo in relazione alle aggiunte.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La raccolta sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento da aggiungere alla raccolta.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> che rappresenta il numero di millisecondi di attesa oppure <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> che rappresenta -1 millisecondi per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Prova ad aggiungere l'elemento specificato a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>true if the <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added to the collection within the specified time span; otherwise, false.</source>
          <target state="translated">true se è stato possibile aggiungere <ph id="ph1">&lt;paramref name="item" /&gt;</ph> alla raccolta nell'intervallo di tempo specificato; in caso contrario, false.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stato contrassegnato come completo in relazione alle aggiunte.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La raccolta sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The item to be added to the collection.</source>
          <target state="translated">Elemento da aggiungere alla raccolta.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token di annullamento da osservare.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to add the specified item to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> within the specified time period, while observing a cancellation token.</source>
          <target state="translated">Prova ad aggiungere l'elemento specificato a <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> nel periodo di tempo specificato, considerando un token di annullamento.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>true if the <ph id="ph1">&lt;paramref name="item" /&gt;</ph> could be added to the collection within the specified time; otherwise, false.</source>
          <target state="translated">true se è stato possibile aggiungere <ph id="ph1">&lt;paramref name="item" /&gt;</ph> alla raccolta entro il tempo specificato; in caso contrario, false.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>If the item is a duplicate, and the underlying collection does not accept duplicate items, then an <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> is thrown.</source>
          <target state="translated">Se l'elemento è un duplicato e la raccolta sottostante non accetta elementi duplicati, viene generato un oggetto <ph id="ph1">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> viene annullato.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the underlying <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> has been disposed.</source>
          <target state="translated">È stato eliminato <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> o l'oggetto <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> sottostante.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been marked as complete with regards to additions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stato contrassegnato come completo in relazione alle aggiunte.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
          <source>The underlying collection didn't accept the item.</source>
          <target state="translated">La raccolta sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Prova ad aggiungere l'elemento specificato a una delle istanze specifiche di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento da aggiungere a una delle raccolte.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Prova ad aggiungere l'elemento specificato a una delle istanze specifiche di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> cui è stato aggiunto l'elemento o -1 se non è stato possibile aggiungere l'elemento.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Almeno una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Almeno un insieme sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento da aggiungere a una delle raccolte.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Prova ad aggiungere l'elemento specificato a una delle istanze specifiche di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> cui è stato aggiunto l'elemento o -1 se non è stato possibile aggiungere l'elemento.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Almeno una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Almeno un insieme sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento da aggiungere a una delle raccolte.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> che rappresenta il numero di millisecondi di attesa oppure <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> che rappresenta -1 millisecondi per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances while observing the specified cancellation token.</source>
          <target state="translated">Prova ad aggiungere l'elemento specificato a una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> specificate considerando il token di annullamento specificato.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> cui è stato aggiunto l'elemento o -1 se non è stato possibile aggiungere l'elemento.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>This method can return early if the cancellationToken is cancelled before space was available for the Add operation.</source>
          <target state="translated">Questo metodo può restituire in anticipo se cancellationToken è stato annullato prima lo spazio disponibile per l'operazione di aggiunta.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances or the <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> has been disposed.</source>
          <target state="translated">Almeno una delle istanze <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> o <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> che hanno creato <ph id="ph3">&lt;paramref name="cancellationToken" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Almeno un insieme sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The item to be added to one of the collections.</source>
          <target state="translated">Elemento da aggiungere a una delle raccolte.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token di annullamento da osservare.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to add the specified item to any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Prova ad aggiungere l'elemento specificato a una delle istanze specifiche di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array to which the item was added, or -1 if the item could not be added.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> cui è stato aggiunto l'elemento o -1 se non è stato possibile aggiungere l'elemento.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> viene annullato.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>At least one underlying collection didn't accept the item.</source>
          <target state="translated">Almeno un insieme sottostante non ha accettato l'elemento.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element, or at least one of collections has been marked as complete for adding.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 o contiene un elemento null o almeno uno degli insiemi è stato contrassegnato come completo per l'aggiunta.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Almeno una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Prova a rimuovere un elemento da <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il metodo <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">Elemento da rimuovere dalla raccolta.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</source>
          <target state="translated">Prova a rimuovere un elemento da <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se un elemento può essere eliminato; altrimenti, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>If the collection is empty, this method immediately returns false.</source>
          <target state="translated">Se la raccolta è vuota, questo metodo restituisce immediatamente false.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Quando si crea un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, è possibile specificare il tipo di raccolta da utilizzare.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Ad esempio, è possibile specificare un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> per il comportamento FIFO (First In, First Out) o un oggetto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> per il comportamento LIFO (Last In, First Out).</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">Il tipo di raccolta predefinito per <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">L'insieme sottostante è stato modificato all'esterno di questa istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">Elemento da rimuovere dalla raccolta.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in the specified time period.</source>
          <target state="translated">Prova rimuovere un elemento da <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> entro il periodo di tempo specificato.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed from the collection within the specified  time; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">È <ph id="ph1">&lt;see langword="true" /&gt;</ph> se è stato possibile rimuovere un elemento dalla raccolta nel tempo specificato; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, you can specify the type of collection to use.</source>
          <target state="translated">Quando si crea un <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, è possibile specificare il tipo di raccolta da utilizzare.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Ad esempio, è possibile specificare un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> per il comportamento FIFO (First In, First Out) o un oggetto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> per il comportamento LIFO (Last In, First Out).</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">Il tipo di raccolta predefinito per <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">L'insieme sottostante è stato modificato all'esterno di questa istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">Elemento da rimuovere dalla raccolta.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>An object that represents the number of milliseconds to wait, or an object that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Oggetto che rappresenta il numero di millisecondi di attesa oppure un oggetto che rappresenta -1 millisecondi per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in the specified time period.</source>
          <target state="translated">Prova rimuovere un elemento da <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> entro il periodo di tempo specificato.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed from the collection within the specified  time; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">È <ph id="ph1">&lt;see langword="true" /&gt;</ph> se è stato possibile rimuovere un elemento dalla raccolta nel tempo specificato; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Quando si crea un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, è possibile specificare il tipo di raccolta da utilizzare.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Ad esempio, è possibile specificare un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> per il comportamento FIFO (First In, First Out) o un oggetto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> per il comportamento LIFO (Last In, First Out).</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">Il tipo di raccolta predefinito per <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed.</source>
          <target state="translated">L'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è maggiore di <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
          <source>The underlying collection was modified outside of this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">L'insieme sottostante è stato modificato all'esterno di questa istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The item to be removed from the collection.</source>
          <target state="translated">Elemento da rimuovere dalla raccolta.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token di annullamento da osservare.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to remove an item from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> in the specified time period while observing a cancellation token.</source>
          <target state="translated">Prova a rimuovere un elemento da <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> nel periodo di tempo specificato, considerando un token di annullamento.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if an item could be removed from the collection within the specified  time; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">È <ph id="ph1">&lt;see langword="true" /&gt;</ph> se è stato possibile rimuovere un elemento dalla raccolta nel tempo specificato; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The order in which an item is removed depends on the type of collection used to create the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> instance.</source>
          <target state="translated">L'ordine in cui un elemento viene rimosso dipende dal tipo di raccolta utilizzato per creare l'istanza di <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>When you create a <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> object, you can specify the type of collection to use.</source>
          <target state="translated">Quando si crea un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph>, è possibile specificare il tipo di raccolta da utilizzare.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>For example, you could specify a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> object for first in, first out (FIFO) behavior, or a <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> object for last in, first out (LIFO) behavior.</source>
          <target state="translated">Ad esempio, è possibile specificare un oggetto <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> per il comportamento FIFO (First In, First Out) o un oggetto <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> per il comportamento LIFO (Last In, First Out).</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>You can use any collection class that implements the <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> interface.</source>
          <target state="translated">È possibile usare qualsiasi classe di raccolta che implementa l'interfaccia <ph id="ph1">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The default collection type for <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> is <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</source>
          <target state="translated">Il tipo di raccolta predefinito per <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> è <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has been canceled.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> annullata.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> has been disposed or the underlying <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> has been disposed.</source>
          <target state="translated">È stato eliminato <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> o l'oggetto <ph id="ph2">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> sottostante.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The underlying collection was modified outside this <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">La raccolta sottostante è stata modificata all'esterno di questa istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.BlockingCollection`1">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Prova a rimuovere un elemento da una delle istanze specifiche di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento rimosso da una delle raccolte.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Prova a rimuovere un elemento da una delle istanze specifiche di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da cui è stato rimosso l'elemento o -1 se non è stato possibile rimuovere un elemento.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una chiamata a TryTakeFromAny venga venga bloccata finché non è disponibile un elemento da rimuovere.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType&gt;</ph> method:</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType&gt;</ph> metodo:</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Almeno una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 matrice o contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento rimosso da una delle raccolte.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Prova a rimuovere un elemento da una delle istanze specifiche di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da cui è stato rimosso l'elemento o -1 se non è stato possibile rimuovere un elemento.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una chiamata a TryTakeFromAny venga venga bloccata finché non è disponibile un elemento da rimuovere.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Almeno una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 matrice o contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento rimosso da una delle raccolte.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> che rappresenta il numero di millisecondi di attesa oppure <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> che rappresenta -1 millisecondi per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Prova a rimuovere un elemento da una delle istanze specifiche di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da cui è stato rimosso l'elemento o -1 se non è stato possibile rimuovere un elemento.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una chiamata a TryTakeFromAny venga venga bloccata finché non è disponibile un elemento da rimuovere.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Almeno una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è un numero negativo diverso da -1 millisecondi che rappresenta un timeout infinito - o - il timeout è più grande di <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 matrice o contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The array of collections.</source>
          <target state="translated">Matrice di raccolte.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The item removed from one of the collections.</source>
          <target state="translated">Elemento rimosso da una delle raccolte.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe.</source>
          <target state="translated">Token di annullamento da osservare.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>Tries to remove an item from any one of the specified <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances.</source>
          <target state="translated">Prova a rimuovere un elemento da una delle istanze specifiche di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The index of the collection in the <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> array from which the item was removed, or -1 if an item could not be removed.</source>
          <target state="translated">Indice della raccolta nella matrice <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> da cui è stato rimosso l'elemento o -1 se non è stato possibile rimuovere un elemento.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>A call to TryTakeFromAny may block until an item is available to be removed.</source>
          <target state="translated">Una chiamata a TryTakeFromAny venga venga bloccata finché non è disponibile un elemento da rimuovere.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> is canceled.</source>
          <target state="translated">Se <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> viene annullato.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the underlying collections was modified outside of its <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instance.</source>
          <target state="translated">Almeno uno degli insiemi sottostanti è stato modificato all'esterno dell'istanza di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is null.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è Null.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The count of <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> is greater than the maximum size of 62 for STA and 63 for MTA.</source>
          <target state="translated">Il conteggio di <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è più grande della dimensione massima di 62 per STA e 63 per MTA.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> argument is a 0-length array or contains a null element.</source>
          <target state="translated">L'argomento <ph id="ph1">&lt;paramref name="collections" /&gt;</ph> è una matrice di lunghezza 0 matrice o contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> instances has been disposed.</source>
          <target state="translated">Almeno una delle istanze di <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.BlockingCollection`1" /&gt;</ph> è stata eliminata.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>