<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="89381694149c6783ea59e91d2ae890826502a5b5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610595" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Incapsula tutte le informazioni specifiche di HTTP relative a una singola richiesta HTTP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che ereditano la <xref:System.Web.IHttpModule> e <xref:System.Web.IHttpHandler> interfacce vengono fornite un riferimento a un <xref:System.Web.HttpContext> oggetto per la richiesta HTTP corrente. L'oggetto fornisce accesso alle proprietà intrinseche <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>, e <xref:System.Web.HttpContext.Server%2A> proprietà per la richiesta.  
  
   
  
## Examples  
 Un progetto di sito Web di Visual Studio con codice sorgente è disponibile a complemento di questo argomento: [scaricare](http://go.microsoft.com/fwlink/?LinkId=192422).  
  
 Nell'esempio riportato di seguito viene illustrato come accedere e visualizzare le proprietà del <xref:System.Web.HttpContext> oggetto. Il contesto della richiesta HTTP corrente è accessibile usando il <xref:System.Web.UI.Page.Context%2A> proprietà del <xref:System.Web.UI.Page> oggetto.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Web.HttpContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">Oggetto <see cref="T:System.Web.HttpWorkerRequest" /> relativo alla richiesta HTTP corrente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Web.HttpContext" /> che usa l'oggetto richiesta di lavoro specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">Oggetto <see cref="T:System.Web.HttpRequest" /> relativo alla richiesta HTTP corrente.</param>
        <param name="response">Oggetto <see cref="T:System.Web.HttpResponse" /> relativo alla richiesta HTTP corrente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Web.HttpContext" /> usando gli oggetti richiesta e risposta specificati.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accetta una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">Funzione utente.</param>
        <summary>Accetta una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> con la funzione utente specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo è equivalente alla chiamata di <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> overload del metodo e passando `null` per il `options` parametro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="userFunc" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La richiesta non è una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">Funzione utente.</param>
        <param name="options">Oggetto delle opzioni.</param>
        <summary>Accetta una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> con la funzione utente specificata e l'oggetto delle opzioni.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="userFunc" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La richiesta non è una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">Oggetto <see cref="T:System.Exception" /> da aggiungere alla raccolta di eccezioni.</param>
        <summary>Aggiunge un'eccezione alla raccolta di eccezioni per la richiesta HTTP corrente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Oggetto di contesto HTTP.</param>
        <summary>Genera un evento virtuale che si verifica quando la parte HTTP della richiesta sta terminando.</summary>
        <returns>Token della sottoscrizione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento si verifica prima di <xref:System.Web.WebSockets.AspNetWebSocket> connessione ha inizio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="callback" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce una matrice degli errori accumulati durante l'elaborazione di una richiesta HTTP.</summary>
        <value>Matrice di oggetti <see cref="T:System.Exception" /> relativa alla richiesta HTTP corrente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se le operazioni asincrone sono consentite durante l'elaborazione delle parti della richiesta ASP.NET quando non sono previste.</summary>
        <value>
          <see langword="false" /> se ASP.NET genera un'eccezione quando l'API asincrona viene usata in un momento in cui non è prevista; in caso contrario, <see langword="true" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo flag non è impostato su `true`, ASP.NET genera un'eccezione quando viene rilevato l'applicazione impropriamente le API asincrone. Ciò può verificarsi se si tenta di chiamare un metodo asincrono durante una parte della richiesta di pipeline di elaborazione in cui le operazioni asincrone non sono previsti o se è ancora in attesa di lavoro asincrono quando un modulo asincrono o un gestore segnala il completamento. Questo comportamento è considerato come una rete di protezione consentono di sapere in anticipo se si scrive codice asincrono che non si adatta schemi previsti e può avere effetti collaterali negativi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.HttpApplicationState" /> relativo alla richiesta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpApplicationState" /> per la richiesta HTTP corrente.  
  
 Per ottenere l'oggetto <see cref="T:System.Web.HttpApplication" /> per la richiesta HTTP corrente, usare <see cref="P:System.Web.HttpContext.ApplicationInstance" />. ASP.NET usa <see langword="ApplicationInstance" /> anziché <see langword="Application" /> come nome di proprietà per fare riferimento all'istanza corrente di <see cref="T:System.Web.HttpApplication" /> per evitare confusione tra ASP.NET e ASP classico. In ASP classico <see langword="Application" /> fa riferimento al dizionario di stato globale dell'applicazione.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Web.HttpApplication" /> relativo alla richiesta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpApplication" /> per la richiesta HTTP corrente.  
  
 ASP.NET usa <see langword="ApplicationInstance" /> anziché <see langword="Application" /> come nome di proprietà per fare riferimento all'istanza corrente di <see cref="T:System.Web.HttpApplication" /> per evitare confusione tra ASP.NET e ASP classico. In ASP classico <see langword="Application" /> fa riferimento al dizionario di stato globale dell'applicazione.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">L'applicazione Web è in esecuzione in IIS 7.0 in modalità integrata e tenta di cambiare il valore della proprietà da un valore non Null a <see langword="null" />.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto che contiene i flag relativi alla modalità di precaricamento asincrona.</summary>
        <value>Oggetto che contiene i flag relativi alla modalità di precaricamento asincrona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La prima volta che si accede a questa proprietà, da cui viene caricato l'oggetto che contiene i flag per la modalità di precaricamento asincrona di <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> impostazione nel file di configurazione.  
  
 Sebbene questa proprietà possa essere impostata a livello di codice, la modifica del valore della proprietà ha effetto solo se la proprietà viene impostata prima del passaggio `ExecuteRequestHandler` nella pipeline delle richieste ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.Caching.Cache" /> per il dominio dell'applicazione corrente.</summary>
        <value>Classe <see cref="T:System.Web.Caching.Cache" /> per il dominio dell'applicazione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istanza di è presente la <xref:System.Web.Caching.Cache> classe per il dominio applicazione. Di conseguenza, il <xref:System.Web.Caching.Cache> oggetto restituito dal <xref:System.Web.HttpContext.Cache%2A> proprietà è di <xref:System.Web.Caching.Cache> oggetto per tutte le richieste nel dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella tutti gli errori relativi alla richiesta HTTP corrente.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Web.HttpContext" /> relativo alla richiesta HTTP corrente.</summary>
        <value>L'istanza <see cref="T:System.Web.HttpContext" /> per la richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è una proprietà statica del <xref:System.Web.HttpContext> classe. Gli archivi delle proprietà di <xref:System.Web.HttpContext> istanza che si applica alla richiesta corrente. Le proprietà di questa istanza sono le proprietà statiche della <xref:System.Web.HttpContext> classe.  
  
 È inoltre possibile utilizzare il <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> proprietà a cui accedere il <xref:System.Web.HttpContext> oggetto per la richiesta HTTP corrente.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Web.HttpContext.Current%2A> proprietà a cui accedere il <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> e <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> metodi e <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> proprietà. L'esempio crea tre eccezioni personalizzate tramite il <xref:System.Web.HttpContext.AddError%2A> metodo e viene utilizzato il <xref:System.Web.HttpContext.AllErrors%2A> proprietà per caricare queste eccezioni in una matrice. Quindi scrive la matrice alla pagina contenente e utilizza il <xref:System.Web.HttpContext.ClearError%2A> metodo per cancellare tutti gli errori del <xref:System.Web.UI.Page.Context%2A> proprietà.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.IHttpHandler" /> che rappresenta il gestore attualmente in esecuzione.</summary>
        <value>
          <see cref="T:System.Web.IHttpHandler" /> rappresenta il gestore attualmente in esecuzione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il gestore attualmente in esecuzione che fa riferimento il <xref:System.Web.HttpContext.CurrentHandler%2A> proprietà potrebbe essere diversa dal gestore a cui fa riferimento il <xref:System.Web.HttpContext.Handler%2A> proprietà. Ciò può verificarsi quando un altro gestore è stato richiesto tramite il <xref:System.Web.HttpServerUtility.Execute%2A> metodo o <xref:System.Web.HttpServerUtility.Transfer%2A> metodo. Al termine dell'elaborazione il gestore attualmente in esecuzione, viene ripristinato il gestore determinato in precedenza.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Web.RequestNotification" /> che indica l'evento <see cref="T:System.Web.HttpApplication" /> attualmente in elaborazione.</summary>
        <value>Uno dei valori di <see cref="T:System.Web.RequestNotification" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà richiede la modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e almeno .NET Framework versione 3.0. Quando è disponibile, la proprietà restituisce un <xref:System.Web.RequestNotification> valore. Il valore di <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà indica quale evento nel <xref:System.Web.HttpApplication> istanza sta elaborando la richiesta.  
  
 Il <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà non deve essere impostata. Al contrario, l'impostazione è [!INCLUDE[iisver](~/includes/iisver-md.md)] durante l'elaborazione della richiesta nella pipeline ASP.NET. L'impostazione di <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà comporterà un errore di compilazione.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> è stato introdotto in .NET Framework versione 3.5.  Per altre informazioni, vedere [Versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà per determinare quali eventi del <xref:System.Web.HttpApplication> l'elaborazione di oggetto che gestisce la richiesta corrente. Nell'esempio, il gestore eventi gestisce diversi eventi del <xref:System.Web.HttpApplication> oggetto e <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà determina il codice richiamato per ogni evento da gestire.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L'operazione richiede una modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e .NET Framework versione 3.0 o successiva.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">Oggetto il cui metodo <see cref="M:System.IDisposable.Dispose" /> deve essere chiamato quando la parte della connessione <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> della richiesta viene completata.</param>
        <summary>Consente di chiamare il metodo <see cref="M:System.IDisposable.Dispose" /> di un oggetto quando la parte della connessione <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> della richiesta viene completata.</summary>
        <returns>Token della sottoscrizione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IDisposable.Dispose%2A> dell'oggetto di destinazione viene chiamato dopo entrambi la parte HTTP della richiesta e <xref:System.Web.WebSockets.AspNetWebSocket> connessione è stata interrotta. Il <xref:System.Web.HttpContext> oggetto non è disponibile per l'ispezione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce il primo errore, se presente, accumulato durante l'elaborazione di una richiesta HTTP.</summary>
        <value>Il primo oggetto <see cref="T:System.Exception" /> per il processo di richiesta/risposta HTTP corrente; in caso contrario, <see langword="null" /> se non sono stati accumulati errori durante l'elaborazione della richiesta HTTP. Il valore predefinito è <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Tag di configurazione dell'applicazione per cui sono state richieste informazioni.</param>
        <summary>Restituisce le informazioni sulla configurazione richieste per l'applicazione in uso.</summary>
        <returns>Oggetto contenente le informazioni sulla configurazione. Eseguire il cast della sezione di configurazione restituita al tipo di configurazione appropriato prima dell'uso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Web.HttpContext.GetAppConfig%2A> è stato deprecato. Utilizzare il <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> metodo la <xref:System.Web.Configuration.WebConfigurationManager> classe per ottenere informazioni di configurazione per l'applicazione corrente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Tag di configurazione per cui sono state richieste informazioni.</param>
        <summary>Restituisce le informazioni sulla configurazione relative alla richiesta HTTP corrente.</summary>
        <returns>Oggetto <see cref="T:System.Configuration.ConfigurationSection" /> specificato, <see langword="null" /> se la sezione non esiste o oggetto interno se la sezione non risulta accessibile in fase di esecuzione. Eseguire il cast dell'oggetto restituito al tipo di configurazione appropriato prima dell'uso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Web.HttpContext.GetConfig%2A> è stato deprecato. Utilizzare il <xref:System.Web.HttpContext.GetSection%2A> metodo per ottenere informazioni di configurazione per la richiesta HTTP corrente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene una risorsa a livello di applicazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">Stringa che rappresenta la proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> dell'oggetto risorsa richiesto.</param>
        <param name="resourceKey">Stringa che rappresenta la proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> dell'oggetto risorsa richiesto.</param>
        <summary>Ottiene un oggetto risorsa a livello di applicazione basato sulle proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> specificate.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che rappresenta l'oggetto risorsa a livello di applicazione richiesto; in caso contrario, Null se non viene individuato alcun oggetto risorsa o se ne viene trovato uno che tuttavia non presenta la proprietà richiesta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> metodo restituisce una risorsa globale utilizzando le impostazioni cultura specificati nel <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> proprietà.  
  
> [!NOTE]
>  La modifica in alcuni ambienti, ad esempio [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], l'editor potrebbe generare in fase di progettazione <xref:System.Resources.MissingManifestResourceException> eccezione se si utilizza un punto (.) nel nome della chiave di risorsa globale. Tuttavia, questa operazione non influenza la possibilità di modificare o salvare il file, ed è possibile ignorare l'errore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Non è stato trovato un oggetto risorsa con il parametro <paramref name="classKey" /> specificato.  
  
 \- oppure -  
  
 L'assembly principale non contiene le risorse indipendenti dalle impostazioni cultura e queste risorse sono obbligatorie perché l'assembly satellite adatto è mancante.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">Stringa che rappresenta la proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> dell'oggetto risorsa richiesto.</param>
        <param name="resourceKey">Stringa che rappresenta una proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> dell'oggetto risorsa richiesto.</param>
        <param name="culture">Stringa che rappresenta l'oggetto <see cref="T:System.Globalization.CultureInfo" /> della risorsa richiesta.</param>
        <summary>Ottiene un oggetto risorsa a livello di applicazione basato sulle proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> specificate e sull'oggetto <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che rappresenta l'oggetto della risorsa a livello di applicazione richiesta, che è localizzato in base alle impostazioni cultura specificate; in caso contrario, <see langword="null" /> se non viene individuato alcun oggetto della risorsa o se ne viene trovato uno che tuttavia non presenta la proprietà richiesta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Globalization.CultureInfo> oggetto rappresenta le impostazioni cultura per cui è stata localizzata la risorsa. Se la risorsa non viene localizzata con queste impostazioni cultura, la ricerca verrà completato un processo di fallback per individuare una risorsa appropriata. Per altre informazioni, vedere [Creazione del pacchetto e distribuzione delle risorse](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  In alcuni ambienti di modifica, ad esempio Visual Web Developer, l'editor potrebbe generare in fase di progettazione <xref:System.Resources.MissingManifestResourceException> eccezione se si utilizza un punto (.) nel nome della chiave di risorsa globale. Tuttavia, questa operazione non influenza la possibilità di modificare o salvare il file, ed è possibile ignorare l'errore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Un oggetto risorsa per il quale non è stato trovato il parametro <paramref name="classKey" /> specificato.  
  
 \- oppure -  
  
 L'assembly principale non contiene le risorse indipendenti dalle impostazioni cultura e queste risorse sono obbligatorie perché l'assembly satellite adatto è mancante.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene una risorsa a livello di pagina.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Proprietà <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> per l'oggetto della risorsa locale.</param>
        <param name="resourceKey">Stringa che rappresenta una proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> dell'oggetto risorsa richiesto</param>
        <summary>Ottiene un oggetto della risorsa a livello di pagina basato sulle proprietà <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> specificate.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che rappresenta l'oggetto della risorsa a livello di pagina richiesta; in caso contrario, <see langword="null" /> se viene trovato un oggetto della risorsa corrispondente, ma non il parametro <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.GetLocalResourceObject%2A> metodo restituisce una risorsa locale utilizzando le impostazioni cultura specificati nel <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Non è stato trovato un oggetto risorsa per il parametro <paramref name="virtualPath" /> specificato.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="virtualPath" /> specificato non si trova nella directory radice dell'applicazione corrente.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stata trovata la classe di risorse per la pagina.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Proprietà <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> per l'oggetto della risorsa locale.</param>
        <param name="resourceKey">Stringa che rappresenta una proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> dell'oggetto risorsa richiesto.</param>
        <param name="culture">Stringa che rappresenta l'oggetto <see cref="T:System.Globalization.CultureInfo" /> dell'oggetto della risorsa richiesta.</param>
        <summary>Ottiene un oggetto della risorsa a livello di pagina basato sulle proprietà <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> specificate e sull'oggetto <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che rappresenta l'oggetto della risorsa locale richiesta, localizzato per le impostazioni cultura specificate; in caso contrario, <see langword="null" /> se viene individuato un oggetto della risorsa corrispondente, ma non il parametro <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la risorsa non viene localizzata con queste impostazioni cultura, la ricerca verrà completato un processo di fallback per individuare una risorsa appropriata. Per altre informazioni, vedere [Creazione del pacchetto e distribuzione delle risorse](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Non è stato trovato un oggetto risorsa per il parametro <paramref name="virtualPath" /> specificato.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="virtualPath" /> specificato non si trova nella directory radice dell'applicazione corrente.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stata trovata la classe di risorse per la pagina.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Percorso della sezione di configurazione (in formato XPath) e nome dell'elemento di configurazione.</param>
        <summary>Ottiene una sezione di configurazione specificata per la configurazione predefinita dell'applicazione corrente.</summary>
        <returns>Oggetto <see cref="T:System.Configuration.ConfigurationSection" /> specificato, <see langword="null" /> se la sezione non esiste o oggetto interno se la sezione non risulta accessibile in fase di esecuzione.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Web.IHttpHandler" /> responsabile dell'elaborazione della richiesta HTTP.</summary>
        <value>Oggetto <see cref="T:System.Web.IHttpHandler" /> responsabile dell'elaborazione della richiesta HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.Handler%2A> proprietà contiene un riferimento al gestore che elabora la richiesta HTTP. Il gestore può essere specificato tramite l'elemento oppure utilizzando un gestore personalizzato definito nel codice utente. Per ulteriori informazioni sui gestori eventi, vedere [gestori HTTP e moduli HTTP Overview](http://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 Il riferimento di <xref:System.Web.HttpContext.Handler%2A> proprietà rimarranno invariati anche dopo la pagina corrente è stata modificata da un metodo sul lato server, ad esempio il <xref:System.Web.HttpServerUtility.Execute%2A> (metodo) o <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un valore che indica se gli errori personalizzati sono stati attivati per la richiesta HTTP corrente.</summary>
        <value>
          <see langword="true" /> se gli errori personalizzati sono attivati; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un valore che indica se la richiesta HTTP corrente è in modalità di debug.</summary>
        <value>
          <see langword="true" /> se la richiesta è in modalità di debug; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che rappresenta il punto di elaborazione corrente nella pipeline ASP.NET subito dopo il completamento dell'elaborazione di un evento <see cref="T:System.Web.HttpApplication" />.</summary>
        <value>
          <see langword="true" /> se gli errori personalizzati sono attivati; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà è supportata solo con la modalità integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e almeno .NET Framework 3.0. Quando è disponibile, la proprietà restituisce un valore booleano che indica se un evento di <xref:System.Web.HttpApplication> oggetto ha terminato l'elaborazione.  
  
 Il <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà non deve essere impostata. Al contrario, viene fornito da [!INCLUDE[iisver](~/includes/iisver-md.md)] al runtime di ASP.NET per ogni notifica. L'impostazione di <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà comporterà un errore di compilazione.  
  
 Negli scenari in cui più eventi del <xref:System.Web.HttpApplication> oggetto vengono gestiti da un gestore eventi, è possibile utilizzare il <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà in combinazione con il <xref:System.Web.RequestNotification> enumerazione per determinare con precisione in ciclo di vita dell'applicazione corrente è richiesta.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> è stato introdotto in .NET Framework versione 3.5.  Per altre informazioni, vedere [Versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà per determinare quando un evento del <xref:System.Web.HttpApplication> oggetto ha terminato l'elaborazione di tutti i gestori eventi. Il gestore dell'evento personalizzato in questo esempio gestisce molti eventi del <xref:System.Web.HttpApplication> oggetto e <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà viene utilizzata per determinare il codice richiamato dopo la gestione di un evento specifico.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L'operazione richiede una modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e in .NET Framework 3.0 o versione successiva.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la richiesta è una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>
          <see langword="true" /> se la richiesta è di tipo <see cref="T:System.Web.WebSockets.AspNetWebSocket" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce `true` se la richiesta contiene iniziale <xref:System.Web.WebSockets.AspNetWebSocket> handshake e `WebSocket` dei moduli di IIS è attivo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se si sta eseguendo l'aggiornamento della connessione da una connessione HTTP a una connessione <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>
          <see langword="true" /> se la connessione è in corso di aggiornamento; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta chiave/valore che è possibile usare per organizzare e condividere dati tra un'interfaccia <see cref="T:System.Web.IHttpModule" /> e un'interfaccia <see cref="T:System.Web.IHttpHandler" /> durante una richiesta HTTP.</summary>
        <value>Raccolta chiave/valore <see cref="T:System.Collections.IDictionary" /> che fornisce l'accesso a un singolo valore all'interno della raccolta in base a una chiave specificata.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un riferimento all'istanza del servizio di strumentazione pagina per questa richiesta.</summary>
        <value>Istanza del servizio di strumentazione pagina per questa richiesta.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.IHttpHandler" /> relativo al gestore padre.</summary>
        <value>Istanza di <see cref="T:System.Web.IHttpHandler" /> oppure <see langword="null" /> se non è stato trovato alcun gestore precedente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.PreviousHandler%2A> proprietà corrisponde all'ultimo gestore precedente è stata eseguita la richiesta corrente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.Profile.ProfileBase" /> relativo al profilo utente corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.Profile.ProfileBase" /> se il file di configurazione dell'applicazione contiene una definizione per le proprietà del profilo; in caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Web.HttpContext.Profile%2A> proprietà viene utilizzata per l'archiviazione permanente dei dati strutturati tramite un'API indipendente dai tipi. Quando un <xref:System.Web.HttpContext.Profile%2A> si accede alla proprietà, ma è presente alcun valore, viene restituita un'istanza vuota. `null` non viene restituito.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">Oggetto che deve elaborare la richiesta.</param>
        <summary>Consente di specificare un gestore per la richiesta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si imposta `handler` a `null`, il gestore predefinito viene utilizzato per elaborare la richiesta. È possibile impostare `handler` su un gestore asincrono o a un gestore sincrono. Il gestore deve implementare il <xref:System.Web.IHttpHandler> interfaccia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> è stato chiamato dopo che si è verificato l'evento <see cref="E:System.Web.HttpApplication.MapRequestHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.HttpRequest" /> relativo alla richiesta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpRequest" /> per la richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.Request%2A> proprietà fornisce l'accesso a livello di codice alle proprietà e metodi di <xref:System.Web.HttpRequest> classe. Poiché le pagine ASP.NET contengono un riferimento predefinito per il <xref:System.Web> dello spazio dei nomi (che contiene il <xref:System.Web.HttpContext> classe), è possibile fare riferimento ai membri di <xref:System.Web.HttpRequest> in una pagina aspx senza utilizzare il riferimento completo della classe <xref:System.Web.HttpContext>. Ad esempio, è possibile utilizzare `Request.Browser` per ottenere le funzionalità del browser del client. Tuttavia, se si desidera utilizzare i membri di <xref:System.Web.HttpRequest> da un modulo di code-behind ASP.NET, è necessario includere un riferimento al <xref:System.Web> spazio dei nomi in cui il modulo e un riferimento completo sia il contesto di richiesta/risposta attualmente attivo e il classe <xref:System.Web> che si desidera utilizzare. In una pagina code-behind, ad esempio, è necessario specificare il nome completo `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  ASP.NET genera un'eccezione se si tenta di utilizzare questa proprietà quando il <xref:System.Web.HttpRequest> oggetto non è disponibile. Ad esempio, questo sarà true nel metodo Application_Start del file Global. asax, o in un metodo che viene chiamato dal metodo Application_Start. In quel momento alcuna richiesta HTTP non è stato ancora creato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'applicazione Web è in esecuzione in IIS 7 in modalità integrata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.Web.HttpResponse" /> relativo alla risposta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpResponse" /> relativo alla risposta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.Response%2A> proprietà fornisce l'accesso a livello di codice alle proprietà e metodi di <xref:System.Web.HttpResponse> classe. Poiché le pagine ASP.NET contengono un riferimento predefinito per il <xref:System.Web> dello spazio dei nomi (che contiene il <xref:System.Web.HttpContext> classe), è possibile fare riferimento ai membri di <xref:System.Web.HttpContext> in una pagina aspx senza utilizzare il riferimento completo della classe <xref:System.Web.HttpContext>. Ad esempio, è possibile utilizzare `Response.Write("some output")` per scrivere l'output in un flusso di output HTTP. Tuttavia, se si desidera utilizzare i membri di <xref:System.Web.HttpResponse> da un modulo di code-behind ASP.NET, è necessario includere un riferimento al <xref:System.Web> spazio dei nomi in cui il modulo e un riferimento completo per il contesto di richiesta/risposta attualmente attivo e la classe in <xref:System.Web> che si desidera utilizzare. In una pagina code-behind, ad esempio, è necessario specificare il nome completo `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'applicazione Web è in esecuzione in IIS 7 in modalità integrata.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reindirizza una richiesta di una risorsa a un percorso diverso da quello indicato dall'URL richiesto. <see cref="Overload:System.Web.HttpContext.RewritePath" /> viene utilizzato nello stato sessione senza cookie per rimuovere ID sessione dagli URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso di riscrittura interno.</param>
        <summary>Riscrive l'URL con il percorso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.RewritePath%28System.String%29> metodo reindirizza una richiesta per una risorsa a un percorso diverso da quello indicato dall'URL richiesto. Se è necessario reimpostare il percorso virtuale in modo che le richieste dal client per le risorse del server vengano risolte correttamente, utilizzare l'overload del metodo che accetta il `rebaseClientPath` parametro e il parametro impostato su `false`.  
  
 La riscrittura URL è utile quando si desidera ristrutturare le pagine dell'applicazione Web e si desidera assicurarsi che gli utenti che hanno salvato gli URL precedenti comunque possono usarle dopo avere spostato le pagine. La riscrittura URL consente di inoltrare in modo trasparente le richieste per la nuova posizione della pagina.  
  
 Se si desidera consentire a un sito utilizzare gli URL che sono più descrittivi e ottimizzati per i motori di ricerca, un'alternativa più affidabile consiste nell'utilizzare il routing di ASP.NET. Per ulteriori informazioni, vedere [Routing ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Web.HttpContext.RewritePath%2A> metodo per consentire a un sito Web rispondere agli URL che non riflettono la struttura dei file nel sito Web. Il primo blocco di codice è una pagina Web ASP.NET denominata RewritePath. aspx. Richiede una stringa di query. Se il nome del sito è WebSite1, l'URL `http://localhost/WebSite1/RewritePath.aspx?page=1` Visualizza "Pagina 1" nel browser. Il blocco di codice che segue la pagina Web è il `Application_BeginRequest` gestore dell'evento nel file Global. asax. Questo codice intercetta le richieste per gli URL, ad esempio `http://localhost/WebSite1/page1` e li converte in formato che è necessario per RewritePath. aspx prima che vengano elaborati. Pertanto, l'URL `http://localhost/WebSite1/page1` richiama RewritePath. aspx con il parametro di stringa di query che visualizza "Pagina 1" nel browser. Se un URL, ad esempio `http://localhost/WebSite1/page1` viene ricevuto un overload di <xref:System.Web.HttpContext.RewritePath%2A> viene richiamato che consente di specificare un valore per il <xref:System.Web.HttpRequest.PathInfo%2A> parametro di stringa di proprietà, nonché una query.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Il parametro <paramref name="path" /> non si trova nella directory radice dell'applicazione corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso di riscrittura interno.</param>
        <param name="rebaseClientPath">
          <see langword="true" /> per reimpostare il percorso virtuale, <see langword="false" /> per mantenere tale percorso invariato.</param>
        <summary>Riscrive l'URL con il percorso specificato e un valore booleano che specifica se il percorso virtuale per le risorse del server è stato modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> metodo viene chiamato dal <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> metodo con il `rebaseClientPath` parametro impostato su `true`. Per assicurarsi che il percorso virtuale utilizzato per costruire i percorsi per le risorse non viene modificato, impostare il `rebaseClientPath` parametro `false`. Uno scenario comune in cui si potrebbe voler impostare `rebaseClientPath` a `false` è quando è necessario riscrivere l'URL e si utilizzano i temi e l'URL di reindirizzamento a una risorsa a cui si trova in una cartella diversa da quella della risorsa richiesta.  
  
 La riscrittura URL è utile quando si desidera ristrutturare le pagine dell'applicazione Web e si desidera assicurarsi che gli utenti che hanno salvato gli URL precedenti comunque possono usarle dopo avere spostato le pagine. La riscrittura URL consente di inoltrare in modo trasparente le richieste per la nuova posizione della pagina.  
  
 Se si desidera consentire a un sito utilizzare gli URL che sono più descrittivi e ottimizzati per i motori di ricerca, un'alternativa più affidabile consiste nell'utilizzare il routing di ASP.NET. Per ulteriori informazioni, vedere [Routing ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Per un esempio di codice, vedere il <xref:System.Web.HttpContext.RewritePath%28System.String%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Il parametro <paramref name="path" /> non si trova nella directory radice dell'applicazione corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">Percorso di riscrittura interno.</param>
        <param name="pathInfo">Informazioni aggiuntive sul percorso di una risorsa. Per ulteriori informazioni, vedere <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Stringa di query della richiesta.</param>
        <summary>Riscrive l'URL usando il percorso specificato, le informazioni sul percorso e le informazioni sulla stringa di query.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.RewritePath%2A> reindirizza una richiesta per una risorsa a un'altra risorsa senza modificare l'URL.  
  
 Il `filePath` parametro non include il `pathInfo` contenuto del parametro. Per l'URL http://www.microsoft.com/virdir/page.html/tail, il `filePath` parametro http://www.microsoft.com/virdir/page.htmle il `pathInfo` parametro è tail.  
  
 La riscrittura URL è utile quando si desidera ristrutturare le pagine dell'applicazione Web e si desidera assicurarsi che gli utenti che hanno salvato gli URL precedenti comunque possono usarle dopo avere spostato le pagine. La riscrittura URL consente di inoltrare in modo trasparente le richieste per la nuova posizione della pagina.  
  
 Se si desidera consentire a un sito utilizzare gli URL che sono più descrittivi e ottimizzati per i motori di ricerca, un'alternativa più affidabile consiste nell'utilizzare il routing di ASP.NET. Per ulteriori informazioni, vedere [Routing ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Per un esempio di codice, incluso un esempio di questo overload del metodo, vedere il <xref:System.Web.HttpContext.RewritePath%28System.String%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="path" /> non si trova nella directory radice dell'applicazione corrente.</exception>
        <exception cref="T:System.Web.HttpException">Il parametro <paramref name="filePath" /> non si trova nella directory radice dell'applicazione corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">Il percorso virtuale alla risorsa che gestisce la richiesta.</param>
        <param name="pathInfo">Informazioni aggiuntive sul percorso da usare per il reindirizzamento dell'URL. Per ulteriori informazioni, vedere <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">La stringa di query della richiesta da usare per il reindirizzamento dell'URL.</param>
        <param name="setClientFilePath">
          <see langword="true" /> per impostare il percorso dei file usato per le risorse del client sul valore del parametro <c>filePath</c>; in caso contrario, <see langword="false" />.</param>
        <summary>Riscrive l'URL con il percorso virtuale specificato, informazioni sul percorso, informazioni sulla stringa di query e un valore booleano che specifica se il percorso del file del client è impostato sul percorso di riscrittura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `filePath` non include il contenuto del parametro di `pathInfo` parametro. Per l'URL http://www.microsoft.com/virdir/page.html/tail, il `filePath` parametro http://www.microsoft.com/virdir/page.htmle il `pathInfo` parametro è tail.  
  
 Per assicurarsi che il percorso virtuale utilizzato per costruire i percorsi per le risorse non viene modificato, impostare il `setClientFilePath` parametro `false`. Uno scenario comune in cui si potrebbe voler impostare `setClientFilePath` a `false` è quando è necessario riscrivere l'URL e si utilizzano i temi e l'URL di reindirizzamento a una risorsa a cui si trova in una cartella diversa da quella della risorsa richiesta.  
  
 La riscrittura URL è utile quando si desidera ristrutturare le pagine dell'applicazione Web e si desidera assicurarsi che gli utenti che hanno salvato gli URL precedenti comunque possono usarle dopo avere spostato le pagine. La riscrittura URL consente di inoltrare in modo trasparente le richieste per la nuova posizione della pagina.  
  
 Se si desidera consentire a un sito utilizzare gli URL che sono più descrittivi e ottimizzati per i motori di ricerca, un'alternativa più affidabile consiste nell'utilizzare il routing di ASP.NET. Per ulteriori informazioni, vedere [Routing ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Per un esempio di codice, vedere il <xref:System.Web.HttpContext.RewritePath%28System.String%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="path" /> non si trova nella directory radice dell'applicazione corrente.</exception>
        <exception cref="T:System.Web.HttpException">Il parametro <paramref name="filePath" /> non si trova nella directory radice dell'applicazione corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.Web.HttpServerUtility" /> che fornisce i metodi usati nell'elaborazione delle richieste Web.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpServerUtility" /> per la richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.Server%2A> proprietà fornisce l'accesso a livello di codice alle proprietà e metodi di <xref:System.Web.HttpServerUtility> classe. Poiché le pagine ASP.NET contengono un riferimento predefinito per il <xref:System.Web> dello spazio dei nomi (che contiene il <xref:System.Web.HttpContext> classe), è possibile fare riferimento ai membri di <xref:System.Web.HttpContext> in una pagina aspx senza utilizzare il riferimento completo della classe <xref:System.Web.HttpContext>. Ad esempio, è possibile utilizzare `Server.CreateObject("MyCOMComponent")` per creare un'istanza di un oggetto COM nel server. Tuttavia, se si desidera utilizzare i membri di <xref:System.Web.HttpServerUtility> da un modulo di code-behind ASP.NET, è necessario includere un riferimento al <xref:System.Web> spazio dei nomi in cui il modulo e un riferimento completo sia il contesto di richiesta/risposta attualmente attivo e il classe <xref:System.Web> che si desidera utilizzare. In una pagina code-behind, ad esempio, è necessario specificare il nome completo `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.SessionState.HttpSessionState" /> relativo alla richiesta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.SessionState.HttpSessionState" /> relativo alla richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.Session%2A> proprietà fornisce l'accesso a livello di codice alle proprietà e metodi di <xref:System.Web.SessionState.HttpSessionState> classe.  
  
 Per utilizzare lo stato della sessione è necessario abilitarlo. Per informazioni su come abilitare lo stato della sessione, vedere **lo stato della sessione di configurazione** in [panoramica dello stato della sessione di ASP.NET](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Per informazioni su come salvare i valori nello stato sessione, vedere [procedura: salvare i valori nello stato sessione](http://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165). Per informazioni su come leggere i valori dello stato della sessione, vedere [procedura: lettura di valori dallo stato sessione](http://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5).  
  
   
  
## Examples  
 Negli esempi seguenti viene illustrato come salvare i valori nello stato della sessione e come leggere i valori dallo stato della sessione.  
  
 Gli esempi presentano i requisiti seguenti:  
  
-   Un'applicazione ASP.NET che ha attivato lo stato della sessione.  
  
-   Una classe di pagina Web Form dotato di accesso per il <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> proprietà o qualsiasi classe che ha accesso al <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> proprietà.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">Uno dei valori di enumerazione che specifica il tipo di comportamento dello stato di sessione necessario.</param>
        <summary>Imposta il tipo di comportamento dello stato di sessione necessario per supportare una richiesta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'implementazione predefinita ASP.NET, un gestore di richieste HTTP indica se è richiesto lo stato della sessione mediante l'implementazione di <xref:System.Web.SessionState.IRequiresSessionState> interfaccia o <xref:System.Web.SessionState.IReadOnlySessionState> interfaccia. Il <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> (metodo) e <xref:System.Web.SessionState.SessionStateBehavior> enumerazione consentono di fornire ulteriori informazioni su quale tipo di supporto dello stato sessione è necessario per gestire una richiesta. Per altre informazioni, vedere l'enumerazione <xref:System.Web.SessionState.SessionStateBehavior>.  
  
 Il <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> metodo deve essere chiamato prima di <xref:System.Web.HttpApplication.AcquireRequestState> eventi pipeline. Le chiamate che si verificano durante o dopo questo evento causerà un <xref:System.InvalidOperationException> eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo è stato chiamato dopo che si è verificato l'evento <see cref="E:System.Web.HttpApplication.AcquireRequestState" />.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se l'oggetto <see cref="T:System.Web.Security.UrlAuthorizationModule" /> deve ignorare il controllo delle autorizzazioni per la richiesta corrente.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Web.Security.UrlAuthorizationModule" /> deve ignorare il controllo delle autorizzazioni; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.SkipAuthorization%2A> proprietà è destinata ad utenti esperti da moduli di autenticazione che devono eseguire il reindirizzamento a una pagina che consente le connessioni anonime. I moduli di autenticazione e il modulo di autenticazione Passport entrambi impostati <xref:System.Web.HttpContext.SkipAuthorization%2A> durante il reindirizzamento a una pagina di accesso configurata. Impostazione <xref:System.Web.HttpContext.SkipAuthorization%2A> richiede il `ControlPrincipal` flag da impostare. Per informazioni di `ControlPrincipal` flag, vedere <xref:System.Security.Permissions.SecurityPermissionFlag>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Tipo di servizio <see cref="T:System.Web.HttpContext" /> su cui impostare il provider di servizi.</param>
        <summary>Restituisce un oggetto per il tipo di servizio corrente.</summary>
        <returns>
          <see cref="T:System.Web.HttpContext" />; in caso contrario, <see langword="null" /> se non viene trovato alcun servizio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è utile per ottenere l'accesso al sottostante <xref:System.Web.HttpWorkerRequest> oggetto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se il runtime ASP.NET deve chiamare <see cref="M:System.Threading.Thread.Abort" /> sul thread che sta rispondendo a questa richiesta quando la richiesta scade.</summary>
        <value>
          <see langword="true" /> se <see cref="M:System.Threading.Thread.Abort" /> verrà chiamato quando scade il thread; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In gestori e i moduli che utilizzano il <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> proprietà per implementare l'annullamento cooperativo, potrebbe essere necessario disabilitare il <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> comportamento che ASP.NET esegue per impostazione predefinita, quando scade una richiesta. Impostando questa proprietà su `false` consentono di assicurarsi che la routine di pulizia e di annullamento verranno eseguito senza alcuna interruzione da ASP.NET.  
  
 Se si imposta questa proprietà su `false`, ASP.NET non visualizzerà automaticamente una pagina di errore "Timeout della richiesta" quando si verifica un timeout. L'applicazione è responsabile dell'impostazione in modo appropriato il contenuto della risposta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce il timestamp iniziale della richiesta HTTP corrente.</summary>
        <value>Timestamp della richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il timestamp restituito dal <xref:System.Web.HttpContext.Timestamp%2A> proprietà è l'ora locale del server e viene impostata durante la creazione dell'istanza di <xref:System.Web.HttpContext> oggetto. L'ora locale è uguale all'ora UTC più l'offset UTC.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.Web.TraceContext" /> relativo alla risposta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.TraceContext" /> relativo alla risposta HTTP corrente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le informazioni sulla sicurezza per la richiesta HTTP corrente.</summary>
        <value>Informazioni sulla sicurezza per la richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.User%2A> proprietà fornisce l'accesso a livello di codice alle proprietà e metodi di <xref:System.Security.Principal.IPrincipal> interfaccia.  
  
 Poiché le pagine ASP.NET contengono un riferimento predefinito per il <xref:System.Web> dello spazio dei nomi (che contiene il <xref:System.Web.HttpContext> classe), è possibile fare riferimento ai membri di <xref:System.Web.HttpContext> in una pagina aspx senza utilizzare il riferimento completo della classe <xref:System.Web.HttpContext>. Ad esempio, è possibile utilizzare `User.Identity.Name` per ottenere il nome dell'utente per conto del quale il processo corrente è in esecuzione. Tuttavia, se si desidera utilizzare i membri di <xref:System.Security.Principal.IPrincipal> da un modulo di code-behind ASP.NET, è necessario includere un riferimento al <xref:System.Web> spazio dei nomi in cui il modulo e un riferimento completo sia il contesto di richiesta/risposta attualmente attivo e il classe <xref:System.Web> che si desidera utilizzare. In una pagina code-behind, ad esempio, è necessario specificare il nome completo `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come accedere alle proprietà dell'utente corrente tramite il <xref:System.Web.HttpContext.User%2A> proprietà. Tali proprietà vengono utilizzate per impostare il titolo della pagina Web.  
  
 Se l'applicazione utilizza l'autenticazione di Windows, il nome utente include il dominio. Ad esempio, il titolo della pagina sarebbe "Home page per dominio omeutente".  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il protocollo negoziato inviato dal server al client per una connessione <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>Protocollo negoziato.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'elenco ordinato dei protocolli richiesti dal client.</summary>
        <value>Protocolli richiesti o <see langword="null" /> se questa non è una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> o non è presente alcun elenco.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>