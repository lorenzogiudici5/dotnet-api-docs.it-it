<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f1598bcd6d1f0d0df8fbe457cbe419cd0e1376c8" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51888890" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Incapsula tutte le informazioni specifiche di HTTP relative a una singola richiesta HTTP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi che ereditano la <xref:System.Web.IHttpModule> e <xref:System.Web.IHttpHandler> interfacce vengono fornite un riferimento a un <xref:System.Web.HttpContext> oggetto per la richiesta HTTP corrente. L'oggetto fornisce l'accesso per l'elemento intrinseco <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>, e <xref:System.Web.HttpContext.Server%2A> proprietà per la richiesta.  
  
> [!IMPORTANT] 
> Questo oggetto è pronto per l'operazione di garbage collection quando il <xref:System.Web.HttpRequest> viene completata. L'utilizzo dopo il completamento della richiesta potrebbe causare un comportamento non definito, ad esempio un <xref:System.NullReferenceException>.
>
> Questo oggetto è disponibile solo nel thread controllati da ASP.NET. L'utilizzo nel thread in background potrebbe causare un comportamento indefinito.

## Examples  
 Nell'esempio seguente viene illustrato come accedere e visualizzare le proprietà del <xref:System.Web.HttpContext> oggetto. È possibile accedere al contesto della richiesta HTTP corrente usando il <xref:System.Web.UI.Page.Context%2A> proprietà del <xref:System.Web.UI.Page> oggetto.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">Una questione di contesto</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Web.HttpContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">Oggetto <see cref="T:System.Web.HttpWorkerRequest" /> relativo alla richiesta HTTP corrente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Web.HttpContext" /> che usa l'oggetto richiesta di lavoro specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">Oggetto <see cref="T:System.Web.HttpRequest" /> relativo alla richiesta HTTP corrente.</param>
        <param name="response">Oggetto <see cref="T:System.Web.HttpResponse" /> relativo alla richiesta HTTP corrente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Web.HttpContext" /> usando gli oggetti richiesta e risposta specificati.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accetta una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">Funzione utente.</param>
        <summary>Accetta una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> con la funzione utente specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo è equivalente alla chiamata di <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> overload del metodo e passando `null` per il `options` parametro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="userFunc" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La richiesta non è una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">Funzione utente.</param>
        <param name="options">Oggetto delle opzioni.</param>
        <summary>Accetta una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> con la funzione utente specificata e l'oggetto delle opzioni.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="userFunc" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La richiesta non è una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">Oggetto <see cref="T:System.Exception" /> da aggiungere alla raccolta di eccezioni.</param>
        <summary>Aggiunge un'eccezione alla raccolta di eccezioni per la richiesta HTTP corrente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Oggetto di contesto HTTP.</param>
        <summary>Genera un evento virtuale che si verifica quando la parte HTTP della richiesta sta terminando.</summary>
        <returns>Token della sottoscrizione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento si verifica prima il <xref:System.Web.WebSockets.AspNetWebSocket> connessione inizia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="callback" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce una matrice degli errori accumulati durante l'elaborazione di una richiesta HTTP.</summary>
        <value>Matrice di oggetti <see cref="T:System.Exception" /> relativa alla richiesta HTTP corrente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se le operazioni asincrone sono consentite durante l'elaborazione delle parti della richiesta ASP.NET quando non sono previste.</summary>
        <value>
          <see langword="false" /> se ASP.NET genera un'eccezione quando l'API asincrona viene usata in un momento in cui non è prevista; in caso contrario, <see langword="true" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo flag non è impostato su `true`, ASP.NET genera un'eccezione quando rileva l'applicazione impropriamente l'API asincrona. Ciò può verificarsi se si prova a chiamare un metodo asincrono durante una parte della richiesta di pipeline di elaborazione in cui le operazioni asincrone non sono previste, o se è ancora in attesa di lavoro asincrono quando un modulo asincrono o un gestore segnala il completamento. Questo comportamento è da intendersi come una rete di protezione per consentono di sapere subito se si scrive codice asincrono che non corrisponda a prevede che i modelli e può avere effetti collaterali negativi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.HttpApplicationState" /> relativo alla richiesta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpApplicationState" /> per la richiesta HTTP corrente.  
  
Per ottenere l'oggetto <see cref="T:System.Web.HttpApplication" /> per la richiesta HTTP corrente, usare <see cref="P:System.Web.HttpContext.ApplicationInstance" />. ASP.NET usa <see langword="ApplicationInstance" /> anziché <see langword="Application" /> come nome di proprietà per fare riferimento all'istanza corrente di <see cref="T:System.Web.HttpApplication" /> per evitare confusione tra ASP.NET e ASP classico. In ASP classico <see langword="Application" /> fa riferimento al dizionario di stato globale dell'applicazione.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Web.HttpApplication" /> relativo alla richiesta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpApplication" /> per la richiesta HTTP corrente.  
  
ASP.NET usa <see langword="ApplicationInstance" /> anziché <see langword="Application" /> come nome di proprietà per fare riferimento all'istanza corrente di <see cref="T:System.Web.HttpApplication" /> per evitare confusione tra ASP.NET e ASP classico. In ASP classico <see langword="Application" /> fa riferimento al dizionario di stato globale dell'applicazione.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">L'applicazione Web è in esecuzione in IIS 7.0 in modalità integrata e tenta di cambiare il valore della proprietà da un valore non Null a <see langword="null" />.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto che contiene i flag relativi alla modalità di precaricamento asincrona.</summary>
        <value>Oggetto che contiene i flag relativi alla modalità di precaricamento asincrona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La prima volta che si accede a questa proprietà, da cui viene caricato l'oggetto che contiene i flag per la modalità di precaricamento asincrona il <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> impostazione nel file di configurazione.  
  
 Sebbene questa proprietà possa essere impostata a livello di codice, la modifica del valore della proprietà ha effetto solo se la proprietà viene impostata prima del passaggio `ExecuteRequestHandler` nella pipeline delle richieste ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.Caching.Cache" /> per il dominio dell'applicazione corrente.</summary>
        <value>Classe <see cref="T:System.Web.Caching.Cache" /> per il dominio dell'applicazione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È presente un'istanza del <xref:System.Web.Caching.Cache> classe per ogni dominio dell'applicazione. Di conseguenza, il <xref:System.Web.Caching.Cache> oggetto restituito dal <xref:System.Web.HttpContext.Cache%2A> proprietà è il <xref:System.Web.Caching.Cache> oggetto per tutte le richieste nel dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella tutti gli errori relativi alla richiesta HTTP corrente.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Web.HttpContext" /> relativo alla richiesta HTTP corrente.</summary>
        <value>L'istanza <see cref="T:System.Web.HttpContext" /> per la richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è una proprietà statica del <xref:System.Web.HttpContext> classe. La proprietà archivia il <xref:System.Web.HttpContext> istanza che si applica alla richiesta corrente. Le proprietà di questa istanza sono di proprietà non statiche del <xref:System.Web.HttpContext> classe.  
  
 È anche possibile usare la <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> proprietà a cui accedere il <xref:System.Web.HttpContext> oggetto per la richiesta HTTP corrente.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Web.HttpContext.Current%2A> proprietà a cui accedere il <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> e <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> metodi e le <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> proprietà. L'esempio crea tre eccezioni personalizzate tramite il <xref:System.Web.HttpContext.AddError%2A> metodo e viene utilizzato il <xref:System.Web.HttpContext.AllErrors%2A> proprietà per caricare queste eccezioni in una matrice. Quindi scrive la matrice alla pagina che lo contiene e Usa il <xref:System.Web.HttpContext.ClearError%2A> metodo per cancellare tutti gli errori rilevati durante il <xref:System.Web.UI.Page.Context%2A> proprietà.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.IHttpHandler" /> che rappresenta il gestore attualmente in esecuzione.</summary>
        <value>
          <see cref="T:System.Web.IHttpHandler" /> rappresenta il gestore attualmente in esecuzione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il gestore attualmente in esecuzione che fa riferimento il <xref:System.Web.HttpContext.CurrentHandler%2A> proprietà potrebbe essere diversa rispetto al gestore che fa riferimento il <xref:System.Web.HttpContext.Handler%2A> proprietà. Ciò può verificarsi quando un altro gestore di è stato richiesto tramite il <xref:System.Web.HttpServerUtility.Execute%2A> metodo o il <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Al termine dell'elaborazione il gestore attualmente in esecuzione, viene ripristinato il gestore stabilito in precedenza.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Panoramica di moduli HTTP e gestori HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Web.RequestNotification" /> che indica l'evento <see cref="T:System.Web.HttpApplication" /> attualmente in elaborazione.</summary>
        <value>Uno dei valori di <see cref="T:System.Web.RequestNotification" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà richiede la modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e almeno .NET Framework versione 3.0. Quando è disponibile, la proprietà restituisce un <xref:System.Web.RequestNotification> valore. Il valore della <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà indica quale evento nel <xref:System.Web.HttpApplication> istanza sta attualmente elaborando la richiesta.  
  
 Il <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà non deve essere impostata. Al contrario, l'impostazione da [!INCLUDE[iisver](~/includes/iisver-md.md)] durante l'elaborazione della richiesta nella pipeline ASP.NET. L'impostazione di <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà comporterà un errore di compilazione.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> è stato introdotto in .NET Framework versione 3.5.  Per altre informazioni, vedere [Versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 L'esempio seguente illustra come usare il <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà per determinare quali eventi del <xref:System.Web.HttpApplication> oggetto che gestisce la richiesta corrente è in fase di elaborazione. Nell'esempio, il gestore eventi gestisce diversi eventi dei <xref:System.Web.HttpApplication> oggetti e il <xref:System.Web.HttpContext.CurrentNotification%2A> proprietà determina il tipo di codice viene richiamato per ogni evento gestito.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L'operazione richiede una modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e .NET Framework versione 3.0 o successiva.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">Oggetto il cui metodo <see cref="M:System.IDisposable.Dispose" /> deve essere chiamato quando la parte della connessione <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> della richiesta viene completata.</param>
        <summary>Consente di chiamare il metodo <see cref="M:System.IDisposable.Dispose" /> di un oggetto quando la parte della connessione <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> della richiesta viene completata.</summary>
        <returns>Token della sottoscrizione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IDisposable.Dispose%2A> dell'oggetto di destinazione viene chiamato dopo sia la parte HTTP della richiesta e <xref:System.Web.WebSockets.AspNetWebSocket> connessione sono scadute. Il <xref:System.Web.HttpContext> oggetto non è disponibile per l'ispezione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce il primo errore, se presente, accumulato durante l'elaborazione di una richiesta HTTP.</summary>
        <value>Il primo oggetto <see cref="T:System.Exception" /> per il processo di richiesta/risposta HTTP corrente; in caso contrario, <see langword="null" /> se non sono stati accumulati errori durante l'elaborazione della richiesta HTTP. Il valore predefinito è <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Tag di configurazione dell'applicazione per cui sono state richieste informazioni.</param>
        <summary>Restituisce le informazioni sulla configurazione richieste per l'applicazione in uso.</summary>
        <returns>Oggetto contenente le informazioni sulla configurazione. Eseguire il cast della sezione di configurazione restituita al tipo di configurazione appropriato prima dell'uso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Web.HttpContext.GetAppConfig%2A> è stato deprecato. Usare il <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> metodo di <xref:System.Web.Configuration.WebConfigurationManager> classe per ottenere le informazioni di configurazione per l'applicazione corrente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Tag di configurazione per cui sono state richieste informazioni.</param>
        <summary>Restituisce le informazioni sulla configurazione relative alla richiesta HTTP corrente.</summary>
        <returns>Oggetto <see cref="T:System.Configuration.ConfigurationSection" /> specificato, <see langword="null" /> se la sezione non esiste o oggetto interno se la sezione non risulta accessibile in fase di esecuzione. Eseguire il cast dell'oggetto restituito al tipo di configurazione appropriato prima dell'uso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Web.HttpContext.GetConfig%2A> è stato deprecato. Usare il <xref:System.Web.HttpContext.GetSection%2A> metodo per ottenere informazioni di configurazione per la richiesta HTTP corrente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene una risorsa a livello di applicazione.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Risorse nelle applicazioni</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Layout del sito Web ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">Stringa che rappresenta la proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> dell'oggetto risorsa richiesto.</param>
        <param name="resourceKey">Stringa che rappresenta la proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> dell'oggetto risorsa richiesto.</param>
        <summary>Ottiene un oggetto risorsa a livello di applicazione basato sulle proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> specificate.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che rappresenta l'oggetto risorsa a livello di applicazione richiesto; in caso contrario, Null se non viene individuato alcun oggetto risorsa o se ne viene trovato uno che tuttavia non presenta la proprietà richiesta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> metodo restituisce una risorsa globale utilizzando le impostazioni cultura specificato nella <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> proprietà.  
  
> [!NOTE]
>  In alcuni ambienti di modifica, ad esempio [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], l'editor può generare in fase di progettazione <xref:System.Resources.MissingManifestResourceException> eccezioni se si usa un punto (.) nel nome della chiave di risorsa globale. Tuttavia, questa operazione non influenza la possibilità di modificare o salvare il file ed è possibile ignorare l'errore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Non è stato trovato un oggetto risorsa con il parametro <paramref name="classKey" /> specificato.  
  
\- oppure - 
L'assembly principale non contiene le risorse indipendenti dalle impostazioni cultura e queste risorse sono obbligatorie perché l'assembly satellite adatto è mancante.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Risorse nelle applicazioni</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Layout del sito Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Creazione del pacchetto e distribuzione delle risorse</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">Stringa che rappresenta la proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> dell'oggetto risorsa richiesto.</param>
        <param name="resourceKey">Stringa che rappresenta una proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> dell'oggetto risorsa richiesto.</param>
        <param name="culture">Stringa che rappresenta l'oggetto <see cref="T:System.Globalization.CultureInfo" /> della risorsa richiesta.</param>
        <summary>Ottiene un oggetto risorsa a livello di applicazione basato sulle proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> specificate e sull'oggetto <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che rappresenta l'oggetto della risorsa a livello di applicazione richiesta, che è localizzato in base alle impostazioni cultura specificate; in caso contrario, <see langword="null" /> se non viene individuato alcun oggetto della risorsa o se ne viene trovato uno che tuttavia non presenta la proprietà richiesta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Globalization.CultureInfo> oggetto rappresenta le impostazioni cultura per cui è stata localizzata la risorsa. Se la risorsa non viene localizzata con queste impostazioni cultura, la ricerca verrà completato un processo di fallback per individuare una risorsa appropriata. Per altre informazioni, vedere [Creazione del pacchetto e distribuzione delle risorse](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  In alcuni ambienti di modifica, ad esempio Visual Web Developer l'editor può generare in fase di progettazione <xref:System.Resources.MissingManifestResourceException> eccezioni se si usa un punto (.) nel nome della chiave di risorsa globale. Tuttavia, questa operazione non influenza la possibilità di modificare o salvare il file ed è possibile ignorare l'errore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Un oggetto risorsa per il quale non è stato trovato il parametro <paramref name="classKey" /> specificato.  
  
\- oppure - 
L'assembly principale non contiene le risorse indipendenti dalle impostazioni cultura e queste risorse sono obbligatorie perché l'assembly satellite adatto è mancante.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Risorse nelle applicazioni</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Creazione del pacchetto e distribuzione delle risorse</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene una risorsa a livello di pagina.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Risorse nelle applicazioni</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Layout del sito Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Creazione del pacchetto e distribuzione delle risorse</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Proprietà <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> per l'oggetto della risorsa locale.</param>
        <param name="resourceKey">Stringa che rappresenta una proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> dell'oggetto risorsa richiesto</param>
        <summary>Ottiene un oggetto della risorsa a livello di pagina basato sulle proprietà <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> specificate.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che rappresenta l'oggetto della risorsa a livello di pagina richiesta; in caso contrario, <see langword="null" /> se viene trovato un oggetto della risorsa corrispondente, ma non il parametro <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.GetLocalResourceObject%2A> metodo restituisce una risorsa locale utilizzando le impostazioni cultura specificato nella <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Non è stato trovato un oggetto risorsa per il parametro <paramref name="virtualPath" /> specificato.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="virtualPath" /> specificato non si trova nella directory radice dell'applicazione corrente.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stata trovata la classe di risorse per la pagina.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Risorse nelle applicazioni</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Layout del sito Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Creazione del pacchetto e distribuzione delle risorse</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Procedura: recuperare i valori della risorsa a livello di codice</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Proprietà <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> per l'oggetto della risorsa locale.</param>
        <param name="resourceKey">Stringa che rappresenta una proprietà <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> dell'oggetto risorsa richiesto.</param>
        <param name="culture">Stringa che rappresenta l'oggetto <see cref="T:System.Globalization.CultureInfo" /> dell'oggetto della risorsa richiesta.</param>
        <summary>Ottiene un oggetto della risorsa a livello di pagina basato sulle proprietà <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> e <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> specificate e sull'oggetto <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che rappresenta l'oggetto della risorsa locale richiesta, localizzato per le impostazioni cultura specificate; in caso contrario, <see langword="null" /> se viene individuato un oggetto della risorsa corrispondente, ma non il parametro <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la risorsa non viene localizzata con queste impostazioni cultura, la ricerca verrà completato un processo di fallback per individuare una risorsa appropriata. Per altre informazioni, vedere [Creazione del pacchetto e distribuzione delle risorse](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Non è stato trovato un oggetto risorsa per il parametro <paramref name="virtualPath" /> specificato.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="virtualPath" /> specificato non si trova nella directory radice dell'applicazione corrente.</exception>
        <exception cref="T:System.InvalidOperationException">Non è stata trovata la classe di risorse per la pagina.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Risorse nelle applicazioni</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Layout del sito Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Creazione del pacchetto e distribuzione delle risorse</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Procedura: recuperare i valori della risorsa a livello di codice</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Percorso della sezione di configurazione (in formato XPath) e nome dell'elemento di configurazione.</param>
        <summary>Ottiene una sezione di configurazione specificata per la configurazione predefinita dell'applicazione corrente.</summary>
        <returns>Oggetto <see cref="T:System.Configuration.ConfigurationSection" /> specificato, <see langword="null" /> se la sezione non esiste o oggetto interno se la sezione non risulta accessibile in fase di esecuzione.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Web.IHttpHandler" /> responsabile dell'elaborazione della richiesta HTTP.</summary>
        <value>Oggetto <see cref="T:System.Web.IHttpHandler" /> responsabile dell'elaborazione della richiesta HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.Handler%2A> proprietà contiene un riferimento al gestore che elabora la richiesta HTTP. Il gestore può essere specificato usando l'elemento, o tramite un gestore personalizzato definito nel codice utente. Per altre informazioni sui gestori, vedere [Panoramica di moduli HTTP e gestori HTTP](https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 Il riferimento al <xref:System.Web.HttpContext.Handler%2A> proprietà subiranno modifiche anche dopo la pagina corrente è stata modificata da un metodo sul lato server, ad esempio il <xref:System.Web.HttpServerUtility.Execute%2A> metodo o il <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Panoramica di moduli HTTP e gestori HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un valore che indica se gli errori personalizzati sono stati attivati per la richiesta HTTP corrente.</summary>
        <value>
          <see langword="true" /> se gli errori personalizzati sono attivati; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un valore che indica se la richiesta HTTP corrente è in modalità di debug.</summary>
        <value>
          <see langword="true" /> se la richiesta è in modalità di debug; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che rappresenta il punto di elaborazione corrente nella pipeline ASP.NET subito dopo il completamento dell'elaborazione di un evento <see cref="T:System.Web.HttpApplication" />.</summary>
        <value>
          <see langword="true" /> se gli errori personalizzati sono attivati; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà è supportata solo con la modalità integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e almeno .NET Framework 3.0. Quando è disponibile, la proprietà restituisce un valore booleano che indica se un evento nel <xref:System.Web.HttpApplication> oggetto ha completato l'elaborazione.  
  
 Il <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà non deve essere impostata. Al contrario, viene fornito da [!INCLUDE[iisver](~/includes/iisver-md.md)] al runtime di ASP.NET per ogni notifica. L'impostazione di <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà comporterà un errore di compilazione.  
  
 Negli scenari in cui più eventi dei <xref:System.Web.HttpApplication> oggetto vengono gestiti da un gestore eventi, è possibile usare il <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà in combinazione con il <xref:System.Web.RequestNotification> enumerazione per determinare con precisione dove nel ciclo di vita dell'applicazione corrente è richiesta.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> è stato introdotto in .NET Framework versione 3.5.  Per altre informazioni, vedere [Versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 L'esempio seguente illustra come usare il <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà per determinare quando un evento del <xref:System.Web.HttpApplication> oggetto ha terminato l'elaborazione di tutti i gestori eventi associati. Il gestore dell'evento personalizzato in questo esempio gestisce molti eventi dei <xref:System.Web.HttpApplication> oggetti e il <xref:System.Web.HttpContext.IsPostNotification%2A> proprietà viene utilizzata per determinare quale codice viene richiamato dopo la gestione di un evento specifico.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L'operazione richiede una modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e in .NET Framework 3.0 o versione successiva.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la richiesta è una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>
          <see langword="true" /> se la richiesta è di tipo <see cref="T:System.Web.WebSockets.AspNetWebSocket" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce `true` se la richiesta contiene iniziale <xref:System.Web.WebSockets.AspNetWebSocket> handshake e `WebSocket` dei moduli di IIS è attivo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se si sta eseguendo l'aggiornamento della connessione da una connessione HTTP a una connessione <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>
          <see langword="true" /> se la connessione è in corso di aggiornamento; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta chiave/valore che è possibile usare per organizzare e condividere dati tra un'interfaccia <see cref="T:System.Web.IHttpModule" /> e un'interfaccia <see cref="T:System.Web.IHttpHandler" /> durante una richiesta HTTP.</summary>
        <value>Raccolta chiave/valore <see cref="T:System.Collections.IDictionary" /> che fornisce l'accesso a un singolo valore all'interno della raccolta in base a una chiave specificata.</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms972109.aspx">Una questione di contesto</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un riferimento all'istanza del servizio di strumentazione pagina per questa richiesta.</summary>
        <value>Istanza del servizio di strumentazione pagina per questa richiesta.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.IHttpHandler" /> relativo al gestore padre.</summary>
        <value>Istanza di <see cref="T:System.Web.IHttpHandler" /> oppure <see langword="null" /> se non è stato trovato alcun gestore precedente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.PreviousHandler%2A> proprietà corrisponde all'ultimo gestore, prima è stata eseguita la richiesta corrente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Panoramica di moduli HTTP e gestori HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.Profile.ProfileBase" /> relativo al profilo utente corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.Profile.ProfileBase" /> se il file di configurazione dell'applicazione contiene una definizione per le proprietà del profilo; in caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Web.HttpContext.Profile%2A> proprietà viene utilizzata per ottenere archiviazione persistente dei dati strutturati tramite un'API type-safe. Quando un <xref:System.Web.HttpContext.Profile%2A> si accede alla proprietà ma non è presente alcun valore, viene restituita un'istanza vuota. `null` non viene restituita.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">Oggetto che deve elaborare la richiesta.</param>
        <summary>Consente di specificare un gestore per la richiesta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si imposta `handler` a `null`, il gestore predefinito viene usato per elaborare la richiesta. È possibile impostare `handler` su un gestore asincrono o a un gestore sincrono. Il gestore deve implementare il <xref:System.Web.IHttpHandler> interfaccia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> è stato chiamato dopo che si è verificato l'evento <see cref="E:System.Web.HttpApplication.MapRequestHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.HttpRequest" /> relativo alla richiesta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpRequest" /> per la richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.Request%2A> proprietà offre l'accesso a livello di codice alle proprietà e metodi del <xref:System.Web.HttpRequest> classe. Poiché le pagine ASP.NET contengono un riferimento predefinito per il <xref:System.Web> dello spazio dei nomi (che contiene il <xref:System.Web.HttpContext> classe), è possibile fare riferimento a membri di <xref:System.Web.HttpRequest> in una pagina aspx senza usare il riferimento completo della classe <xref:System.Web.HttpContext>. Ad esempio, è possibile usare `Request.Browser` per ottenere le funzionalità del browser client. Tuttavia, se si desidera usare i membri di <xref:System.Web.HttpRequest> da un modulo di code-behind ASP.NET, è necessario includere un riferimento al <xref:System.Web> dello spazio dei nomi nel modulo e un riferimento completo sia il contesto di richiesta/risposta attualmente attiva e il classe <xref:System.Web> che si desidera utilizzare. In una pagina code-behind, ad esempio, è necessario specificare il nome completo `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  In ASP.NET verrà generata un'eccezione se si prova a usare questa proprietà quando il <xref:System.Web.HttpRequest> oggetto non è disponibile. Ad esempio, sarebbe true nel metodo Application_Start del file Global. asax, o in un metodo che viene chiamato dal metodo Application_Start. In quel momento nessuna richiesta HTTP è ancora stata creata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'applicazione Web è in esecuzione in IIS 7 in modalità integrata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.Web.HttpResponse" /> relativo alla risposta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpResponse" /> relativo alla risposta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.Response%2A> proprietà offre l'accesso a livello di codice alle proprietà e metodi del <xref:System.Web.HttpResponse> classe. Poiché le pagine ASP.NET contengono un riferimento predefinito per il <xref:System.Web> dello spazio dei nomi (che contiene il <xref:System.Web.HttpContext> classe), è possibile fare riferimento a membri di <xref:System.Web.HttpContext> in una pagina aspx senza usare il riferimento completo della classe <xref:System.Web.HttpContext>. Ad esempio, è possibile usare `Response.Write("some output")` per scrivere l'output in un flusso di output HTTP. Tuttavia, se si desidera usare i membri di <xref:System.Web.HttpResponse> da un modulo di code-behind ASP.NET, è necessario includere un riferimento al <xref:System.Web> dello spazio dei nomi nel modulo e un riferimento completo per il contesto di richiesta/risposta attualmente attiva e la classe in <xref:System.Web> che si desidera utilizzare. In una pagina code-behind, ad esempio, è necessario specificare il nome completo `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'applicazione Web è in esecuzione in IIS 7 in modalità integrata.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reindirizza una richiesta di una risorsa a un percorso diverso da quello indicato dall'URL richiesto. <see cref="Overload:System.Web.HttpContext.RewritePath" /> viene utilizzato nello stato sessione senza cookie per rimuovere ID sessione dagli URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso di riscrittura interno.</param>
        <summary>Riscrive l'URL con il percorso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.RewritePath%28System.String%29> metodo reindirizza una richiesta per una risorsa a un percorso diverso rispetto a quello indicato dall'URL richiesto. Se è necessario reimpostare il percorso virtuale in modo che le richieste dal client per le risorse del server vengano risolte correttamente, usare l'overload del metodo che accetta il `rebaseClientPath` parametro e il parametro impostato su `false`.  
  
 La riscrittura degli URL è utile quando si desidera ristrutturare le pagine nell'applicazione Web, e si desidera assicurarsi che le persone che hanno salvato gli URL precedenti comunque possono usarle dopo avere spostato le pagine. Riscrittura dell'URL consente in modo trasparente inoltrare le richieste al nuovo percorso della pagina.  
  
 Se si desidera consentire a un sito usare gli URL sono più semplici da usare e sono ottimizzati per i motori di ricerca, un'alternativa più affidabile consiste nell'utilizzare il routing di ASP.NET. Per altre informazioni, vedere [Routing ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Web.HttpContext.RewritePath%2A> metodo per consentire a un sito Web rispondere agli URL che non riflettono la struttura di file nel sito Web. Il primo blocco di codice è una pagina Web ASP.NET denominato RewritePath. aspx. Richiede una stringa di query. Se il nome del sito è WebSite1, l'URL `http://localhost/WebSite1/RewritePath.aspx?page=1` Visualizza "Pagina 1" nel browser. Il blocco di codice che segue la pagina Web è il `Application_BeginRequest` gestore dell'evento nel file Global. asax. Questo codice intercetta le richieste per gli URL, ad esempio `http://localhost/WebSite1/page1` e li converte in formato che è necessario per RewritePath. aspx prima di essere elaborati. Pertanto, l'URL `http://localhost/WebSite1/page1` richiama RewritePath. aspx con il parametro di stringa di query che visualizza "Pagina 1" nel browser. Se un URL, ad esempio `http://localhost/WebSite1/page1` viene ricevuto un overload di <xref:System.Web.HttpContext.RewritePath%2A> viene richiamato che consente di fornire un valore per il <xref:System.Web.HttpRequest.PathInfo%2A> proprietà così una query come parametro di stringa.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Il parametro <paramref name="path" /> non si trova nella directory radice dell'applicazione corrente.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Procedura dettagliata: Uso di Routing in un'applicazione Web Form ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso di riscrittura interno.</param>
        <param name="rebaseClientPath">
          <see langword="true" /> per reimpostare il percorso virtuale, <see langword="false" /> per mantenere tale percorso invariato.</param>
        <summary>Riscrive l'URL con il percorso specificato e un valore booleano che specifica se il percorso virtuale per le risorse del server è stato modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> metodo viene chiamato dal <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> metodo con il `rebaseClientPath` parametro impostato su `true`. Per garantire che non venga modificato il percorso virtuale utilizzato per costruire i percorsi per le risorse, impostare il `rebaseClientPath` parametro per `false`. Uno scenario comune in cui si potrebbe voler impostare `rebaseClientPath` a `false` è quando è necessario riscrivere l'URL e si usa i temi e l'URL di reindirizzamento a una risorsa che si trova in una cartella diversa da quella della risorsa richiesta.  
  
 La riscrittura degli URL è utile quando si desidera ristrutturare le pagine nell'applicazione Web, e si desidera assicurarsi che le persone che hanno salvato gli URL precedenti comunque possono usarle dopo avere spostato le pagine. Riscrittura dell'URL consente in modo trasparente inoltrare le richieste al nuovo percorso della pagina.  
  
 Se si desidera consentire a un sito usare gli URL sono più semplici da usare e sono ottimizzati per i motori di ricerca, un'alternativa più affidabile consiste nell'utilizzare il routing di ASP.NET. Per altre informazioni, vedere [Routing ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Per un esempio di codice, vedere il <xref:System.Web.HttpContext.RewritePath%28System.String%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Il parametro <paramref name="path" /> non si trova nella directory radice dell'applicazione corrente.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Procedura dettagliata: Uso di Routing in un'applicazione Web Form ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">Percorso di riscrittura interno.</param>
        <param name="pathInfo">Informazioni aggiuntive sul percorso di una risorsa. Per ulteriori informazioni, vedere <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Stringa di query della richiesta.</param>
        <summary>Riscrive l'URL usando il percorso specificato, le informazioni sul percorso e le informazioni sulla stringa di query.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.RewritePath%2A> metodo reindirizza una richiesta per una risorsa a un'altra risorsa senza modificare l'URL.  
  
 Il `filePath` parametro non include il `pathInfo` contenuto del parametro. Per l'URL http://www.microsoft.com/virdir/page.html/tail, il `filePath` parametro è http://www.microsoft.com/virdir/page.htmle il `pathInfo` parametro è della parte finale.  
  
 La riscrittura degli URL è utile quando si desidera ristrutturare le pagine nell'applicazione Web, e si desidera assicurarsi che le persone che hanno salvato gli URL precedenti comunque possono usarle dopo avere spostato le pagine. Riscrittura dell'URL consente in modo trasparente inoltrare le richieste al nuovo percorso della pagina.  
  
 Se si desidera consentire a un sito usare gli URL sono più semplici da usare e sono ottimizzati per i motori di ricerca, un'alternativa più affidabile consiste nell'utilizzare il routing di ASP.NET. Per altre informazioni, vedere [Routing ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Per un esempio di codice, incluso un esempio di questo overload del metodo, vedere il <xref:System.Web.HttpContext.RewritePath%28System.String%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="path" /> non si trova nella directory radice dell'applicazione corrente.</exception>
        <exception cref="T:System.Web.HttpException">Il parametro <paramref name="filePath" /> non si trova nella directory radice dell'applicazione corrente.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Procedura dettagliata: Uso di Routing in un'applicazione Web Form ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">Il percorso virtuale alla risorsa che gestisce la richiesta.</param>
        <param name="pathInfo">Informazioni aggiuntive sul percorso da usare per il reindirizzamento dell'URL. Per ulteriori informazioni, vedere <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">La stringa di query della richiesta da usare per il reindirizzamento dell'URL.</param>
        <param name="setClientFilePath">
          <see langword="true" /> per impostare il percorso dei file usato per le risorse del client sul valore del parametro <c>filePath</c>; in caso contrario, <see langword="false" />.</param>
        <summary>Riscrive l'URL con il percorso virtuale specificato, informazioni sul percorso, informazioni sulla stringa di query e un valore booleano che specifica se il percorso del file del client è impostato sul percorso di riscrittura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `filePath` non include il contenuto del parametro di `pathInfo` parametro. Per l'URL http://www.microsoft.com/virdir/page.html/tail, il `filePath` parametro è http://www.microsoft.com/virdir/page.htmle il `pathInfo` parametro è della parte finale.  
  
 Per garantire che non venga modificato il percorso virtuale utilizzato per costruire i percorsi per le risorse, impostare il `setClientFilePath` parametro per `false`. Uno scenario comune in cui si potrebbe voler impostare `setClientFilePath` a `false` è quando è necessario riscrivere l'URL e si usa i temi e l'URL di reindirizzamento a una risorsa che si trova in una cartella diversa da quella della risorsa richiesta.  
  
 La riscrittura degli URL è utile quando si desidera ristrutturare le pagine nell'applicazione Web, e si desidera assicurarsi che le persone che hanno salvato gli URL precedenti comunque possono usarle dopo avere spostato le pagine. Riscrittura dell'URL consente in modo trasparente inoltrare le richieste al nuovo percorso della pagina.  
  
 Se si desidera consentire a un sito usare gli URL sono più semplici da usare e sono ottimizzati per i motori di ricerca, un'alternativa più affidabile consiste nell'utilizzare il routing di ASP.NET. Per altre informazioni, vedere [Routing ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Per un esempio di codice, vedere il <xref:System.Web.HttpContext.RewritePath%28System.String%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="path" /> non si trova nella directory radice dell'applicazione corrente.</exception>
        <exception cref="T:System.Web.HttpException">Il parametro <paramref name="filePath" /> non si trova nella directory radice dell'applicazione corrente.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Procedura dettagliata: Uso di Routing in un'applicazione Web Form ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.Web.HttpServerUtility" /> che fornisce i metodi usati nell'elaborazione delle richieste Web.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpServerUtility" /> per la richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.Server%2A> proprietà offre l'accesso a livello di codice alle proprietà e metodi del <xref:System.Web.HttpServerUtility> classe. Poiché le pagine ASP.NET contengono un riferimento predefinito per il <xref:System.Web> dello spazio dei nomi (che contiene il <xref:System.Web.HttpContext> classe), è possibile fare riferimento a membri di <xref:System.Web.HttpContext> in una pagina aspx senza usare il riferimento completo della classe <xref:System.Web.HttpContext>. Ad esempio, è possibile usare `Server.CreateObject("MyCOMComponent")` per creare un'istanza di un oggetto COM nel server. Tuttavia, se si desidera usare i membri di <xref:System.Web.HttpServerUtility> da un modulo di code-behind ASP.NET, è necessario includere un riferimento al <xref:System.Web> dello spazio dei nomi nel modulo e un riferimento completo sia il contesto di richiesta/risposta attualmente attiva e il classe <xref:System.Web> che si desidera utilizzare. In una pagina code-behind, ad esempio, è necessario specificare il nome completo `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.SessionState.HttpSessionState" /> relativo alla richiesta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.SessionState.HttpSessionState" /> relativo alla richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.Session%2A> proprietà offre l'accesso a livello di codice alle proprietà e metodi del <xref:System.Web.SessionState.HttpSessionState> classe.  
  
 Per usare lo stato della sessione è necessario abilitarlo. Per informazioni su come abilitare lo stato della sessione, vedere **lo stato della sessione Configuring** nelle [Cenni preliminari sullo stato della sessione di ASP.NET](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Per informazioni su come salvare i valori nello stato sessione, vedere [procedura: salvare i valori nello stato sessione](https://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165). Per informazioni su come leggere i valori dello stato della sessione, vedere [procedura: leggere valori dallo stato sessione](https://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5).  
  
   
  
## Examples  
 Gli esempi seguenti illustrano come salvare i valori nello stato sessione e su come leggere i valori dello stato della sessione.  
  
 Gli esempi presentano i requisiti seguenti:  
  
-   Un'applicazione ASP.NET che ha attivato lo stato della sessione.  
  
-   Una classe di pagina Web Form dotata di accesso per il <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> proprietà o qualsiasi classe che può accedere al <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> proprietà.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">Uno dei valori di enumerazione che specifica il tipo di comportamento dello stato di sessione necessario.</param>
        <summary>Imposta il tipo di comportamento dello stato di sessione necessario per supportare una richiesta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nell'implementazione predefinita di ASP.NET, un gestore di richieste HTTP indica se è necessario impostare lo stato della sessione mediante l'implementazione di <xref:System.Web.SessionState.IRequiresSessionState> interfaccia o <xref:System.Web.SessionState.IReadOnlySessionState> interfaccia. Il <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> metodo e <xref:System.Web.SessionState.SessionStateBehavior> enumerazione consentono di fornire altri dettagli su quale tipo podpory stavu relace è necessaria per gestire una richiesta. Per altre informazioni, vedere l'enumerazione <xref:System.Web.SessionState.SessionStateBehavior>.  
  
 Il <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> metodo deve essere chiamato prima di <xref:System.Web.HttpApplication.AcquireRequestState> evento della pipeline. Le chiamate che si verificano durante o dopo questo evento causerà una <xref:System.InvalidOperationException> eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo è stato chiamato dopo che si è verificato l'evento <see cref="E:System.Web.HttpApplication.AcquireRequestState" />.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se l'oggetto <see cref="T:System.Web.Security.UrlAuthorizationModule" /> deve ignorare il controllo delle autorizzazioni per la richiesta corrente.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Web.Security.UrlAuthorizationModule" /> deve ignorare il controllo delle autorizzazioni; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.SkipAuthorization%2A> proprietà è destinata ad utenti esperti da moduli di autenticazione che devono eseguire il reindirizzamento a una pagina che consentirà connessioni anonime. Il modulo di autenticazione form e il modulo di autenticazione Passport entrambi impostati <xref:System.Web.HttpContext.SkipAuthorization%2A> durante il reindirizzamento a una pagina di accesso configurata. L'impostazione <xref:System.Web.HttpContext.SkipAuthorization%2A> richiede il `ControlPrincipal` flag da impostare. Per informazioni sul `ControlPrincipal` flag, vedere <xref:System.Security.Permissions.SecurityPermissionFlag>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Tipo di servizio <see cref="T:System.Web.HttpContext" /> su cui impostare il provider di servizi.</param>
        <summary>Restituisce un oggetto per il tipo di servizio corrente.</summary>
        <returns>
          <see cref="T:System.Web.HttpContext" />; in caso contrario, <see langword="null" /> se non viene trovato alcun servizio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è utile per ottenere l'accesso a sottostante <xref:System.Web.HttpWorkerRequest> oggetto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se il runtime ASP.NET deve chiamare <see cref="M:System.Threading.Thread.Abort" /> sul thread che sta rispondendo a questa richiesta quando la richiesta scade.</summary>
        <value>
          <see langword="true" /> se <see cref="M:System.Threading.Thread.Abort" /> verrà chiamato quando scade il thread; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I gestori e moduli che usano il <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> proprietà per implementare l'annullamento cooperativo, si potrebbe voler disabilitare il <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> comportamento che ASP.NET esegue per impostazione predefinita, quando scade una richiesta. Impostando questa proprietà su `false` consente di assicurarsi che le routine di annullamento ed eliminazione verranno eseguita senza subire interruzioni da ASP.NET.  
  
 Se si imposta questa proprietà su `false`, ASP.NET non visualizzerà automaticamente una pagina di errore "Timeout della richiesta" quando si verifica un timeout. L'applicazione è responsabile dell'impostazione del contenuto della risposta in modo appropriato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce il timestamp iniziale della richiesta HTTP corrente.</summary>
        <value>Timestamp della richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il timestamp restituito dal <xref:System.Web.HttpContext.Timestamp%2A> proprietà è l'ora locale del server e viene impostata durante la creazione dell'istanza di <xref:System.Web.HttpContext> oggetto. È uguale all'ora UTC più l'offset UTC nell'ora locale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.Web.TraceContext" /> relativo alla risposta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.TraceContext" /> relativo alla risposta HTTP corrente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le informazioni sulla sicurezza per la richiesta HTTP corrente.</summary>
        <value>Informazioni sulla sicurezza per la richiesta HTTP corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpContext.User%2A> proprietà offre l'accesso a livello di codice alle proprietà e metodi del <xref:System.Security.Principal.IPrincipal> interfaccia.  
  
 Poiché le pagine ASP.NET contengono un riferimento predefinito per il <xref:System.Web> dello spazio dei nomi (che contiene il <xref:System.Web.HttpContext> classe), è possibile fare riferimento a membri di <xref:System.Web.HttpContext> in una pagina aspx senza usare il riferimento completo della classe <xref:System.Web.HttpContext>. Ad esempio, è possibile usare `User.Identity.Name` per ottenere il nome dell'utente per conto del quale il processo corrente è in esecuzione. Tuttavia, se si desidera usare i membri di <xref:System.Security.Principal.IPrincipal> da un modulo di code-behind ASP.NET, è necessario includere un riferimento al <xref:System.Web> dello spazio dei nomi nel modulo e un riferimento completo sia il contesto di richiesta/risposta attualmente attiva e il classe <xref:System.Web> che si desidera utilizzare. In una pagina code-behind, ad esempio, è necessario specificare il nome completo `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come accedere alle proprietà dell'utente corrente tramite il <xref:System.Web.HttpContext.User%2A> proprietà. Tali proprietà vengono usate per impostare il titolo della pagina Web.  
  
 Se l'applicazione usa l'autenticazione di Windows, il nome utente include il dominio. Ad esempio, il titolo della pagina sarà "Home page per dominio\nome utente".  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.asp.net/mvc/tutorials/security/using-oauth-providers-with-mvc">Uso di provider OAuth con MVC 4</related>
        <related type="ExternalDocumentation" href="http://www.asp.net/web-forms/tutorials/aspnet-45/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">Introduzione a Web Form ASP.NET 4.5 - completamento della transazione e pagamento con PayPal</related>
        <related type="ExternalDocumentation" href="http://www.asp.net/web-api/overview/creating-web-apis/using-web-api-with-entity-framework/using-web-api-with-entity-framework,-part-6">Using Web API with Entity Framework - parte 6</related>
        <related type="ExternalDocumentation" href="http://www.asp.net/mvc/tutorials/older-versions/nerddinner/secure-applications-using-authentication-and-authorization">Dinner nerd - applicazioni protette utilizzando l'autenticazione e autorizzazione</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il protocollo negoziato inviato dal server al client per una connessione <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>Protocollo negoziato.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'elenco ordinato dei protocolli richiesti dal client.</summary>
        <value>Protocolli richiesti o <see langword="null" /> se questa non è una richiesta <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> o non è presente alcun elenco.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>