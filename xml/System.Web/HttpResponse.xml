<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="68657bcf291225564a735695474ef67da01c6dca" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683994" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Incapsula le informazioni sulla risposta HTTP da un'operazione ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I metodi e proprietà del <xref:System.Web.HttpResponse> classe sono esposte tramite il <xref:System.Web.HttpApplication.Response%2A> proprietà del <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, e <xref:System.Web.UI.UserControl> classi.  
  
 I metodi seguenti della <xref:System.Web.HttpResponse> classe sono supportati solo in scenari di postback e non durante i postback asincroni postback scenari:  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Aggiornamenti a pagina parziale sono abilitati quando si utilizza <xref:System.Web.UI.UpdatePanel> controlli per aggiornare aree selezionate di una pagina anziché aggiornare l'intera pagina con un postback. Per ulteriori informazioni, vedere [Cenni preliminari sul controllo UpdatePanel](http://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) e [Panoramica per il Rendering parziale della pagina](http://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 Nell'esempio seguente disegna tre rettangoli sovrapposti quando la pagina viene richiesta. Il codice inizia con l'impostazione di <xref:System.Web.HttpResponse.ContentType%2A> proprietà su image/jpeg, in modo che l'intera pagina verrà visualizzato in un'immagine JPEG. Il codice chiama quindi il <xref:System.Web.HttpResponse.Clear%2A> metodo per verificare che nessun contenuto estraneo venga inviato con la risposta. Successivamente, il codice imposta il <xref:System.Web.HttpResponse.BufferOutput%2A> la proprietà su true in modo che la pagina viene elaborata completamente prima che venga inviato al client richiedente. Quindi vengono creati due oggetti utilizzati per disegnare rettangoli: un <xref:System.Drawing.Bitmap> e <xref:System.Drawing.Graphics> oggetto. Le variabili create nella pagina vengono utilizzate come coordinate per disegnare rettangoli e una stringa che viene visualizzato all'interno del rettangolo più grande.  
  
 Quando vengono disegnati i tre rettangoli e la stringa visualizzata all'interno di questi, il <xref:System.Drawing.Bitmap> viene salvato il <xref:System.IO.Stream> oggetto a cui è associato il <xref:System.Web.HttpResponse.OutputStream%2A> proprietà e il formato è impostato su JPEG. Il codice chiama il <xref:System.Drawing.Image.Dispose%2A> e <xref:System.Drawing.Graphics.Dispose%2A> metodi per rilasciare le risorse usate da due oggetti disegno. Infine, il codice chiama il <xref:System.Web.HttpResponse.Flush%2A> metodo per inviare la risposta memorizzata nel buffer per il client richiedente.  
  
> [!NOTE]
>  Nel codice, il <xref:System.Web.HttpResponse> oggetto fa riferimento la parola chiave `Response`. Ad esempio, `Response.Clear()` si intende il <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> metodo. Il <xref:System.Web.UI.Page> classe ha una proprietà denominata <xref:System.Web.UI.Page.Response%2A> che espone l'istanza corrente di <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> che consente l'output HTTP personalizzato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Web.HttpResponse" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro supporta l'infrastruttura .NET Framework e non è possibile usarlo direttamente dal codice.  
  
 I metodi e le proprietà di <xref:System.Web.HttpResponse> classe sono esposte tramite la funzione intrinseca <xref:System.Web.HttpContext.Response%2A> oggetto in ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">File, chiave di cache oppure oggetto <see cref="T:System.Web.Caching.CacheDependency" /> da aggiungere all'elenco delle dipendenze dell'applicazione.</param>
        <summary>Associa un set di dipendenze della cache alla risposta per semplificare l'invalidamento della risposta se è stata memorizzata nella cache di output e le dipendenze specificate vengono modificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.AddCacheDependency%2A> metodo consente di dipendenze da creare tra le risposte memorizzate nella cache e un <xref:System.Web.Caching.CacheDependency> oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare una dipendenza della cache mediante il <xref:System.Web.HttpResponse.AddCacheDependency%2A> (metodo) e un <xref:System.Web.Caching.CacheDependency> oggetto.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="dependencies" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Questo metodo è stato chiamato troppo tardi nella pipeline di elaborazione della cache, dopo che la risposta inserita nella cache era già stata creata.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rende la validità di una risposta memorizzata nella cache dipendente da altri elementi della cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Oggetto <see cref="T:System.Collections.ArrayList" /> contenente le chiavi degli elementi da cui dipende la risposta corrente memorizzata nella cache.</param>
        <summary>Rende la validità di una risposta memorizzata nella cache dipendente da altri elementi della cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando gli elementi di riferimento di `cacheKeys` parametro vengono rimossi dalla cache, la risposta memorizzata nella cache dell'elemento corrente non è valida.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare una pagina ASP.NET che è nella cache di output. Il codice per la pagina Crea un <xref:System.Collections.ArrayList> oggetto delle chiavi associate agli elementi archiviati nel <xref:System.Web.Caching.Cache> oggetto. Successivamente, il codice passa il <xref:System.Collections.ArrayList> come parametro in una chiamata al <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> metodo. In questo modo la risposta memorizzata nella cache di output non valido, se i file specificati nella <xref:System.Collections.ArrayList> modificare.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Matrice delle chiavi dell'elemento da cui dipende la risposta memorizzata nella cache.</param>
        <summary>Rende la validità di un elemento memorizzato nella cache dipendente da un altro elemento della cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un il `cacheKey`s vengono rimossi dalla cache, la risposta memorizzata nella cache dell'elemento corrente non è valida.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Chiave dell'elemento da cui dipende la risposta memorizzata nella cache.</param>
        <summary>Rende la validità di una risposta memorizzata nella cache dipendente da un altro elemento della cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando l'elemento corrispondente di `cacheKey` parametro viene rimosso dalla cache, la risposta memorizzata nella cache dell'elemento corrente non è valida.  
  
   
  
## Examples  
 L'esempio seguente è un controllo utente ASP.NET nella cache di output. Il codice per le chiamate di controllo di <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> (metodo) con la chiave di un elemento archiviato nel <xref:System.Web.Caching.Cache> oggetto passato come parametro. Se l'elemento non esiste nella cache, viene invalidata la risposta del controllo che è stata memorizzata nella cache di output. Ciò significa che nella richiesta successiva, una nuova versione della risposta del controllo verrà aggiunto alla cache di output.  
  
 Successivamente, il codice verifica se un elemento associato a un `bookData` chiave viene archiviata nel `Cache` dell'oggetto e viene visualizzato uno dei due righe di testo a seconda del risultato. Quindi, il codice imposta il <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> proprietà di un <xref:System.Web.UI.WebControls.DataGrid> controllo, denominato `dgBooks`, con una chiamata a un oggetto personalizzato `DataHelper` classe condivisa `GetBookData` (metodo) e popolare il <xref:System.Web.UI.WebControls.DataGrid> con il <xref:System.Web.UI.Control.DataBind%2A> (metodo).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge un gruppo di nomi file alla raccolta dei nomi file da cui dipende la risposta corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Raccolta di file da aggiungere.</param>
        <summary>Aggiunge un gruppo di nomi file alla raccolta dei nomi file da cui dipende la risposta corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente è una pagina ASP.NET che è nella cache di output. Il codice per la pagina Crea un <xref:System.Collections.ArrayList> di percorsi di file e quindi passa il <xref:System.Collections.ArrayList> come parametro in una chiamata al <xref:System.Web.HttpResponse.AddFileDependencies%2A> metodo. In questo modo i file specificati nell'output memorizzato nella cache risposta non valida se il <xref:System.Collections.ArrayList> le modifiche.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">Matrice di file da aggiungere.</param>
        <summary>Aggiunge una matrice di nomi file alla raccolta dei nomi file da cui dipende la risposta corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente aggiunge una matrice di nomi di file per il <xref:System.Web.HttpResponse.AddFileDependencies%2A> elenco di dipendenze di file. Se i file viene modificata, viene invalidata la risposta memorizzata nella cache.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da aggiungere.</param>
        <summary>Aggiunge un singolo nome file alla raccolta dei nomi file da cui dipende la risposta corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza il <xref:System.Web.HttpResponse.AddFileDependency%2A> metodo per aggiungere una dipendenza di file, è necessario specificare anche la cache di output a livello di programmazione o in modo dichiarativo. Ad esempio, per specificare in modo dichiarativo di memorizzazione nella cache di output, utilizzare la direttiva. Per ulteriori informazioni, vedere [come: Cache di Output delle pagine con dipendenze dei File](http://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere un singolo nome file per il <xref:System.Web.HttpResponse.AddFileDependency%2A> elenco di dipendenze di file. Se il file viene modificato, viene invalidata la risposta memorizzata nella cache.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'intestazione HTTP a cui aggiungere <c>value</c>.</param>
        <param name="value">Stringa da aggiungere all'intestazione.</param>
        <summary>Aggiunge un'intestazione HTTP al flusso di output. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> viene fornito per supportare la compatibilità con le versioni precedenti di ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> è identico <xref:System.Web.HttpResponse.AppendHeader%2A> e viene fornito solo per compatibilità con le versioni precedenti di ASP. Con ASP.NET, utilizzare <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Metodo di callback.</param>
        <summary>[Supportato in .NET Framework 4.5.2 e versioni successive]  
  
 Registra un callback che verrà richiamato dal runtime ASP.NET immediatamente prima che le intestazioni di risposta vengano inviate per questa richiesta.</summary>
        <returns>Oggetto <see cref="T:System.Web.ISubscriptionToken" /> che rappresenta la sottoscrizione dello pseudoevento OnSendingHeaders.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Se il modulo nativo Scarica la risposta prima di tutto, non viene richiamato il metodo AddOnSendingHeaders.  
  
 Il Pseudoevento onsendingheaders è diverso dall'evento IHttpModule a livello della pipeline, in quanto si tratta di una sottoscrizione di ogni richiesta, anziché a una sottoscrizione per ogni applicazione. Lo scopo è che il callback può modificare il codice di stato della risposta oppure può impostare un'intestazione o il cookie di risposta. Altre note sull'utilizzo e avvertenze:  
  
-   Questo metodo è efficace solo quando IIS viene eseguito nella pipeline in modalità pipeline integrata e solo se le intestazioni di risposta non sono ancora state inviate per la richiesta corrente.  
  
-   Il runtime di ASP.NET non garantisce necessariamente il callback viene richiamato sul thread. Ad esempio, il callback può essere richiamato in modo sincrono in un thread in background se è in corso lo scaricamento in background. <xref:System.Web.HttpContext.Current%2A> potrebbe non essere disponibili in tale thread.  
  
-   Il callback non deve chiamare qualsiasi metodo che consente di modificare il corpo entità della risposta o che comporta lo scaricamento. Ad esempio, il callback non deve chiamare <xref:System.Web.HttpResponse.Redirect%2A>, come tale metodo può modificare il corpo entità della risposta.  
  
-   Il callback deve contenere solo codice sincrono con esecuzione breve. Il tentativo di richiamare un'operazione asincrona o attendere l'operazione potrebbe causare un deadlock.  
  
-   Il callback non deve generare un'eccezione. in caso contrario, il comportamento è indefinito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Oggetto <see cref="T:System.Web.HttpCookie" /> da aggiungere al flusso di output.</param>
        <summary>Aggiunge un cookie HTTP alla raccolta di cookie intrinseca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un nuovo cookie denominato `LastVisit`, imposta il valore del cookie per la data e ora correnti e il cookie viene aggiunto alla raccolta di cookie corrente. Tutti i cookie nella raccolta di cookie inviati al client il `Set-Cookie` flusso di output dell'intestazione HTTP.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Viene aggiunto un cookie dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'intestazione HTTP da aggiungere al flusso di output.</param>
        <param name="value">Stringa da aggiungere all'intestazione.</param>
        <summary>Aggiunge un'intestazione HTTP al flusso di output.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si utilizza il <xref:System.Web.HttpResponse.AppendHeader%2A> per inviare intestazioni specifiche della cache e allo stesso tempo, utilizzare il modello a oggetti della cache (<xref:System.Web.HttpResponse.Cache%2A>) per impostare criteri di cache, le intestazioni di risposta HTTP che riguardano la memorizzazione nella cache (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, e `Vary`) potrebbe essere stata eliminata quando viene utilizzato il modello a oggetti della cache. Questo comportamento consente ad ASP.NET di mantenere le impostazioni più restrittive. Si consideri ad esempio una pagina che include controlli utente. Se tali controlli sono in conflitto i criteri di cache, verrà utilizzato il criterio più restrittivo di cache. Se un controllo utente imposta l'intestazione "`Cache-Control: Public`"e un altro controllo utente imposta l'intestazione più restrittiva"`Cache-Control: Private`" tramite chiamate a <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, il "`Cache-Control: Private`" intestazione verrà inviata alla risposta.  
  
 Per un elenco di intestazioni HTTP/1.1 standard, vedere la sezione 14, "Definizioni di campo di intestazione", nel [Hypertext Transfer Protocol - HTTP/1.1](http://go.microsoft.com/fwlink/?LinkID=73147) specifica sul sito Web del World Wide Web Consortium (W3C).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Web.HttpResponse.AppendHeader%2A> metodo per aggiungere un'intestazione personalizzata per il <xref:System.Web.HttpResponse> oggetto inviato al client richiedente.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'intestazione viene accodata dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Testo da aggiungere al file di log.</param>
        <summary>Aggiunge informazioni di log personalizzate nel file di log IIS (Internet Information Services).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per consentire la stringa specificata deve essere registrato nel file di log, è innanzitutto necessario abilitare il **Query URI** opzione del **proprietà registrazione estese** la finestra di dialogo per il sito che si desidera registrare l'attività in IIS .  
  
 Per personalizzare la registrazione estesa in IIS 6.0, seguire questi passaggi:  
  
1.  In Gestione IIS espandere il nodo del computer locale, espandere la cartella di siti Web o FTP, il sito Web o FTP destro e quindi fare clic su **proprietà**.  
  
2.  Fare clic su di **sito Web o FTP** scheda e quindi selezionare il **abilitare la registrazione** casella di controllo (se non è già selezionata).  
  
3.  Nel **formato registro attivo** fare clic su **formato File registro esteso W3C**.  
  
4.  Fare clic su **proprietà**.  
  
5.  Fare clic su di **avanzate** scheda, selezionare le proprietà che si desidera accedere e quindi fare clic su **OK**.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere una stringa nel log.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Percorso virtuale di una risorsa.</param>
        <summary>Aggiunge un ID sessione al percorso virtuale, se la sessione usa lo stato di sessione <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> e restituisce il percorso combinato. Se non viene usato lo stato di sessione <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" />, il metodo <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> restituisce il percorso virtuale originale.</summary>
        <returns>
          <paramref name="virtualPath" /> con l'ID sessione inserito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> viene utilizzato solo con sessioni senza cookie per creare href assoluti.  
  
   
  
## Examples  
 Nell'esempio seguente viene dichiarata una variabile di stringa denominata `urlConverted`e lo imposta sul risultato di un <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> chiamata al metodo. Il codice passa quindi il valore della variabile a un <xref:System.Web.UI.WebControls.HyperLink> del controllo <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> proprietà.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Oggetto di callback.</param>
        <param name="state">Stato della risposta.</param>
        <summary>Invia al client la risposta attualmente memorizzata nel buffer.</summary>
        <returns>Oggetto risultato asincrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto sottostante <xref:System.Web.HttpWorkerRequest> oggetto supporta le operazioni di scaricamento asincrone e questo metodo viene chiamato da un evento asincrono modulo o da un gestore asincrono, l'operazione di scaricamento viene eseguita in modo asincrono. In caso contrario, l'operazione di scaricamento viene eseguita in modo sincrono. Operazione di scaricamento asincrono è supportata per IIS 6.0 e versioni successive.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La risposta è già stata completata.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Byte da scrivere nel flusso di output.</param>
        <summary>Scrive una stringa di caratteri binari nel flusso di output HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente legge un file di testo in un buffer e scrive il buffer nel flusso di output HTTP.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se memorizzare l'output nel buffer e inviarlo al termine dell'elaborazione dell'intera risposta.</summary>
        <value>
          <see langword="true" /> se l'output verso il client è memorizzato nel buffer; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.Buffer%2A> proprietà è stata deprecata a favore della <xref:System.Web.HttpResponse.BufferOutput%2A> proprietà e viene fornito solo per compatibilità con le versioni precedenti di ASP. Con ASP.NET, utilizzare <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se memorizzare l'output nel buffer e inviarlo al termine dell'elaborazione dell'intera pagina.</summary>
        <value>
          <see langword="true" /> se l'output verso il client è memorizzato nel buffer; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente imposta il <xref:System.Web.HttpResponse.ContentType%2A> proprietà per la risposta su image/jpeg, chiama il <xref:System.Web.HttpResponse.Clear%2A> metodo per rimuovere altri contenuti che possono essere associati alla risposta e quindi imposta il <xref:System.Web.HttpResponse.BufferOutput%2A> la proprietà su true in modo che l'intera pagina elaborati prima che qualsiasi contenuto venga inviato al client richiedente.  
  
 Per un esempio completo, vedere la <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i criteri di memorizzazione nella cache di una pagina Web (tempo di scadenza, impostazioni di privacy, clausole di variazione).</summary>
        <value>Oggetto <see cref="T:System.Web.HttpCachePolicy" /> contenente informazioni sui criteri di memorizzazione nella cache della risposta corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente scrive le proprietà dei criteri di cache corrente nel flusso di output HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'intestazione HTTP <see langword="Cache-Control" /> corrispondente a uno dei valori dell'enumerazione <see cref="T:System.Web.HttpCacheability" />.</summary>
        <value>Rappresentazione di stringa del valore dell'enumerazione <see cref="T:System.Web.HttpCacheability" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori per `Private`, `Public`, e `No-Cache` sono stringhe e devono essere racchiusi tra virgolette (""). Se il <xref:System.Web.HttpResponse.CacheControl%2A> è impostata su un valore che corrisponde a uno del <xref:System.Web.HttpCacheability> valori di enumerazione, un oggetto <xref:System.ArgumentException> viene generata un'eccezione. Se il <xref:System.Web.HttpResponse.CacheControl%2A> non è impostata, la cache della risposta è impostata su <xref:System.Web.HttpCacheability.NoCache>.  
  
 Il `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, e <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> proprietà sono state deprecate. Al contrario, i metodi del <xref:System.Web.HttpCachePolicy> classe sono disponibili tramite il <xref:System.Web.HttpResponse.Cache%2A> intrinseco per controllare Internet Information Services (IIS) di output della cache e cache dei client.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore di stringa non corrisponde a uno dei valori di enumerazione <see cref="T:System.Web.HttpCacheability" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il set di caratteri HTTP del flusso di output.</summary>
        <value>Set di caratteri HTTP del flusso di output.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Charset` può essere impostata su `null` esclusione HTTP `Content-Type` intestazione.  
  
   
  
## Examples  
 Nell'esempio seguente controlla se il set di caratteri del flusso di output è Europa centrale (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La proprietà <see langword="Charset" /> è stata impostata dopo l'invio delle intestazioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella tutto l'output di contenuto dal flusso del buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.Clear%2A> metodo non cancella le informazioni di intestazione.  
  
   
  
## Examples  
 L'esempio seguente imposta il <xref:System.Web.HttpResponse.ContentType%2A> proprietà per la risposta su image/jpeg, chiama il <xref:System.Web.HttpResponse.Clear%2A> metodo per rimuovere altri contenuti che possono essere associati alla risposta e quindi imposta il <xref:System.Web.HttpResponse.BufferOutput%2A> la proprietà su true in modo che nella pagina operazione completata elaborati prima che qualsiasi contenuto venga inviato al client richiedente.  
  
 Per un esempio completo, vedere la <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella tutto l'output di contenuto dal flusso del buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.ClearContent%2A> metodo non cancella le informazioni di intestazione.  
  
   
  
## Examples  
 Nell'esempio seguente consente di cancellare tutto il contenuto dal flusso del buffer.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella tutte le intestazioni dal flusso del buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente chiama il <xref:System.Web.HttpResponse.ClearHeaders%2A> metodo per assicurarsi che nessuna intestazione venga inviata con la risposta corrente. Questa tecnica può rivelarsi particolarmente importante se la risposta ASP.NET genera un'immagine, ad esempio un file JPEG. In questo esempio il <xref:System.Web.HttpResponse.ContentType%2A> proprietà è impostata su image/jpeg.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le intestazioni vengono cancellate dopo l'invio delle intestazioni HTTP.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Threading.CancellationToken" /> che viene attivato in caso di disconnessione del client.</summary>
        <value>Token di annullamento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa API è thread-safe. Tuttavia, esistono alcune restrizioni relative alla modalità di utilizzo del token di annullamento. L'errato utilizzo può comportare situazioni di race condition, deadlock o altri comportamenti imprevisti. Tenere presenti le linee guida seguenti:  
  
-   Verificare che non vengano chiamate in questa API all'esterno dei limiti di una singola richiesta, poiché ASP.NET si eliminerà il token di annullamento alla fine della richiesta. Non c'è garanzia che il token mai passerà allo stato annullato prima di eliminarlo. Ad esempio, se la richiesta viene completata senza il client con disconnesso, il token verrà eliminato senza prima avere stato annullato.  
  
-   È in attesa di <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, in quanto Annulla lo scopo di notifica asincrona e possono causare deadlock.  
  
-   Non chiamare il <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> overload cui richiamare il callback sul originale <xref:System.Threading.SynchronizationContext> oggetto.  
  
-   Non utilizzare il <xref:System.Web.HttpContext> oggetto o altri non thread-safe agli oggetti intrinseci ASP.NET all'interno di callback specificato per il <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> metodo. Il callback potrebbe essere in esecuzione contemporaneamente altri ASP.NET o codice dell'applicazione.  
  
-   Mantenere i metodi di callback a esecuzione breve e non bloccante.  
  
-   Assicurarsi di non generare eccezioni all'interno dei metodi di callback.  
  
 Questa proprietà è applicabile per Internet Information Service (IIS) 7.5 solo in modalità integrata. Se viene richiamata senza la destra IIS versione o pipeline modalità, un <xref:System.PlatformNotSupportedException> viene generata un'eccezione. Per determinare la versione di IIS, utilizzare <xref:System.Web.HttpRuntime.IISVersion%2A>. Per determinare la modalità pipeline, utilizzare <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude la connessione socket a un client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo termina la connessione al client in modo improvviso e non può essere normale elaborazione della richiesta HTTP. Il metodo invia un pacchetto di ripristino per il client, che può generare dati di risposta che viene memorizzato nel buffer nel server, il client o in un punto intermedio che si desidera eliminare.  
  
 Tuttavia, in genere è necessario chiamare <xref:System.Web.HttpApplication.CompleteRequest%2A> invece se si desidera passare al <xref:System.Web.HttpApplication.EndRequest> eventi e inviare una risposta al client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il set di caratteri HTTP del flusso di output.</summary>
        <value>Oggetto <see cref="T:System.Text.Encoding" /> contenente informazioni sul set di caratteri della risposta corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Predefinito `ContentEncoding` può essere specificato in un file di configurazione di ASP.NET nel [globalization Element (Schema delle impostazioni ASP.NET)](http://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) sezione. Se <xref:System.Web.HttpResponse.ContentEncoding%2A> specificato dal client, vengono sottoposte a override le impostazioni di configurazione predefinite.  
  
   
  
## Examples  
 Nell'esempio seguente scrive una descrizione leggibile del set di codifica per il flusso di output di caratteri.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Si è tentato di impostare <see cref="P:System.Web.HttpResponse.ContentEncoding" /> su <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo MIME HTTP del flusso di output.</summary>
        <value>Tipo MIME HTTP del flusso di output. Il valore predefinito è "<see langword="text/html" />".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente imposta il <xref:System.Web.HttpResponse.ContentType%2A> proprietà per la risposta su image/jpeg, chiama il <xref:System.Web.HttpResponse.Clear%2A> metodo per rimuovere altri contenuti che possono essere associati alla risposta e quindi imposta il <xref:System.Web.HttpResponse.BufferOutput%2A> la proprietà su true in modo che nella pagina operazione completata elaborati prima che qualsiasi contenuto venga inviato al client richiedente.  
  
 Per un esempio completo, vedere la <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La proprietà <see cref="P:System.Web.HttpResponse.ContentType" /> è impostata su <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la raccolta di cookie di risposta.</summary>
        <value>Raccolta di cookie di risposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET include due raccolte di cookie intrinseca. La raccolta a cui si accede tramite il <xref:System.Web.HttpRequest.Cookies%2A> insieme di <xref:System.Web.HttpRequest> contiene i cookie trasmessi dal client al server nel `Cookie` intestazione. La raccolta a cui si accede tramite il <xref:System.Web.HttpResponse.Cookies%2A> insieme di <xref:System.Web.HttpResponse> contiene i nuovi cookie creato nel server e trasmesso al client il `Set-Cookie` intestazione.  
  
 Dopo aver aggiunto un cookie utilizzando il <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> raccolta, il cookie è immediatamente disponibile nel <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> raccolta, anche se la risposta non è stata inviata al client.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un nuovo cookie denominato `LastVisit`, imposta il valore del cookie per la data e ora correnti e il cookie viene aggiunto alla raccolta di cookie corrente. Tutti i cookie nella raccolta di cookie inviati al client il `Set-Cookie` flusso di output dell'intestazione HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disabilita la memorizzazione nella cache del kernel per la risposta corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la cache del kernel non è supportata, questo metodo non ha alcun effetto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disabilita la memorizzazione nella cache in modalità utente di IIS per la risposta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la memorizzazione nella cache in modalità utente IIS non è supportato, questo metodo restituisce senza eseguire alcuna azione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invia al client tutto l'output attualmente memorizzato nel buffer, interrompe l'esecuzione della pagina e genera l'evento <see cref="E:System.Web.HttpApplication.EndRequest" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito solo per compatibilità con ASP, vale a dire per la compatibilità con tecnologia di programmazione Web basato su COM che ha preceduto ASP.NET. Se si desidera passare al <xref:System.Web.HttpApplication.EndRequest> eventi e inviare una risposta al client, è in genere preferibile chiamare <xref:System.Web.HttpApplication.CompleteRequest%2A> invece.  
  
 Per simulare il comportamento del `End` metodo ASP, questo metodo tenta di generare un <xref:System.Threading.ThreadAbortException> eccezione. Se questo tentativo ha esito positivo, il thread chiamante verrà interrotta, ovvero effetti negativo sulle prestazioni del sito. In questo caso, nessun codice dopo la chiamata al <xref:System.Web.HttpResponse.End%2A> metodo viene eseguito.  
  
 Se il <xref:System.Web.HttpResponse.End%2A> metodo non è in grado di generare un <xref:System.Threading.ThreadAbortException>, invece Svuota i byte di risposta al client. Ciò avviene in modo sincrono, che può anche essere effetti negativi sulle prestazioni del sito.  
  
 In entrambi i casi (o meno un <xref:System.Threading.ThreadAbortException> è stata generata eccezione), la pipeline di risposta si passa il <xref:System.Web.HttpApplication.EndRequest> evento.  
  
 Il <xref:System.Web.HttpApplication.CompleteRequest%2A> metodo non genera un'eccezione e il codice dopo la chiamata al <xref:System.Web.HttpApplication.CompleteRequest%2A> il metodo può essere eseguito. Se si desidera evitare l'esecuzione di codice successivo e la riduzione delle prestazioni di <xref:System.Web.HttpResponse.End%2A> è accettabile, è possibile chiamare <xref:System.Web.HttpResponse.End%2A> anziché <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">La chiamata a <see cref="M:System.Web.HttpResponse.End" /> ha terminato la richiesta corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto risultato asincrono.</param>
        <summary>Completa un'operazione di scaricamento asincrona.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Lo scaricamento asincrono non è supportato e il parametro <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Lo scaricamento asincrono non è supportato e non è possibile eseguire il cast del parametro <paramref name="asyncResult" /> a un oggetto <c>FlushAsyncResult</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di minuti dopo i quali una pagina inserita nella cache di un browser scade. Se l'utente torna alla stessa pagina prima che scada, viene visualizzata la versione memorizzata nella cache. <see cref="P:System.Web.HttpResponse.Expires" /> viene fornito per supportare la compatibilità con le versioni precedenti di ASP.</summary>
        <value>Numero di minuti dopo i quali la pagina scade.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> e <xref:System.Web.HttpResponse.CacheControl%2A> proprietà sono state deprecate a favore i metodi del <xref:System.Web.HttpCachePolicy> classe disponibile tramite il <xref:System.Web.HttpResponse.Cache%2A> cache di output intrinseco per controllare Internet Information Services (IIS) e memorizza nella cache client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la data e l'ora assolute in cui rimuovere le informazioni memorizzate dalla cache. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> viene fornito per supportare la compatibilità con le versioni precedenti di ASP.</summary>
        <value>Data e ora di scadenza della pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, e <xref:System.Web.HttpResponse.CacheControl%2A> proprietà sono state deprecate a favore i metodi del <xref:System.Web.HttpCachePolicy> classe disponibile tramite il <xref:System.Web.HttpResponse.Cache%2A> cache di output intrinseco per controllare Internet Information Services (IIS) e memorizza nella cache client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto filtro di wrapping usato per modificare il corpo dell'entità HTTP prima della trasmissione.</summary>
        <value>Oggetto <see cref="T:System.IO.Stream" /> che funge da filtro di output.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si crea un `Stream` e impostare il <xref:System.Web.HttpResponse.Filter%2A> proprietà per il `Stream` oggetto, HTTP tutti output inviato da <xref:System.Web.HttpResponse.Write%2A> passa attraverso il filtro.  
  
   
  
## Examples  
 L'esempio seguente è una pagina ASP.NET che imposta il <xref:System.Web.HttpResponse.Filter%2A> proprietà in una nuova istanza del `UpperCaseFilter` classe, un oggetto personalizzato <xref:System.IO.Stream> classe che consente di convertire tutto il testo che passa attraverso di esso in lettere maiuscole. Le informazioni sulla richiesta vengono salvate in un file di testo, quindi il <xref:System.Web.HttpResponse.Filter%2A> proprietà è impostata. Una volta il filtro di risposta, il codice chiama il <xref:System.Web.HttpRequest.MapPath%2A> metodo per ottenere il percorso assoluto in un file di testo denominato `TestFile.txt` che funge da origine per il contenuto della risposta. Il codice crea quindi un nuovo <xref:System.IO.StreamReader> oggetto da cui leggere il file di testo dall'inizio alla fine e quindi chiama il <xref:System.Web.HttpResponse.Write%2A> metodo per visualizzare il contenuto del file della pagina.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'applicazione di filtri non è consentita con l'entità.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invia al client tutto l'output attualmente memorizzato nel buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Forza tutti attualmente memorizzato nel buffer di output da inviare al client. Il <xref:System.Web.HttpResponse.Flush%2A> metodo può essere chiamato più volte durante l'elaborazione della richiesta.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Drawing.Graphics.Save%2A> per salvare un <xref:System.Drawing.Bitmap> dell'oggetto per il <xref:System.Web.HttpResponse.OutputStream%2A> formato proprietà e converte l'immagine JPEG. Il codice chiama quindi il `Dispose` metodo il <xref:System.Drawing.Bitmap> oggetto e un <xref:System.Drawing.Graphics> oggetto rilasciare le risorse che erano in uso. Chiama quindi il <xref:System.Web.HttpResponse.Flush%2A> metodo per inviare il contenuto della risposta al client richiedente.  
  
 Per un esempio completo, vedere la <xref:System.Web.HttpResponse> classe.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La cache viene svuotata dopo l'invio della risposta.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invia in modo asincrono al client tutto l'output attualmente memorizzato nel buffer.</summary>
        <returns>Oggetto <see cref="T:System.Threading.Tasks.Task" /> che rappresenta l'operazione asincrona.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto <see cref="T:System.Text.Encoding" /> che rappresenta la codifica per il flusso di output dell'intestazione corrente.</summary>
        <value>Oggetto <see cref="T:System.Text.Encoding" /> contenente informazioni riguardanti il set di caratteri per l'intestazione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.HeaderEncoding%2A> proprietà offre la possibilità di disabilitare o modificare il <xref:System.Text.Encoding> oggetto su un'intestazione di risposta utilizzando il <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, o <xref:System.Text.UTF8Encoding> oggetto. Il valore predefinito di valore di codifica è il <xref:System.Text.UTF8Encoding> classe.  
  
 Modificando il tipo di <xref:System.Web.HttpResponse.HeaderEncoding%2A> proprietà, è possibile aumentare il rischio di determinati attacchi dannosi o dati sensibili causa da inviare tramite l'intestazione della risposta. Attacchi injection di intestazione possono essere evitati in parte, lasciando il <xref:System.Web.HttpResponse.HeaderEncoding%2A> proprietà di una risposta per l'impostazione predefinita. Un attacco contro un'applicazione vulnerabile può restituire dati consegnati come parte di un'intestazione di risposta. Se il <xref:System.Web.HttpResponse.HeaderEncoding%2A> è disabilitata a causa di un requisito per le righe di continuazione in un'intestazione o se un'intestazione viene costruita in base al risultato di dati non attendibili, i dati dell'intestazione devono essere convalidati prima dell'invio nel flusso di risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore di codifica è <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Il valore di codifica è <see cref="P:System.Text.Encoding.Unicode" />.  
  
 \- oppure -  
  
 Le intestazioni sono già state inviate.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la raccolta di intestazioni di risposta.</summary>
        <value>Oggetto <see cref="T:System.Collections.Specialized.NameValueCollection" /> di intestazioni di risposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.Headers%2A> proprietà è supportata solo con il [!INCLUDE[iisver](~/includes/iisver-md.md)] modalità pipeline integrata e almeno .NET Framework 3.0. Quando si tenta di accedere il <xref:System.Web.HttpResponse.Headers%2A> proprietà e una di queste due condizioni non vengono soddisfatte, un <xref:System.PlatformNotSupportedException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L'operazione richiede la modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e almeno .NET Framework versione 3.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supportato in .NET Framework 4.5.2 e versioni successive]  
  
 Ottiene un valore che indica se le intestazioni delle risposte sono state scritte.</summary>
        <value>
          <see langword="true" /> se le intestazioni delle risposte sono state scritte; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il client è ancora connesso al server.</summary>
        <value>
          <see langword="true" /> se il client è attualmente connesso; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.IsClientConnected%2A> restituisce proprietà `false` quando le condizioni seguenti sono vere:  
  
-   È stata interrotta la connessione al client. Ciò può verificarsi se il <xref:System.Web.HttpResponse.Close%2A> chiamata del metodo, o se il client ha arrestato l'esecuzione della pagina Web o visualizzare in un'altra pagina.  
  
-   Il <xref:System.Web.HttpWorkerRequest> oggetto che gestisce la richiesta è `null` o <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> restituisce `false`. Se un oggetto personalizzato <xref:System.Web.HttpWorkerRequest> oggetto gestisce la richiesta, il <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> metodo potrebbe essere impostato in base a criteri personalizzati. Ad esempio, la richiesta di lavoro personalizzato potrebbe forzare un timeout dopo un periodo di tempo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Web.HttpResponse.IsClientConnected%2A> proprietà per verificare se il client che richiede la pagina rimane connesso al server. Se <xref:System.Web.HttpResponse.IsClientConnected%2A> è true, il codice chiama il <xref:System.Web.HttpResponse.Redirect%2A> (metodo) e il client visualizzerà un'altra pagina. Se <xref:System.Web.HttpResponse.IsClientConnected%2A> è false, quindi il codice chiama il <xref:System.Web.HttpResponse.End%2A> metodo e tutta l'elaborazione di pagina viene interrotto.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore booleano che indica se il client è in fase di trasferimento a una nuova posizione.</summary>
        <value>
          <see langword="true" /> se il valore dell'intestazione di risposta della posizione è diverso dalla posizione corrente; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> proprietà con il <xref:System.Web.HttpResponse.RedirectLocation%2A> proprietà per verificare e determinare se l'URI assoluto trasmesso al client in HTTP `Location` intestazione è diversa da quello di URI corrente e ciò che il nuovo URI che viene saranno trasferiti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Consente l'output del testo verso il flusso di risposta HTTP in uscita.</summary>
        <value>Oggetto <see cref="T:System.IO.TextWriter" /> che consente l'output personalizzato verso il client.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente è una pagina ASP.NET che contiene un <xref:System.Web.UI.WebControls.TextBox> controllo che ha il <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> proprietà impostata su <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Il codice della pagina accetta il testo da un utente immette nel <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, utilizza il <xref:System.Web.HttpServerUtility.HtmlEncode%2A> codificarli in formato HTML (metodo) e <xref:System.Web.HttpResponse.Output%2A> proprietà per visualizzare la stringa codificata per la pagina.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Consente l'output binario verso il corpo del contenuto HTTP in uscita.</summary>
        <value>Oggetto I/O <see cref="T:System.IO.Stream" /> che rappresenta il contenuto non elaborato del corpo del contenuto HTTP in uscita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire da .NET Framework versione 2.0, quando si utilizza il <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo del flusso dei / o restituito dal <xref:System.Web.HttpResponse.OutputStream%2A> proprietà, potrebbero essere generate le eccezioni seguenti:  
  
-   <xref:System.ArgumentOutOfRangeException>, se il `offset` o `count` parametro è negativo o se il `buffer` la lunghezza del parametro meno il `offset` parametro è minore o uguale a zero.  
  
-   <xref:System.ArgumentNullException>, se il `buffer` parametro `null`.  
  
   
  
## Examples  
 Nell'esempio seguente viene chiamato il <xref:System.Drawing.Image.Save%2A> per salvare un <xref:System.Drawing.Bitmap> dell'oggetto per il <xref:System.Web.HttpResponse.OutputStream%2A> , proprietà e convertire l'immagine in formato JPEG. Il codice chiama quindi il metodo Dispose sul <xref:System.Drawing.Bitmap> oggetto e un <xref:System.Drawing.Graphics> oggetto rilasciare le risorse che erano in uso. Infine, il codice chiama il <xref:System.Web.HttpResponse.Flush%2A> metodo per inviare il contenuto della risposta al client richiedente.  
  
 Per un esempio completo, vedere la <xref:System.Web.HttpResponse> classe.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> non è disponibile.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da aggiungere all'intestazione <see langword="PICS-Label" />.</param>
        <summary>Aggiunge un'intestazione HTTP <see langword="PICS-Label" /> al flusso di output.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Piattaforma per Internet Content Selection (PICS) è uno standard del World Wide Web Consortium (W3C) per le etichette del contenuto. PICS è essenzialmente un linguaggio per la creazione di un sistema di classificazione.  
  
 Qualsiasi valore può essere un'etichetta PICS; ASP.NET non convalida l'etichetta. La lunghezza massima della stringa è di 255 caratteri. Per ulteriori informazioni sulla sintassi e standard PICS, vedere il [World Wide Web Consortium](http://go.microsoft.com/fwlink/?LinkID=37125) sito Web.  
  
   
  
## Examples  
 L'esempio seguente è una pagina ASP.NET che visualizza un'immagine. Il codice della pagina chiama il <xref:System.Web.HttpResponse.Pics%2A> per impostare il protocollo HTTP `PICS-Label` intestazione per la risposta. La stringa che viene passata come parametro per il <xref:System.Web.HttpResponse.Pics%2A> metodo rappresenta un'etichetta di classificazione generata dal sito Web di contenuto classificazione associazione ICRA (Internet).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Alza di livello un oggetto promesso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">URL della richiesta push. Deve essere il percorso virtuale della risorsa relativa di cui il server eseguirà il push al client.</param>
        <summary>Questa API è destinata al supporto di applicazioni che inviano promesse push ai client HTTP 2.0. Per altre informazioni relative al push del server HTTP2, vedere l'articolo relativo alla [Specifica HTTP/2, sezione 8.2: push del server](https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise è non deterministico e applicazioni non devono contenere la logica che dipende da esso. Il suo unico scopo è il vantaggio di prestazioni in alcuni casi. Esistono numerose condizioni (protocollo e implementazione) che possono causare per ignorare le richieste di push completamente. La previsione è basata sul fire and forget.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">URL della richiesta push. Deve essere il percorso virtuale della risorsa relativa di cui il server eseguirà il push al client.</param>
        <param name="method">Metodo di richiesta HTTP che verrà usato dalla richiesta di push.</param>
        <param name="headers">Intestazione della richiesta HTTP che verrà usato dalla richiesta di push.</param>
        <summary>Questa API è destinata al supporto di applicazioni che inviano promesse push ai client HTTP 2.0. Per altre informazioni relative al push del server HTTP2, vedere l'articolo relativo alla [Specifica HTTP/2, sezione 8.2: push del server](https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise è non deterministico e applicazioni non devono contenere la logica che dipende da esso. Il suo unico scopo è il vantaggio di prestazioni in alcuni casi. Esistono numerose condizioni (protocollo e implementazione) che possono causare per ignorare le richieste di push completamente. La previsione è basata sul fire and forget.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reindirizza un client a un nuovo URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Percorso di destinazione. Può trattarsi di un percorso virtuale relativo dell'applicazione.</param>
        <summary>Reindirizza una richiesta a un nuovo URL e specifica il nuovo URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata <xref:System.Web.HttpResponse.Redirect%2A> è equivalente alla chiamata <xref:System.Web.HttpResponse.Redirect%2A> con il secondo parametro impostato su `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> chiamate <xref:System.Web.HttpResponse.End%2A> che genera un <xref:System.Threading.ThreadAbortException> eccezione dopo il completamento. Questa eccezione ha effetti negativi sulle prestazioni dell'applicazione Web. È pertanto consigliabile anziché questo overload di utilizzare il <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> overload e passare `false` per il `endResponse` parametro e quindi chiamare il <xref:System.Web.HttpApplication.CompleteRequest%2A> metodo. Per altre informazioni, vedere il metodo <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Per pagine mobile, se l'applicazione si basa su sessioni senza cookie o potrebbe ricevere richieste da dispositivi mobili che richiedono sessioni senza cookie, usando una tilde (~) in un percorso può comportare la creazione di una nuova sessione e la possibile perdita di dati della sessione. Per impostare una proprietà in un controllo per dispositivi mobili con un percorso, ad esempio "~ / percorso", risolvere il percorso utilizzando <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / percorso" prima di assegnarlo alla proprietà.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 302. È un modo alternativo per trasferire il controllo a un'altra pagina di <xref:System.Web.HttpServerUtility.Transfer%2A> metodo. Il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo è in genere più efficiente perché non provoca un round trip al client. Per ulteriori informazioni, vedere [come: reindirizzare gli utenti a un'altra pagina](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 Nell'esempio seguente forza un reindirizzamento a un altro sito Web non condizionale.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Viene tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Posizione della destinazione.</param>
        <param name="endResponse">Indica se l'esecuzione della pagina corrente deve terminare.</param>
        <summary>Reindirizza un client a un nuovo URL. Specifica il nuovo URL e se l'esecuzione della pagina corrente deve terminare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un URL assoluto (ad esempio, http://www.contoso.com/default.aspx) o un URL relativo (ad esempio default. aspx) può essere specificato per il percorso di destinazione, ma alcuni browser potrebbe rifiutare un URL relativo.  
  
 Quando si utilizza questo metodo in un gestore di pagina per terminare una richiesta per una pagina e avviare una nuova richiesta per un'altra pagina, impostare `endResponse` a `false` e quindi chiamare il <xref:System.Web.HttpApplication.CompleteRequest%2A> metodo. Se si specifica `true` per il `endResponse` parametro, questo metodo chiama il <xref:System.Web.HttpResponse.End%2A> metodo per la richiesta originale, che genera un <xref:System.Threading.ThreadAbortException> eccezione quando viene completato. Questa eccezione ha effetti negativi sulle prestazioni dell'applicazione Web, motivo per cui il passaggio di `false` per il `endResponse` consiglia di parametro. Per altre informazioni, vedere il metodo <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Pagine per dispositivi mobili, se l'applicazione si basa su sessioni senza cookie o potrebbe ricevere richieste da dispositivi mobili che richiedono sessioni senza cookie, usando una tilde (~) in un percorso può creare una nuova sessione e perdere i dati della sessione. Per impostare una proprietà in un controllo per dispositivi mobili con un percorso, ad esempio "~ / percorso", risolvere il percorso utilizzando <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / percorso" prima di assegnarlo alla proprietà.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 302. È un modo alternativo per trasferire il controllo a un'altra pagina di <xref:System.Web.HttpServerUtility.Transfer%2A> metodo. Il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo è in genere più efficiente perché non provoca un round trip al client. Per ulteriori informazioni, vedere [come: reindirizzare gli utenti a un'altra pagina](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Web.HttpResponse.IsClientConnected%2A> proprietà per verificare se il client che richiede la pagina rimane connesso al server. Se <xref:System.Web.HttpResponse.IsClientConnected%2A> è true, il codice chiama il <xref:System.Web.HttpResponse.Redirect%2A> (metodo) e il client visualizzerà un'altra pagina. Se <xref:System.Web.HttpResponse.IsClientConnected%2A> è false, quindi il codice chiama il <xref:System.Web.HttpResponse.End%2A> metodo e tutta l'elaborazione di pagina viene interrotto.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> contiene un carattere di nuova riga.</exception>
        <exception cref="T:System.Web.HttpException">Viene tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <exception cref="T:System.ApplicationException">La richiesta della pagina è il risultato di un callback.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione <see langword="Location" /> HTTP.</summary>
        <value>URI assoluto trasmesso al client nell'intestazione HTTP <see langword="Location" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare questa proprietà per specificare l'URL di reindirizzamento quando si codifica un reindirizzamento permanente tramite il codice di risposta HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le intestazioni HTTP sono già state scritte.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un URL specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Percorso a cui reindirizzare la richiesta.</param>
        <summary>Esegue un reindirizzamento permanente dall'URL richiesto all'URL specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> overload del metodo fornisce un codice di stato HTTP 301 nella risposta e include l'URL a cui reindirizzare la richiesta. Un codice di stato HTTP 301 è un codice standard in una risposta HTTP. Indica che esiste un reindirizzamento permanente e viene indicato il percorso di reindirizzamento.  
  
 La chiamata di <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> overload del metodo termina la risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> include un carattere di nuova riga (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Percorso a cui reindirizzare la richiesta.</param>
        <param name="endResponse">
          <see langword="true" /> per terminare la risposta; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</param>
        <summary>Esegue un reindirizzamento permanente dall'URL richiesto all'URL specificato e fornisce l'opzione per completare la risposta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> overload del metodo fornisce un codice di stato HTTP 301 nella risposta e include l'URL a cui reindirizzare la richiesta. Overload di questo metodo fornisce anche l'opzione per specificare se terminare o per completare la risposta dopo il reindirizzamento è stato eseguito. Un codice di stato HTTP 301 è un codice standard in una risposta HTTP. Indica che esiste un reindirizzamento permanente e viene indicato il percorso di reindirizzamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> include un carattere di nuova riga (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reindirizza una richiesta a un nuovo URL tramite valori di parametri di route, un nome di route o entrambi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Reindirizza una richiesta a un nuovo URL tramite valori di parametri di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte l'oggetto è passato in `routeValues` per un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> oggetto utilizzando il <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> costruttore. Il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> viene quindi chiamato il metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 302.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per reindirizzare una route che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <summary>Reindirizza una richiesta a un nuovo URL tramite un nome di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte il nome della route che viene passato in `routeName` a un URL tramite il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodo.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 302.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per reindirizzare una route denominata `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Reindirizza una richiesta a un nuovo URL tramite valori di parametri di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo chiama il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 302.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per reindirizzare una route che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Reindirizza una richiesta a un nuovo URL tramite valori di parametri di route e un nome di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte l'oggetto è passato in `routeValues` per un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> oggetto utilizzando il <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> costruttore. Il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> viene quindi chiamato il metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 302.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per reindirizzare una route denominata `Product` e che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Reindirizza una richiesta a un nuovo URL tramite valori di parametri di route e un nome di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodo viene chiamato per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 302.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per reindirizzare una route denominata `Product` e che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite valori di parametri di route, un nome di route o entrambi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite valori di parametri di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte l'oggetto è passato in `routeValues` per un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> oggetto utilizzando il <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> costruttore. Il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> viene quindi chiamato il metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 301.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per reindirizzare una route che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite un nome di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte il nome della route che viene passato in `routeName` a un URL tramite il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodo.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 301.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per reindirizzare una route denominata `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite valori di parametri di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo chiama il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 301.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per reindirizzare una route che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite i valori di parametri di route e il nome di route corrispondenti al nuovo URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.RedirectPermanent%2A> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte l'oggetto è passato in `routeValues` per un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> oggetto utilizzando il <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> costruttore. Il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> viene quindi chiamato il metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 301.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per reindirizzare una route denominata `Product` e che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite valori di parametri di route e un nome di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo chiama il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento restituendo un codice di stato HTTP 301.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per reindirizzare una route denominata `Product` e che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rimuove elementi memorizzati nella cache dalla cache di output usando il provider della cache di output predefinito.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso virtuale assoluto degli elementi rimossi dalla cache.</param>
        <summary>Rimuove dalla cache tutti gli elementi memorizzati associati al provider della cache di output predefinito. Il metodo è statico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo per rimuovere gli elementi della cache di output associati con il provider di cache di output predefinito. Chiamare il <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> per rimuovere gli elementi della cache di output associati al provider della cache di output personalizzati che vengono specificati nel file di configurazione del sito Web.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> non è un percorso virtuale assoluto.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso virtuale assoluto degli elementi rimossi dalla cache.</param>
        <param name="providerName">Provider usato per rimuovere gli artefatti della cache di output associati al percorso specificato.</param>
        <summary>Usa il provider della cache di output specificato per rimuovere tutti gli elementi della cache di output associati al percorso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo per rimuovere gli elementi della cache di output che sono associati i provider di cache di output personalizzati che vengono specificati nel file di configurazione del sito Web. Per rimuovere gli elementi della cache di output associati con il provider di cache di output predefinito, chiamare il <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> non è un percorso valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Cookie della raccolta da aggiornare.</param>
        <summary>Poiché il metodo <b>HttpResponse.SetCookie</b> è solo per uso interno, non è possibile chiamarlo nel codice. In alternativa, è possibile chiamare il metodo <b>HttpResponse.Cookies.Set</b>, come illustrato nell'esempio seguente.<br /> Aggiorna un cookie esistente nella raccolta di cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente aggiorna il valore di un cookie esistente.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Si è tentato di impostare il cookie dopo l'invio delle intestazioni HTTP.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta la riga <see langword="Status" /> restituita al client.</summary>
        <value>L'impostazione del codice di stato fa in modo che venga restituita al client una stringa di descrizione dello stato dell'output HTTP. Il valore predefinito è 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> è stato deprecato a favore del <xref:System.Web.HttpResponse.StatusDescription%2A> e viene fornito solo per compatibilità con le versioni precedenti di ASP. Con ASP.NET, utilizzare <xref:System.Web.HttpResponse.StatusDescription%2A> invece.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Lo stato è impostato su un codice non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il codice di stato HTTP dell'output restituito al client.</summary>
        <value>Intero che rappresenta lo stato dell'output HTTP restituito al client. Il valore predefinito è 200 (OK). Per un elenco dei codici di stato validi, vedere [codici di stato Http](http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente controlla il codice di stato del flusso di output. Se il codice di stato non è uguale a 200, viene eseguito il codice aggiuntivo.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          Il parametro <see cref="P:System.Web.HttpResponse.StatusCode" /> viene impostato dopo l'invio delle intestazioni HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la stringa di stato HTTP dell'output restituito al client.</summary>
        <value>Stringa che descrive lo stato dell'output HTTP restituito al client. Il valore predefinito è "OK". Per un elenco dei codici di stato validi, vedere [codici di stato Http](http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente verifica la stringa di stato del flusso di output. Se lo stato non è uguale a "OK", viene eseguito il codice aggiuntivo.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          Il parametro <paramref name="StatusDescription" /> viene impostato dopo l'invio delle intestazioni HTTP.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza del valore selezionato è maggiore di 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che qualifica il codice di stato della risposta.</summary>
        <value>Intero che rappresenta il codice di stato secondario [!INCLUDE[iisver](~/includes/iisver-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.SubStatusCode%2A> proprietà è supportata solo con la modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e almeno .NET Framework versione 3.0. Quando si imposta la <xref:System.Web.HttpResponse.SubStatusCode%2A> proprietà, lo stato viene registrato [!INCLUDE[iisver](~/includes/iisver-md.md)] se è definita la traccia richieste non riuscite. Indipendentemente dal fatto è definita la traccia, il codice mai inviato come parte della risposta finale alla richiesta. Per ulteriori informazioni, vedere [risoluzione dei problemi non è stato possibile Requests utilizzando Failed Request Tracing in IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 L'esempio seguente imposta il <xref:System.Web.HttpResponse.SubStatusCode%2A> proprietà in un gestore eventi per il <xref:System.Web.HttpApplication> istanza il <xref:System.Web.HttpApplication.PostAuthenticateRequest> evento. Inserire il file di codice nella cartella App_Code dell'applicazione Web e configurare il file Web. config per registrare il modulo. Per ulteriori informazioni, vedere [procedura dettagliata: creazione e registrazione di un modulo HTTP personalizzato](http://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L'operazione richiede la modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e almeno .NET Framework versione 3.0.</exception>
        <exception cref="T:System.Web.HttpException">Il codice di stato viene impostato dopo l'invio di tutte le intestazioni HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la connessione supporta le operazioni di scaricamento asincrone.</summary>
        <value>
          <see langword="true" /> se la connessione supporta le operazioni di scaricamento asincrone; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce il valore di <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se inviare il contenuto HTTP al client.</summary>
        <value>
          <see langword="true" /> per sopprimere l'output; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene controllato se il <xref:System.Web.HttpRequest.IsSecureConnection%2A> è impostata su false. Questo caso, il <xref:System.Web.HttpResponse.SuppressContent%2A> è impostata su true per interrompere l'invio della risposta.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supportato in .NET Framework 4.5.2 e versioni successive]  
  
 Ottiene o imposta un valore che indica se eliminare l'intestazione <c>Cache Control: private</c> predefinita per la risposta HTTP corrente.</summary>
        <value>
          <see langword="true" /> Per eliminare il valore predefinito <c>Cache Control: private</c> intestazione per la risposta HTTP corrente; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, ASP.NET invia una `Cache-Control: private` intestazione della risposta a meno che non è stato specificato un criterio di cache esplicita per la risposta. Questa proprietà consente di eliminare l'intestazione della risposta predefinita in base a una richiesta. L'intestazione può ancora essere inibita per l'intera applicazione impostando <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> in [elemento httpRuntime (Schema delle impostazioni ASP.NET)](http://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) o [outputCache elemento per la memorizzazione nella cache (Schema delle impostazioni ASP.NET)](http://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Prestare attenzione quando il valore predefinito di eliminazione `Cache-Control: private` intestazione, come proxy e agli altri intermediari possono considerare le risposte senza questa intestazione come memorizzabile nella cache per impostazione predefinita. Quest ' ultimo può causare l'involontaria memorizzazione nella cache di informazioni riservate. Vedere [RFC 2616, 13.4 sec](http://tools.ietf.org/html/rfc2616) per ulteriori informazioni.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se il reindirizzamento di autenticazione basata su form alla pagina di accesso deve essere eliminato.</summary>
        <value>
          <see langword="true" /> se deve essere soppresso il reindirizzamento dell'autenticazione basata su moduli; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, autenticazione basata su form converte i codici di stato HTTP 401 in 302 per reindirizzare alla pagina di accesso. Non è adatto per alcune classi di errori, ad esempio quando l'autenticazione ha esito positivo ma l'autorizzazione ha esito negativo, o quando la richiesta corrente è una richiesta di servizio AJAX o web. Questa proprietà fornisce un modo per disattivare il comportamento di reindirizzamento e inviare il codice di stato originale al client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive il file specificato direttamente in un flusso di output di risposta HTTP senza memorizzarlo nel buffer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da scrivere nell'output HTTP.</param>
        <summary>Scrive il file specificato direttamente in un flusso di output di risposta HTTP senza memorizzarlo nel buffer.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="filename" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da scrivere nell'output HTTP.</param>
        <param name="offset">Posizione nel file da scrivere nell'output HTTP.</param>
        <param name="length">Numero di byte da trasmettere.</param>
        <summary>Scrive la parte di file specificata direttamente in un flusso di output di risposta HTTP senza memorizzarla nel buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si specifica 0 come il `offset` parametro e -1 come il `length` parametro, viene inviato l'intero file.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="offset" /> è minore di zero.  
  
 \- oppure -  
  
 Il parametro <paramref name="length" /> è minore di -1.  
  
 \- oppure -  
  
 Il parametro <paramref name="length" /> specifica un numero di byte maggiore del numero di byte contenuto nel file meno l'offset.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La richiesta di lavoro out-of-process non è supportata.  
  
 \- oppure -  
  
 La risposta non utilizza l'oggetto <see cref="T:System.Web.HttpWriter" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="offset" /> è minore di zero o maggiore delle dimensioni del file.  
  
 \- oppure -  
  
 Il parametro <paramref name="length" /> è minore di -1 o maggiore del valore del parametro <paramref name="offset" /> più le dimensioni del file.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se gli errori personalizzati [!INCLUDE[iisver](~/includes/iisver-md.md)] sono disabilitati.</summary>
        <value>
          <see langword="true" /> per disabilitare gli errori personalizzati IIS; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> proprietà viene utilizzata solo quando l'applicazione è ospitata in IIS 7.0. Durante l'esecuzione in modalità classica in IIS 7.0 il <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> è il valore predefinito della proprietà `true`. Durante l'esecuzione in modalità integrata, il <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> è il valore predefinito della proprietà `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni in un flusso di output di risposta HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Carattere da scrivere nel flusso di output HTTP.</param>
        <summary>Scrive un carattere in un flusso di output di risposta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente crea una serie di costanti che vengono scritti in una pagina ASP.NET utilizzando il metodo Write. Il codice chiama questa versione del metodo di scrittura per scrivere le costanti di singoli caratteri della pagina.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Object" /> da inviare al flusso di output HTTP.</param>
        <summary>Scrive un oggetto <see cref="T:System.Object" /> in un flusso di risposta HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa da scrivere nel flusso di output HTTP.</param>
        <summary>Scrive una stringa in un flusso di output di risposta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pagine HTML generate in modo dinamico possono provocare rischi di sicurezza se input ricevuti dai client Web non viene convalidato quando viene ricevuto da un client o quando la trasmissione a un client. Lo script dannoso incorporato nell'input inviato a un sito Web e successivamente riscritti a un client può sembrare originati da una fonte attendibile. Questo rischio di sicurezza viene considerato un attacco di script tra siti. È sempre opportuno convalidare i dati ricevuti da un client quando verrà trasmesso dal sito al browser client.  
  
 Inoltre, ogni volta che si scrivono in formato HTML tutti i dati ricevuti come input, è necessario codificarli usando una tecnica, ad esempio <xref:System.Web.HttpServerUtility.HtmlEncode%2A> o <xref:System.Web.HttpServerUtility.UrlEncode%2A> per impedire l'esecuzione di uno script dannoso. Questa tecnica è utile per i dati che non è stati convalidati quando è stato ricevuto.  
  
 Quando si codificano o filtrare i dati, è necessario specificare un set di caratteri per le pagine Web in modo che il filtro può identificare e rimuovere qualsiasi sequenze di byte che non appartengono a impostato (ad esempio, le sequenze non alfanumerici) che potrebbero avere uno script dannoso incorporato nel essi.  
  
 Per ulteriori informazioni sugli attacchi script tra siti, vedere l'articolo Q252985 "Modalità per impedire Cross-Site Scripting problemi di protezione" sui [della Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?LinkID=37115) sito Web.  
  
   
  
## Examples  
 Nell'esempio seguente restituisce il nome del client al browser del client. Il <xref:System.Web.HttpServerUtility.HtmlEncode%2A> metodo rimuove qualsiasi script dannoso e caratteri non validi che è state inviate nel `UserName` campo di input.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di caratteri da scrivere.</param>
        <param name="index">Posizione di inizio scrittura all'interno della matrice di caratteri.</param>
        <param name="count">Numero di caratteri da scrivere, a partire da <c>index</c>.</param>
        <summary>Scrive una matrice di caratteri in un flusso di output di risposta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente crea una serie di costanti che vengono scritti in una pagina ASP.NET utilizzando il metodo Write. Il codice chiama questa versione del metodo di scrittura per scrivere le costanti di singoli caratteri della pagina.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive il file specificato direttamente in un flusso di output di risposta HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da scrivere nell'output HTTP.</param>
        <summary>Scrive il contenuto del file specificato direttamente in un flusso di output di risposta HTTP come blocco file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene utilizzato con file di grandi dimensioni, la chiamata al metodo potrebbe generare un'eccezione. Le dimensioni del file che può essere utilizzato con questo metodo dipendono dalla configurazione hardware del server Web. Per ulteriori informazioni, vedere l'articolo 812406 "PRB: WriteFile non è possibile scaricare un File di grandi dimensioni" sui [della Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) sito Web.  
  
   
  
## Examples  
 Nell'esempio seguente scrive tutto il contenuto di un file di testo denominato `Login.txt` (che potrebbe contenere letterale i controlli di input di testo e HTML) direttamente nel flusso di output.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="filename" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da scrivere in un blocco di memoria.</param>
        <param name="readIntoMemory">Indica se il file verrà scritto in un blocco di memoria.</param>
        <summary>Scrive il contenuto del file specificato direttamente in un flusso di output di risposta HTTP come blocco di memoria.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene utilizzato con file di grandi dimensioni, la chiamata al metodo potrebbe generare un'eccezione. Le dimensioni del file che può essere utilizzato con questo metodo dipendono dalla configurazione hardware del server Web. Per ulteriori informazioni, vedere l'articolo 812406 "PRB: WriteFile non è possibile scaricare un File di grandi dimensioni" sui [della Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) sito Web.  
  
   
  
## Examples  
 Nell'esempio seguente scrive un file di memoria.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="filename" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Handle di file da scrivere nel flusso di output HTTP.</param>
        <param name="offset">Posizione di byte nel file in cui inizierà la scrittura.</param>
        <param name="size">Numero di byte da scrivere nel flusso di output.</param>
        <summary>Scrive il file specificato direttamente in un flusso di output di risposta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene utilizzato con file di grandi dimensioni, la chiamata al metodo potrebbe generare un'eccezione. Le dimensioni del file che può essere utilizzato con questo metodo dipendono dalla configurazione hardware del server Web. Per ulteriori informazioni, vedere l'articolo 812406 "PRB: WriteFile non è possibile scaricare un File di grandi dimensioni" sui [della Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) sito Web.  
  
   
  
## Examples  
 Nell'esempio seguente scrive tutto il contenuto di un file di testo denominato `Login.txt` (che potrebbe contenere letterale i controlli di input di testo e HTML) direttamente nel flusso di output.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileHandler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> è minore di 0.  
  
 \- oppure -  
  
 <paramref name="size" /> è maggiore della differenza tra la dimensione del file e <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da scrivere nel flusso di output HTTP.</param>
        <param name="offset">Posizione di byte nel file in cui inizierà la scrittura.</param>
        <param name="size">Numero di byte da scrivere nel flusso di output.</param>
        <summary>Scrive il file specificato direttamente in un flusso di output di risposta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene utilizzato con file di grandi dimensioni, la chiamata al metodo potrebbe generare un'eccezione. Le dimensioni del file che può essere utilizzato con questo metodo dipendono dalla configurazione hardware del server Web. Per ulteriori informazioni, vedere l'articolo 812406 "PRB: WriteFile non è possibile scaricare un File di grandi dimensioni" sui [della Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) sito Web.  
  
   
  
## Examples  
 Nell'esempio seguente scrive tutto il contenuto di un file di testo denominato `Login.txt` (che può contenere testo letterale e HTML controlli di input) direttamente nel flusso di output.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> è minore di 0.  
  
 \- oppure -  
  
 <paramref name="size" /> è maggiore della differenza tra la dimensione del file e <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="filename" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Metodo, controllo utente o oggetto da sostituire.</param>
        <summary>Consente l'inserimento di blocchi di sostituzione della risposta nella risposta, che consente la generazione dinamica di aree di risposta specificate per risposte memorizzate nella cache di output.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare il <xref:System.Web.HttpResponse.WriteSubstitution%2A> metodo per la sostituzione post-cache nelle pagine nella cache di output. Passando un <xref:System.Web.HttpContext> oggetto a un metodo di callback con prescritta <xref:System.Web.HttpResponseSubstitutionCallback> firma, è possibile sostituire l'output memorizzato nella cache contenuto in qualsiasi posizione specificata nella cache della pagina. Per avviare la sostituzione, chiamare il <xref:System.Web.HttpResponse.WriteSubstitution%2A> metodo, passando il metodo di callback, che deve essere thread-safe e può essere uno dei seguenti:  
  
-   Un metodo statico del controllo pagina o un utente del contenitore.  
  
-   Un valore statico o metodo su un altro oggetto arbitrario di istanza.  
  
 Alla prima richiesta per la pagina, il <xref:System.Web.HttpResponse.WriteSubstitution%2A> chiamate di <xref:System.Web.HttpResponseSubstitutionCallback> delegato per produrre l'output. Aggiunge quindi un buffer di sostituzione nella risposta, che mantiene il delegato da chiamare alle richieste future. Infine, comporta una riduzione sul lato client nella cache da pubblica a solo server, garantendo le richieste successive di pagina richiamino il delegato non nella cache sul client.  
  
> [!NOTE]
>  Sostituzione post-cache non è supportata per un controllo utente memorizzato nella cache nella cache di output in cui viene applicata a livello di controllo utente. Questa operazione è nota anche come frammento di memorizzazione nella cache. Per ulteriori informazioni, vedere [la memorizzazione nella cache di parti di una pagina ASP.NET](http://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La destinazione del parametro <paramref name="callback" /> è di tipo <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
      </Docs>
    </Member>
  </Members>
</Type>