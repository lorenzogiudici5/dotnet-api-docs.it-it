<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a17c7c8e915146f80783b48f66085b74aa697ffa" />
    <Meta Name="ms.sourcegitcommit" Value="c902e847cd05ac37d93eca981b0fb009aae0a790" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/28/2018" />
    <Meta Name="ms.locfileid" Value="52454926" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Incapsula le informazioni sulla risposta HTTP da un'operazione ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I metodi e proprietà del <xref:System.Web.HttpResponse> classe vengono esposte tramite i <xref:System.Web.HttpApplication.Response%2A> proprietà delle <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, e <xref:System.Web.UI.UserControl> classi.  
  
 I metodi seguenti del <xref:System.Web.HttpResponse> classe sono supportati solo in scenari di postback e non nella post asincrono supportare gli scenari:  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Aggiornamenti parziali di pagine sono abilitati quando si usa <xref:System.Web.UI.UpdatePanel> controlli per aggiornare le aree selezionate di una pagina anziché aggiornare l'intera pagina con un postback. Per altre informazioni, vedere [Cenni preliminari sul controllo UpdatePanel](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) e [Cenni preliminari sul Rendering parziale della pagina](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 Nell'esempio seguente consente di disegnare rettangoli che si sovrappongono tre quando viene richiesta la pagina. Il codice inizia con l'impostazione di <xref:System.Web.HttpResponse.ContentType%2A> proprietà su image/jpeg, in modo che l'intera pagina verrà visualizzato in formato immagine JPEG. Il codice chiama quindi il <xref:System.Web.HttpResponse.Clear%2A> metodo per assicurarsi che con questa risposta non viene inviato alcun contenuto estraneo. Successivamente, il codice imposta la <xref:System.Web.HttpResponse.BufferOutput%2A> la proprietà su true in modo che la pagina viene elaborata completamente prima che venga inviato al client richiedente. Quindi vengono creati due oggetti utilizzati per disegnare rettangoli: una <xref:System.Drawing.Bitmap> e un <xref:System.Drawing.Graphics> oggetto. Le variabili create nella pagina vengono utilizzate come coordinate per disegnare rettangoli e una stringa che viene visualizzato all'interno del rettangolo più grande.  
  
 Quando vengono disegnati i tre rettangoli e la stringa visualizzata all'interno di questi, il <xref:System.Drawing.Bitmap> viene salvato nel <xref:System.IO.Stream> oggetto di cui è associato il <xref:System.Web.HttpResponse.OutputStream%2A> proprietà e il relativo formato è impostato su JPEG. Il codice chiama il <xref:System.Drawing.Image.Dispose%2A> e <xref:System.Drawing.Graphics.Dispose%2A> per rilasciare le risorse utilizzate dagli oggetti disegni due metodi. Infine, il codice chiama il <xref:System.Web.HttpResponse.Flush%2A> metodo per inviare la risposta memorizzata nel buffer sul client richiedente.  
  
> [!NOTE]
>  Nel codice, il <xref:System.Web.HttpResponse> oggetto viene definito con la parola chiave `Response`. Ad esempio, `Response.Clear()` si intende il <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> (metodo). Il <xref:System.Web.UI.Page> classe ha una proprietà denominata <xref:System.Web.UI.Page.Response%2A> che espone l'istanza corrente di <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> che consente l'output HTTP personalizzato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Web.HttpResponse" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro supporta l'infrastruttura .NET Framework e non è possibile usarlo direttamente dal codice.  
  
 I metodi e proprietà del <xref:System.Web.HttpResponse> classe vengono esposte tramite la funzione intrinseca <xref:System.Web.HttpContext.Response%2A> oggetto in ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">File, chiave di cache oppure oggetto <see cref="T:System.Web.Caching.CacheDependency" /> da aggiungere all'elenco delle dipendenze dell'applicazione.</param>
        <summary>Associa un set di dipendenze della cache alla risposta per semplificare l'invalidamento della risposta se è stata memorizzata nella cache di output e le dipendenze specificate vengono modificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.AddCacheDependency%2A> metodo consente di dipendenze da creare tra le risposte memorizzate nella cache e un <xref:System.Web.Caching.CacheDependency> oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare una dipendenza della cache usando il <xref:System.Web.HttpResponse.AddCacheDependency%2A> metodo e un <xref:System.Web.Caching.CacheDependency> oggetto.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="dependencies" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Questo metodo è stato chiamato troppo tardi nella pipeline di elaborazione della cache, dopo che la risposta inserita nella cache era già stata creata.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La memorizzazione nella cache le pagine ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rende la validità di una risposta memorizzata nella cache dipendente da altri elementi della cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Oggetto <see cref="T:System.Collections.ArrayList" /> contenente le chiavi degli elementi da cui dipende la risposta corrente memorizzata nella cache.</param>
        <summary>Rende la validità di una risposta memorizzata nella cache dipendente da altri elementi della cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando gli elementi di riferimento di `cacheKeys` parametro vengono rimossi dalla cache, la risposta memorizzata nella cache dell'elemento corrente non è valida.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare una pagina ASP.NET che è memorizzato nella cache di output. Il codice per la pagina Crea un' <xref:System.Collections.ArrayList> delle chiavi a cui sono associati agli elementi archiviati nell'oggetto di <xref:System.Web.Caching.Cache> oggetto. Successivamente, il codice passa il <xref:System.Collections.ArrayList> come parametro in una chiamata al <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> (metodo). In questo modo la risposta memorizzata nella cache di output non valido, se i file specificati nella <xref:System.Collections.ArrayList> modificare.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La memorizzazione nella cache le pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Matrice delle chiavi dell'elemento da cui dipende la risposta memorizzata nella cache.</param>
        <summary>Rende la validità di un elemento memorizzato nella cache dipendente da un altro elemento della cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando uno del `cacheKey`s vengono rimossi dalla cache, la risposta memorizzata nella cache dell'elemento corrente non è valida.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La memorizzazione nella cache le pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Chiave dell'elemento da cui dipende la risposta memorizzata nella cache.</param>
        <summary>Rende la validità di una risposta memorizzata nella cache dipendente da un altro elemento della cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando l'elemento corrispondente di `cacheKey` parametro viene rimosso dalla cache, la risposta memorizzata nella cache dell'elemento corrente non è valida.  
  
   
  
## Examples  
 L'esempio seguente è un controllo utente ASP.NET che è memorizzato nella cache di output. Il codice per il controllo chiama il <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> metodo con la chiave di un elemento archiviato nel <xref:System.Web.Caching.Cache> oggetto passato come parametro. Se l'elemento non esiste nella cache, viene invalidata la risposta del controllo che sono stata memorizzata nella cache di output. Ciò significa che nella richiesta successiva, una nuova versione della risposta del controllo verrà aggiunto alla cache di output.  
  
 Successivamente, il codice controlla se un elemento associato a un `bookData` chiave viene archiviata nel `Cache` dell'oggetto e viene visualizzato uno dei due righe di testo a seconda del risultato. Quindi, il codice imposta il <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> proprietà di un <xref:System.Web.UI.WebControls.DataGrid> controllo, denominata `dgBooks`, con una chiamata a un oggetto personalizzato `DataHelper` classe condivisa `GetBookData` metodo e popola la <xref:System.Web.UI.WebControls.DataGrid> con il <xref:System.Web.UI.Control.DataBind%2A> (metodo).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La memorizzazione nella cache le pagine ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge un gruppo di nomi file alla raccolta dei nomi file da cui dipende la risposta corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Raccolta di file da aggiungere.</param>
        <summary>Aggiunge un gruppo di nomi file alla raccolta dei nomi file da cui dipende la risposta corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente è una pagina ASP.NET che è memorizzato nella cache di output. Il codice per la pagina Crea un' <xref:System.Collections.ArrayList> dei percorsi di file e quindi ne passa la <xref:System.Collections.ArrayList> come parametro in una chiamata al <xref:System.Web.HttpResponse.AddFileDependencies%2A> (metodo). In questo modo l'output risposta memorizzata nella cache non è valido se uno qualsiasi dei file specificati nella <xref:System.Collections.ArrayList> le modifiche.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La memorizzazione nella cache le pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">Matrice di file da aggiungere.</param>
        <summary>Aggiunge una matrice di nomi file alla raccolta dei nomi file da cui dipende la risposta corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente aggiunge una matrice di nomi di file per il <xref:System.Web.HttpResponse.AddFileDependencies%2A> elenco di dipendenze di file. Se i file viene modificato, la risposta memorizzata nella cache viene invalidata.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La memorizzazione nella cache le pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da aggiungere.</param>
        <summary>Aggiunge un singolo nome file alla raccolta dei nomi file da cui dipende la risposta corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si usa il <xref:System.Web.HttpResponse.AddFileDependency%2A> metodo per aggiungere una dipendenza di file, è necessario specificare anche la cache di output a livello di programmazione o in modo dichiarativo. Ad esempio, per specificare in modo dichiarativo di memorizzazione nella cache di output, usare la direttiva. Per altre informazioni, vedere [procedura: Cache di Output delle pagine con le dipendenze di File](https://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere un singolo nome file per il <xref:System.Web.HttpResponse.AddFileDependency%2A> elenco di dipendenze di file. Se il file viene modificato, la risposta memorizzata nella cache viene invalidata.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La memorizzazione nella cache le pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'intestazione HTTP a cui aggiungere <paramref name="value" />.</param>
        <param name="value">Stringa da aggiungere all'intestazione.</param>
        <summary>Aggiunge un'intestazione HTTP al flusso di output. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> viene fornito per supportare la compatibilità con le versioni precedenti di ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> equivale a <xref:System.Web.HttpResponse.AppendHeader%2A> e viene fornito solo per compatibilità con le versioni precedenti di ASP. Con ASP.NET, usare <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Metodo di callback.</param>
        <summary>[Supportato in .NET Framework 4.5.2 e versioni successive] 
Registra un callback che verrà richiamato dal runtime ASP.NET immediatamente prima che le intestazioni di risposta vengano inviate per questa richiesta.</summary>
        <returns>Oggetto <see cref="T:System.Web.ISubscriptionToken" /> che rappresenta la sottoscrizione dello pseudoevento OnSendingHeaders.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il metodo AddOnSendingHeaders non viene richiamato se il modulo nativo Scarica prima di tutto la risposta.  
  
 Il Pseudoevento onsendingheaders differisce dall'evento IHttpModule a livello della pipeline in quanto si tratta di una sottoscrizione per ogni richiesta anziché a una sottoscrizione per ogni applicazione. L'intento è che la richiamata può modificare il codice di stato risposta o può impostare un'intestazione o il cookie di risposta. Altre note sull'utilizzo e avvertenze:  
  
-   Questo metodo è efficace solo quando IIS viene eseguito nella pipeline in modalità pipeline integrata e solo se le intestazioni di risposta non sono ancora state inviate per la richiesta corrente.  
  
-   Il runtime ASP.NET non garantisce alcun dettaglio relativo thread in cui il callback viene richiamato su. Ad esempio, il callback può essere richiamato in modo sincrono in un thread in background se è in corso lo scaricamento in background. <xref:System.Web.HttpContext.Current%2A> non è garantito a essere disponibile in tale thread.  
  
-   Il callback non deve chiamare qualsiasi metodo che consente di modificare il corpo dell'entità risposta o che comporta uno svuotamento. Ad esempio, il callback non deve chiamare <xref:System.Web.HttpResponse.Redirect%2A>, come tale metodo potrebbe modificare il corpo entità della risposta.  
  
-   Il callback deve contenere solo codice sincrono con esecuzione rapida. Tentativo di richiamare un'operazione asincrona o in attesa su tale operazione potrebbe causare un deadlock.  
  
-   Il callback non deve generare un'eccezione. in caso contrario, il comportamento è indefinito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Oggetto <see cref="T:System.Web.HttpCookie" /> da aggiungere al flusso di output.</param>
        <summary>Aggiunge un cookie HTTP alla raccolta di cookie intrinseca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea un nuovo cookie denominato `LastVisit`, imposta il valore del cookie per la data e ora correnti e il cookie viene aggiunto alla raccolta di cookie corrente. Tutti i cookie nella raccolta di cookie vengono inviati al client sotto il `Set-Cookie` flusso di output intestazione con il protocollo HTTP.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Viene aggiunto un cookie dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'intestazione HTTP da aggiungere al flusso di output.</param>
        <param name="value">Stringa da aggiungere all'intestazione.</param>
        <summary>Aggiunge un'intestazione HTTP al flusso di output.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si usa la <xref:System.Web.HttpResponse.AppendHeader%2A> metodo per inviare le intestazioni specifiche della cache e contemporaneamente usare il modello a oggetti della cache (<xref:System.Web.HttpResponse.Cache%2A>) per impostare criteri di cache, le intestazioni di risposta HTTP che riguardano la memorizzazione nella cache (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, e `Vary`) potrebbe essere stato eliminato quando viene utilizzato il modello a oggetti della cache. Questo comportamento consente ad ASP.NET mantenere le impostazioni più restrittive. Ad esempio, si consideri una pagina che include controlli utente. Se tali controlli sono in conflitto i criteri di cache, verrà utilizzato il criterio più restrittivo della cache. Se un controllo utente imposta l'intestazione "`Cache-Control: Public`"e un altro controllo utente di impostare l'intestazione più restrittivo"`Cache-Control: Private`" tramite le chiamate a <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, quindi il "`Cache-Control: Private`" intestazione verrà inviata con la risposta.  
  
 Per un elenco di intestazioni standard HTTP/1.1, vedere la sezione 14, "Definizioni di campo di intestazione", nelle [Hypertext Transfer Protocol, protocollo HTTP/1.1](https://go.microsoft.com/fwlink/?LinkID=73147) specifica sul sito Web del World Wide Web Consortium (W3C).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Web.HttpResponse.AppendHeader%2A> metodo per aggiungere un'intestazione personalizzata per il <xref:System.Web.HttpResponse> oggetto inviato al client richiedente.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'intestazione viene accodata dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Testo da aggiungere al file di log.</param>
        <summary>Aggiunge informazioni di log personalizzate nel file di log IIS (Internet Information Services).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per consentire la stringa specificata deve essere registrato nel file di log, è innanzitutto necessario abilitare la **Query URI** opzione del **Extended Properties registrazione** finestra di dialogo per il sito che si desidera registrare l'attività in IIS .  
  
 Per personalizzare la registrazione estesa in IIS 6.0, seguire questa procedura:  
  
1.  In Gestione IIS espandere il nodo computer locale, espandere la cartella siti Web o FTP, fare clic sul sito Web o FTP e quindi fare clic su **proprietà**.  
  
2.  Fare clic sui **sito Web o FTP** scheda e quindi selezionare la **abilitare la registrazione** casella di controllo (se non è già selezionato).  
  
3.  Nel **formato registro attivo** fare clic su **formato File registro esteso W3C**.  
  
4.  Fare clic su **proprietà**.  
  
5.  Scegliere il **avanzate** scheda, selezionare le proprietà che si desidera accedere e quindi fare clic su **OK**.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come aggiungere una stringa nel log.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=36829">Guida del prodotto di Windows Server 2003</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Percorso virtuale di una risorsa.</param>
        <summary>Aggiunge un ID sessione al percorso virtuale, se la sessione usa lo stato di sessione <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> e restituisce il percorso combinato. Se non viene usato lo stato di sessione <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" />, il metodo <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> restituisce il percorso virtuale originale.</summary>
        <returns>
          <paramref name="virtualPath" /> con l'ID sessione inserito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> viene utilizzato solo con le sessioni senza cookie per costruire href assoluti.  
  
   
  
## Examples  
 L'esempio seguente dichiara una variabile stringa denominata `urlConverted`e lo imposta sul risultato di un <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> chiamata al metodo. Il codice passa quindi il valore della variabile a un <xref:System.Web.UI.WebControls.HyperLink> del controllo <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> proprietà.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Oggetto di callback.</param>
        <param name="state">Stato della risposta.</param>
        <summary>Invia al client la risposta attualmente memorizzata nel buffer.</summary>
        <returns>Oggetto risultato asincrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto sottostante <xref:System.Web.HttpWorkerRequest> oggetto supporta operazioni di scaricamento asincrone e questo metodo viene chiamato da un evento asincrono del modulo o da un gestore asincrono, l'operazione di svuotamento avviene in modo asincrono. In caso contrario, l'operazione di svuotamento avviene in modo sincrono. Lo scaricamento asincrono è supportato per IIS 6.0 e versioni successive.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La risposta è già stata completata.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Byte da scrivere nel flusso di output.</param>
        <summary>Scrive una stringa di caratteri binari nel flusso di output HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente legge un file di testo in un buffer e inserisce il buffer nel flusso di output HTTP.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se memorizzare l'output nel buffer e inviarlo al termine dell'elaborazione dell'intera risposta.</summary>
        <value>
          <see langword="true" /> se l'output verso il client è memorizzato nel buffer; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.Buffer%2A> proprietà è stata deprecata in favore del <xref:System.Web.HttpResponse.BufferOutput%2A> proprietà e viene fornito solo per compatibilità con le versioni precedenti di ASP. Con ASP.NET, usare <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se memorizzare l'output nel buffer e inviarlo al termine dell'elaborazione dell'intera pagina.</summary>
        <value>
          <see langword="true" /> se l'output verso il client è memorizzato nel buffer; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente imposta la <xref:System.Web.HttpResponse.ContentType%2A> proprietà per la risposta su image/jpeg, chiama il <xref:System.Web.HttpResponse.Clear%2A> metodo per rimuovere altro contenuto che può essere associato alla risposta e imposta il <xref:System.Web.HttpResponse.BufferOutput%2A> la proprietà su true in modo che l'intera pagina elaborati prima che qualsiasi contenuto venga inviato al client richiedente.  
  
 Per un esempio completo, vedere il <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i criteri di memorizzazione nella cache di una pagina Web (tempo di scadenza, impostazioni di privacy, clausole di variazione).</summary>
        <value>Oggetto <see cref="T:System.Web.HttpCachePolicy" /> contenente informazioni sui criteri di memorizzazione nella cache della risposta corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente scrive le proprietà dei criteri della cache corrente nel flusso di output HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'intestazione HTTP <see langword="Cache-Control" /> corrispondente a uno dei valori dell'enumerazione <see cref="T:System.Web.HttpCacheability" />.</summary>
        <value>Rappresentazione di stringa del valore dell'enumerazione <see cref="T:System.Web.HttpCacheability" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori per `Private`, `Public`, e `No-Cache` sono stringhe e deve essere racchiuso tra virgolette doppie (""). Se il <xref:System.Web.HttpResponse.CacheControl%2A> proprietà è impostata su un valore che corrisponde a uno del <xref:System.Web.HttpCacheability> valori di enumerazione, un oggetto <xref:System.ArgumentException> viene generata un'eccezione. Se il <xref:System.Web.HttpResponse.CacheControl%2A> non è impostata, la cache della risposta è impostata su <xref:System.Web.HttpCacheability.NoCache>.  
  
 Il `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, e <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> proprietà sono state deprecate. Al contrario, i metodi del <xref:System.Web.HttpCachePolicy> classe sono disponibili tramite il <xref:System.Web.HttpResponse.Cache%2A> intrinseco per controllare l'Internet Information Services (IIS) di output della cache e cache dei client.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore di stringa non corrisponde a uno dei valori di enumerazione <see cref="T:System.Web.HttpCacheability" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il set di caratteri HTTP del flusso di output.</summary>
        <value>Set di caratteri HTTP del flusso di output.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Charset` può essere impostata su `null` per eliminare il protocollo HTTP `Content-Type` intestazione.  
  
   
  
## Examples  
 Nell'esempio seguente controlla se il set di caratteri del flusso di output è Europa centrale (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La proprietà <see langword="Charset" /> è stata impostata dopo l'invio delle intestazioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella tutto l'output di contenuto dal flusso del buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.Clear%2A> metodo consente di cancellare le informazioni di intestazione.  
  
   
  
## Examples  
 L'esempio seguente imposta la <xref:System.Web.HttpResponse.ContentType%2A> proprietà per la risposta su image/jpeg, chiama il <xref:System.Web.HttpResponse.Clear%2A> metodo per rimuovere altro contenuto che può essere associato alla risposta e imposta il <xref:System.Web.HttpResponse.BufferOutput%2A> la proprietà su true in modo che nella pagina operazione completata elaborati prima che qualsiasi contenuto venga inviato al client richiedente.  
  
 Per un esempio completo, vedere il <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella tutto l'output di contenuto dal flusso del buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.ClearContent%2A> metodo consente di cancellare le informazioni di intestazione.  
  
   
  
## Examples  
 L'esempio seguente Cancella tutto il contenuto del flusso del buffer.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella tutte le intestazioni dal flusso del buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente chiama il <xref:System.Web.HttpResponse.ClearHeaders%2A> metodo per garantire che nessun intestazioni vengono inviate con la risposta corrente. Questa tecnica può essere particolarmente importante se la risposta ASP.NET genera un'immagine, ad esempio un file JPEG. In questo esempio il <xref:System.Web.HttpResponse.ContentType%2A> proprietà è impostata su image/jpeg.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le intestazioni vengono cancellate dopo l'invio delle intestazioni HTTP.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Threading.CancellationToken" /> che viene attivato in caso di disconnessione del client.</summary>
        <value>Token di annullamento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa API è thread-safe. Tuttavia, esistono alcune restrizioni su come usare il token di annullamento. Usarla in modo non corretto può causare situazioni di race condition, deadlock o altri comportamenti imprevisti. Tenere presente le linee guida seguenti:  
  
-   Assicurarsi che sia non chiamare questa API esterna ai limiti di una singola richiesta, poiché ASP.NET si eliminerà il token di annullamento alla fine della richiesta. Non c'è garanzia che il token esegue sempre la transizione a uno stato annullato prima di eliminarlo. Ad esempio, se la richiesta viene completata senza il client con disconnesso, il token verrà eliminato senza prima avere stato annullato.  
  
-   Attendere il <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, come ciò vanifica lo scopo di una notifica asincrona e può causare deadlock.  
  
-   Non si chiama il <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> overload che richiama il callback sul originale <xref:System.Threading.SynchronizationContext> oggetto.  
  
-   Non usare la <xref:System.Web.HttpContext> o altri non thread-safe ASP.NET intrinseco più oggetti all'interno del callback fornito per il <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> (metodo). Il callback potrebbe essere in esecuzione contemporaneamente ad altri ASP.NET o codice dell'applicazione.  
  
-   Mantenere i metodi di callback a esecuzione breve e non bloccante.  
  
-   Rendere ogni sforzo per evitare la generazione di eccezioni da all'interno dei metodi di callback.  
  
 Questa proprietà è supportata solo in Internet Information Service (IIS) 7.5 o versione successiva in modalità integrata. Se viene richiamato senza la corretta IIS versione o una pipeline modalità, un <xref:System.PlatformNotSupportedException> viene generata un'eccezione. Per determinare la versione di IIS, usare <xref:System.Web.HttpRuntime.IISVersion%2A>. Per determinare la modalità pipeline, utilizzare <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude la connessione socket a un client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo termina la connessione al client in modo improvviso e non può essere normale elaborazione della richiesta HTTP. Il metodo invia un pacchetto di reimpostazione per il client, che può generare dati di risposta che viene memorizzato nel buffer nel server, client o in un punto intermedio che si desidera eliminare.  
  
 Tuttavia, in genere è necessario chiamare <xref:System.Web.HttpApplication.CompleteRequest%2A> invece se si vuole passare direttamente alla sezione di <xref:System.Web.HttpApplication.EndRequest> eventi e inviare una risposta al client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il set di caratteri HTTP del flusso di output.</summary>
        <value>Oggetto <see cref="T:System.Text.Encoding" /> contenente informazioni sul set di caratteri della risposta corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Default `ContentEncoding` può essere specificato in un file di configurazione in ASP.NET il [globalization Element (Schema delle impostazioni ASP.NET)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) sezione. Se <xref:System.Web.HttpResponse.ContentEncoding%2A> specificato dal client, vengono sottoposte a override le impostazioni di configurazione predefinite.  
  
   
  
## Examples  
 Nell'esempio seguente consente di scrivere una descrizione leggibile del set di codifica per il flusso di output di caratteri.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Si è tentato di impostare <see cref="P:System.Web.HttpResponse.ContentEncoding" /> su <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo MIME HTTP del flusso di output.</summary>
        <value>Tipo MIME HTTP del flusso di output. Il valore predefinito è "<see langword="text/html" />".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente imposta la <xref:System.Web.HttpResponse.ContentType%2A> proprietà per la risposta su image/jpeg, chiama il <xref:System.Web.HttpResponse.Clear%2A> metodo per rimuovere altro contenuto che può essere associato alla risposta e imposta il <xref:System.Web.HttpResponse.BufferOutput%2A> la proprietà su true in modo che nella pagina operazione completata elaborati prima che qualsiasi contenuto venga inviato al client richiedente.  
  
 Per un esempio completo, vedere il <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La proprietà <see cref="P:System.Web.HttpResponse.ContentType" /> è impostata su <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la raccolta di cookie di risposta.</summary>
        <value>Raccolta di cookie di risposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET include due raccolte di cookie intrinseca. La raccolta a cui si accede tramite il <xref:System.Web.HttpRequest.Cookies%2A> raccolta di <xref:System.Web.HttpRequest> contiene i cookie trasmessi dal client al server nel `Cookie` intestazione. La raccolta a cui si accede tramite il <xref:System.Web.HttpResponse.Cookies%2A> raccolta di <xref:System.Web.HttpResponse> contiene i nuovi cookie creato nel server e trasmesso al client sotto il `Set-Cookie` intestazione.  
  
 Dopo aver aggiunto un cookie utilizzando la <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> raccolta, il cookie è immediatamente disponibile nel <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> raccolta, anche se la risposta non è stata inviata al client.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo cookie denominato `LastVisit`, imposta il valore del cookie per la data e ora correnti e il cookie viene aggiunto alla raccolta di cookie corrente. Tutti i cookie nella raccolta di cookie vengono inviati al client sotto il `Set-Cookie` flusso di output intestazione con il protocollo HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disabilita la memorizzazione nella cache del kernel per la risposta corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la memorizzazione nella cache del kernel non è supportato, questo metodo non ha effetto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disabilita la memorizzazione nella cache in modalità utente di IIS per la risposta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la memorizzazione nella cache in modalità utente IIS non è supportato, questo metodo restituisce senza eseguire alcuna azione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invia al client tutto l'output attualmente memorizzato nel buffer, interrompe l'esecuzione della pagina e genera l'evento <see cref="E:System.Web.HttpApplication.EndRequest" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene fornito solo per compatibilità con ASP, vale a dire, per garantire la compatibilità con la tecnologia di programmazione Web basato su COM che hanno preceduto ASP.NET. Se si vuole passare direttamente alla sezione di <xref:System.Web.HttpApplication.EndRequest> eventi e inviare una risposta al client, è in genere preferibile chiamare <xref:System.Web.HttpApplication.CompleteRequest%2A> invece.  
  
 Per simulare il comportamento dei `End` metodo nelle pagine ASP, questo metodo tenta di generare un <xref:System.Threading.ThreadAbortException> eccezione. Se questo tentativo ha esito positivo, il thread chiamante verrà interrotta, che è dannosa per le prestazioni del sito. In tal caso, nessun codice dopo la chiamata al <xref:System.Web.HttpResponse.End%2A> metodo viene eseguito.  
  
 Se il <xref:System.Web.HttpResponse.End%2A> metodo non è in grado di generare un <xref:System.Threading.ThreadAbortException>, invece Svuota i byte di risposta al client. Ciò avviene in modo sincrono, che può essere anche dannosa per le prestazioni del sito.  
  
 In entrambi i casi (o meno una <xref:System.Threading.ThreadAbortException> eccezione viene generata correttamente), la pipeline di risposta si passa il <xref:System.Web.HttpApplication.EndRequest> evento.  
  
 Il <xref:System.Web.HttpApplication.CompleteRequest%2A> metodo non genera un'eccezione e il codice dopo la chiamata al <xref:System.Web.HttpApplication.CompleteRequest%2A> metodo può essere eseguito. Se si desidera evitare l'esecuzione di codice successivo e se la riduzione delle prestazioni dovuta <xref:System.Web.HttpResponse.End%2A> è accettabile, è possibile chiamare <xref:System.Web.HttpResponse.End%2A> invece di <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">La chiamata a <see cref="M:System.Web.HttpResponse.End" /> ha terminato la richiesta corrente.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto risultato asincrono.</param>
        <summary>Completa un'operazione di scaricamento asincrona.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Lo scaricamento asincrono non è supportato e il parametro <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Lo scaricamento asincrono non è supportato e non è possibile eseguire il cast del parametro <paramref name="asyncResult" /> a un oggetto <c>FlushAsyncResult</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero di minuti dopo i quali una pagina inserita nella cache di un browser scade. Se l'utente torna alla stessa pagina prima che scada, viene visualizzata la versione memorizzata nella cache. <see cref="P:System.Web.HttpResponse.Expires" /> viene fornito per supportare la compatibilità con le versioni precedenti di ASP.</summary>
        <value>Numero di minuti dopo i quali la pagina scade.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> e <xref:System.Web.HttpResponse.CacheControl%2A> delle proprietà sono state deprecate a favore di metodi del <xref:System.Web.HttpCachePolicy> classe disponibili tramite il <xref:System.Web.HttpResponse.Cache%2A> cache di output intrinseco per controllare l'Internet Information Services (IIS) e client memorizza nella cache.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la data e l'ora assolute in cui rimuovere le informazioni memorizzate dalla cache. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> viene fornito per supportare la compatibilità con le versioni precedenti di ASP.</summary>
        <value>Data e ora di scadenza della pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, e <xref:System.Web.HttpResponse.CacheControl%2A> delle proprietà sono state deprecate a favore di metodi del <xref:System.Web.HttpCachePolicy> classe disponibili tramite il <xref:System.Web.HttpResponse.Cache%2A> cache di output intrinseco per controllare l'Internet Information Services (IIS) e client memorizza nella cache.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto filtro di wrapping usato per modificare il corpo dell'entità HTTP prima della trasmissione.</summary>
        <value>Oggetto <see cref="T:System.IO.Stream" /> che funge da filtro di output.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si crea una `Stream` dell'oggetto e impostare il <xref:System.Web.HttpResponse.Filter%2A> proprietà per il `Stream` oggetto, HTTP tutti output inviato dal <xref:System.Web.HttpResponse.Write%2A> passa attraverso il filtro.  
  
   
  
## Examples  
 L'esempio seguente è una pagina ASP.NET che consente di impostare il <xref:System.Web.HttpResponse.Filter%2A> proprietà in una nuova istanza del `UpperCaseFilter` classe, una classe personalizzata <xref:System.IO.Stream> classe che consente di convertire tutto il testo che passa attraverso di esso in lettere maiuscole. Le informazioni relative alla richiesta viene salvate in un file di testo e quindi il <xref:System.Web.HttpResponse.Filter%2A> è impostata. Dopo aver applicato il filtro di risposta, il codice chiama il <xref:System.Web.HttpRequest.MapPath%2A> metodo per ottenere il percorso assoluto di un file di testo denominato `TestFile.txt` che funge da origine per il contenuto della risposta. Il codice crea quindi una nuova <xref:System.IO.StreamReader> oggetto da cui leggere il file di testo dall'inizio alla fine e quindi chiama il <xref:System.Web.HttpResponse.Write%2A> metodo per visualizzare il contenuto del file della pagina.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'applicazione di filtri non è consentita con l'entità.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invia al client tutto l'output attualmente memorizzato nel buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Forza tutte attualmente memorizzati nel buffer di output da inviare al client. Il <xref:System.Web.HttpResponse.Flush%2A> metodo può essere chiamato più volte durante l'elaborazione della richiesta.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Drawing.Graphics.Save%2A> per salvare un <xref:System.Drawing.Bitmap> dell'oggetto per il <xref:System.Web.HttpResponse.OutputStream%2A> formato proprietà e converte l'immagine JPEG. Il codice chiama quindi il `Dispose` metodo sul <xref:System.Drawing.Bitmap> oggetto e un <xref:System.Drawing.Graphics> oggetto, rilasciando le risorse che erano in uso. Chiama quindi il <xref:System.Web.HttpResponse.Flush%2A> metodo per inviare il contenuto della risposta sul client richiedente.  
  
 Per un esempio completo, vedere il <xref:System.Web.HttpResponse> classe.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La cache viene svuotata dopo l'invio della risposta.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invia in modo asincrono al client tutto l'output attualmente memorizzato nel buffer.</summary>
        <returns>Oggetto <see cref="T:System.Threading.Tasks.Task" /> che rappresenta l'operazione asincrona.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto <see cref="T:System.Text.Encoding" /> che rappresenta la codifica per il flusso di output dell'intestazione corrente.</summary>
        <value>Oggetto <see cref="T:System.Text.Encoding" /> contenente informazioni riguardanti il set di caratteri per l'intestazione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.HeaderEncoding%2A> proprietà offre la possibilità di disabilitare o modificare i <xref:System.Text.Encoding> oggetto su un'intestazione di risposta tramite il <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, o <xref:System.Text.UTF8Encoding> oggetto. Il valore di codifica predefinito è il <xref:System.Text.UTF8Encoding> classe.  
  
 Modificando il tipo del <xref:System.Web.HttpResponse.HeaderEncoding%2A> proprietà, è possibile aumentare il rischio di determinati attacchi dannosi o causa i dati sensibili da inviare tramite l'intestazione della risposta. Attacchi injection intestazione possono essere evitati, in parte, se si lascia il <xref:System.Web.HttpResponse.HeaderEncoding%2A> proprietà di una risposta per l'impostazione predefinita. Un attacco contro un'applicazione vulnerabile potrebbe restituire dati consegnati come parte di un'intestazione di risposta. Se il <xref:System.Web.HttpResponse.HeaderEncoding%2A> è disabilitato a causa di un requisito di righe di continuazione in un'intestazione o se tutte le intestazioni che viene costruita sulla base del risultato di dati non attendibili, i dati dell'intestazione devono essere convalidati prima dell'invio nel flusso di risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore di codifica è <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Il valore di codifica è <see cref="P:System.Text.Encoding.Unicode" />.  
  
\- oppure - 
Le intestazioni sono già state inviate.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la raccolta di intestazioni di risposta.</summary>
        <value>Oggetto <see cref="T:System.Collections.Specialized.NameValueCollection" /> di intestazioni di risposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.Headers%2A> proprietà è supportata solo con il [!INCLUDE[iisver](~/includes/iisver-md.md)] modalità pipeline integrata e almeno .NET Framework 3.0. Quando si tenta di accedere il <xref:System.Web.HttpResponse.Headers%2A> proprietà e una di queste due condizioni non viene soddisfatta, un <xref:System.PlatformNotSupportedException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L'operazione richiede la modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e almeno .NET Framework versione 3.0.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=86952">L'aggiornamento di applicazioni ASP.NET in IIS 7.0: differenze tra la modalità integrata IIS 7.0 e la modalità di distribuzione classica</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supportato in .NET Framework 4.5.2 e versioni successive] 
Ottiene un valore che indica se le intestazioni delle risposte sono state scritte.</summary>
        <value>
          <see langword="true" /> se le intestazioni delle risposte sono state scritte; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il client è ancora connesso al server.</summary>
        <value>
          <see langword="true" /> se il client è attualmente connesso; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.IsClientConnected%2A> restituisce proprietà `false` quando vengono soddisfatte le condizioni seguenti:  
  
-   È stata interrotta la connessione al client. Ciò può verificarsi se il <xref:System.Web.HttpResponse.Close%2A> metodo richiamato, o se il client ha arrestato l'esecuzione della pagina Web o esplorati in un'altra pagina.  
  
-   Il <xref:System.Web.HttpWorkerRequest> oggetto che gestisce la richiesta viene `null` o nella <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> restituzione del metodo `false`. Se una classe personalizzata <xref:System.Web.HttpWorkerRequest> oggetto gestisce la richiesta, il <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> metodo potrebbe essere impostato in base ai criteri personalizzati. Ad esempio, la richiesta di lavoro personalizzato potrebbe imporre un timeout dopo un periodo di tempo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Web.HttpResponse.IsClientConnected%2A> proprietà per verificare se il client che richiede la pagina rimane connesso al server. Se <xref:System.Web.HttpResponse.IsClientConnected%2A> è true, il codice chiama il <xref:System.Web.HttpResponse.Redirect%2A> metodo e i client visualizzeranno un'altra pagina. Se <xref:System.Web.HttpResponse.IsClientConnected%2A> è false, quindi il codice chiama il <xref:System.Web.HttpResponse.End%2A> (metodo) e tutti l'elaborazione delle pagine viene interrotto.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore booleano che indica se il client è in fase di trasferimento a una nuova posizione.</summary>
        <value>
          <see langword="true" /> se il valore dell'intestazione di risposta della posizione è diverso dalla posizione corrente; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> proprietà con il <xref:System.Web.HttpResponse.RedirectLocation%2A> proprietà da testare e determinare se l'URI assoluto che viene trasmesso al client in HTTP `Location` intestazione è diversa rispetto al valore URI corrente e ciò che il nuovo URI che è in corso saranno trasferiti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Consente l'output del testo verso il flusso di risposta HTTP in uscita.</summary>
        <value>Oggetto <see cref="T:System.IO.TextWriter" /> che consente l'output personalizzato verso il client.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente è una pagina ASP.NET che contiene un <xref:System.Web.UI.WebControls.TextBox> controllo dotato di relativi <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> impostata su <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Il codice della pagina elabora il testo che un utente immette nel <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, Usa le <xref:System.Web.HttpServerUtility.HtmlEncode%2A> metodo in formato HTML come codificarla e il <xref:System.Web.HttpResponse.Output%2A> proprietà per visualizzare la stringa codificata per la pagina.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Consente l'output binario verso il corpo del contenuto HTTP in uscita.</summary>
        <value>Oggetto I/O <see cref="T:System.IO.Stream" /> che rappresenta il contenuto non elaborato del corpo del contenuto HTTP in uscita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire da .NET Framework versione 2.0, quando si utilizza il <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> del flusso dei / o restituito dal metodo di <xref:System.Web.HttpResponse.OutputStream%2A> proprietà, potrebbero essere generate le eccezioni seguenti:  
  
-   <xref:System.ArgumentOutOfRangeException>, se il `offset` o `count` parametro è un valore negativo o se il `buffer` la lunghezza del parametro meno il `offset` parametro è minore o uguale a zero.  
  
-   <xref:System.ArgumentNullException>, se il `buffer` parametro è `null`.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Drawing.Image.Save%2A> per salvare una <xref:System.Drawing.Bitmap> dell'oggetto per il <xref:System.Web.HttpResponse.OutputStream%2A> proprietà e converte l'immagine in formato JPEG. Il codice chiama quindi il metodo Dispose sul <xref:System.Drawing.Bitmap> oggetto e un <xref:System.Drawing.Graphics> oggetto, rilasciando le risorse che erano in uso. Infine, il codice chiama il <xref:System.Web.HttpResponse.Flush%2A> metodo per inviare il contenuto della risposta sul client richiedente.  
  
 Per un esempio completo, vedere il <xref:System.Web.HttpResponse> classe.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> non è disponibile.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da aggiungere all'intestazione <see langword="PICS-Label" />.</param>
        <summary>Aggiunge un'intestazione HTTP <see langword="PICS-Label" /> al flusso di output.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Piattaforma per la selezione di contenuto Internet (PICS) è uno standard di World Wide Web Consortium (W3C) per le etichette del contenuto. PICS è essenzialmente un linguaggio per la creazione di un sistema di classificazione.  
  
 Qualsiasi valore può essere usata come etichetta PICS; ASP.NET non viene convalidato l'etichetta. La lunghezza massima della stringa è di 255 caratteri. Per altre informazioni sulla sintassi e standard PICS, vedere la [World Wide Web Consortium](https://go.microsoft.com/fwlink/?LinkID=37125) sito Web.  
  
   
  
## Examples  
 L'esempio seguente è una pagina ASP.NET che visualizza un'immagine. Il codice della pagina chiama il <xref:System.Web.HttpResponse.Pics%2A> per impostare il protocollo HTTP `PICS-Label` intestazione per la risposta. La stringa che viene passata come parametro per il <xref:System.Web.HttpResponse.Pics%2A> metodo rappresenta un'etichetta di classificazione generata dal sito Web Internet contenuto ICRA Rating Association ().  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Alza di livello un oggetto promesso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">URL della richiesta push. Deve essere il percorso virtuale della risorsa relativa di cui il server eseguirà il push al client.</param>
        <summary>Questa API è destinata al supporto di applicazioni che inviano promesse push ai client HTTP 2.0. Per altre informazioni relative al push del server HTTP2, vedere l'articolo relativo alla <see href="https://http2.github.io/http2-spec/#PushResources">Specifica HTTP/2, sezione 8.2: push del server</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise è non deterministico e le applicazioni non devono avere la logica che dipende da esso. Il suo unico scopo è vantaggio per le prestazioni in alcuni casi. Esistono molte condizioni (protocollo e l'implementazione) che potrebbero essere di ignorare completamente le richieste di push. Si prevede si basa su fire-and-forget.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">URL della richiesta push. Deve essere il percorso virtuale della risorsa relativa di cui il server eseguirà il push al client.</param>
        <param name="method">Metodo di richiesta HTTP che verrà usato dalla richiesta di push.</param>
        <param name="headers">Intestazione della richiesta HTTP che verrà usato dalla richiesta di push.</param>
        <summary>Questa API è destinata al supporto di applicazioni che inviano promesse push ai client HTTP 2.0. Per altre informazioni relative al push del server HTTP2, vedere l'articolo relativo alla <see href="https://http2.github.io/http2-spec/#PushResources">Specifica HTTP/2, sezione 8.2: push del server</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise è non deterministico e le applicazioni non devono avere la logica che dipende da esso. Il suo unico scopo è vantaggio per le prestazioni in alcuni casi. Esistono molte condizioni (protocollo e l'implementazione) che potrebbero essere di ignorare completamente le richieste di push. Si prevede si basa su fire-and-forget.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reindirizza un client a un nuovo URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Percorso di destinazione. Può trattarsi di un percorso virtuale relativo dell'applicazione.</param>
        <summary>Reindirizza una richiesta a un nuovo URL e specifica il nuovo URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata <xref:System.Web.HttpResponse.Redirect%2A> è equivalente alla chiamata <xref:System.Web.HttpResponse.Redirect%2A> con il secondo parametro impostato su `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> le chiamate <xref:System.Web.HttpResponse.End%2A> che genera un <xref:System.Threading.ThreadAbortException> eccezione dopo il completamento. Questa eccezione ha effetti negativi sulle prestazioni dell'applicazione Web. È pertanto consigliabile che invece questo overload è usare il <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> rapporto di overload e passare `false` per il `endResponse` parametro e quindi chiamare il <xref:System.Web.HttpApplication.CompleteRequest%2A> (metodo). Per altre informazioni, vedere il metodo <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Pagine per dispositivi mobili, solo se l'applicazione si basa sulle sessioni senza cookie, o potrebbe ricevere le richieste dai dispositivi mobili che richiedono sessioni senza cookie, usando una tilde (\~) in un percorso può comportare la creazione di una nuova sessione e perdere potenzialmente sessione dati. Per impostare una proprietà su un controllo per dispositivi mobili con un percorso, ad esempio "\~/path", risolvere il percorso usando <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "\~/path" prima di assegnarlo alla proprietà.  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 302. È un modo alternativo per trasferire il controllo a un'altra pagina di <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo è in genere più efficiente perché non provoca un round trip al client. Per altre informazioni, vedere [procedura: reindirizzare gli utenti a un'altra pagina](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 Nell'esempio seguente forza un reindirizzamento non condizionale a un altro sito Web.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Viene tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Posizione della destinazione.</param>
        <param name="endResponse">Indica se l'esecuzione della pagina corrente deve terminare.</param>
        <summary>Reindirizza un client a un nuovo URL. Specifica il nuovo URL e se l'esecuzione della pagina corrente deve terminare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un URL assoluto (ad esempio, http://www.contoso.com/default.aspx) o un URL relativo (ad esempio default. aspx) può essere specificato per il percorso di destinazione, ma alcuni browser potrebbe pertanto rifiutare un URL relativo.  
  
 Quando si utilizza questo metodo in un gestore di pagina per terminare una richiesta per una pagina e avviare una nuova richiesta per un'altra pagina, impostare `endResponse` al `false` e quindi chiamare il <xref:System.Web.HttpApplication.CompleteRequest%2A> (metodo). Se si specifica `true` per il `endResponse` parametro, questo metodo chiama il <xref:System.Web.HttpResponse.End%2A> metodo per la richiesta originale, che genera un <xref:System.Threading.ThreadAbortException> eccezione quando viene completato. Questa eccezione ha effetti negativi sulle prestazioni dell'applicazione Web, motivo per cui passando `false` per il `endResponse` parametro è consigliato. Per altre informazioni, vedere il metodo <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Per le pagine per dispositivi mobili, se l'applicazione si basa sulle sessioni senza cookie, o potrebbe ricevere le richieste dai dispositivi mobili che richiedono sessioni senza cookie, usando una tilde (\~) in un percorso possibile creare una nuova sessione e che vengano persi i dati della sessione. Per impostare una proprietà su un controllo per dispositivi mobili con un percorso, ad esempio "\~/path", risolvere il percorso usando <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "\~/path" prima di assegnarlo alla proprietà.  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 302. È un modo alternativo per trasferire il controllo a un'altra pagina di <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo è in genere più efficiente perché non provoca un round trip al client. Per altre informazioni, vedere [procedura: reindirizzare gli utenti a un'altra pagina](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Web.HttpResponse.IsClientConnected%2A> proprietà per verificare se il client che richiede la pagina rimane connesso al server. Se <xref:System.Web.HttpResponse.IsClientConnected%2A> è true, il codice chiama il <xref:System.Web.HttpResponse.Redirect%2A> metodo e i client visualizzeranno un'altra pagina. Se <xref:System.Web.HttpResponse.IsClientConnected%2A> è false, quindi il codice chiama il <xref:System.Web.HttpResponse.End%2A> (metodo) e tutti l'elaborazione delle pagine viene interrotto.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> contiene un carattere di nuova riga.</exception>
        <exception cref="T:System.Web.HttpException">Viene tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <exception cref="T:System.ApplicationException">La richiesta della pagina è il risultato di un callback.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore dell'intestazione <see langword="Location" /> HTTP.</summary>
        <value>URI assoluto trasmesso al client nell'intestazione HTTP <see langword="Location" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare questa proprietà per specificare l'URL di reindirizzamento quando si codifica un reindirizzamento permanente usando il codice di risposta HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le intestazioni HTTP sono già state scritte.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un URL specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Percorso a cui reindirizzare la richiesta.</param>
        <summary>Esegue un reindirizzamento permanente dall'URL richiesto all'URL specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> overload del metodo fornisce un codice di stato HTTP 301 nella risposta e include l'URL per reindirizzare la richiesta. Un codice di stato HTTP 301 è un codice standard in una risposta HTTP. Indica che esiste un reindirizzamento permanente e fornisce il percorso di reindirizzamento.  
  
 La chiamata di <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> overload del metodo consente di terminare la risposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> include un carattere di nuova riga (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Percorso a cui reindirizzare la richiesta.</param>
        <param name="endResponse">
          <see langword="true" /> per terminare la risposta; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</param>
        <summary>Esegue un reindirizzamento permanente dall'URL richiesto all'URL specificato e fornisce l'opzione per completare la risposta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> overload del metodo fornisce un codice di stato HTTP 301 nella risposta e include l'URL per reindirizzare la richiesta. Questo overload del metodo fornisce anche l'opzione per specificare se si desidera terminare o per completare la risposta dopo aver eseguito il reindirizzamento. Un codice di stato HTTP 301 è un codice standard in una risposta HTTP. Indica che esiste un reindirizzamento permanente e fornisce il percorso di reindirizzamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> include un carattere di nuova riga (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reindirizza una richiesta a un nuovo URL tramite valori di parametri di route, un nome di route o entrambi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Reindirizza una richiesta a un nuovo URL tramite valori di parametri di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte l'oggetto che viene passato `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> oggetto utilizzando il <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> costruttore. Il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> viene quindi chiamato il metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 302.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per il reindirizzamento a una route con parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <summary>Reindirizza una richiesta a un nuovo URL tramite un nome di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte il nome della route che viene passato `routeName` a un URL usando il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> (metodo).  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 302.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per il reindirizzamento a una route denominata `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Reindirizza una richiesta a un nuovo URL tramite valori di parametri di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo chiama il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 302.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per il reindirizzamento a una route con parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Reindirizza una richiesta a un nuovo URL tramite valori di parametri di route e un nome di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte l'oggetto che viene passato `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> oggetto utilizzando il <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> costruttore. Il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> viene quindi chiamato il metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 302.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per il reindirizzamento a una route denominata `Product` e che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Reindirizza una richiesta a un nuovo URL tramite valori di parametri di route e un nome di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> viene chiamato per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 302.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per il reindirizzamento a una route denominata `Product` e che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite valori di parametri di route, un nome di route o entrambi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite valori di parametri di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte l'oggetto che viene passato `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> oggetto utilizzando il <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> costruttore. Il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> viene quindi chiamato il metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 301.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per il reindirizzamento a una route con parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite un nome di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte il nome della route che viene passato `routeName` a un URL usando il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> (metodo).  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 301.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per il reindirizzamento a una route denominata `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite valori di parametri di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo chiama il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 301.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per il reindirizzamento a una route con parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite i valori di parametri di route e il nome di route corrispondenti al nuovo URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.RedirectPermanent%2A> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo converte l'oggetto che viene passato `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> oggetto utilizzando il <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> costruttore. Il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> viene quindi chiamato il metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 301.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per il reindirizzamento a una route denominata `Product` e che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nome della route.</param>
        <param name="routeValues">Valori di parametri di route.</param>
        <summary>Esegue un reindirizzamento permanente da un URL richiesto a un nuovo URL tramite valori di parametri di route e un nome di route.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per comodità di codifica. È equivalente alla chiamata di <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> metodo con il secondo parametro impostato su `false`.  
  
 Questo metodo chiama il <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> metodo per determinare l'URL.  
  
 ASP.NET esegue il reindirizzamento, restituendo un codice di stato HTTP 301.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare questo metodo per il reindirizzamento a una route denominata `Product` e che dispone di parametri denominati `productid` e `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessuna route corrisponde ai parametri di route specificati.</exception>
        <exception cref="T:System.Web.HttpException">È stato tentato un reindirizzamento dopo l'invio delle intestazioni HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routing di ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rimuove elementi memorizzati nella cache dalla cache di output usando il provider della cache di output predefinito.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso virtuale assoluto degli elementi rimossi dalla cache.</param>
        <summary>Rimuove dalla cache tutti gli elementi memorizzati associati al provider della cache di output predefinito. Il metodo è statico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo per rimuovere gli elementi della cache di output associati con il provider di cache di output predefinito. Chiamare il <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> metodo per rimuovere gli elementi della cache di output associati al provider di cache di output personalizzati che vengono specificate nel file di configurazione del sito Web.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> non è un percorso virtuale assoluto.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso virtuale assoluto degli elementi rimossi dalla cache.</param>
        <param name="providerName">Provider usato per rimuovere gli artefatti della cache di output associati al percorso specificato.</param>
        <summary>Usa il provider della cache di output specificato per rimuovere tutti gli elementi della cache di output associati al percorso specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo per rimuovere gli elementi della cache di output associati con il provider della cache di output personalizzati che vengono specificate nel file di configurazione del sito Web. Per rimuovere gli elementi della cache di output associati al provider di cache di output predefinito, chiamare il <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> non è un percorso valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Cookie della raccolta da aggiornare.</param>
        <summary>Poiché il metodo <b>HttpResponse.SetCookie</b> è solo per uso interno, non è possibile chiamarlo nel codice. In alternativa, è possibile chiamare il metodo <b>HttpResponse.Cookies.Set</b>, come illustrato nell'esempio seguente.<br /> Aggiorna un cookie esistente nella raccolta di cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente aggiorna il valore di un cookie esistente.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Si è tentato di impostare il cookie dopo l'invio delle intestazioni HTTP.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta la riga <see langword="Status" /> restituita al client.</summary>
        <value>L'impostazione del codice di stato fa in modo che venga restituita al client una stringa di descrizione dello stato dell'output HTTP. Il valore predefinito è 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> è stato deprecato in favore di <xref:System.Web.HttpResponse.StatusDescription%2A> e viene fornito solo per compatibilità con le versioni precedenti di ASP. Con ASP.NET, usare <xref:System.Web.HttpResponse.StatusDescription%2A> invece.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Lo stato è impostato su un codice non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il codice di stato HTTP dell'output restituito al client.</summary>
        <value>Intero che rappresenta lo stato dell'output HTTP restituito al client. Il valore predefinito è 200 (OK). Per un elenco dei codici di stato validi, vedere [codici di stato Http](https://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente controlla il codice di stato del flusso di output. Se il codice di stato non è uguale a 200, viene eseguito codice aggiuntivo.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Il parametro <see cref="P:System.Web.HttpResponse.StatusCode" /> viene impostato dopo l'invio delle intestazioni HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la stringa di stato HTTP dell'output restituito al client.</summary>
        <value>Stringa che descrive lo stato dell'output HTTP restituito al client. Il valore predefinito è "OK". Per un elenco dei codici di stato validi, vedere [codici di stato Http](https://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente controlla la stringa di stato del flusso di output. Se lo stato non è uguale a "OK", viene eseguito codice aggiuntivo.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Il parametro <paramref name="StatusDescription" /> viene impostato dopo l'invio delle intestazioni HTTP.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza del valore selezionato è maggiore di 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che qualifica il codice di stato della risposta.</summary>
        <value>Intero che rappresenta il codice di stato secondario [!INCLUDE[iisver](~/includes/iisver-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.SubStatusCode%2A> proprietà è supportata solo con la modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e almeno .NET Framework versione 3.0. Quando si impostano i <xref:System.Web.HttpResponse.SubStatusCode%2A> proprietà, lo stato viene registrato [!INCLUDE[iisver](~/includes/iisver-md.md)] se è configurata la traccia richieste non riuscite. Indipendentemente dal fatto che la configurazione della tracciatura, il codice non viene mai inviato come parte della risposta finale alla richiesta. Per altre informazioni, vedere [risoluzione dei problemi non è stato possibile Requests usando Failed Request Tracing in IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 L'esempio seguente imposta la <xref:System.Web.HttpResponse.SubStatusCode%2A> proprietà in un gestore eventi per il <xref:System.Web.HttpApplication> istanza la <xref:System.Web.HttpApplication.PostAuthenticateRequest> evento. Inserire il file di codice nella cartella App_Code dell'applicazione Web e configurare il file Web. config per registrare il modulo. Per altre informazioni, vedere [procedura dettagliata: creazione e registrazione di un modulo HTTP personalizzato](https://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L'operazione richiede la modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] e almeno .NET Framework versione 3.0.</exception>
        <exception cref="T:System.Web.HttpException">Il codice di stato viene impostato dopo l'invio di tutte le intestazioni HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la connessione supporta le operazioni di scaricamento asincrone.</summary>
        <value>
          <see langword="true" /> se la connessione supporta le operazioni di scaricamento asincrone; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce il valore della <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se inviare il contenuto HTTP al client.</summary>
        <value>
          <see langword="true" /> per sopprimere l'output; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene controllato se il <xref:System.Web.HttpRequest.IsSecureConnection%2A> proprietà è impostata su false. In caso affermativo il <xref:System.Web.HttpResponse.SuppressContent%2A> proprietà è impostata su true per arrestare l'invio della risposta.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supportato in .NET Framework 4.5.2 e versioni successive] 
Ottiene o imposta un valore che indica se eliminare l'intestazione <c>Cache Control: private</c> predefinita per la risposta HTTP corrente.</summary>
        <value>
          <see langword="true" /> Per eliminare il valore predefinito <c>Cache Control: private</c> intestazione per la risposta HTTP corrente; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, ASP.NET invia una `Cache-Control: private` intestazione della risposta a meno che non è stato specificato un criterio di cache esplicita per questa risposta. Questa proprietà consente l'eliminazione di questa intestazione di risposta predefinito in ogni richiesta. L'intestazione può ancora essere inibito per l'intera applicazione impostando <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> nelle [elemento httpRuntime (Schema delle impostazioni ASP.NET)](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) o [elemento outputCache per caching (Schema delle impostazioni ASP.NET)](https://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Prestare attenzione durante l'eliminazione del valore predefinito `Cache-Control: private` intestazione, come proxy e agli altri intermediari possono considerare le risposte senza questa intestazione come inseribili nella cache per impostazione predefinita. Quest ' ultimo può causare l'involontaria memorizzazione nella cache di informazioni riservate. Visualizzare [RFC 2616, sec. 13.4](http://tools.ietf.org/html/rfc2616) per altre informazioni.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se il reindirizzamento di autenticazione basata su form alla pagina di accesso deve essere eliminato.</summary>
        <value>
          <see langword="true" /> se deve essere soppresso il reindirizzamento dell'autenticazione basata su moduli; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, autenticazione basata su form converte i codici di stato HTTP 401 in 302 per reindirizzare alla pagina di accesso. Non è appropriato per alcune classi di errori, ad esempio quando l'autenticazione ha esito positivo ma l'autorizzazione ha esito negativo o se la richiesta corrente è una richiesta di servizio AJAX o web. Questa proprietà fornisce un modo per disattivare il comportamento di reindirizzamento e inviare il codice di stato originale al client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive il file specificato direttamente in un flusso di output di risposta HTTP senza memorizzarlo nel buffer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da scrivere nell'output HTTP.</param>
        <summary>Scrive il file specificato direttamente in un flusso di output di risposta HTTP senza memorizzarlo nel buffer.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="filename" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da scrivere nell'output HTTP.</param>
        <param name="offset">Posizione nel file da scrivere nell'output HTTP.</param>
        <param name="length">Numero di byte da trasmettere.</param>
        <summary>Scrive la parte di file specificata direttamente in un flusso di output di risposta HTTP senza memorizzarla nel buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si specifica 0 come le `offset` parametro e -1 come il `length` parametro, viene inviato l'intero file.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="offset" /> è minore di zero.  
  
\- oppure - 
Il parametro <paramref name="length" /> è minore di -1.  
  
\- oppure - 
Il parametro <paramref name="length" /> specifica un numero di byte maggiore del numero di byte contenuto nel file meno l'offset.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La richiesta di lavoro out-of-process non è supportata.  
  
\- oppure - 
La risposta non utilizza l'oggetto <see cref="T:System.Web.HttpWriter" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="offset" /> è minore di zero o maggiore delle dimensioni del file.  
  
\- oppure - 
Il parametro <paramref name="length" /> è minore di -1 o maggiore del valore del parametro <paramref name="offset" /> più le dimensioni del file.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se gli errori personalizzati [!INCLUDE[iisver](~/includes/iisver-md.md)] sono disabilitati.</summary>
        <value>
          <see langword="true" /> per disabilitare gli errori personalizzati IIS; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> proprietà viene utilizzata solo quando l'applicazione è ospitata in IIS 7.0 e versioni successive. Durante l'esecuzione in modalità classica, la <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> valore predefinito della proprietà è `true`. Durante l'esecuzione in modalità integrata, il <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> valore predefinito della proprietà è `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive le informazioni in un flusso di output di risposta HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Carattere da scrivere nel flusso di output HTTP.</param>
        <summary>Scrive un carattere in un flusso di output di risposta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente crea una serie di costanti che vengono scritti in una pagina ASP.NET utilizzando il metodo Write. Il codice chiama questa versione il metodo di scrittura per scrivere le costanti carattere singoli nella pagina.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Object" /> da inviare al flusso di output HTTP.</param>
        <summary>Scrive un oggetto <see cref="T:System.Object" /> in un flusso di risposta HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa da scrivere nel flusso di output HTTP.</param>
        <summary>Scrive una stringa in un flusso di output di risposta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pagine HTML generate in modo dinamico possono introdurre rischi di sicurezza se input ricevuti dai client Web non viene convalidato quando viene ricevuto da un client o quando quest'ultima viene trasmessa a un client. Script dannoso incorporato nell'input inviato a un sito Web e successivamente riscritti a un client può sembrare originati da una fonte attendibile. Questo rischio di sicurezza si intende un attacco di scripting intersito. È sempre opportuno convalidare i dati ricevuti da un client quando quest'ultima verrà trasmessa dal sito ai browser client.  
  
 Inoltre, ogni volta che si scrivono come HTML tutti i dati che è stati ricevuti come input, è necessario codificarli usando una tecnica, ad esempio <xref:System.Web.HttpServerUtility.HtmlEncode%2A> o <xref:System.Web.HttpServerUtility.UrlEncode%2A> per impedire l'esecuzione di script dannosi. Questa tecnica è utile per i dati che non è stati convalidati al momento della ricezione.  
  
 Quando si codifica o filtrare i dati, è necessario specificare un set di caratteri per le pagine Web in modo che il filtro può identificare e rimuovere eventuali sequenze di byte che non appartengono al set (ad esempio, le sequenze non alfanumerico), che potrebbero avere uno script dannoso incorporato nel essi.  
  
 Per altre informazioni sugli attacchi di scripting intersito, vedere l'articolo Q252985 "Come per evitare il Cross-Site Scripting problemi di sicurezza" sul [della Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?LinkID=37115) sito Web.  
  
   
  
## Examples  
 Nell'esempio seguente restituisce il nome del client al browser del client. Il <xref:System.Web.HttpServerUtility.HtmlEncode%2A> metodo rimuove qualsiasi script dannoso e caratteri non validi che è state inviate nel `UserName` campo di input.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di caratteri da scrivere.</param>
        <param name="index">Posizione di inizio scrittura all'interno della matrice di caratteri.</param>
        <param name="count">Numero di caratteri da scrivere, a partire da <paramref name="index" />.</param>
        <summary>Scrive una matrice di caratteri in un flusso di output di risposta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente crea una serie di costanti che vengono scritti in una pagina ASP.NET utilizzando il metodo Write. Il codice chiama questa versione il metodo di scrittura per scrivere le costanti carattere singoli nella pagina.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive il file specificato direttamente in un flusso di output di risposta HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da scrivere nell'output HTTP.</param>
        <summary>Scrive il contenuto del file specificato direttamente in un flusso di output di risposta HTTP come blocco file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene utilizzato con file di grandi dimensioni, la chiamata al metodo potrebbe generare un'eccezione. Le dimensioni del file che può essere utilizzato con questo metodo dipendono dalla configurazione hardware del server Web. Per altre informazioni, vedere l'articolo 812406, "PRB: Response. WriteFile non è possibile scaricare un File di grandi dimensioni" nel [della Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) sito Web.  
  
   
  
## Examples  
 L'esempio seguente scrive tutto il contenuto di un file di testo denominato `Login.txt` (che potrebbe contenere letterale i controlli di input di testo e HTML) direttamente nel flusso di output.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="filename" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da scrivere in un blocco di memoria.</param>
        <param name="readIntoMemory">Indica se il file verrà scritto in un blocco di memoria.</param>
        <summary>Scrive il contenuto del file specificato direttamente in un flusso di output di risposta HTTP come blocco di memoria.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene utilizzato con file di grandi dimensioni, la chiamata al metodo potrebbe generare un'eccezione. Le dimensioni del file che può essere utilizzato con questo metodo dipendono dalla configurazione hardware del server Web. Per altre informazioni, vedere l'articolo 812406, "PRB: Response. WriteFile non è possibile scaricare un File di grandi dimensioni" nel [della Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) sito Web.  
  
   
  
## Examples  
 Nell'esempio seguente scrive un file alla memoria.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="filename" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Handle di file da scrivere nel flusso di output HTTP.</param>
        <param name="offset">Posizione di byte nel file in cui inizierà la scrittura.</param>
        <param name="size">Numero di byte da scrivere nel flusso di output.</param>
        <summary>Scrive il file specificato direttamente in un flusso di output di risposta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene utilizzato con file di grandi dimensioni, la chiamata al metodo potrebbe generare un'eccezione. Le dimensioni del file che può essere utilizzato con questo metodo dipendono dalla configurazione hardware del server Web. Per altre informazioni, vedere l'articolo 812406, "PRB: Response. WriteFile non è possibile scaricare un File di grandi dimensioni" nel [della Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) sito Web.  
  
   
  
## Examples  
 L'esempio seguente scrive tutto il contenuto di un file di testo denominato `Login.txt` (che potrebbe contenere letterale i controlli di input di testo e HTML) direttamente nel flusso di output.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileHandler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> è minore di 0.  
  
\- oppure - 
 <paramref name="size" /> è maggiore della dimensione del file meno <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nome del file da scrivere nel flusso di output HTTP.</param>
        <param name="offset">Posizione di byte nel file in cui inizierà la scrittura.</param>
        <param name="size">Numero di byte da scrivere nel flusso di output.</param>
        <summary>Scrive il file specificato direttamente in un flusso di output di risposta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene utilizzato con file di grandi dimensioni, la chiamata al metodo potrebbe generare un'eccezione. Le dimensioni del file che può essere utilizzato con questo metodo dipendono dalla configurazione hardware del server Web. Per altre informazioni, vedere l'articolo 812406, "PRB: Response. WriteFile non è possibile scaricare un File di grandi dimensioni" nel [della Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) sito Web.  
  
   
  
## Examples  
 L'esempio seguente scrive tutto il contenuto di un file di testo denominato `Login.txt` (che potrebbe contenere testo letterale e HTML controlli di input) direttamente nel flusso di output.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> è minore di 0.  
  
\- oppure - 
 <paramref name="size" /> è maggiore della dimensione del file meno <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="filename" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Metodo, controllo utente o oggetto da sostituire.</param>
        <summary>Consente l'inserimento di blocchi di sostituzione della risposta nella risposta, che consente la generazione dinamica di aree di risposta specificate per risposte memorizzate nella cache di output.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il <xref:System.Web.HttpResponse.WriteSubstitution%2A> metodo per la sostituzione post-cache nelle pagine nella cache di output. Passando un <xref:System.Web.HttpContext> oggetto a un metodo di callback con un prescritte <xref:System.Web.HttpResponseSubstitutionCallback> firma, è possibile sostituire nella cache di output del contenuto in qualsiasi posizione specificata nella cache della pagina. Per avviare la sostituzione, chiamare il <xref:System.Web.HttpResponse.WriteSubstitution%2A> passandogli il metodo di callback, che deve essere thread-safe e può essere uno dei modi seguenti:  
  
-   Un metodo statico sul controllo contenitore utente o pagina.  
  
-   Un valore statico o istanza di metodo su un altro oggetto arbitrario.  
  
 Alla prima richiesta alla pagina, il <xref:System.Web.HttpResponse.WriteSubstitution%2A> chiama il <xref:System.Web.HttpResponseSubstitutionCallback> delegato per produrre l'output. Quindi, aggiunge un buffer di sostituzione nella risposta, che mantiene il delegato da chiamare alle richieste future. Infine, comporta una riduzione lato client nella cache da pubblica a solo server, garantendo le richieste successive per la pagina nuovo richiamare il delegato memorizzando nella cache non sul client.  
  
> [!NOTE]
>  Sostituzione post-cache non è supportata per un controllo utente memorizzato nella cache la memorizzazione nella cache di output in cui viene applicata a livello di controllo utente. Questa operazione è nota anche come memorizzazione di frammenti. Per altre informazioni, vedere [memorizzazione nella cache parti di una pagina ASP.NET](https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La destinazione del parametro <paramref name="callback" /> è di tipo <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://msdn.microsoft.com/library/d5fbd79f-972d-4557-9a39-f90684b3dcd3">Impostazioni nella cache di una pagina</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e">La memorizzazione nella cache parti di una pagina ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/09c9bd9a-0d68-4a5c-aa6f-1b461c208795">Aggiornamento dinamico di parti di una pagina memorizzata nella cache</related>
      </Docs>
    </Member>
  </Members>
</Type>