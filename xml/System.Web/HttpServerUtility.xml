<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80eb5a3f30a3ad4a39f49dca9820cd97cfa81308" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37529049" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <TypeSignature Language="F#" Value="type HttpServerUtility = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides helper methods for processing Web requests.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I metodi e proprietà del <xref:System.Web.HttpServerUtility> classe vengono esposte tramite la funzione intrinseca <xref:System.Web.HttpContext.Server%2A> relativo oggetto fornito da ASP.NET.  
  
   
  
## Examples  
 Un progetto di sito Web di Visual Studio con il codice sorgente è disponibile a complemento di questo argomento: [scaricare](http://go.microsoft.com/fwlink/?LinkId=192870).  
  
 L'esempio seguente illustra come usare il <xref:System.Web.HttpServerUtility.HtmlEncode%2A> metodo e il <xref:System.Web.HttpServerUtility.UrlEncode%2A> metodo del <xref:System.Web.HttpServerUtility> classe. Il <xref:System.Web.HttpServerUtility.HtmlEncode%2A> metodo aiuta a garantire che qualsiasi stringa fornito dall'utente di input verrà eseguito il rendering come testo statico in browser anziché gli elementi HTML o script eseguibile. Il <xref:System.Web.HttpServerUtility.UrlEncode%2A> metodo codifica URL in modo che vengano trasmessi correttamente nel flusso HTTP.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpServerUtility.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the previous exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente cancella l'ultima eccezione generata.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a server instance of a COM object.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : string -&gt; obj" Usage="httpServerUtility.CreateObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">The class or type of object to create an instance of.</param>
        <summary>Creates a server instance of a COM object identified by the object's programmatic identifier (ProgID).</summary>
        <returns>The new object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea un oggetto utilizzando il ProgID dell'oggetto.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">An instance of the object could not be created.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : Type -&gt; obj" Usage="httpServerUtility.CreateObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> representing the object to create.</param>
        <summary>Creates a server instance of a COM object identified by the object's type.</summary>
        <returns>The new object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectFromClsid : string -&gt; obj" Usage="httpServerUtility.CreateObjectFromClsid clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">The class identifier of the object to create an instance of.</param>
        <summary>Creates a server instance of a COM object identified by the object's class identifier (CLSID).</summary>
        <returns>The new object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> metodo per creare un'istanza del server di un oggetto COM.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">An instance of the object could not be created.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes the handler for a specified resource in the context of the current request and returns execution to the page that invoked it.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Execute : string -&gt; unit" Usage="httpServerUtility.Execute path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The URL path to execute.</param>
        <summary>Executes the handler for the specified virtual path in the context of the current request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.Execute%2A> metodo continua l'esecuzione della pagina originale al termine dell'esecuzione della nuova pagina. Il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo trasferisce in modo incondizionato l'esecuzione a un altro gestore.  
  
 ASP.NET non verifica che l'utente corrente sia autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguita prima che venga chiamato il gestore di risorse originale, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Execute%2A> metodo e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza dell'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzata.  
  
 È possibile forzare la riautorizzazione usando la <xref:System.Web.HttpResponse.Redirect%2A> invece del metodo di <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). <xref:System.Web.HttpResponse.Redirect%2A> esegue un reindirizzamento lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, questo viene sottoposto a tutta la logica di autenticazione e autorizzazione dei criteri di sicurezza di Internet Information Services (IIS) sia ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che usa il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Execute%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente mostra la pagina. aspx "Updateinfo" nella directory corrente. L'esecuzione del programma torna alla pagina inizia dopo che viene visualizzata la pagina Updateinfo.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The current <see cref="T:System.Web.HttpContext" /> is <see langword="null" />.  \- or -  An error occurred while executing the handler specified by <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.  \- or -  <paramref name="path" /> is not a virtual path.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * bool -&gt; unit" Usage="httpServerUtility.Execute (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The URL path to execute.</param>
        <param name="preserveForm">
          <see langword="true" /> to preserve the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections; <see langword="false" /> to clear the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections.</param>
        <summary>Executes the handler for the specified virtual path in the context of the current request and specifies whether to clear the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come eseguire la pagina. aspx `Updateinfo.aspx` nella richiesta corrente e conserva le <xref:System.Web.HttpRequest.QueryString%2A> e <xref:System.Web.HttpRequest.Form%2A> raccolte. L'esecuzione del programma torna alla pagina inizia dopo `Updateinfo.aspx` viene visualizzato.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The current <see cref="T:System.Web.HttpContext" /> is <see langword="null" />.  \- or -  An error occurred while executing the handler specified by <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.  \- or -  <paramref name="path" /> is not a virtual path.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.Execute (path, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">The URL path to execute.</param>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> to capture the output.</param>
        <summary>Executes the handler for the specified virtual path in the context of the current request. A <see cref="T:System.IO.TextWriter" /> captures output from the executed handler.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.Execute%2A> metodo continua l'esecuzione della richiesta originale al termine dell'esecuzione del percorso virtuale specificato. Il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo trasferisce in modo incondizionato l'esecuzione a un altro gestore.  
  
 ASP.NET non verifica che l'utente corrente sia autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguita prima che venga chiamato il gestore di risorse originale, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Execute%2A> metodo e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza dell'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzata.  
  
 È possibile forzare la riautorizzazione usando la <xref:System.Web.HttpResponse.Redirect%2A> invece del metodo di <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). <xref:System.Web.HttpResponse.Redirect%2A> esegue un reindirizzamento lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, questo viene sottoposto a tutta la logica di autenticazione e autorizzazione dei criteri di sicurezza di Internet Information Services (IIS) sia ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che usa il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Execute%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita la `Login.aspx` pagina sul server nella directory corrente e riceve l'output dalla pagina tramite il <xref:System.IO.StringWriter> oggetto `writer`. Scrive nel flusso HTML ricevuto da `writer` flusso di output per il protocollo HTTP.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The current <see cref="T:System.Web.HttpContext" /> is <see langword="null" />.  \- or -  An error occurred while executing the handler specified by <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.  \- or -  <paramref name="path" /> is not a virtual path.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (path, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The URL path to execute.</param>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> to capture the output.</param>
        <param name="preserveForm">
          <see langword="true" /> to preserve the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections; <see langword="false" /> to clear the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections.</param>
        <summary>Executes the handler for the specified virtual path in the context of the current request. A <see cref="T:System.IO.TextWriter" /> captures output from the page and a Boolean parameter specifies whether to clear the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.Execute%2A> metodo continua l'esecuzione della richiesta originale al termine dell'esecuzione del percorso virtuale specificato. Il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo trasferisce in modo incondizionato l'esecuzione a un altro gestore.  
  
 ASP.NET non verifica che l'utente corrente sia autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguita prima che venga chiamato il gestore di risorse originale, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Execute%2A> metodo e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza dell'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzata.  
  
 È possibile forzare la riautorizzazione usando la <xref:System.Web.HttpResponse.Redirect%2A> invece del metodo di <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). <xref:System.Web.HttpResponse.Redirect%2A> esegue un reindirizzamento lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, questo viene sottoposto a tutta la logica di autenticazione e autorizzazione dei criteri di sicurezza di Internet Information Services (IIS) sia ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che usa il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Execute%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita la `Login.aspx` pagina sul server nella directory corrente e riceve l'output dalla pagina tramite il <xref:System.IO.StringWriter> oggetto `writer`. Scrive nel flusso HTML ricevuto da `writer` flusso di output per il protocollo HTTP. Il contenuto del <xref:System.Web.HttpRequest.Form%2A> e <xref:System.Web.HttpRequest.QueryString%2A> raccolte vengono mantenute.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The current <see cref="T:System.Web.HttpContext" /> is a null reference (<see langword="Nothing" /> in Visual Basic).  \- or -  <paramref name="path" /> ends with a period (.).  \- or -  An error occurred while executing the handler specified by <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is not a virtual path.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : System.Web.IHttpHandler * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (handler, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">The HTTP handler that implements the <see cref="T:System.Web.IHttpHandler" /> to transfer the current request to.</param>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> to capture the output.</param>
        <param name="preserveForm">
          <see langword="true" /> to preserve the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections; <see langword="false" /> to clear the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections.</param>
        <summary>Executes the handler for the specified virtual path in the context of the current request. A <see cref="T:System.IO.TextWriter" /> captures output from the executed handler and a Boolean parameter specifies whether to clear the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile scrivere gestori HTTP personalizzati per l'elaborazione di tipi predefiniti specifici di richieste HTTP in qualsiasi linguaggio conforme con le Specification (CLS). Il codice eseguibile che viene definito nelle classi del gestore HTTP invece di pagine ASP.NET o pagine ASP (noto anche come ASP classico) convenzionale risponde a queste richieste specifiche. Consentano i gestori HTTP per l'interazione con i servizi di risposta di un server Web che esegue Internet Information Services (IIS) e la richiesta di basso livello e forniscono funzionalità simili alle estensioni ISAPI ma con un modello di programmazione più semplice.  
  
 ASP.NET non verifica che l'utente corrente sia autorizzato a visualizzare la risorsa che viene distribuita dal <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguita prima che venga chiamato il gestore di risorse originale, ASP.NET richiama direttamente il gestore di è indicato dal <xref:System.Web.HttpServerUtility.Execute%2A> metodo e non viene rieseguita la logica di autenticazione e autorizzazione per il nuova risorsa. Se i criteri di sicurezza per l'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzata.  
  
 È possibile forzare la riautorizzazione usando la <xref:System.Web.HttpResponse.Redirect%2A> invece del metodo di <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). Il <xref:System.Web.HttpResponse.Redirect%2A> esegue un reindirizzamento lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, questo viene sottoposto a tutta la logica di autenticazione e autorizzazione dei criteri di sicurezza di IIS e ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che usa il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Execute%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">An error occurred while executing the handler specified by <paramref name="handler" />.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="handler" /> parameter is <see langword="null" />.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberSignature Language="F#" Value="member this.GetLastError : unit -&gt; Exception" Usage="httpServerUtility.GetLastError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the previous exception.</summary>
        <returns>The previous exception that was thrown.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente visualizza una descrizione dell'errore ultimo dell'applicazione nel flusso di output HTTP. Stampa "No Errors" Se non sono stati rilevati errori.  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodes a string that has been encoded to eliminate invalid HTML characters.  To encode or decode values outside of a web application, use the <see cref="T:System.Net.WebUtility" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string -&gt; string" Usage="httpServerUtility.HtmlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The HTML string to decode.</param>
        <summary>Decodes an HTML-encoded string and returns the decoded string.</summary>
        <returns>The decoded text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codifica HTML consente di verificare che il testo è visualizzato correttamente nel browser e non interpretato dal browser come HTML. Ad esempio, se una stringa di testo contiene un segno di minore (\<) o superiore al segno (>), questi caratteri vengono interpretati come l'apertura o di una parentesi quadra di chiusura di un tag HTML dal browser. Quando i caratteri sono codificati in HTML, vengono convertiti in stringhe `&lt;` e `&gt;`, in modo che il browser visualizzare il segno di minore il segno di maggiore e versioni successive in modo corretto. <xref:System.Web.HttpServerUtility.HtmlDecode%2A> decodifica il testo che è stato trasmesso al server.  
  
 Questo metodo è un modo pratico per accedere la <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, questo metodo Usa <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> decodificare le stringhe.  
  
 Nel file code-behind per una pagina web ASP.NET, accedere a un'istanza del <xref:System.Web.HttpServerUtility> classe tramite la `Server` proprietà. In una classe che non è in un file code-behind, usare `HttpContext.Current.Server` accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe.  
  
 Di fuori di un'applicazione web, usare il <xref:System.Net.WebUtility> classe per codificare o decodificare i valori.  
  
   
  
## Examples  
 Nell'esempio seguente contiene la funzione `LoadDecodedFile`, che consente di decodificare i dati da un file e lo copia in un'unica stringa.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">The HTML string to decode.</param>
        <param name="output">The <see cref="T:System.IO.TextWriter" /> output stream that contains the decoded string.</param>
        <summary>Decodes an HTML-encoded string and sends the resulting output to a <see cref="T:System.IO.TextWriter" /> output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codifica HTML consente di verificare che il testo è visualizzato correttamente nel browser e non interpretato dal browser come HTML. Ad esempio, se una stringa di testo contiene un segno di minore (\<) o superiore al segno (>), questi caratteri vengono interpretati come l'apertura o di una parentesi quadra di chiusura di un tag HTML dal browser. Quando i caratteri sono codificati in HTML, vengono convertiti in stringhe `&lt;` e `&gt;`, in modo che il browser visualizzare il segno di minore il segno di maggiore e versioni successive in modo corretto.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> decodifica il testo che è stato trasmesso al server.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> è un modo pratico per accedere la <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente <xref:System.Web.HttpServerUtility.HtmlDecode%2A> Usa <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> decodificare le stringhe.  
  
 Per codificare o decodificare i valori di fuori di un'applicazione web, usare il <xref:System.Net.WebUtility> classe.  
  
   
  
## Examples  
 Nell'esempio seguente consente di decodificare una stringa che è stata codificata in formato HTML per la trasmissione tramite HTTP. Consente di decodificare la stringa fornita denominata `EncodedString` che contiene il testo "si tratta di un &lt;stringa di prova&gt;." e lo copia nella stringa denominata `DecodedString` come "si tratta di un \<Test stringa >.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encodes a string to be displayed in a browser.  To encode or decode values outside of a web application, use the <see cref="T:System.Net.WebUtility" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string -&gt; string" Usage="httpServerUtility.HtmlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The text string to encode.</param>
        <summary>HTML-encodes a string and returns the encoded string.</summary>
        <returns>The HTML-encoded text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codifica HTML consente di verificare che il testo è visualizzato correttamente nel browser e non interpretato dal browser come HTML. Ad esempio, se una stringa di testo contiene un segno di minore (\<) o superiore al segno (>), questi caratteri vengono interpretati come l'apertura o di una parentesi quadra di chiusura di un tag HTML dal browser. Quando i caratteri sono codificati in HTML, vengono convertiti in stringhe `&lt;` e `&gt;`, in modo che il browser visualizzare il segno di minore il segno di maggiore e versioni successive in modo corretto.  
  
 Questo metodo è un modo pratico per accedere la <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, questo metodo Usa <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> per codificare le stringhe.  
  
 Nel file code-behind per una pagina web ASP.NET, accedere a un'istanza del <xref:System.Web.HttpServerUtility> classe tramite la `Server` proprietà. In una classe che non è in un file code-behind, usare `HttpContext.Current.Server` accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe.  
  
 Di fuori di un'applicazione web, usare il <xref:System.Net.WebUtility> classe per codificare o decodificare i valori.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come la codifica HTML un valore che potenzialmente codici codice unsafe. Il codice si trova nel file code-behind per una pagina web. Il valore per la codifica è hardcoded in questo esempio solo per semplificare l'esempio e visualizzare il tipo di valore che si potrebbe applicare la codifica HTML. In genere, si farebbe codifica HTML un valore che è stato ricevuto dall'utente o la richiesta. `Result` fa riferimento a un `Literal` controllo.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 L'esempio seguente è simile all'esempio precedente ma viene illustrato come per la codifica HTML in un valore dall'interno di una classe che non è nel file code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">The string to encode.</param>
        <param name="output">The <see cref="T:System.IO.TextWriter" /> output stream that contains the encoded string.</param>
        <summary>HTML-encodes a string and sends the resulting output to a <see cref="T:System.IO.TextWriter" /> output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica HTML assicura che il testo verrà visualizzato correttamente nel browser, non interpretato dal browser come HTML. Ad esempio, se una stringa di testo contiene un segno di minore (\<) o superiore al segno (>), questi caratteri verrà interpretati come una parentesi o parentesi quadra di chiusura di un tag HTML nel browser. La codifica HTML di questi due caratteri viene `&lt;` e `&gt;`, rispettivamente, in modo che il browser visualizzare il segno di minore il segno di maggiore e versioni successive in modo corretto.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> è un modo pratico per accedere la <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Usa <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> per codificare le stringhe.  
  
 Per codificare o decodificare i valori di fuori di un'applicazione web, usare il <xref:System.Net.WebUtility> classe.  
  
   
  
## Examples  
 Nell'esempio seguente codifica una stringa per la trasmissione tramite HTTP. Consente di codificare la stringa `TestString`, che contiene il testo "si tratta di un \<stringa di Test >." e lo copia nella stringa denominata `EncodedString` come "si tratta di una &lt;stringa Test&gt;.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the server's computer name.</summary>
        <value>Nome del computer locale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente vengono archiviati il nome del computer server come una variabile di stringa.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The computer name cannot be found.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpServerUtility.MapPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The virtual path in the Web application.</param>
        <summary>Returns the physical file path that corresponds to the specified virtual path.</summary>
        <returns>The physical file path on the Web server that corresponds to <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `path` viene `null`, il <xref:System.Web.HttpServerUtility.MapPath%2A> metodo restituisce il percorso fisico completo della directory che contiene la richiesta corrente per il percorso. Il percorso relativo non è necessario specificare un file esistente o una cartella per questo metodo restituire un valore. Tuttavia, è possibile specificare un percorso all'esterno dell'applicazione Web.  
  
> [!IMPORTANT]
>  Il <xref:System.Web.HttpServerUtility.MapPath%2A> metodo potenzialmente contiene informazioni riservate riguardanti l'ambiente di hosting. Il valore restituito non deve essere visibile agli utenti.  
  
 Un'applicazione Web che si trova nella `C:\ExampleSites\TestMapPath` restituirà i risultati seguenti:  
  
|Richiesta da|`path`|Valore restituito|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/ DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/ NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|".. / OutsideApplication "|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come recuperare il file fisico di un percorso virtuale relativo. Il codice si trova nel file code-behind per una pagina web e Usa il valore predefinito `Server` oggetto.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 L'esempio seguente è simile all'esempio precedente ma viene illustrato come recuperare un percorso fisico dall'interno di una classe che non si trova il file code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The current <see cref="T:System.Web.HttpContext" /> is <see langword="null" />.
 -or-  <paramref name="path" /> is a physical path, but a virtual path was expected.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptTimeout : int with get, set" Usage="System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets and sets the request time-out value in seconds.</summary>
        <value>Impostazione del valore di timeout per le richieste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> proprietà può essere impostata nel file Web. config impostando il `executionTimeout` attributo dell'elemento. Impostazione del timeout a livello di codice con il <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> proprietà ha la precedenza sull'impostazione Web. config.  
  
> [!NOTE]
>  Se si impostano i `debug` attributo dell'elemento da `true` nel file Web. config, il valore di <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> verranno ignorati.  
  
   
  
## Examples  
 Nell'esempio seguente imposta il periodo di timeout della richiesta su 60 secondi.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The current <see cref="T:System.Web.HttpContext" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The time-out period is <see langword="null" /> or otherwise could not be set.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Terminates execution of the current page and starts execution of a new page for the current request.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string -&gt; unit" Usage="httpServerUtility.Transfer path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The URL path of the new page on the server to execute.</param>
        <summary>For the current request, terminates execution of the current page and starts execution of a new page by using the specified URL path of the page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La pagina trasferita a deve essere un'altra pagina. aspx. Ad esempio, un trasferimento a una pagina ASP o con estensione asmx non è valido. Il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo mantiene il <xref:System.Web.HttpRequest.QueryString%2A> e <xref:System.Web.HttpRequest.Form%2A> raccolte.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> le chiamate <xref:System.Web.HttpResponse.End%2A>, che genera un <xref:System.Threading.ThreadAbortException> eccezione dopo il completamento.  
  
 ASP.NET non verifica che l'utente corrente sia autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguita prima che venga chiamato il gestore di risorse originale, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Transfer%2A> metodo e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza dell'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzata.  
  
 È possibile forzare la riautorizzazione usando la <xref:System.Web.HttpResponse.Redirect%2A> invece del metodo di <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Il <xref:System.Web.HttpResponse.Redirect%2A> metodo esegue un reindirizzamento lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, questo viene sottoposto a tutta la logica di autenticazione e autorizzazione dei criteri di sicurezza di Internet Information Services (IIS) sia ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che usa il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string * bool -&gt; unit" Usage="httpServerUtility.Transfer (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The URL path of the new page on the server to execute.</param>
        <param name="preserveForm">
          <see langword="true" /> to preserve the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections; <see langword="false" /> to clear the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections.</param>
        <summary>Terminates execution of the current page and starts execution of a new page by using the specified URL path of the page. Specifies whether to clear the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La pagina trasferita a deve essere un'altra pagina. aspx. Ad esempio, un trasferimento a una pagina ASP o con estensione asmx non è valido.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> le chiamate <xref:System.Web.HttpResponse.End%2A>, che genera un <xref:System.Threading.ThreadAbortException> eccezione dopo il completamento.  
  
 Se si imposta la `preserveForm` parametro per `true`, la pagina di destinazione saranno in grado di accedere allo stato di visualizzazione di pagina precedente usando il <xref:System.Web.UI.Page.PreviousPage%2A> proprietà.  
  
 Per motivi di sicurezza, è consigliabile mantenere il `enableViewStateMac` attributo è impostato su `true`. ASP.NET non verifica che l'utente corrente sia autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguita prima che venga chiamato il gestore di risorse originale, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Transfer%2A> metodo e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza dell'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzata.  
  
 È possibile forzare la riautorizzazione usando la <xref:System.Web.HttpResponse.Redirect%2A> invece del metodo di <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Il <xref:System.Web.HttpResponse.Redirect%2A> metodo esegue un reindirizzamento lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, questo viene sottoposto a tutta la logica di autenticazione e autorizzazione dei criteri di sicurezza di Internet Information Services (IIS) sia ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che usa il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita una nuova pagina nella stessa directory della pagina corrente.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">The current page request is a callback.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : System.Web.IHttpHandler * bool -&gt; unit" Usage="httpServerUtility.Transfer (handler, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">The HTTP handler that implements the <see cref="T:System.Web.IHttpHandler" /> to transfer the current request to.</param>
        <param name="preserveForm">
          <see langword="true" /> to preserve the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections; <see langword="false" /> to clear the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections.</param>
        <summary>Terminates execution of the current page and starts execution of a new request by using a custom HTTP handler that implements the <see cref="T:System.Web.IHttpHandler" /> interface and specifies whether to clear the <see cref="P:System.Web.HttpRequest.QueryString" /> and <see cref="P:System.Web.HttpRequest.Form" /> collections.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile scrivere gestori HTTP personalizzati per l'elaborazione di tipi predefiniti specifici di richieste HTTP in qualsiasi linguaggio conforme con le Specification (CLS). Il codice eseguibile che viene definito nelle classi del gestore HTTP invece di pagine ASP.NET o pagine ASP (noto anche come ASP classico) convenzionale risponde a queste richieste specifiche. Consentano i gestori HTTP per l'interazione con i servizi di risposta di un server Web che esegue Internet Information Services (IIS) e la richiesta di basso livello e forniscono funzionalità simili alle estensioni ISAPI ma con un modello di programmazione più semplice.  
  
 Se si imposta la `preserveForm` parametro per `true`, la pagina di destinazione saranno in grado di accedere allo stato di visualizzazione di pagina precedente usando il <xref:System.Web.UI.Page.PreviousPage%2A> proprietà.  
  
 Per motivi di sicurezza, è consigliabile mantenere il `enableViewStateMac` attributo è impostato su `true`. ASP.NET non verifica che l'utente corrente sia autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguita prima che venga chiamato il gestore di risorse originale, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo) e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza per l'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzata.  
  
 È possibile forzare la riautorizzazione usando la <xref:System.Web.HttpResponse.Redirect%2A> invece del metodo di <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Il <xref:System.Web.HttpResponse.Redirect%2A> metodo esegue un reindirizzamento lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, questo viene sottoposto a tutta la logica di autenticazione e autorizzazione dei criteri di sicurezza di IIS e ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che usa il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">The current page request is a callback.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Performs an asynchronous execution of the specified URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> è stato introdotto in .NET Framework versione 3.5. Per informazioni di riepilogo relative a .NET Framework, vedere [versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string -&gt; unit" Usage="httpServerUtility.TransferRequest path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The URL path of the new page on the server to execute.</param>
        <summary>Performs an asynchronous execution of the specified URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo chiama il <xref:System.Web.HttpServerUtility.TransferRequest%2A> overload con il `preserveForm` parametro impostato su `false`, il `method` parametro impostato su `null`, la `headers` parametro impostato su `null`e il `preserveUser` parametro impostato su `true`. Per altre informazioni, vedere la sezione "Osservazioni" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> rapporto di overload.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The request requires the integrated pipeline mode of [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">The server is not available to handle the request.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The URL path of the new page on the server to execute.</param>
        <param name="preserveForm">
          <see langword="true" /> to preserve the <see cref="P:System.Web.HttpRequest.Form" /> collection; <see langword="false" /> to clear the <see cref="P:System.Web.HttpRequest.Form" /> collection.</param>
        <summary>Performs an asynchronous execution of the specified URL and preserves query string parameters.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload chiama il <xref:System.Web.HttpServerUtility.TransferRequest%2A> rapporto di overload con il `preserveForm` parametro impostato sul valore passato, il `method` parametro impostato su `null`, il `headers` parametro impostato su `null`e il `preserveUser` set di parametri per `true`. Per altre informazioni, vedere la sezione "Osservazioni" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> è stato introdotto in .NET Framework versione 3.5.  Per altre informazioni, vedere [Versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The request requires the integrated pipeline mode of [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">The server is not available to handle the request.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">The URL path of the new page on the server to execute.</param>
        <param name="preserveForm">
          <see langword="true" /> to preserve the <see cref="P:System.Web.HttpRequest.Form" /> collection; <see langword="false" /> to clear the <see cref="P:System.Web.HttpRequest.Form" /> collection.</param>
        <param name="method">The HTTP method to use in the execution of the new request.</param>
        <param name="headers">A <see cref="T:System.Collections.Specialized.NameValueCollection" /> of request headers for the new request.</param>
        <summary>Performs an asynchronous execution of the specified URL using the specified HTTP method and headers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato durante l'esecuzione con la modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] per consentire l'elaborazione della richiesta essere trasferito da un tipo di risorsa a un altro durante l'esecuzione della richiesta di destinazione con il contesto di richiesta corretto. Ad esempio, è possibile usare il <xref:System.Web.HttpServerUtility.TransferRequest%2A> metodo per trasferire una richiesta per una pagina ASPX in una richiesta per una pagina XML.  
  
 Il <xref:System.Web.HttpServerUtility.TransferRequest%2A> metodo esegue un'esecuzione asincrona figlio dell'URL specificato con le condizioni seguenti:  
  
-   Se il `path` parametro specifica una stringa di query, verrà usato come la nuova stringa di query. Se non è inclusa alcuna stringa di query, la stringa di query della richiesta sarà usata nuovamente.  
  
-   Se il `method` viene specificato, verrà usato. Se si tratta di `null`, verrà utilizzato il metodo HTTP della richiesta originale.  
  
-   Se il `preserveForm` parametro è `true`, il corpo dell'entità corrente della richiesta saranno disponibile per la richiesta di destinazione. Ciò consente di invii di form e lo carica per essere trasferita.  
  
-   Se l'identità dell'utente è attualmente impostato nella richiesta originale, l'identità verrà trasferito alla nuova richiesta. In questo modo le richieste autenticate di riutilizzare il risultato dell'autenticazione per la nuova richiesta. Se si preferisce che non l'utente da trasferire, impostare l'utente `null` nella richiesta originale prima del trasferimento.  
  
-   Se il `headers` viene specificato, la nuova richiesta verrà eseguita con le intestazioni specificate. Ciò può essere utilizzato per modificare le intestazioni di richiesta e i cookie per la nuova richiesta o aggiunta un'intestazione speciale che specifica in cui è stata ricevuta la richiesta originale.  
  
     Questo metodo chiama il <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> overload del metodo con il `preserveUser` parametro impostato su `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The request requires [!INCLUDE[iisver](~/includes/iisver-md.md)] running in integrated mode.</exception>
        <exception cref="T:System.Web.HttpException">The server is not available to handle the request.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers, preserveUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="preserveUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The path.</param>
        <param name="preserveForm">
          <see langword="true" /> to preserve the <see cref="P:System.Web.HttpRequest.Form" /> collection; <see langword="false" /> to clear the <see cref="P:System.Web.HttpRequest.Form" /> collection.</param>
        <param name="method">The HTTP method to use in the new request.</param>
        <param name="headers">A <see cref="T:System.Collections.Specialized.NameValueCollection" /> object that contains request headers for the new request.</param>
        <param name="preserveUser">
          <see langword="true" /> to preserve the user identity; otherwise, <see langword="false" />. The other method overloads of this method call this overload with this parameter set to <see langword="true" />.</param>
        <summary>Performs an asynchronous execution of the specified URL using the specified HTTP method, headers, and path, and optionally preserves form values and the user identity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni, vedere la sezione "Osservazioni" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The request requires the integrated pipeline mode of [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">The server is not available to handle the request.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is invalid.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodes a string that was encoded for HTTP transmission and then sent to the server in a URL.  To encode or decode values outside of a web application, use the <see cref="T:System.Net.WebUtility" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string -&gt; string" Usage="httpServerUtility.UrlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The text string to decode.</param>
        <summary>URL-decodes a string and returns the decoded string.</summary>
        <returns>The decoded text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codifica URL garantisce che tutti i browser trasmetterà correttamente testo in stringhe URL. Caratteri, ad esempio un punto interrogativo (?), e commerciale (&), barra (/) di contrassegnare e spazi potrebbero essere troncati o danneggiati da alcuni browser. Di conseguenza, questi caratteri devono essere codificati `<a>` tag o in stringhe di query in cui le stringhe possono essere nuovamente inviate da un browser in una stringa di richiesta.  
  
 Questo metodo è un modo pratico per accedere la <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, questo metodo Usa <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> decodificare le stringhe.  
  
 Nel file code-behind per una pagina web ASP.NET, accedere a un'istanza del <xref:System.Web.HttpServerUtility> classe tramite la `Server` proprietà. In una classe che non è in un file code-behind, usare `HttpContext.Current.Server` accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe.  
  
 Di fuori di un'applicazione web, usare il <xref:System.Net.WebUtility> classe per codificare o decodificare i valori.  
  
   
  
## Examples  
 L'esempio seguente mostra come URL decodifica un valore che viene recuperato dalla stringa di query. Il codice si trova nel file code-behind per una pagina web. `ReturnPage` fa riferimento a un `HyperLink` controllo.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 L'esempio seguente è simile all'esempio precedente ma viene illustrato come decodificare URL un valore dall'interno di una classe che non è nel file code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">The HTML string to decode.</param>
        <param name="output">The <see cref="T:System.IO.TextWriter" /> output stream that contains the decoded string.</param>
        <summary>Decodes an HTML string received in a URL and sends the resulting output to a <see cref="T:System.IO.TextWriter" /> output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codifica URL garantisce che tutti i browser trasmetterà correttamente testo in stringhe URL. Caratteri, ad esempio un punto interrogativo (?), e commerciale (&), barra (/) di contrassegnare e spazi potrebbero essere troncati o danneggiati da alcuni browser. Di conseguenza, questi caratteri devono essere codificati `<a>` tag o in stringhe di query in cui le stringhe possono essere nuovamente inviate da un browser in una stringa di richiesta.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> è un modo pratico per accedere la <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente <xref:System.Web.HttpServerUtility.UrlDecode%2A> Usa <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> decodificare le stringhe.  
  
 Per codificare o decodificare i valori di fuori di un'applicazione web, usare il <xref:System.Net.WebUtility> classe.  
  
   
  
## Examples  
 Nell'esempio seguente consente di decodificare la stringa denominata `EncodedString` (ricevute in un URL) nella stringa denominata `DecodedString`.  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encodes a string for reliable HTTP transmission from the Web server to a client through the URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> è un modo pratico per accedere la <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente <xref:System.Web.HttpServerUtility.UrlEncode%2A> Usa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> per codificare le stringhe.  
  
 Per codificare o decodificare i valori di fuori di un'applicazione web, usare il <xref:System.Net.WebUtility> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string -&gt; string" Usage="httpServerUtility.UrlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The text to URL-encode.</param>
        <summary>URL-encodes a string and returns the encoded string.</summary>
        <returns>The URL-encoded text.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codifica URL garantisce che tutti i browser trasmetterà correttamente testo in stringhe URL. Caratteri, ad esempio un punto interrogativo (?), e commerciale (&), barra (/) di contrassegnare e spazi potrebbero essere troncati o danneggiati da alcuni browser. Di conseguenza, questi caratteri devono essere codificati `<a>` tag o in stringhe di query in cui le stringhe possono essere nuovamente inviate da un browser in una stringa di richiesta.  
  
 Questo metodo è un modo pratico per accedere la <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, questo metodo Usa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> per codificare le stringhe.  
  
 Nel file code-behind per una pagina web ASP.NET, accedere a un'istanza del <xref:System.Web.HttpServerUtility> classe tramite la `Server` proprietà. In una classe che non è in un file code-behind, usare `HttpContext.Current.Server` accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe.  
  
 Di fuori di un'applicazione web, usare il <xref:System.Net.WebUtility> classe per codificare o decodificare i valori.  
  
   
  
## Examples  
 L'esempio seguente illustra come codificare in URL di un valore che viene usato come valore di stringa di query di un collegamento ipertestuale. Il codice si trova nel file code-behind per una pagina web. Il valore per la codifica è hardcoded in questo esempio solo per semplificare l'esempio e visualizzare il tipo di valore che è possibile codificare in URL. In genere, è necessario codificare in URL un valore che è stato ricevuto dall'utente o la richiesta. `NextPage` fa riferimento a un `HyperLink` controllo.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 L'esempio seguente è simile all'esempio precedente ma viene illustrato come per la codifica URL in un valore dall'interno di una classe che non è nel file code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">The text string to encode.</param>
        <param name="output">The <see cref="T:System.IO.TextWriter" /> output stream that contains the encoded string.</param>
        <summary>URL-encodes a string and sends the resulting output to a <see cref="T:System.IO.TextWriter" /> output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codifica URL garantisce che tutti i browser trasmetterà correttamente testo in stringhe URL. Caratteri, ad esempio un punto interrogativo (?), e commerciale (&), barra (/) di contrassegnare e spazi potrebbero essere troncati o danneggiati da alcuni browser. Di conseguenza, questi caratteri devono essere codificati `<a>` tag o in stringhe di query in cui le stringhe possono essere nuovamente inviate da un browser in una stringa di richiesta.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> è un modo pratico per accedere la <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente <xref:System.Web.HttpServerUtility.UrlEncode%2A> Usa <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> per codificare le stringhe.  
  
 Per codificare o decodificare i valori di fuori di un'applicazione web, usare il <xref:System.Net.WebUtility> classe.  
  
   
  
## Examples  
 Nell'esempio seguente codifica una stringa per la trasmissione tramite HTTP. Consente di codificare la stringa `TestString`, che contiene il testo "questo è un \<stringa di Test >." e lo copia nella stringa denominata `EncodedString` come "This + è + a + 3cTest % + stringa % 3e.".  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlPathEncode : string -&gt; string" Usage="httpServerUtility.UrlPathEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The text to URL-encode.</param>
        <summary>Do not use; intended only for browser compatibility. Use <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>The URL encoded text.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenDecode : string -&gt; byte[]" Usage="System.Web.HttpServerUtility.UrlTokenDecode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">The URL string token to decode.</param>
        <summary>Decodes a URL string token to its equivalent byte array using base 64 digits.</summary>
        <returns>The byte array containing the decoded URL string token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> metodo converte un token di stringa URL, che codifica dati binari come cifre base 64, alla relativa rappresentazione di matrice di byte equivalente. Usare la <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> metodo da decodificare i token trasmessi nell'URL e la codifica di <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>.  
  
 Il <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> metodo restituirà una matrice di byte vuota se il `input` parametro ha una lunghezza di minore di 1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value of the <paramref name="input" /> parameter is <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenEncode : byte[] -&gt; string" Usage="System.Web.HttpServerUtility.UrlTokenEncode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="input">The byte array to encode.</param>
        <summary>Encodes a byte array into its equivalent string representation using base 64 digits, which is usable for transmission on the URL.</summary>
        <returns>The string containing the encoded token if the byte array *length* is greater than one; otherwise, an empty string ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> metodo converte una matrice di byte in una rappresentazione di stringa equivalente codificata con cifre base 64. Il token di stringa risultante può essere trasmesso nell'URL.  
  
 Il <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> restituirà una stringa vuota se il `input` parametro ha una lunghezza di minore di 1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value of the <paramref name="input" /> parameter is <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>