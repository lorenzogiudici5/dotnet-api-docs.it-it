<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="af79683dbebba2bc232c66a7a70dd0748a5935a9" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610765" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce metodi helper per l'elaborazione delle richieste Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I metodi e le proprietà di <xref:System.Web.HttpServerUtility> classe sono esposte tramite la funzione intrinseca <xref:System.Web.HttpContext.Server%2A> oggetto fornito da ASP.NET.  
  
   
  
## Examples  
 Un progetto di sito Web di Visual Studio con codice sorgente è disponibile a complemento di questo argomento: [scaricare](http://go.microsoft.com/fwlink/?LinkId=192870).  
  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Web.HttpServerUtility.HtmlEncode%2A> (metodo) e <xref:System.Web.HttpServerUtility.UrlEncode%2A> metodo la <xref:System.Web.HttpServerUtility> classe. Il <xref:System.Web.HttpServerUtility.HtmlEncode%2A> metodo assicura che qualsiasi stringa fornito dall'utente di input verrà eseguito il rendering come testo statico nei browser anziché eseguibile script o elementi HTML. Il <xref:System.Web.HttpServerUtility.UrlEncode%2A> metodo codifica URL in modo che vengano trasmessi correttamente nel flusso HTTP.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella l'eccezione precedente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene cancellata l'ultima eccezione generata.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'istanza server di un oggetto COM.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Classe o tipo di oggetto di cui creare un'istanza.</param>
        <summary>Crea un'istanza del server di un oggetto COM identificato dall'identificatore a livello di codice (ProgID) dell'oggetto.</summary>
        <returns>Nuovo oggetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente crea un oggetto tramite il ProgID dell'oggetto.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Non è stato possibile creare un'istanza dell'oggetto.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> che rappresenta l'oggetto da creare.</param>
        <summary>Crea un'istanza del server di un oggetto COM identificato dal tipo di oggetto.</summary>
        <returns>Nuovo oggetto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Identificatore di classe dell'oggetto di cui creare un'istanza.</param>
        <summary>Crea un'istanza del server di un oggetto COM identificato dall'identificatore di classe (CLSID) dell'oggetto.</summary>
        <returns>Nuovo oggetto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> metodo per creare un'istanza del server di un oggetto COM.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Non è stato possibile creare un'istanza dell'oggetto.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue il gestore per una risorsa specificata nel contesto della richiesta corrente e restituisce l'esecuzione alla pagina che lo ha richiamato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso URL da eseguire.</param>
        <summary>Esegue il gestore per il percorso virtuale specificato nel contesto della richiesta corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.Execute%2A> metodo continua l'esecuzione della pagina originale al termine dell'esecuzione della nuova pagina. Il <xref:System.Web.HttpServerUtility.Transfer%2A> incondizionatamente trasferisce l'esecuzione a un altro gestore.  
  
 ASP.NET non verifica che l'utente corrente è autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Execute%2A> metodo. Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguito prima che venga chiamato il gestore di risorse, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Execute%2A> (metodo) e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza dell'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzato.  
  
 È possibile forzare la nuova autorizzazione tramite il <xref:System.Web.HttpResponse.Redirect%2A> anziché il <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). <xref:System.Web.HttpResponse.Redirect%2A> esegue un reindirizzamento sul lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, è soggetto a in tutta la logica di autenticazione e autorizzazione di criteri di sicurezza di Internet Information Services (IIS) sia ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che utilizza il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Execute%2A> metodo.  
  
   
  
## Examples  
 L'esempio seguente mostra la pagina. aspx "Updateinfo" nella directory corrente. Esecuzione del programma torna alla pagina inizia dopo viene visualizzata la pagina Updateinfo.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'oggetto <see cref="T:System.Web.HttpContext" /> corrente è <see langword="null" />.  
  
 \- oppure -  
  
 Si è verificato un errore durante l'esecuzione del gestore specificato da <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.  
  
 \- oppure -  
  
 <paramref name="path" /> non è un percorso virtuale.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso URL da eseguire.</param>
        <param name="preserveForm">
          <see langword="true" /> per mantenere le raccolte <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />. <see langword="false" /> per cancellare le raccolte <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Esegue il gestore per il percorso specificato nel contesto della richiesta corrente e specifica se è necessario cancellare gli insiemi <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come eseguire la pagina aspx `Updateinfo.aspx` nella richiesta corrente e viene mantenuto il <xref:System.Web.HttpRequest.QueryString%2A> e <xref:System.Web.HttpRequest.Form%2A> raccolte. Esecuzione del programma torna alla pagina inizia dopo `Updateinfo.aspx` viene visualizzato.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'oggetto <see cref="T:System.Web.HttpContext" /> corrente è <see langword="null" />.  
  
 \- oppure -  
  
 Si è verificato un errore durante l'esecuzione del gestore specificato da <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.  
  
 \- oppure -  
  
 <paramref name="path" /> non è un percorso virtuale.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">Percorso URL da eseguire.</param>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> per acquisire l'output.</param>
        <summary>Esegue il gestore per il percorso virtuale specificato nel contesto della richiesta corrente. L'output del gestore eseguito viene acquisito dall'oggetto <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.Execute%2A> metodo continua l'esecuzione della richiesta originale al termine dell'esecuzione del percorso virtuale specificato. Il <xref:System.Web.HttpServerUtility.Transfer%2A> incondizionatamente trasferisce l'esecuzione a un altro gestore.  
  
 ASP.NET non verifica che l'utente corrente è autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Execute%2A> metodo. Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguito prima che venga chiamato il gestore di risorse, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Execute%2A> (metodo) e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza dell'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzato.  
  
 È possibile forzare la nuova autorizzazione tramite il <xref:System.Web.HttpResponse.Redirect%2A> anziché il <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). <xref:System.Web.HttpResponse.Redirect%2A> esegue un reindirizzamento sul lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, è soggetto a in tutta la logica di autenticazione e autorizzazione di criteri di sicurezza di Internet Information Services (IIS) sia ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che utilizza il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Execute%2A> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita la `Login.aspx` pagina sul server nella directory corrente e riceve l'output dalla pagina tramite il <xref:System.IO.StringWriter> oggetto `writer`. Scrive nel flusso HTML ricevuto da `writer` flusso di output per il protocollo HTTP.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'oggetto <see cref="T:System.Web.HttpContext" /> corrente è <see langword="null" />.  
  
 \- oppure -  
  
 Si è verificato un errore durante l'esecuzione del gestore specificato da <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.  
  
 \- oppure -  
  
 <paramref name="path" /> non è un percorso virtuale.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso URL da eseguire.</param>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> per acquisire l'output.</param>
        <param name="preserveForm">
          <see langword="true" /> per mantenere le raccolte <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />. <see langword="false" /> per cancellare le raccolte <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Esegue il gestore per il percorso virtuale specificato nel contesto della richiesta corrente. L'output della pagina viene acquisito dall'oggetto <see cref="T:System.IO.TextWriter" /> e un parametro booleano specifica se gli insiemi <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" /> devono essere cancellati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.Execute%2A> metodo continua l'esecuzione della richiesta originale al termine dell'esecuzione del percorso virtuale specificato. Il <xref:System.Web.HttpServerUtility.Transfer%2A> incondizionatamente trasferisce l'esecuzione a un altro gestore.  
  
 ASP.NET non verifica che l'utente corrente è autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Execute%2A> metodo. Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguito prima che venga chiamato il gestore di risorse, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Execute%2A> (metodo) e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza dell'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzato.  
  
 È possibile forzare la nuova autorizzazione tramite il <xref:System.Web.HttpResponse.Redirect%2A> anziché il <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). <xref:System.Web.HttpResponse.Redirect%2A> esegue un reindirizzamento sul lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, è soggetto a in tutta la logica di autenticazione e autorizzazione di criteri di sicurezza di Internet Information Services (IIS) sia ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che utilizza il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Execute%2A> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita la `Login.aspx` pagina sul server nella directory corrente e riceve l'output dalla pagina tramite il <xref:System.IO.StringWriter> oggetto `writer`. Scrive nel flusso HTML ricevuto da `writer` flusso di output per il protocollo HTTP. Il contenuto del <xref:System.Web.HttpRequest.Form%2A> e <xref:System.Web.HttpRequest.QueryString%2A> raccolte vengono mantenute.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La classe <see cref="T:System.Web.HttpContext" /> corrente è un riferimento null (<see langword="Nothing" /> in Visual Basic).  
  
 \- oppure -  
  
 <paramref name="path" /> termina con un punto (.).  
  
 \- oppure -  
  
 Si è verificato un errore durante l'esecuzione del gestore specificato da <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> non è un percorso virtuale.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">Gestore HTTP che implementa l'interfaccia <see cref="T:System.Web.IHttpHandler" /> alla quale trasferire la richiesta corrente.</param>
        <param name="writer">Oggetto <see cref="T:System.IO.TextWriter" /> per acquisire l'output.</param>
        <param name="preserveForm">
          <see langword="true" /> per mantenere le raccolte <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />. <see langword="false" /> per cancellare le raccolte <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Esegue il gestore per il percorso virtuale specificato nel contesto della richiesta corrente. L'output del gestore eseguito viene acquisito dall'oggetto <see cref="T:System.IO.TextWriter" /> e un parametro booleano specifica se gli insiemi <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" /> devono essere cancellati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile scrivere gestori HTTP personalizzati per elaborare i tipi predefiniti specifici di richieste HTTP in qualsiasi linguaggio compatibile con la lingua specifica CLS (Common). Il codice eseguibile definito nelle classi del gestore HTTP anziché le pagine ASP (noto anche come ASP classico) convenzionale o delle pagine ASP.NET risponde a queste richieste specifiche. I gestori HTTP consentono l'interazione con i servizi di risposta di un server Web che esegue Internet Information Services (IIS) e la richiesta di basso livello e forniscono funzionalità simili alle estensioni ISAPI ma con un modello di programmazione più semplice.  
  
 ASP.NET non verifica che l'utente corrente sia autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Execute%2A> metodo. Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguito prima che venga chiamato il gestore di risorse, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Execute%2A> (metodo) e non viene rieseguita la logica di autenticazione e autorizzazione per il nuova risorsa. Se i criteri di sicurezza per l'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzato.  
  
 È possibile forzare la nuova autorizzazione tramite il <xref:System.Web.HttpResponse.Redirect%2A> anziché il <xref:System.Web.HttpServerUtility.Execute%2A> (metodo). Il <xref:System.Web.HttpResponse.Redirect%2A> esegue un reindirizzamento sul lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, è soggetto a in tutta la logica di autenticazione e autorizzazione di criteri di sicurezza di IIS e ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che utilizza il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Execute%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Si è verificato un errore durante l'esecuzione del gestore specificato da <paramref name="handler" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="handler" /> è <see langword="null" />.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'eccezione precedente.</summary>
        <returns>Eccezione generata in precedenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente visualizza una descrizione dell'ultimo errore dell'applicazione nel flusso di output HTTP. Se non sono stati rilevati errori, viene visualizzato "No Errors".  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Consente di decodificare una stringa codificata per eliminare i caratteri HTML non validi.  
  
 Per codificare o decodificare i valori al di fuori di un'applicazione web, utilizzare la classe <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa HTML da decodificare.</param>
        <summary>Decodifica una stringa codificata in HTML e restituisce la stringa decodificata.</summary>
        <returns>Testo decodificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica HTML assicura che il testo viene visualizzato correttamente nel browser e non interpretato dal browser come HTML. Ad esempio, se una stringa di testo contiene un segno di minore di (\<) o maggiore al segno (>), questi caratteri vengono interpretati come l'apertura o la parentesi quadra di chiusura di un tag HTML dal browser. Quando i caratteri sono codificati in HTML, vengono convertiti in stringhe `&lt;` e `&gt;`, causando il browser visualizzare il segno di minore e maggiore correttamente minore. <xref:System.Web.HttpServerUtility.HtmlDecode%2A> decodifica il testo che è stato trasmesso al server.  
  
 Questo metodo è un modo pratico per accedere il <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, questo metodo utilizza <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> per decodificare stringhe.  
  
 Nel file code-behind per una pagina web ASP.NET, accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe tramite il `Server` proprietà. In una classe che non è in un file code-behind, utilizzare `HttpContext.Current.Server` per accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe.  
  
 Di fuori di un'applicazione web, utilizzare la <xref:System.Net.WebUtility> classe per codificare o decodificare i valori.  
  
   
  
## Examples  
 Nell'esempio seguente contiene la funzione `LoadDecodedFile`, che consente di decodificare i dati da un file e li copia in un'unica stringa.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Stringa HTML da decodificare.</param>
        <param name="output">Flusso di output <see cref="T:System.IO.TextWriter" /> contenente la stringa decodificata.</param>
        <summary>Consente di decodificare una stringa codificata HTML e di inviare l'output risultante al flusso di output di un oggetto <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica HTML assicura che il testo viene visualizzato correttamente nel browser e non interpretato dal browser come HTML. Ad esempio, se una stringa di testo contiene un segno di minore di (\<) o maggiore al segno (>), questi caratteri vengono interpretati come l'apertura o la parentesi quadra di chiusura di un tag HTML dal browser. Quando i caratteri sono codificati in HTML, vengono convertiti in stringhe `&lt;` e `&gt;`, causando il browser visualizzare il segno di minore e maggiore correttamente minore.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> decodifica il testo che è stato trasmesso al server.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> è un modo pratico per accedere il <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, <xref:System.Web.HttpServerUtility.HtmlDecode%2A> utilizza <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> per decodificare stringhe.  
  
 Per codificare o decodificare i valori al di fuori di un'applicazione web, utilizzare la classe <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 Nell'esempio seguente viene decodifica una stringa che è stata codificata in formato HTML per la trasmissione tramite HTTP. Consente di decodificare la stringa fornita denominata `EncodedString` che contiene il testo "questo è un &lt;stringa Test&gt;." e viene copiato nella stringa denominata `DecodedString` come "si tratta di un \<Test String >.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica una stringa da visualizzare in un browser.  
  
 Per codificare o decodificare i valori al di fuori di un'applicazione web, utilizzare la classe <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa di testo da codificare.</param>
        <summary>Codifica in HTML una stringa e restituisce la stringa codificata.</summary>
        <returns>Testo codificato in HTML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica HTML assicura che il testo viene visualizzato correttamente nel browser e non interpretato dal browser come HTML. Ad esempio, se una stringa di testo contiene un segno di minore di (\<) o maggiore al segno (>), questi caratteri vengono interpretati come l'apertura o la parentesi quadra di chiusura di un tag HTML dal browser. Quando i caratteri sono codificati in HTML, vengono convertiti in stringhe `&lt;` e `&gt;`, causando il browser visualizzare il segno di minore e maggiore correttamente minore.  
  
 Questo metodo è un modo pratico per accedere il <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, questo metodo utilizza <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> per codificare le stringhe.  
  
 Nel file code-behind per una pagina web ASP.NET, accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe tramite il `Server` proprietà. In una classe che non è in un file code-behind, utilizzare `HttpContext.Current.Server` per accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe.  
  
 Di fuori di un'applicazione web, utilizzare la <xref:System.Net.WebUtility> classe per codificare o decodificare i valori.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come per la codifica HTML un valore che potenzialmente codici codice unsafe. Il codice si trova nel file code-behind per una pagina web. Il valore per la codifica è a livello di codice in questo esempio solo per semplificare l'esempio e visualizzare il tipo di valore, che è possibile codificare in formato HTML. In genere, si farebbe codifica HTML valore ricevuto dall'utente o la richiesta. `Result` fa riferimento a un `Literal` controllo.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 Nell'esempio seguente è simile all'esempio precedente, ma viene illustrato come per la codifica HTML in un valore dall'interno di una classe che non sia il file code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Stringa da codificare.</param>
        <param name="output">Flusso di output <see cref="T:System.IO.TextWriter" /> contenente la stringa codificata.</param>
        <summary>Codifica in HTML una stringa e invia l'output risultante a un flusso di output di <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica HTML assicura che il testo verrà visualizzato correttamente nel browser, non è stato interpretato dal browser come HTML. Ad esempio, se una stringa di testo contiene un segno di minore di (\<) o maggiore al segno (>), questi caratteri vengono interpretati come una parentesi o parentesi quadra di chiusura di un tag HTML dal browser. La codifica HTML di questi due caratteri è `&lt;` e `&gt;`, rispettivamente, che fa sì che il browser visualizzare il segno di minore e maggiore correttamente minore.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> è un modo pratico per accedere il <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, <xref:System.Web.HttpServerUtility.HtmlEncode%2A> utilizza <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> per codificare le stringhe.  
  
 Per codificare o decodificare i valori al di fuori di un'applicazione web, utilizzare la classe <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 Nell'esempio seguente consente di codificare una stringa per la trasmissione tramite HTTP. Consente di codificare la stringa `TestString`, che contiene il testo "questo è un \<Test String >." e viene copiato nella stringa denominata `EncodedString` come "si tratta di un &lt;stringa Test&gt;.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce il nome del computer server.</summary>
        <value>Nome del computer locale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente archivia il nome del computer server come una variabile di stringa.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Impossibile trovare il nome del computer.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso virtuale nell'applicazione Web.</param>
        <summary>Restituisce il percorso fisico al file che corrisponde al percorso virtuale specificato.</summary>
        <returns>Percorso fisico del file nel server Web che corrisponde a <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `path` è `null`, <xref:System.Web.HttpServerUtility.MapPath%2A> il metodo restituisce il percorso fisico completo della directory che contiene la richiesta per il percorso corrente. Il percorso relativo non è necessario specificare un file esistente o una cartella per questo metodo restituire un valore. Tuttavia, è possibile specificare un percorso all'esterno dell'applicazione Web.  
  
> [!IMPORTANT]
>  Il <xref:System.Web.HttpServerUtility.MapPath%2A> metodo potenzialmente contiene informazioni riservate sull'ambiente di hosting. Il valore restituito non deve essere visibile agli utenti.  
  
 Un'applicazione Web che si trova in `C:\ExampleSites\TestMapPath` restituisce i risultati seguenti:  
  
|Richiesta da|`path`|Valore restituito|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|".. / OutsideApplication "|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come recuperare il file fisico di un percorso virtuale relativo. Il codice si trova nel file code-behind per una pagina web e utilizza il valore predefinito `Server` oggetto.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 Nell'esempio seguente è simile all'esempio precedente, ma viene illustrato come recuperare un percorso fisico dall'interno di una classe che non si trova il file code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'oggetto <see cref="T:System.Web.HttpContext" /> corrente è <see langword="null" />.
        
oppure 
        
<paramref name="path" /> è un percorso fisico, mentre è previsto un percorso virtuale.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene e imposta il valore di timeout della richiesta in secondi.</summary>
        <value>Impostazione del valore di timeout per le richieste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> proprietà può essere impostata nel file Web. config mediante l'impostazione di `executionTimeout` attributo dell'elemento. L'impostazione del timeout a livello di codice con il <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> proprietà ha la precedenza sull'impostazione Web. config.  
  
> [!NOTE]
>  Se si imposta la `debug` attributo dell'elemento da `true` nel file Web. config, il valore di <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> verrà ignorato.  
  
   
  
## Examples  
 Nell'esempio seguente imposta il periodo di timeout della richiesta su 60 secondi.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'oggetto <see cref="T:System.Web.HttpContext" /> corrente è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il periodo di timeout è <see langword="null" /> oppure non può essere impostato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Termina l'esecuzione della pagina corrente e inizia l'esecuzione di una nuova pagina per la richiesta corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso URL della nuova pagina sul server da eseguire.</param>
        <summary>Per la richiesta corrente, termina l'esecuzione della pagina corrente e avvia l'esecuzione di una nuova pagina usando il percorso URL di pagina specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La pagina trasferita deve essere un'altra pagina. aspx. Ad esempio, un trasferimento a una pagina ASP o ASMX non è valido. Il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo mantiene il <xref:System.Web.HttpRequest.QueryString%2A> e <xref:System.Web.HttpRequest.Form%2A> raccolte.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> chiamate <xref:System.Web.HttpResponse.End%2A>, che genera un <xref:System.Threading.ThreadAbortException> eccezione dopo il completamento.  
  
 ASP.NET non verifica che l'utente corrente è autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Transfer%2A> metodo. Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguito prima che venga chiamato il gestore di risorse, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo) e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza dell'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzato.  
  
 È possibile forzare la nuova autorizzazione tramite il <xref:System.Web.HttpResponse.Redirect%2A> anziché il <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Il <xref:System.Web.HttpResponse.Redirect%2A> metodo esegue un reindirizzamento sul lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, è soggetto a in tutta la logica di autenticazione e autorizzazione di criteri di sicurezza di Internet Information Services (IIS) sia ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che utilizza il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso URL della nuova pagina sul server da eseguire.</param>
        <param name="preserveForm">
          <see langword="true" /> per mantenere le raccolte <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />. <see langword="false" /> per cancellare le raccolte <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Termina l'esecuzione della pagina corrente e avvia l'esecuzione di una nuova pagina usando il percorso URL di pagina specificato. Consente di specificare se eliminare gli insiemi <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La pagina trasferita deve essere un'altra pagina. aspx. Ad esempio, un trasferimento a una pagina ASP o ASMX non è valido.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> chiamate <xref:System.Web.HttpResponse.End%2A>, che genera un <xref:System.Threading.ThreadAbortException> eccezione dopo il completamento.  
  
 Se si imposta la `preserveForm` parametro `true`, la pagina di destinazione saranno in grado di accedere allo stato di visualizzazione della pagina precedente utilizzando il <xref:System.Web.UI.Page.PreviousPage%2A> proprietà.  
  
 Per motivi di sicurezza, è necessario mantenere il `enableViewStateMac` attributo impostato su `true`. ASP.NET non verifica che l'utente corrente è autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Transfer%2A> metodo. Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguito prima che venga chiamato il gestore di risorse, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo) e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza dell'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzato.  
  
 È possibile forzare la nuova autorizzazione tramite il <xref:System.Web.HttpResponse.Redirect%2A> anziché il <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Il <xref:System.Web.HttpResponse.Redirect%2A> metodo esegue un reindirizzamento sul lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, è soggetto a in tutta la logica di autenticazione e autorizzazione di criteri di sicurezza di Internet Information Services (IIS) sia ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che utilizza il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita una nuova pagina nella stessa directory della pagina corrente.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">La richiesta della pagina corrente è un callback.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">Gestore HTTP che implementa l'interfaccia <see cref="T:System.Web.IHttpHandler" /> alla quale trasferire la richiesta corrente.</param>
        <param name="preserveForm">
          <see langword="true" /> per mantenere le raccolte <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />. <see langword="false" /> per cancellare le raccolte <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Termina l'esecuzione della pagina corrente e inizia l'esecuzione di una nuova richiesta tramite un gestore HTTP personalizzato che implementa l'interfaccia <see cref="T:System.Web.IHttpHandler" /> e specifica se gli insiemi <see cref="P:System.Web.HttpRequest.QueryString" /> e <see cref="P:System.Web.HttpRequest.Form" /> devono essere cancellati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile scrivere gestori HTTP personalizzati per elaborare i tipi predefiniti specifici di richieste HTTP in qualsiasi linguaggio compatibile con la lingua specifica CLS (Common). Il codice eseguibile definito nelle classi del gestore HTTP anziché le pagine ASP (noto anche come ASP classico) convenzionale o delle pagine ASP.NET risponde a queste richieste specifiche. I gestori HTTP consentono l'interazione con i servizi di risposta di un server Web che esegue Internet Information Services (IIS) e la richiesta di basso livello e forniscono funzionalità simili alle estensioni ISAPI ma con un modello di programmazione più semplice.  
  
 Se si imposta la `preserveForm` parametro `true`, la pagina di destinazione saranno in grado di accedere allo stato di visualizzazione della pagina precedente utilizzando il <xref:System.Web.UI.Page.PreviousPage%2A> proprietà.  
  
 Per motivi di sicurezza, è necessario mantenere il `enableViewStateMac` attributo impostato su `true`. ASP.NET non verifica che l'utente corrente è autorizzato a visualizzare la risorsa fornita dal <xref:System.Web.HttpServerUtility.Transfer%2A> metodo. Anche se la logica di autenticazione e autorizzazione ASP.NET viene eseguito prima che venga chiamato il gestore di risorse, ASP.NET chiama direttamente il gestore indicato dal <xref:System.Web.HttpServerUtility.Transfer%2A> metodo e non viene rieseguita la logica di autenticazione e autorizzazione per il nuovo risorsa. Se i criteri di sicurezza per l'applicazione richiedono che i client dispongano di autorizzazioni appropriate per accedere alla risorsa, l'applicazione deve essere forzata o forniscono un meccanismo di controllo di accesso personalizzato.  
  
 È possibile forzare la nuova autorizzazione tramite il <xref:System.Web.HttpResponse.Redirect%2A> anziché il <xref:System.Web.HttpServerUtility.Transfer%2A> (metodo). Il <xref:System.Web.HttpResponse.Redirect%2A> metodo esegue un reindirizzamento sul lato client in cui il browser richiede la nuova risorsa. Poiché questo reindirizzamento è una nuova richiesta in ingresso nel sistema, è soggetto a in tutta la logica di autenticazione e autorizzazione di criteri di sicurezza di IIS e ASP.NET.  
  
 È possibile verificare che l'utente disponga dell'autorizzazione per visualizzare la risorsa incorporando un metodo di autorizzazione personalizzato che utilizza il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo prima l'applicazione chiama il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">La richiesta della pagina corrente è un callback.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un'esecuzione asincrona dell'URL specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> è stato introdotto in .NET Framework versione 3.5. Per informazioni di riepilogo relative a .NET Framework, vedere [versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso URL della nuova pagina sul server da eseguire.</param>
        <summary>Esegue un'esecuzione asincrona dell'URL specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Overload di questo metodo chiama il <xref:System.Web.HttpServerUtility.TransferRequest%2A> overload con il `preserveForm` parametro impostato su `false`, `method` parametro impostato su `null`, il `headers` parametro impostato su `null`e `preserveUser` parametro impostato su `true`. Per ulteriori informazioni, vedere la sezione "Osservazioni" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> rapporto di overload.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Per la richiesta è necessaria la modalità pipeline integrata di [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Il server non è disponibile per gestire la richiesta.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso URL della nuova pagina sul server da eseguire.</param>
        <param name="preserveForm">
          <see langword="true" /> per conservare la raccolta <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> per cancellare la raccolta <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Esegue un'esecuzione asincrona dell'URL specificato e mantiene i parametri della stringa di query.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload chiama il <xref:System.Web.HttpServerUtility.TransferRequest%2A> overload con il `preserveForm` parametro impostato sul valore passato, il `method` parametro impostato su `null`, `headers` parametro impostato su `null`e il `preserveUser` set di parametri per `true`. Per ulteriori informazioni, vedere la sezione "Osservazioni" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> è stato introdotto in .NET Framework versione 3.5.  Per altre informazioni, vedere [Versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Per la richiesta è necessaria la modalità pipeline integrata di [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Il server non è disponibile per gestire la richiesta.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">Percorso URL della nuova pagina sul server da eseguire.</param>
        <param name="preserveForm">
          <see langword="true" /> per conservare la raccolta <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> per cancellare la raccolta <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <param name="method">Metodo HTTP da usare nell'esecuzione della nuova richiesta.</param>
        <param name="headers">
          <see cref="T:System.Collections.Specialized.NameValueCollection" /> di intestazioni delle richieste per la nuova richiesta.</param>
        <summary>Esegue un'esecuzione asincrona dell'URL specificato usando il metodo e le intestazioni HTTP specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato durante l'esecuzione con la modalità pipeline integrata in [!INCLUDE[iisver](~/includes/iisver-md.md)] per consentire l'elaborazione della richiesta essere trasferito da un tipo di risorsa a un altro durante l'esecuzione della richiesta di destinazione con il contesto di richiesta corretto. Ad esempio, è possibile utilizzare il <xref:System.Web.HttpServerUtility.TransferRequest%2A> metodo per trasferire una richiesta per una pagina ASPX a una richiesta per una pagina XML.  
  
 Il <xref:System.Web.HttpServerUtility.TransferRequest%2A> metodo esegue un'esecuzione figlio asincrona dell'URL specificato con le condizioni seguenti:  
  
-   Se il `path` parametro specifica una stringa di query, verrà considerato come la nuova stringa di query. Se nessuna stringa di query è inclusa, la stringa di query della richiesta sarà utilizzata nuovamente.  
  
-   Se il `method` viene specificato, verrà utilizzato. Se è `null`, verrà utilizzato il metodo HTTP della richiesta originale.  
  
-   Se il `preserveForm` parametro `true`, il corpo dell'entità corrente della richiesta sarà disponibile per la richiesta di destinazione. In questo modo gli invii di form e carica per essere trasferita.  
  
-   Se l'identità dell'utente è attualmente impostata nella richiesta originale, l'identità verrà trasferito alla nuova richiesta. In questo modo le richieste autenticate di riutilizzare il risultato dell'autenticazione per la nuova richiesta. Se non si desidera che l'utente da trasferire, impostare l'utente `null` nella richiesta originale prima del trasferimento.  
  
-   Se il `headers` viene specificato, la nuova richiesta verrà eseguita con le intestazioni specificate. Questo può essere utilizzato per modificare le intestazioni di richiesta e i cookie per la nuova richiesta o aggiunta un'intestazione speciale che specifica in cui è stata ricevuta la richiesta originale.  
  
     Questo metodo chiama il <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> overload del metodo con il `preserveUser` parametro impostato su `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Per la richiesta è necessario che [!INCLUDE[iisver](~/includes/iisver-md.md)] sia in esecuzione in modalità integrata.</exception>
        <exception cref="T:System.Web.HttpException">Il server non è disponibile per gestire la richiesta.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="preserveUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Percorso.</param>
        <param name="preserveForm">
          <see langword="true" /> per conservare la raccolta <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> per cancellare la raccolta <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <param name="method">Metodo HTTP da usare nella nuova richiesta.</param>
        <param name="headers">Oggetto <see cref="T:System.Collections.Specialized.NameValueCollection" /> che contiene le intestazioni di richiesta per le nuove richieste.</param>
        <param name="preserveUser">
          <see langword="true" /> per mantenere l'identità dell'utente; in caso contrario, <see langword="false" />. Gli altri overload di questo metodo chiamano questo overload con il parametro impostato su <see langword="true" />.</param>
        <summary>Esegue un'esecuzione asincrona dell'URL specificato usando il metodo HTTP, le intestazioni e il percorso specificati e, facoltativamente, mantiene i valori del form e l'identità dell'utente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere la sezione "Osservazioni" in <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Per la richiesta è necessaria la modalità pipeline integrata di [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Il server non è disponibile per gestire la richiesta.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="path" /> non è valido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodifica una stringa codificata per la trasmissione HTTP e inviata al server in un URL.  
  
 Per codificare o decodificare i valori al di fuori di un'applicazione web, utilizzare la classe <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa di testo da decodificare.</param>
        <summary>Decodifica una stringa in URL e restituisce la stringa decodificata.</summary>
        <returns>Testo decodificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica URL assicura che tutti i browser verranno trasmesso correttamente il testo nelle stringhe URL. Caratteri, ad esempio un punto interrogativo (?), e commerciale (&), barra (/) di contrassegnare e spazi potrebbero essere troncati o danneggiati da alcuni browser. Di conseguenza, questi caratteri devono essere codificati `<a>` tag o in stringhe di query in cui le stringhe possono essere nuovamente inviate in una stringa di richiesta da un browser.  
  
 Questo metodo è un modo pratico per accedere il <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, questo metodo utilizza <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> per decodificare stringhe.  
  
 Nel file code-behind per una pagina web ASP.NET, accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe tramite il `Server` proprietà. In una classe che non è in un file code-behind, utilizzare `HttpContext.Current.Server` per accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe.  
  
 Di fuori di un'applicazione web, utilizzare la <xref:System.Net.WebUtility> classe per codificare o decodificare i valori.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come decodificare URL di un valore che viene recuperato dalla stringa di query. Il codice si trova nel file code-behind per una pagina web. `ReturnPage` fa riferimento a un `HyperLink` controllo.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 Nell'esempio seguente è simile all'esempio precedente, ma viene illustrato come decodificare URL valore all'interno di una classe che non sia il file code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Stringa HTML da decodificare.</param>
        <param name="output">Flusso di output <see cref="T:System.IO.TextWriter" /> contenente la stringa decodificata.</param>
        <summary>Consente di decodificare una stringa HTML ricevuta in un URL e di inviare l'output risultante a un flusso di output di <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica URL assicura che tutti i browser verranno trasmesso correttamente il testo nelle stringhe URL. Caratteri, ad esempio un punto interrogativo (?), e commerciale (&), barra (/) di contrassegnare e spazi potrebbero essere troncati o danneggiati da alcuni browser. Di conseguenza, questi caratteri devono essere codificati `<a>` tag o in stringhe di query in cui le stringhe possono essere nuovamente inviate in una stringa di richiesta da un browser.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> è un modo pratico per accedere il <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, <xref:System.Web.HttpServerUtility.UrlDecode%2A> utilizza <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> per decodificare stringhe.  
  
 Per codificare o decodificare i valori al di fuori di un'applicazione web, utilizzare la classe <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 Nell'esempio seguente consente di decodificare la stringa `EncodedString` (ricevuti in un URL) nella stringa denominata `DecodedString`.  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica una stringa per una trasmissione HTTP affidabile dal server Web a un client tramite l'URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> è un modo pratico per accedere il <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, <xref:System.Web.HttpServerUtility.UrlEncode%2A> utilizza <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> per codificare le stringhe.  
  
 Per codificare o decodificare i valori al di fuori di un'applicazione web, utilizzare la classe <xref:System.Net.WebUtility>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Testo da codificare in URL.</param>
        <summary>Codifica una stringa in URL e restituisce la stringa codificata.</summary>
        <returns>Testo codificato in URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica URL assicura che tutti i browser verranno trasmesso correttamente il testo nelle stringhe URL. Caratteri, ad esempio un punto interrogativo (?), e commerciale (&), barra (/) di contrassegnare e spazi potrebbero essere troncati o danneggiati da alcuni browser. Di conseguenza, questi caratteri devono essere codificati `<a>` tag o in stringhe di query in cui le stringhe possono essere nuovamente inviate in una stringa di richiesta da un browser.  
  
 Questo metodo è un modo pratico per accedere il <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, questo metodo utilizza <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> per codificare le stringhe.  
  
 Nel file code-behind per una pagina web ASP.NET, accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe tramite il `Server` proprietà. In una classe che non è in un file code-behind, utilizzare `HttpContext.Current.Server` per accedere a un'istanza di <xref:System.Web.HttpServerUtility> classe.  
  
 Di fuori di un'applicazione web, utilizzare la <xref:System.Net.WebUtility> classe per codificare o decodificare i valori.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come codificare in URL di un valore che viene utilizzato come valore di stringa di query di un collegamento ipertestuale. Il codice si trova nel file code-behind per una pagina web. Il valore per la codifica è a livello di codice in questo esempio solo per semplificare l'esempio e visualizzare il tipo di valore, che è possibile applicare la codifica URL. In genere, si farebbe URL codifica un valore ricevuto dall'utente o la richiesta. `NextPage` fa riferimento a un `HyperLink` controllo.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 Nell'esempio seguente è simile all'esempio precedente, ma viene illustrato come per la codifica URL in un valore dall'interno di una classe che non sia il file code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Stringa di testo da codificare.</param>
        <param name="output">Flusso di output <see cref="T:System.IO.TextWriter" /> contenente la stringa codificata.</param>
        <summary>Consente di codificare in URL una stringa e di inviare l'output risultante a un flusso di output di <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codifica URL assicura che tutti i browser verranno trasmesso correttamente il testo nelle stringhe URL. Caratteri, ad esempio un punto interrogativo (?), e commerciale (&), barra (/) di contrassegnare e spazi potrebbero essere troncati o danneggiati da alcuni browser. Di conseguenza, questi caratteri devono essere codificati `<a>` tag o in stringhe di query in cui le stringhe possono essere nuovamente inviate in una stringa di richiesta da un browser.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> è un modo pratico per accedere il <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> metodo in fase di esecuzione da un'applicazione ASP.NET. Internamente, <xref:System.Web.HttpServerUtility.UrlEncode%2A> utilizza <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> per codificare le stringhe.  
  
 Per codificare o decodificare i valori al di fuori di un'applicazione web, utilizzare la classe <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 Nell'esempio seguente consente di codificare una stringa per la trasmissione tramite HTTP. Consente di codificare la stringa `TestString`, che contiene il testo "questo è un \<Test String >." e viene copiato nella stringa denominata `EncodedString` come "This + è + a + % 3cTest + String % 3e.".  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Testo da codificare in URL.</param>
        <summary>Non usare. Progettato solo per compatibilità browser. Usare <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>Testo codificato in URL.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Token di stringa URL da decodificare.</param>
        <summary>Decodifica il token di una stringa URL nella relativa matrice di byte equivalente usando cifre Base64.</summary>
        <returns>Matrice di byte contenente il token di stringa URL decodificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> metodo converte un token di stringa URL, che codifica dati binari come cifre base 64, nella relativa rappresentazione di matrice di byte equivalente. Utilizzare il <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> metodo per decodificare i token trasmessi nell'URL e codificati tramite la <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>.  
  
 Il <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> metodo restituirà una matrice di byte vuota se il `input` parametro ha una lunghezza minore di 1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="input" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="input">Matrice di byte da codificare.</param>
        <summary>Codifica una matrice di byte nella rappresentazione di stringa equivalente con cifre Base64, indicate per la trasmissione nell'URL.</summary>
        <returns>Stringa contenente il token codificato se il parametro *length* della matrice di byte è maggiore di uno; in caso contrario, una stringa vuota ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> metodo converte una matrice di byte in una rappresentazione di stringa equivalente codificata con cifre base 64. Il token di stringa risultante può essere trasmesso nell'URL.  
  
 Il <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> restituirà una stringa vuota se il `input` parametro ha una lunghezza minore di 1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="input" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>