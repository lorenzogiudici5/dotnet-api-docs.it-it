<Type Name="IsolatedStorageFileStream" FullName="System.IO.IsolatedStorage.IsolatedStorageFileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8eb05ccb12109231f5298b1737311d1a391259c9" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420475" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class IsolatedStorageFileStream : System.IO.FileStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit IsolatedStorageFileStream extends System.IO.FileStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class IsolatedStorageFileStream&#xA;Inherits FileStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class IsolatedStorageFileStream : System::IO::FileStream" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Espone un file all'interno dello spazio di memorizzazione isolato.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa classe per leggere, scrivere e creare i file nell'archiviazione isolata.  
  
 Poiché questa classe estende <xref:System.IO.FileStream>, è possibile utilizzare un'istanza di <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> nella maggior parte dei casi in cui un <xref:System.IO.FileStream> potrebbero essere utilizzate in caso contrario, ad esempio per costruire un <xref:System.IO.StreamReader> o <xref:System.IO.StreamWriter>.  
  
 Questo tipo implementa il <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
> [!IMPORTANT]
>  Lo spazio di memorizzazione isolato non è disponibile per le applicazioni [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] . Al contrario, utilizzare le classi di dati dell'applicazione negli spazi dei nomi `Windows.Storage` inclusi nell'API [!INCLUDE[wrt](~/includes/wrt-md.md)] per archiviare dati e file locali. Per altre informazioni, vedere [Dati dell'applicazione](http://go.microsoft.com/fwlink/?LinkId=229175) nel Centro per sviluppatori Windows.  
  
   
  
## Examples  
 L'applicazione console seguente viene illustrato come utilizzare <xref:System.IO.IsolatedStorage.IsolatedStorageFile> e <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> per scrivere dati in un file di memorizzazione isolato. L'utente viene richiesto di accedere. Se l'utente è un nuovo utente, un URL di News e un URL sportivi vengono registrate come le preferenze personali nell'archiviazione isolata. Se l'utente ha effettuato l'accesso, le preferenze dell'utente corrente. Gli esempi di codice utilizzati in questo spazio dei nomi vengono presentati nel contesto di questa applicazione di esempio. È possibile utilizzare il [Storeadm.exe (strumento di memorizzazione isolato)](~/docs/framework/tools/storeadm-exe-isolated-storage-tool.md) utilità per elencare e rimuovere i file di memorizzazione isolato che vengono creati con questa applicazione console.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#1)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#1)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />. È possibile aprire un oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> soltanto mediante uno dei suoi costruttori.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo del file all'interno dello spazio di memorizzazione isolato.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.IO.FileMode" />.</param>
        <summary>Inizializza una nuova istanza di un oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dando accesso al file designato da <paramref name="path" /> nella modalità (<paramref name="mode" />) specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'archivio isolato che viene utilizzato l'ambito è dall'identità dell'assembly in esecuzione corrente e quello del dominio di applicazione in cui è in esecuzione. Questo archivio rimarrà aperto solo per la durata del <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto. Per specificare un ambito diverso di memorizzazione isolato, o per consentire all'archivio di rimanere aperti (in modo più <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> gli oggetti possono essere aperti da esso), utilizzare la forma del costruttore che accetta un <xref:System.IO.IsolatedStorage.IsolatedStorageFile> oggetto.  
  
 Il `mode` parametro indica se è necessario creare un nuovo file, usata uno esistente e così via.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e possono causare un'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato di <paramref name="path" /> non è corretto.</exception>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La directory in <paramref name="path" /> non esiste.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è stato trovato alcun file e <paramref name="mode" /> è impostato su <see cref="F:System.IO.FileMode.Open" /></exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">per l'accesso all'archiviazione isolata</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo del file all'interno dello spazio di memorizzazione isolato.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinazione bit per bit dei valori di <see cref="T:System.IO.FileAccess" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dando accesso al file designato da <paramref name="path" /> nella modalità (<paramref name="mode" />) specificata, con il tipo di accesso (<paramref name="access" />) richiesto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'archivio isolato che viene utilizzato l'ambito è dall'identità dell'assembly in esecuzione corrente e quello del dominio di applicazione in cui è in esecuzione. Questo archivio rimarrà aperto solo per la durata del <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto. Per specificare un ambito diverso di memorizzazione isolato, o per consentire all'archivio di rimanere aperti (in modo più <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> gli oggetti possono essere aperti da esso), utilizzare la forma del costruttore che accetta un <xref:System.IO.IsolatedStorage.IsolatedStorageFile> oggetto.  
  
 Il `mode` parametro indica se è necessario creare un nuovo file o utilizzarne uno esistente. Il `access` parametro include di sola lettura, lettura/scrittura, lettura e scrittura.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e possono provocare un'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato di <paramref name="path" /> non è corretto.</exception>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è stato trovato alcun file e <paramref name="mode" /> è impostato su <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">per l'accesso all'archiviazione isolata</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo del file all'interno dello spazio di memorizzazione isolato.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.IO.FileMode" />.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> in cui aprire l'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dando accesso al file designato da <paramref name="path" /> nella modalità (<paramref name="mode" />) specificata e nel contesto dell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> specificato da <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `mode` parametro indica se è necessario creare un nuovo file, usata uno esistente e così via.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e possono provocare un'eccezione generata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del costruttore. Per il contesto completo di questo esempio, vedere il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Panoramica.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato di <paramref name="path" /> non è corretto.</exception>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è stato trovato alcun file e <paramref name="mode" /> è impostato su <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          Non sono disponibili quote per <paramref name="isf" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">per l'accesso all'archiviazione isolata</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo del file all'interno dello spazio di memorizzazione isolato.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinazione bit per bit dei valori di <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Combinazione bit per bit dei valori di <see cref="T:System.IO.FileShare" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dando accesso al file designato da <paramref name="path" /> nella modalità (<paramref name="mode" />) specificata, con l'accesso (<paramref name="access" />) specificato al file, usando la modalità di condivisione file specificata da <paramref name="share" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'archivio isolato che viene utilizzato l'ambito è dall'identità dell'assembly in esecuzione corrente e quello del dominio di applicazione in cui è in esecuzione. Questo archivio rimarrà aperto solo per la durata del <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto. Per specificare un ambito diverso di memorizzazione isolato, o per consentire all'archivio di rimanere aperti (in modo più <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> gli oggetti possono essere aperti da esso), utilizzare la forma del costruttore che accetta un <xref:System.IO.IsolatedStorage.IsolatedStorageFile> oggetto.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e possono causare un'eccezione generata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del costruttore. Per il contesto completo di questo esempio, vedere il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Panoramica.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#15)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#15)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato di <paramref name="path" /> non è corretto.</exception>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è stato trovato alcun file e <paramref name="mode" /> è impostato su <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">per l'accesso all'archiviazione isolata</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo del file all'interno dello spazio di memorizzazione isolato.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinazione bit per bit dei valori di <see cref="T:System.IO.FileAccess" />.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> in cui aprire l'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dando accesso al file designato da <paramref name="path" /> nella modalità (<paramref name="mode" />) specificata, con l'accesso (<paramref name="access" />) specificato e nel contesto dell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> specificato da <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `mode` parametro indica se è necessario creare un nuovo file o utilizzarne uno esistente. Il `access` parametro include di sola lettura, lettura/scrittura, lettura e scrittura.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e possono provocare un'eccezione generata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del costruttore. Per il contesto completo di questo esempio, vedere il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Panoramica.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato di <paramref name="path" /> non è corretto.</exception>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'archivio isolato è chiuso.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è stato trovato alcun file e <paramref name="mode" /> è impostato su <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          Non sono disponibili quote per <paramref name="isf" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">per l'accesso all'archiviazione isolata</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo del file all'interno dello spazio di memorizzazione isolato.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinazione bit per bit dei valori di <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Combinazione bit per bit dei valori di <see cref="T:System.IO.FileShare" />.</param>
        <param name="bufferSize">Dimensioni del buffer <see cref="T:System.IO.FileStream" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dando accesso al file designato da <paramref name="path" /> nella modalità (<paramref name="mode" />) specificata, con l'accesso (<paramref name="access" />) al file specificato, usando la modalità di condivisione file specificata da <paramref name="share" />, con la dimensione buffer (<paramref name="buffersize" />) specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'archivio isolato che viene utilizzato l'ambito è dall'identità dell'assembly in esecuzione corrente e quello del dominio di applicazione in cui è in esecuzione. Questo archivio rimarrà aperto solo per la durata del <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto. Per specificare un ambito diverso di memorizzazione isolato, o per consentire all'archivio di rimanere aperti (in modo più <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> gli oggetti possono essere aperti da esso), utilizzare la forma del costruttore che accetta un <xref:System.IO.IsolatedStorage.IsolatedStorageFile> oggetto.  
  
 Il `mode` parametro indica se è necessario creare un nuovo file o utilizzarne uno esistente. Il `access` parametro include di sola lettura, lettura/scrittura, lettura e scrittura.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e possono provocare un'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato di <paramref name="path" /> non è corretto.</exception>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è stato trovato alcun file e <paramref name="mode" /> è impostato su <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">per l'accesso all'archiviazione isolata</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo del file all'interno dello spazio di memorizzazione isolato.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinazione bit per bit dei valori di <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Combinazione bit per bit dei valori di <see cref="T:System.IO.FileShare" />.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> in cui aprire l'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dando accesso al file designato da <paramref name="path" /> nella modalità (<paramref name="mode" />) specificata, con l'accesso (<paramref name="access" />) al file specificato, usando la modalità di condivisione file specificata da <paramref name="share" /> e nel contesto dell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> specificato da <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `mode` parametro indica se è necessario creare un nuovo file o utilizzarne uno esistente. Il `access` parametro include di sola lettura, lettura/scrittura, lettura e scrittura.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e possono provocare un'eccezione generata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del costruttore. Per il contesto completo di questo esempio, vedere il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Panoramica.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato di <paramref name="path" /> non è corretto.</exception>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è stato trovato alcun file e <paramref name="mode" /> è impostato su <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          Non sono disponibili quote per <paramref name="isf" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">per l'accesso all'archiviazione isolata</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Percorso relativo del file all'interno dello spazio di memorizzazione isolato.</param>
        <param name="mode">Uno dei valori di <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinazione bit per bit dei valori di <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Combinazione bit per bit dei valori di <see cref="T:System.IO.FileShare" />.</param>
        <param name="bufferSize">Dimensioni del buffer <see cref="T:System.IO.FileStream" />.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> in cui aprire l'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dando accesso al file designato da <paramref name="path" /> nella modalità (<paramref name="mode" />) specificata, con l'accesso (<paramref name="access" />) al file specificato, usando la modalità di condivisione file specificata da <paramref name="share" />, con le dimensioni del buffer (<paramref name="buffersize" />) specificate e nel contesto dell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> specificato da <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `mode` parametro indica se è necessario creare un nuovo file o utilizzarne uno esistente. Il `access` parametro include di sola lettura, lettura/scrittura, lettura e scrittura.  
  
> [!CAUTION]
>  Quando si esegue la compilazione di un set di caratteri con una lingua specifica e recuperano gli stessi caratteri con una lingua diversa, i caratteri potrebbero non essere interpretati e possono provocare un'eccezione generata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del costruttore. Per il contesto completo di questo esempio, vedere il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Panoramica.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#12)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#12)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il formato di <paramref name="path" /> non è corretto.</exception>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="path" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Non è stato trovato alcun file e <paramref name="mode" /> è impostato su <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          Non sono disponibili quote per <paramref name="isf" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">per l'accesso all'archiviazione isolata</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer in cui leggere i dati.</param>
        <param name="offset">Offset dei byte in <c>buffer</c> in corrispondenza del quale iniziare la lettura.</param>
        <param name="numBytes">Numero massimo di byte da leggere.</param>
        <param name="userCallback">Metodo da chiamare quando l'operazione di lettura asincrona viene completata. Questo parametro è facoltativo.</param>
        <param name="stateObject">Stato della lettura asincrona.</param>
        <summary>Inizia una lettura asincrona.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che rappresenta la lettura asincrona, che probabilmente è ancora in sospeso. Per determinare il numero di byte letti, è necessario passare questo oggetto <see cref="T:System.IAsyncResult" /> al metodo <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" /> di questo flusso. È possibile eseguire questa operazione tramite lo stesso codice che ha chiamato <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> o in un callback passato a <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La posizione corrente nel flusso viene aggiornata quando si esegue la lettura o scrittura asincrona, non al completamento dell'operazione dei / o.  
  
 È necessario chiamare <xref:System.IO.Stream.EndRead%2A> con questo <xref:System.IAsyncResult> per verificare il numero di byte letti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è provato a eseguire la lettura asincrona oltre la fine del file.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer in cui scrivere i dati.</param>
        <param name="offset">Offset dei byte in <c>buffer</c> in corrispondenza del quale iniziare la scrittura.</param>
        <param name="numBytes">Numero massimo di byte da scrivere.</param>
        <param name="userCallback">Metodo da chiamare quando l'operazione di scrittura asincrona viene completata. Questo parametro è facoltativo.</param>
        <param name="stateObject">Stato della scrittura asincrona.</param>
        <summary>Inizia una scrittura asincrona.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> che rappresenta la scrittura asincrona, che probabilmente è ancora in sospeso. È necessario passare questo oggetto <see cref="T:System.IAsyncResult" /> al metodo <see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" /> del flusso per assicurarsi che la scrittura venga completata e le risorse liberate in modo corretto. È possibile eseguire questa operazione tramite lo stesso codice che ha chiamato <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> o in un callback passato a <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto sia accessibile in scrittura, il flusso di scrittura alla fine del flusso espande.  
  
 La posizione corrente nel flusso viene aggiornata quando si esegue la lettura o scrittura asincrona, non al completamento dell'operazione dei / o.  
  
 È necessario chiamare <xref:System.IO.Stream.EndWrite%2A> con il <xref:System.IAsyncResult> oggetto restituito da questo metodo per determinare il numero di byte scritti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è provato a eseguire la scrittura asincrona oltre la fine del file.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore booleano che indica se è possibile leggere il file.</summary>
        <value>
          <see langword="true" /> se è possibile leggere un oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà per determinare se il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto può essere letti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come è possibile usare il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead%2A> proprietà, come un controllo per verificare se è possibile leggere un flusso prima di chiamare il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> metodi. Per il contesto completo di questo esempio, vedere il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Panoramica.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore booleano che indica se le operazioni di ricerca sono supportate.</summary>
        <value>
          <see langword="true" /> se un oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> supporta le operazioni di ricerca; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà per determinare se il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto supporta le operazioni di ricerca.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore booleano che indica se è possibile scrivere nel file.</summary>
        <value>
          <see langword="true" /> se è possibile scrivere in un oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà per determinare se il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto può essere scritti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come è possibile usare il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite%2A> proprietà, come un controllo per verificare se è possibile leggere un flusso prima di chiamare il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write%2A> o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A> metodi. Per il contesto completo di questo esempio, vedere il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Panoramica.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#13)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#13)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal metodo pubblico <xref:System.IDisposable.Dispose%2A> (metodo) e <xref:System.Object.Finalize%2A> metodo. <xref:System.IDisposable.Dispose%2A> richiama il metodo protetto <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> metodo con il `disposing` parametro impostato su true. <xref:System.Object.Finalize%2A> richiama <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> con `disposing` impostato su false.  
  
 Quando il `disposing` parametro è true, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti da questo <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> riferimenti. Il metodo richiama il metodo <xref:System.IDisposable.Dispose%2A> di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            Il metodo <see cref="M:System.IDisposable.Dispose" /> può essere chiamato più volte da altri oggetti. In caso di override di <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, non fare riferimento a oggetti già eliminati in una chiamata precedente a <see cref="M:System.IDisposable.Dispose" />. Per ulteriori informazioni su come implementare <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Per ulteriori informazioni su <see cref="M:System.IDisposable.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">La richiesta asincrona in sospeso.</param>
        <summary>Termina una richiesta di lettura asincrona in sospeso.</summary>
        <returns>Numero di byte letti dal flusso, compreso tra 0 e il numero di byte richiesto. I flussi restituiranno zero solo alla fine del flusso, altrimenti verranno bloccati finché non sia disponibile almeno un byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> oggetto <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>e la chiamata <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> è l'unico modo per conoscere il numero di byte letti dal <xref:System.IO.Stream>. <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> verrà bloccata finché non viene completata l'operazione dei / o.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <paramref name="asyncResult" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Richiesta di I/O asincrona in sospeso da terminare.</param>
        <summary>Termina una scrittura asincrona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> deve essere chiamato esattamente una volta per ogni <xref:System.IAsyncResult> da <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> verrà bloccata finché non viene completata l'operazione dei / o.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="asyncResult" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cancella i buffer del flusso e fa sì che i dati memorizzati nel buffer vengano scritti nel file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancella i buffer del flusso e fa sì che i dati memorizzati nel buffer vengano scritti nel file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché un buffer può essere utilizzato per la lettura o scrittura, ma non entrambi contemporaneamente, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%2A> svolge due funzioni. Innanzitutto, tutti i dati scritti in precedenza per il buffer viene copiati il file e il buffer è deselezionato. Quindi, se <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> è `true` e dati sono stati copiati in precedenza dal file nel buffer per la lettura, la posizione corrente all'interno del file viene applicata il numero di byte letti nel buffer. Il buffer viene quindi cancellato.  
  
 Utilizzare il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29> overload del metodo quando si desidera assicurarsi che tutti i dati memorizzati nel buffer di file intermedi vengono scritti su disco.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush(bool flushToDisk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> per svuotare tutti i buffer di file intermedi; in caso contrario, <see langword="false" />.</param>
        <summary>Cancella i buffer del flusso e fa sì che i dati memorizzati nei buffer vengano scritti nel file, cancellando anche tutti i buffer di file intermedi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload quando si desidera assicurarsi che tutti i dati memorizzati nel buffer di file intermedi sia scritti su disco.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public override IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle - once available")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle di file relativo al file incapsulato dall'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> corrente. Poiché l'accesso a questa proprietà non è consentito su un oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />, viene generata un'eccezione <see cref="T:System.IO.IsolatedStorage.IsolatedStorageException" />.</summary>
        <value>Handle di file relativo al file incapsulato dall'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere <xref:System.IO.FileStream.Handle%2A>.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle%2A> proprietà.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#4)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#4)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">La proprietà <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" /> genera sempre questa eccezione.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public override bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore booleano che indica se l'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> è stato aperto in modo sincrono o asincrono.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> supporta l'accesso asincrono; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrona <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> non è possibile creare oggetti, a differenza <xref:System.IO.FileStream>. Tuttavia, il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>, e <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> i metodi sono supportati nelle istanze sincrone, con alcuni effetti negativi sulle prestazioni.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync%2A> proprietà per verificare che un <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> è sincrono. Per il contesto completo di questo esempio, vedere il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Panoramica.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#7)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#7)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la lunghezza dell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</summary>
        <value>Lunghezza dell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> espressa in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> rappresenta il numero di byte attualmente presenti nel file. Non è interessato dalla quota di spazio di memorizzazione isolato.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> proprietà.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public override void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Lock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Posizione iniziale dell'intervallo da bloccare. Il valore di questo parametro deve essere uguale o maggiore di zero (0).</param>
        <param name="length">Numero di byte da bloccare.</param>
        <summary>Impedisce ad altri processi di leggere o scrivere nel flusso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bloccando l'intervallo di un flusso di file offre i thread dell'accesso esclusivo processo blocco di intervallo del flusso di file.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> o <paramref name="length" /> è negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">Il file viene chiuso.</exception>
        <exception cref="T:System.IO.IOException">Il processo non può accedere al file perché un altro processo ne ha bloccato una parte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la posizione corrente dell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> corrente.</summary>
        <value>Posizione corrente di questo oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostazione di questa proprietà funziona quando la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> proprietà `true`.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position%2A> proprietà per scrivere dati in un file.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La posizione non è impostata su un numero negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer in cui leggere.</param>
        <param name="offset">Offset nel buffer in corrispondenza del quale iniziare la scrittura.</param>
        <param name="count">Numero massimo di byte da leggere.</param>
        <summary>Copia i byte dall'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> attualmente memorizzato nel buffer in una matrice.</summary>
        <returns>Numero complessivo di byte letti nel <paramref name="buffer" />. Questo numero può essere minore di quello dei byte richiesti, se la quantità di byte non è attualmente disponibile, oppure corrispondere a zero se viene raggiunta la fine del flusso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `buffer` parametro può essere un'istanza di <xref:System.Buffer> classe o una matrice di uno dei seguenti tipi: <xref:System.Byte>, <xref:System.SByte>, <xref:System.Char>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt16>, <xref:System.UInt32> , <xref:System.UInt64>, <xref:System.Single>, o <xref:System.Double>. Il `offset` parametro fornisce l'offset del byte nel buffer in corrispondenza del quale iniziare la scrittura (indice nel buffer) e `count` parametro fornisce il numero massimo di byte che verranno letti dal flusso corrente. Il valore restituito è il numero effettivo di byte letti, oppure zero se viene raggiunta la fine del flusso. Se l'operazione di lettura ha esito positivo, la posizione corrente del flusso viene anticipata per il numero di byte letti. Se si verifica un'eccezione, la posizione corrente del flusso viene modificata.  
  
 Il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> metodo considera il `buffer` parametro come un blocco di byte, indipendentemente dal tipo effettivo. Analogamente, il `offset` e `count` i parametri vengono sempre specificati in byte. Per `buffer` parametri diversi da matrici di byte, ciò significa che un indice di elemento deve essere moltiplicato per la dimensione dell'elemento in byte, per formare un valore corretto per `offset` o `count`.  
  
 Il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> metodo restituirà zero solo se viene raggiunta la fine del flusso. In tutti gli altri casi, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> legge sempre almeno un byte dal flusso prima della restituzione. Se non sono disponibili da dati di <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto su una chiamata a <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>, il metodo verrà bloccato fino a quando non può essere restituito almeno un byte di dati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legge un singolo byte dall'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> nello spazio di memorizzazione isolato.</summary>
        <returns>Il valore intero senza segno a 8 bit letto dal file dello spazio di memorizzazione isolato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte%2A> metodo può essere utilizzato per leggere i dati da un <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto. Per il contesto completo di questo esempio, vedere il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Panoramica.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public override Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> che rappresenta l'handle di file del sistema operativo per il file incapsulato dall'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> corrente.</summary>
        <value>Oggetto <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> che rappresenta l'handle di file del sistema operativo per il file incapsulato dall'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle%2A> proprietà non è supportata e genera sempre un' <xref:System.IO.IsolatedStorage.IsolatedStorageException> eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">La proprietà <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" /> genera sempre questa eccezione.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter accedere a codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Nuova posizione dell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <param name="origin">Uno dei valori di <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Imposta la posizione corrente di questo oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> sul valore specificato.</summary>
        <returns>Nuova posizione all'interno dell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetti supporta il posizionamento oltre la lunghezza del flusso, altri genererà un'eccezione in questo caso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <paramref name="origin" /> deve essere uno dei valori <see cref="T:System.IO.SeekOrigin" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nuova lunghezza dell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Imposta la lunghezza di questo oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> sul valore <paramref name="value" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto specificato `value` è minore della lunghezza corrente del <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> dell'oggetto, il flusso viene troncato. Se l'oggetto specificato `value` è maggiore della lunghezza corrente del flusso, il flusso viene esteso. Se il flusso è espanso, il contenuto del flusso tra il vecchio e la nuova lunghezza non è definito. Per utilizzare questo metodo, un <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto deve supportare la scrittura e ricerca.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> è un numero negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public override void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Unlock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Posizione iniziale dell'intervallo da sbloccare. Il valore di questo parametro deve essere uguale o maggiore di zero (0).</param>
        <param name="length">Numero di byte da sbloccare.</param>
        <summary>Consente ad altri processi di accedere a una parte o a tutto il file bloccato in precedenza.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> o <paramref name="length" /> è negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer in cui scrivere.</param>
        <param name="offset">Offset di byte nel buffer da cui iniziare.</param>
        <param name="count">Numero massimo di byte da scrivere.</param>
        <summary>Scrive un blocco di byte nell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> usando i dati letti da una matrice di byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `offset` parametro fornisce l'offset del byte nel `buffer` in corrispondenza del quale iniziare la lettura e `count` parametro fornisce il numero di byte che verranno scritte in questo <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto. Se l'operazione di scrittura ha esito positivo, la posizione corrente del <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> avanzare l'oggetto per il numero di byte scritti. Se si verifica un'eccezione, la posizione corrente di <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto non viene modificato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Il tentativo di scrittura supera la quota per l'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Valore di byte da scrivere nel file dello spazio di memorizzazione isolato.</param>
        <summary>Scrive un singolo byte nell'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte%2A> metodo può essere utilizzato per leggere i dati da un <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> oggetto. Per il contesto completo di questo esempio, vedere il <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Panoramica.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Il tentativo di scrittura supera la quota per l'oggetto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>