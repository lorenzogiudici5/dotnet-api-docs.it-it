<Type Name="EventSource" FullName="System.Diagnostics.Tracing.EventSource">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6736ac0fc9f26ddd67969a70736a98d86106eefa" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39746356" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventSource : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventSource extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Tracing.EventSource" />
  <TypeSignature Language="VB.NET" Value="Public Class EventSource&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventSource : IDisposable" />
  <TypeSignature Language="F#" Value="type EventSource = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Consente di creare eventi per Traccia eventi per Windows (ETW).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe è destinata a essere ereditato da una classe che fornisce eventi specifici da utilizzare per ETW. Il <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A?displayProperty=nameWithType> metodi vengono chiamati per registrare gli eventi.  
  
> [!IMPORTANT]
>  Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare il tipo direttamente, chiamare relativi <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 La funzionalità di base di <xref:System.Diagnostics.Tracing.EventSource> è sufficiente per la maggior parte delle applicazioni.  Se si desidera maggiore controllo sul manifesto ETW che viene creato, è possibile applicare il <xref:System.Diagnostics.Tracing.EventAttribute> attributo ai metodi. Per le applicazioni di origine eventi avanzati, è possibile intercettare i comandi inviati all'origine evento derivata e modificare il filtro o per fare in modo azioni (ad esempio, il dump di una struttura di dati) che deve essere eseguito dall'erede.  Un'origine evento può essere attivata immediatamente con i controller ETW di Windows, ad esempio lo strumento Logman.  È anche possibile controllare a livello di codice e di intercettare il dispatcher di dati.  Il <xref:System.Diagnostics.Tracing.EventListener> classe fornisce funzionalità aggiuntive.  
  
 A partire [!INCLUDE[net_v46](~/includes/net-v46-md.md)], <xref:System.Diagnostics.Tracing.EventSource> fornisce supporto del canale e alcune delle regole di convalida di origine eventi sono stati ridotti. Vale a dire che:  
  
-   <xref:System.Diagnostics.Tracing.EventSource> i tipi possono ora implementare interfacce. In questo modo l'utilizzo dei tipi di origini evento nei sistemi di registrazione avanzata che usano le interfacce per definire una destinazione di registrazione comuni.  
  
-   È stato introdotto il concetto di un tipo di origine di eventi di utilità. Questa funzionalità consente di condivisione di codice tra più tipi di origine evento in un progetto per abilitare scenari, ad esempio ottimizzate <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> overload.  
  
 Per una versione del <xref:System.Diagnostics.Tracing.EventSource> fa riferimento a classe che fornisce il supporto per funzionalità quali channel [!INCLUDE[net_v451](~/includes/net-v451-md.md)] o versioni precedenti, vedere [Microsoft EventSource Library 1.0.16](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.EventSource).  
  
   
  
## Examples  
 L'esempio seguente illustra un'implementazione semplice del <xref:System.Diagnostics.Tracing.EventSource> classe.  
  
 [!code-csharp[ETWTraceSmall#1](~/samples/snippets/csharp/VS_Snippets_CLR/etwtracesmall/cs/program.cs#1)]
 [!code-vb[ETWTraceSmall#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/etwtracesmall/vb/program.vb#1)]  
  
 L'esempio seguente illustra un'implementazione più complessa del <xref:System.Diagnostics.Tracing.EventSource> classe.  
  
 [!code-csharp[ETWTrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/etwtrace/cs/program.cs#1)]
 [!code-vb[ETWTrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/etwtrace/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza della classe <see cref="T:System.Diagnostics.Tracing.EventSource" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected EventSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; EventSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crea una nuova istanza della classe <see cref="T:System.Diagnostics.Tracing.EventSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected EventSource (bool throwOnEventWriteErrors);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool throwOnEventWriteErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (throwOnEventWriteErrors As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; EventSource(bool throwOnEventWriteErrors);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Tracing.EventSource : bool -&gt; System.Diagnostics.Tracing.EventSource" Usage="new System.Diagnostics.Tracing.EventSource throwOnEventWriteErrors" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="throwOnEventWriteErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="throwOnEventWriteErrors">
          <see langword="true" /> per generare un'eccezione quando si verifica un errore nel codice sottostante di Windows; in caso contrario, <see langword="false" />.</param>
        <summary>Crea una nuova istanza della classe <see cref="T:System.Diagnostics.Tracing.EventSource" /> e specifica se generare un'eccezione quando si verifica un errore nel codice sottostante di Windows.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected EventSource (System.Diagnostics.Tracing.EventSourceSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Diagnostics.Tracing.EventSourceSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.#ctor(System.Diagnostics.Tracing.EventSourceSettings)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (settings As EventSourceSettings)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; EventSource(System::Diagnostics::Tracing::EventSourceSettings settings);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Tracing.EventSource : System.Diagnostics.Tracing.EventSourceSettings -&gt; System.Diagnostics.Tracing.EventSource" Usage="new System.Diagnostics.Tracing.EventSource settings" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="settings" Type="System.Diagnostics.Tracing.EventSourceSettings" />
      </Parameters>
      <Docs>
        <param name="settings">Combinazione bit per bit di valori di enumerazione che specificano le impostazioni di configurazione da applicare all'origine evento.</param>
        <summary>Crea una nuova istanza della classe <see cref="T:System.Diagnostics.Tracing.EventSource" /> con le impostazioni di configurazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Che specifica `settings` quando il <xref:System.Diagnostics.Tracing.EventSource> viene costruito consente di specificare se l'evento viene scritto in un formato autodescrittivo o una basata su manifesto. Inoltre, è possibile specificare che deve essere generata un'eccezione quando si verifica un errore durante il processo di scrittura di eventi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventSource (string eventSourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string eventSourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (eventSourceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventSource(System::String ^ eventSourceName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Tracing.EventSource : string -&gt; System.Diagnostics.Tracing.EventSource" Usage="new System.Diagnostics.Tracing.EventSource eventSourceName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventSourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventSourceName">Nome da applicare all'origine evento. Non deve essere <see langword="null" />.</param>
        <summary>Crea una nuova istanza della classe <see cref="T:System.Diagnostics.Tracing.EventSource" /> con il nome specificato.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSourceName" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected EventSource (System.Diagnostics.Tracing.EventSourceSettings settings, params string[] traits);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Diagnostics.Tracing.EventSourceSettings settings, string[] traits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.#ctor(System.Diagnostics.Tracing.EventSourceSettings,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (settings As EventSourceSettings, ParamArray traits As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; EventSource(System::Diagnostics::Tracing::EventSourceSettings settings, ... cli::array &lt;System::String ^&gt; ^ traits);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Tracing.EventSource : System.Diagnostics.Tracing.EventSourceSettings * string[] -&gt; System.Diagnostics.Tracing.EventSource" Usage="new System.Diagnostics.Tracing.EventSource (settings, traits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="settings" Type="System.Diagnostics.Tracing.EventSourceSettings" />
        <Parameter Name="traits" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="settings">Combinazione bit per bit di valori di enumerazione che specificano le impostazioni di configurazione da applicare all'origine evento.</param>
        <param name="traits">Coppie chiave-valore che specificano i tratti per l'origine evento.</param>
        <summary>Inizializza una nuova istanza dell'oggetto <see cref="T:System.Diagnostics.Tracing.EventSource" /> da usare con eventi non di contratto che contengono le impostazioni e i tratti specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tratti di forniscono informazioni aggiuntive per un evento e sono interpretati da un listener di eventi. Tratti vengono specificati come coppie chiave-valore e se non specificato in coppie, si verificherà un'eccezione. È possibile recuperare un tratto passando la chiave per il <xref:System.Diagnostics.Tracing.EventSource.GetTrait%2A>, metodo.  
  
 Che specifica `settings` quando il <xref:System.Diagnostics.Tracing.EventSource> viene costruito consente di specificare se l'evento viene scritto in un formato autodescrittivo o una basata su manifesto. Inoltre, è possibile specificare che deve essere generata un'eccezione quando si verifica un errore durante il processo di scrittura di eventi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="traits" /> non è specificato nelle coppie chiave-valore.</exception>
        <altmember cref="M:System.Diagnostics.Tracing.EventSource.GetTrait(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventSource (string eventSourceName, System.Diagnostics.Tracing.EventSourceSettings config);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string eventSourceName, valuetype System.Diagnostics.Tracing.EventSourceSettings config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.#ctor(System.String,System.Diagnostics.Tracing.EventSourceSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (eventSourceName As String, config As EventSourceSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventSource(System::String ^ eventSourceName, System::Diagnostics::Tracing::EventSourceSettings config);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Tracing.EventSource : string * System.Diagnostics.Tracing.EventSourceSettings -&gt; System.Diagnostics.Tracing.EventSource" Usage="new System.Diagnostics.Tracing.EventSource (eventSourceName, config)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventSourceName" Type="System.String" />
        <Parameter Name="config" Type="System.Diagnostics.Tracing.EventSourceSettings" />
      </Parameters>
      <Docs>
        <param name="eventSourceName">Nome da applicare all'origine evento. Non deve essere <see langword="null" />.</param>
        <param name="config">Combinazione bit per bit di valori di enumerazione che specificano le impostazioni di configurazione da applicare all'origine evento.</param>
        <summary>Crea una nuova istanza della classe <see cref="T:System.Diagnostics.Tracing.EventSource" /> con il nome e le impostazioni specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Che specifica `settings` quando il <xref:System.Diagnostics.Tracing.EventSource> viene costruito consente di specificare se l'evento viene scritto in un formato autodescrittivo o una basata su manifesto. Inoltre, è possibile specificare che deve essere generata un'eccezione quando si verifica un errore durante il processo di scrittura di eventi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSourceName" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventSource (string eventSourceName, System.Diagnostics.Tracing.EventSourceSettings config, params string[] traits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string eventSourceName, valuetype System.Diagnostics.Tracing.EventSourceSettings config, string[] traits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.#ctor(System.String,System.Diagnostics.Tracing.EventSourceSettings,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (eventSourceName As String, config As EventSourceSettings, ParamArray traits As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventSource(System::String ^ eventSourceName, System::Diagnostics::Tracing::EventSourceSettings config, ... cli::array &lt;System::String ^&gt; ^ traits);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Tracing.EventSource : string * System.Diagnostics.Tracing.EventSourceSettings * string[] -&gt; System.Diagnostics.Tracing.EventSource" Usage="new System.Diagnostics.Tracing.EventSource (eventSourceName, config, traits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventSourceName" Type="System.String" />
        <Parameter Name="config" Type="System.Diagnostics.Tracing.EventSourceSettings" />
        <Parameter Name="traits" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventSourceName">Nome da applicare all'origine evento. Non deve essere <see langword="null" />.</param>
        <param name="config">Combinazione bit per bit di valori di enumerazione che specificano le impostazioni di configurazione da applicare all'origine evento.</param>
        <param name="traits">Coppie chiave-valore che specificano i tratti per l'origine evento.</param>
        <summary>Crea una nuova istanza della classe <see cref="T:System.Diagnostics.Tracing.EventSource" /> con le impostazioni di configurazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tratti di forniscono informazioni aggiuntive per un evento e sono interpretati da un listener di eventi. Tratti vengono specificati come coppie chiave-valore e se non specificato in coppie, si verificherà un'eccezione. È possibile recuperare un tratto passando la chiave per il <xref:System.Diagnostics.Tracing.EventSource.GetTrait%2A>, metodo.  
  
 Che specifica `config` quando il <xref:System.Diagnostics.Tracing.EventSource> viene costruito consente di specificare se l'evento viene scritto in un formato autodescrittivo o una basata su manifesto. Inoltre, è possibile specificare che deve essere generata un'eccezione quando si verifica un errore durante il processo di scrittura di eventi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSourceName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="traits" /> non è specificato nelle coppie chiave-valore.</exception>
        <altmember cref="M:System.Diagnostics.Tracing.EventSource.GetTrait(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ConstructionException">
      <MemberSignature Language="C#" Value="public Exception ConstructionException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception ConstructionException" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Tracing.EventSource.ConstructionException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ ConstructionException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionException : Exception" Usage="System.Diagnostics.Tracing.EventSource.ConstructionException" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supportato in .NET Framework 4.5.1 e versioni successive] 
Ottiene un'eccezione generata durante la costruzione dell'origine evento.</summary>
        <value>Eccezione generata durante la costruzione dell'origine evento o <see langword="null" /> se non è stata generata alcuna eccezione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Tracing.EventSource> i costruttori non generano eccezioni. Qualsiasi eccezione generata viene invece assegnato per il <xref:System.Diagnostics.Tracing.EventSource.ConstructionException%2A> proprietà e registrate dal <xref:System.Diagnostics.Trace.WriteLine%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentThreadActivityId">
      <MemberSignature Language="C#" Value="public static Guid CurrentThreadActivityId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Guid CurrentThreadActivityId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Tracing.EventSource.CurrentThreadActivityId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThreadActivityId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Guid CurrentThreadActivityId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThreadActivityId : Guid" Usage="System.Diagnostics.Tracing.EventSource.CurrentThreadActivityId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.5;netstandard-1.6">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netstandard-1.2;netstandard-1.3;netstandard-1.4">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supportato in .NET Framework 4.5.1 e versioni successive] 
Ottiene l'ID attività del thread corrente.</summary>
        <value>ID attività del thread corrente.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Diagnostics.Tracing.EventSource.SetCurrentThreadActivityId(System.Guid)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Diagnostics.Tracing.EventSource" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="eventSource.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Diagnostics.Tracing.EventSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il metodo `Dispose` dopo aver terminato di utilizzare l'oggetto <xref:System.Diagnostics.Tracing.EventSource>. Il metodo `Dispose` lascia l'oggetto <xref:System.Diagnostics.Tracing.EventSource> in una condizione di inutilizzabilità. Dopo la chiamata `Dispose`, è necessario rilasciare tutti i riferimenti per il <xref:System.Diagnostics.Tracing.EventSource> in modo che il garbage collector di recuperare la memoria che il <xref:System.Diagnostics.Tracing.EventSource> occupata.  
  
 Per altre informazioni, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementa un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Chiamare sempre il metodo `Dispose` prima di rilasciare l'ultimo riferimento a <xref:System.Diagnostics.Tracing.EventSource>. In caso contrario, le risorse utilizzate non verranno liberate finché il metodo <xref:System.Diagnostics.Tracing.EventSource> dell'oggetto `Finalize` non viene richiamato dal Garbage Collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="eventSource.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate dalla classe <see cref="T:System.Diagnostics.Tracing.EventSource" /> e facoltativamente le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da parte del pubblico `Dispose()` metodo e `Finalize` (metodo). `Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. `Finalize` richiama `Dispose` con `disposing` impostato su `false`.  
  
 Se il parametro `disposing` è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti a cui la classe <xref:System.Diagnostics.Tracing.EventSource> fa riferimento. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see langword="Dispose(Boolean)" />, prestare attenzione a non fare riferimento agli oggetti che sono stati eliminati in una precedente chiamata al metodo Dispose <see langword="Dispose" />. Per altre informazioni su come implementare <see langword="Dispose(Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  Per altre informazioni sulle <see langword="Dispose" /> e <see langword="Finalize" />, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EventCommandExecuted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Diagnostics.Tracing.EventCommandEventArgs&gt; EventCommandExecuted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Tracing.EventCommandEventArgs&gt; EventCommandExecuted" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Tracing.EventSource.EventCommandExecuted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EventCommandExecuted As EventHandler(Of EventCommandEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Diagnostics::Tracing::EventCommandEventArgs ^&gt; ^ EventCommandExecuted;" />
      <MemberSignature Language="F#" Value="member this.EventCommandExecuted : EventHandler&lt;System.Diagnostics.Tracing.EventCommandEventArgs&gt; " Usage="member this.EventCommandExecuted : System.EventHandler&lt;System.Diagnostics.Tracing.EventCommandEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Tracing.EventCommandEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un comando proviene da un listener di eventi.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~EventSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!EventSource ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="eventSource.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente all'oggetto <see cref="T:System.Diagnostics.Tracing.EventSource" /> di provare a liberare risorse ed eseguire altre operazioni di pulizia prima che l'oggetto venga recuperato da Garbage Collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GenerateManifest">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una stringa del manifesto XML associato all'origine evento corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GenerateManifest">
      <MemberSignature Language="C#" Value="public static string GenerateManifest (Type eventSourceType, string assemblyPathToIncludeInManifest);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateManifest(class System.Type eventSourceType, string assemblyPathToIncludeInManifest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.GenerateManifest(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GenerateManifest (eventSourceType As Type, assemblyPathToIncludeInManifest As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GenerateManifest(Type ^ eventSourceType, System::String ^ assemblyPathToIncludeInManifest);" />
      <MemberSignature Language="F#" Value="static member GenerateManifest : Type * string -&gt; string" Usage="System.Diagnostics.Tracing.EventSource.GenerateManifest (eventSourceType, assemblyPathToIncludeInManifest)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSourceType" Type="System.Type" />
        <Parameter Name="assemblyPathToIncludeInManifest" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventSourceType">Tipo dell'origine evento.</param>
        <param name="assemblyPathToIncludeInManifest">Percorso del file di assembly (DLL) da includere nell'elemento [provider](http://msdn.microsoft.com/library/windows/desktop/aa384022\(v=vs.85\).aspx) del manifesto.</param>
        <summary>Restituisce una stringa del manifesto XML associato all'origine evento corrente.</summary>
        <returns>Stringa di dati XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le informazioni sullo schema XML per il manifesto di eventi, vedere [dello Schema manifesto evento](http://go.microsoft.com/fwlink/?LinkId=228077) in MSDN Library.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateManifest">
      <MemberSignature Language="C#" Value="public static string GenerateManifest (Type eventSourceType, string assemblyPathToIncludeInManifest, System.Diagnostics.Tracing.EventManifestOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateManifest(class System.Type eventSourceType, string assemblyPathToIncludeInManifest, valuetype System.Diagnostics.Tracing.EventManifestOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.GenerateManifest(System.Type,System.String,System.Diagnostics.Tracing.EventManifestOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GenerateManifest (eventSourceType As Type, assemblyPathToIncludeInManifest As String, flags As EventManifestOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GenerateManifest(Type ^ eventSourceType, System::String ^ assemblyPathToIncludeInManifest, System::Diagnostics::Tracing::EventManifestOptions flags);" />
      <MemberSignature Language="F#" Value="static member GenerateManifest : Type * string * System.Diagnostics.Tracing.EventManifestOptions -&gt; string" Usage="System.Diagnostics.Tracing.EventSource.GenerateManifest (eventSourceType, assemblyPathToIncludeInManifest, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSourceType" Type="System.Type" />
        <Parameter Name="assemblyPathToIncludeInManifest" Type="System.String" />
        <Parameter Name="flags" Type="System.Diagnostics.Tracing.EventManifestOptions" />
      </Parameters>
      <Docs>
        <param name="eventSourceType">Tipo dell'origine evento.</param>
        <param name="assemblyPathToIncludeInManifest">Percorso del file di assembly (DLL) da includere nell'elemento [provider](http://msdn.microsoft.com/library/windows/desktop/aa384022\(v=vs.85\).aspx) del manifesto.</param>
        <param name="flags">Combinazione bit per bit dei valori di enumerazione che specificano le modalità di generazione del manifesto.</param>
        <summary>Restituisce una stringa del manifesto XML associato all'origine evento corrente.</summary>
        <returns>Stringa di dati XML o <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `flags` specifica `OnlyIfNeededForRegistration` e il `eventSourceType` specificato non richiede la registrazione esplicita, <xref:System.Diagnostics.Tracing.EventSource.GenerateManifest%2A> restituisce `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public static Guid GetGuid (Type eventSourceType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetGuid(class System.Type eventSourceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.GetGuid(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGuid (eventSourceType As Type) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetGuid(Type ^ eventSourceType);" />
      <MemberSignature Language="F#" Value="static member GetGuid : Type -&gt; Guid" Usage="System.Diagnostics.Tracing.EventSource.GetGuid eventSourceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSourceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="eventSourceType">Tipo dell'origine evento.</param>
        <summary>Ottiene l'identificatore univoco per questa implementazione dell'origine evento.</summary>
        <returns>Identificatore univoco per questo tipo dell'origine evento.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (Type eventSourceType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetName(class System.Type eventSourceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.GetName(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (eventSourceType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(Type ^ eventSourceType);" />
      <MemberSignature Language="F#" Value="static member GetName : Type -&gt; string" Usage="System.Diagnostics.Tracing.EventSource.GetName eventSourceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSourceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="eventSourceType">Tipo dell'origine evento.</param>
        <summary>Ottiene il nome descrittivo dell'origine evento.</summary>
        <returns>Nome descrittivo dell'origine evento. Il valore predefinito è il nome semplice della classe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSources">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Tracing.EventSource&gt; GetSources ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Diagnostics.Tracing.EventSource&gt; GetSources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.GetSources" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSources () As IEnumerable(Of EventSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::Diagnostics::Tracing::EventSource ^&gt; ^ GetSources();" />
      <MemberSignature Language="F#" Value="static member GetSources : unit -&gt; seq&lt;System.Diagnostics.Tracing.EventSource&gt;" Usage="System.Diagnostics.Tracing.EventSource.GetSources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Tracing.EventSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene lo snapshot di tutte le origini evento per il dominio applicazione.</summary>
        <returns>Enumerazione di tutte le origini evento nel dominio applicazione.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTrait">
      <MemberSignature Language="C#" Value="public string GetTrait (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTrait(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.GetTrait(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTrait (key As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTrait(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.GetTrait : string -&gt; string" Usage="eventSource.GetTrait key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave del tratto da ottenere.</param>
        <summary>Ottiene il valore del tratto associato alla chiave specificata.</summary>
        <returns>Valore del tratto associato alla chiave specificata. Se la chiave non viene trovata, restituisce <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tratti di forniscono informazioni aggiuntive per un evento e sono interpretati da un listener di eventi. Tratti vengono specificati come coppie chiave-valore quando viene costruita l'origine dell'evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Guid">
      <MemberSignature Language="C#" Value="public Guid Guid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Guid" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Tracing.EventSource.Guid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Guid As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Guid { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Guid : Guid" Usage="System.Diagnostics.Tracing.EventSource.Guid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identificatore univoco per l'origine evento.</summary>
        <value>Identificatore univoco per l'origine evento.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsEnabled">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se l'origine evento corrente è abilitata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled();" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : unit -&gt; bool" Usage="eventSource.IsEnabled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se l'origine evento corrente è abilitata.</summary>
        <returns>
          <see langword="true" /> se l'origine evento corrente è abilitata; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled (System.Diagnostics.Tracing.EventLevel level, System.Diagnostics.Tracing.EventKeywords keywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled(valuetype System.Diagnostics.Tracing.EventLevel level, valuetype System.Diagnostics.Tracing.EventKeywords keywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.IsEnabled(System.Diagnostics.Tracing.EventLevel,System.Diagnostics.Tracing.EventKeywords)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled (level As EventLevel, keywords As EventKeywords) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled(System::Diagnostics::Tracing::EventLevel level, System::Diagnostics::Tracing::EventKeywords keywords);" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : System.Diagnostics.Tracing.EventLevel * System.Diagnostics.Tracing.EventKeywords -&gt; bool" Usage="eventSource.IsEnabled (level, keywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Diagnostics.Tracing.EventLevel" />
        <Parameter Name="keywords" Type="System.Diagnostics.Tracing.EventKeywords" />
      </Parameters>
      <Docs>
        <param name="level">Livello dell'origine evento.</param>
        <param name="keywords">Parola chiave dell'origine evento.</param>
        <summary>Determina se l'origine evento corrente con il livello e la parola chiave specificati è abilitata.</summary>
        <returns>
          <see langword="true" /> se l'origine evento è abilitata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il risultato di questo metodo è solo un'approssimazione che indica se un particolare evento è attivo.  Usarlo per evitare attività onerose di calcolo per la registrazione quando quest'ultima è disabilitata.   Origini evento possono includere filtri aggiuntivi che ne determinano l'attività.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled (System.Diagnostics.Tracing.EventLevel level, System.Diagnostics.Tracing.EventKeywords keywords, System.Diagnostics.Tracing.EventChannel channel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled(valuetype System.Diagnostics.Tracing.EventLevel level, valuetype System.Diagnostics.Tracing.EventKeywords keywords, valuetype System.Diagnostics.Tracing.EventChannel channel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.IsEnabled(System.Diagnostics.Tracing.EventLevel,System.Diagnostics.Tracing.EventKeywords,System.Diagnostics.Tracing.EventChannel)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled (level As EventLevel, keywords As EventKeywords, channel As EventChannel) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled(System::Diagnostics::Tracing::EventLevel level, System::Diagnostics::Tracing::EventKeywords keywords, System::Diagnostics::Tracing::EventChannel channel);" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : System.Diagnostics.Tracing.EventLevel * System.Diagnostics.Tracing.EventKeywords * System.Diagnostics.Tracing.EventChannel -&gt; bool" Usage="eventSource.IsEnabled (level, keywords, channel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Diagnostics.Tracing.EventLevel" />
        <Parameter Name="keywords" Type="System.Diagnostics.Tracing.EventKeywords" />
        <Parameter Name="channel" Type="System.Diagnostics.Tracing.EventChannel" />
      </Parameters>
      <Docs>
        <param name="level">Livello dell'evento da controllare. Un'origine evento verrà considerata abilitata quando il relativo livello è maggiore o uguale a <c>level</c>.</param>
        <param name="keywords">Parole chiave dell'evento da controllare.</param>
        <param name="channel">Canale dell'evento da controllare.</param>
        <summary>Determina se l'origine evento è abilitata per eventi con il livello, le parole chiave e il canale specificati.</summary>
        <returns>
          <see langword="true" /> se l'origine evento è abilitata per il livello, le parole chiave e il canale specificati; in caso contrario, <see langword="false" />.  
  
Il risultato di questo metodo è solo un'approssimazione che indica se un particolare evento è attivo.  Usarlo per evitare attività onerose di calcolo per la registrazione quando quest'ultima è disabilitata.   Le origini evento possono includere filtri aggiuntivi che ne determinano l'attività.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Tracing.EventSource.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Diagnostics.Tracing.EventSource.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Il nome descrittivo della classe che deriva dall'origine evento.</summary>
        <value>Nome descrittivo della classe derivata.  Il valore predefinito è il nome semplice della classe.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEventCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnEventCommand (System.Diagnostics.Tracing.EventCommandEventArgs command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEventCommand(class System.Diagnostics.Tracing.EventCommandEventArgs command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.OnEventCommand(System.Diagnostics.Tracing.EventCommandEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEventCommand (command As EventCommandEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEventCommand(System::Diagnostics::Tracing::EventCommandEventArgs ^ command);" />
      <MemberSignature Language="F#" Value="abstract member OnEventCommand : System.Diagnostics.Tracing.EventCommandEventArgs -&gt; unit&#xA;override this.OnEventCommand : System.Diagnostics.Tracing.EventCommandEventArgs -&gt; unit" Usage="eventSource.OnEventCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Diagnostics.Tracing.EventCommandEventArgs" />
      </Parameters>
      <Docs>
        <param name="command">Argomenti per l'evento.</param>
        <summary>Chiamato quando l'origine evento corrente viene aggiornata dal controller.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendCommand">
      <MemberSignature Language="C#" Value="public static void SendCommand (System.Diagnostics.Tracing.EventSource eventSource, System.Diagnostics.Tracing.EventCommand command, System.Collections.Generic.IDictionary&lt;string,string&gt; commandArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SendCommand(class System.Diagnostics.Tracing.EventSource eventSource, valuetype System.Diagnostics.Tracing.EventCommand command, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; commandArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.SendCommand(System.Diagnostics.Tracing.EventSource,System.Diagnostics.Tracing.EventCommand,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SendCommand(System::Diagnostics::Tracing::EventSource ^ eventSource, System::Diagnostics::Tracing::EventCommand command, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ commandArguments);" />
      <MemberSignature Language="F#" Value="static member SendCommand : System.Diagnostics.Tracing.EventSource * System.Diagnostics.Tracing.EventCommand * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; unit" Usage="System.Diagnostics.Tracing.EventSource.SendCommand (eventSource, command, commandArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSource" Type="System.Diagnostics.Tracing.EventSource" />
        <Parameter Name="command" Type="System.Diagnostics.Tracing.EventCommand" />
        <Parameter Name="commandArguments" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="eventSource">L'origine evento a cui inviare il comando.</param>
        <param name="command">Il comando di evento da inviare.</param>
        <param name="commandArguments">Argomenti per il comando evento.</param>
        <summary>Invia un comando a un'origine evento specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata <xref:System.Diagnostics.Tracing.EventSource.SendCommand%2A> inoltra il comando per il <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A> callback.  Novità di <xref:System.Diagnostics.Tracing.EventSource> eseguite con il comando e relativi argomenti è specifico per l'origine dell'evento.  Il comando e argomenti del comando vengono passati al <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A> callback dell'origine evento specificata.   Se possibile, l'origine evento corrente non dovrebbe influenzare gli eventi di filtro degli altri listener di eventi; Tuttavia, che potrebbe non essere possibile se il comando causa una garbage collection, un sistema di scaricamento o un'altra attività globale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCurrentThreadActivityId">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>[Supportato in .NET Framework 4.5.1 e versioni successive] 
Imposta l'ID attività nel thread corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCurrentThreadActivityId">
      <MemberSignature Language="C#" Value="public static void SetCurrentThreadActivityId (Guid activityId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentThreadActivityId(valuetype System.Guid activityId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.SetCurrentThreadActivityId(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentThreadActivityId (activityId As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentThreadActivityId(Guid activityId);" />
      <MemberSignature Language="F#" Value="static member SetCurrentThreadActivityId : Guid -&gt; unit" Usage="System.Diagnostics.Tracing.EventSource.SetCurrentThreadActivityId activityId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activityId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="activityId">ID attività del nuovo thread corrente o <see cref="F:System.Guid.Empty" /> per indicare che il lavoro sul thread corrente non è associato ad alcuna attività.</param>
        <summary>[Supportato in .NET Framework 4.5.1 e versioni successive] 
Imposta l'ID attività nel thread corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Diagnostics.Tracing.EventSource.SetCurrentThreadActivityId%2A> metodo imposta l'ID dell'attività su un singolo thread. Tutti gli eventi sul thread avrà tale ID attività fino a quando non viene avviata una nuova attività sullo stesso thread.  
  
 Questo metodo viene chiamato solo dalle librerie che gestiscono i propri thread.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentThreadActivityId">
      <MemberSignature Language="C#" Value="public static void SetCurrentThreadActivityId (Guid activityId, out Guid oldActivityThatWillContinue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentThreadActivityId(valuetype System.Guid activityId, [out] valuetype System.Guid&amp; oldActivityThatWillContinue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.SetCurrentThreadActivityId(System.Guid,System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentThreadActivityId (activityId As Guid, ByRef oldActivityThatWillContinue As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentThreadActivityId(Guid activityId, [Runtime::InteropServices::Out] Guid % oldActivityThatWillContinue);" />
      <MemberSignature Language="F#" Value="static member SetCurrentThreadActivityId : Guid *  -&gt; unit" Usage="System.Diagnostics.Tracing.EventSource.SetCurrentThreadActivityId (activityId, oldActivityThatWillContinue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activityId" Type="System.Guid" />
        <Parameter Name="oldActivityThatWillContinue" Type="System.Guid" RefType="out" />
      </Parameters>
      <Docs>
        <param name="activityId">ID attività del nuovo thread corrente o <see cref="F:System.Guid.Empty" /> per indicare che il lavoro sul thread corrente non è associato ad alcuna attività.</param>
        <param name="oldActivityThatWillContinue">Quando questo metodo viene restituito, contiene l'ID attività precedente nel thread corrente.</param>
        <summary>[Supportato in .NET Framework 4.5.1 e versioni successive] 
Imposta l'ID attività nel thread corrente e restituisce l'ID attività precedente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile chiamare il <xref:System.Diagnostics.Tracing.EventSource.SetCurrentThreadActivityId%28System.Guid%2CSystem.Guid%40%29> metodo temporaneamente sovrascrivere ID attività del thread corrente con un nuovo ID di attività. È quindi necessario ripristinare l'ID attività precedente, passando il `oldActivityThatWillContinue` argomento per il <xref:System.Diagnostics.Tracing.EventSource.SetCurrentThreadActivityId%28System.Guid%29> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Tracing.EventSourceSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.Tracing.EventSourceSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Tracing.EventSource.Settings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Settings As EventSourceSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::Tracing::EventSourceSettings Settings { System::Diagnostics::Tracing::EventSourceSettings get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Diagnostics.Tracing.EventSourceSettings" Usage="System.Diagnostics.Tracing.EventSource.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Tracing.EventSourceSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le impostazioni applicate a questa origine evento.</summary>
        <value>Impostazioni applicate a questa origine evento.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="eventSource.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una rappresentazione di stringa dell'istanza dell'origine evento corrente.</summary>
        <returns>Nome e identificatore univoco che identificano l'origine evento corrente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive un evento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string eventName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string eventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (eventName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ eventName);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="eventSource.Write eventName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventName">Nome dell'evento da scrivere.</param>
        <summary>Scrive un evento senza campi, ma con il nome e le opzioni predefinite specificate.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventName" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string eventName, System.Diagnostics.Tracing.EventSourceOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string eventName, valuetype System.Diagnostics.Tracing.EventSourceOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.Write(System.String,System.Diagnostics.Tracing.EventSourceOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (eventName As String, options As EventSourceOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ eventName, System::Diagnostics::Tracing::EventSourceOptions options);" />
      <MemberSignature Language="F#" Value="member this.Write : string * System.Diagnostics.Tracing.EventSourceOptions -&gt; unit" Usage="eventSource.Write (eventName, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="options" Type="System.Diagnostics.Tracing.EventSourceOptions" />
      </Parameters>
      <Docs>
        <param name="eventName">Nome dell'evento da scrivere.</param>
        <param name="options">Opzioni, quali livello, parole chiave e codice operativo per l'evento.</param>
        <summary>Scrive un evento senza campi, ma con il nome e le opzioni specificate.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventName" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Write&lt;T&gt; (string eventName, T data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write&lt;T&gt;(string eventName, !!T data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.Write``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write(Of T) (eventName As String, data As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; void Write(System::String ^ eventName, T data);" />
      <MemberSignature Language="F#" Value="member this.Write : string * 'T -&gt; unit" Usage="eventSource.Write (eventName, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="data" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo che definisce l'evento e i relativi dati associati. Questo tipo deve essere anonimo o contrassegnato con l'attributo <see cref="T:System.Diagnostics.Tracing.EventSourceAttribute" />.</typeparam>
        <param name="eventName">Nome dell'evento.</param>
        <param name="data">Dati dell'evento. Questo tipo deve essere anonimo o contrassegnato con l'attributo <see cref="T:System.Diagnostics.Tracing.EventDataAttribute" />.</param>
        <summary>Scrive un evento con il nome e i dati specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `eventName` viene `null`, il nome dell'evento verrà derivato automaticamente dai dati di evento di tipo "T" (<xref:System.Diagnostics.Tracing.EventDataAttribute.Name%2A>) o viene determinata in base al nome del tipo `T`. Proprietà di istanza pubblico `data` verrà scritto in modo ricorsivo per creare i campi evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Write&lt;T&gt; (string eventName, System.Diagnostics.Tracing.EventSourceOptions options, T data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write&lt;T&gt;(string eventName, valuetype System.Diagnostics.Tracing.EventSourceOptions options, !!T data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.Write``1(System.String,System.Diagnostics.Tracing.EventSourceOptions,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write(Of T) (eventName As String, options As EventSourceOptions, data As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; void Write(System::String ^ eventName, System::Diagnostics::Tracing::EventSourceOptions options, T data);" />
      <MemberSignature Language="F#" Value="member this.Write : string * System.Diagnostics.Tracing.EventSourceOptions * 'T -&gt; unit" Usage="eventSource.Write (eventName, options, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="options" Type="System.Diagnostics.Tracing.EventSourceOptions" />
        <Parameter Name="data" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo che definisce l'evento e i relativi dati associati. Questo tipo deve essere anonimo o contrassegnato con l'attributo <see cref="T:System.Diagnostics.Tracing.EventSourceAttribute" />.</typeparam>
        <param name="eventName">Nome dell'evento.</param>
        <param name="options">Opzioni dell'evento.</param>
        <param name="data">Dati dell'evento. Questo tipo deve essere anonimo o contrassegnato con l'attributo <see cref="T:System.Diagnostics.Tracing.EventDataAttribute" />.</param>
        <summary>Scrive un evento con il nome, i dati e le opzioni specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `eventName` viene `null`, il nome dell'evento verrà derivato automaticamente dai dati di evento di tipo "T" (<xref:System.Diagnostics.Tracing.EventDataAttribute.Name%2A>) o viene determinata in base al nome del tipo `T`. Proprietà di istanza pubblico `data` verrà scritto in modo ricorsivo per creare i campi evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Write&lt;T&gt; (string eventName, ref System.Diagnostics.Tracing.EventSourceOptions options, ref T data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write&lt;T&gt;(string eventName, valuetype System.Diagnostics.Tracing.EventSourceOptions&amp; options, !!T&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.Write``1(System.String,System.Diagnostics.Tracing.EventSourceOptions@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write(Of T) (eventName As String, ByRef options As EventSourceOptions, ByRef data As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; void Write(System::String ^ eventName, System::Diagnostics::Tracing::EventSourceOptions % options, T % data);" />
      <MemberSignature Language="F#" Value="member this.Write : string *  *  -&gt; unit" Usage="eventSource.Write (eventName, options, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="options" Type="System.Diagnostics.Tracing.EventSourceOptions" RefType="ref" />
        <Parameter Name="data" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo che definisce l'evento e i relativi dati associati. Questo tipo deve essere anonimo o contrassegnato con l'attributo <see cref="T:System.Diagnostics.Tracing.EventSourceAttribute" />.</typeparam>
        <param name="eventName">Nome dell'evento.</param>
        <param name="options">Opzioni dell'evento.</param>
        <param name="data">Dati dell'evento. Questo tipo deve essere anonimo o contrassegnato con l'attributo <see cref="T:System.Diagnostics.Tracing.EventDataAttribute" />.</param>
        <summary>Scrive un evento con il nome, le opzioni e i dati specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `eventName` viene `null`, il nome dell'evento verrà derivato automaticamente dai dati di evento di tipo "T" (<xref:System.Diagnostics.Tracing.EventDataAttribute.Name%2A>) o viene determinata in base al nome del tipo `T`. Proprietà di istanza pubblico `data` verrà scritto in modo ricorsivo per creare i campi evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Write&lt;T&gt; (string eventName, ref System.Diagnostics.Tracing.EventSourceOptions options, ref Guid activityId, ref Guid relatedActivityId, ref T data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write&lt;T&gt;(string eventName, valuetype System.Diagnostics.Tracing.EventSourceOptions&amp; options, valuetype System.Guid&amp; activityId, valuetype System.Guid&amp; relatedActivityId, !!T&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.Write``1(System.String,System.Diagnostics.Tracing.EventSourceOptions@,System.Guid@,System.Guid@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write(Of T) (eventName As String, ByRef options As EventSourceOptions, ByRef activityId As Guid, ByRef relatedActivityId As Guid, ByRef data As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; void Write(System::String ^ eventName, System::Diagnostics::Tracing::EventSourceOptions % options, Guid % activityId, Guid % relatedActivityId, T % data);" />
      <MemberSignature Language="F#" Value="member this.Write : string *  *  *  *  -&gt; unit" Usage="eventSource.Write (eventName, options, activityId, relatedActivityId, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="options" Type="System.Diagnostics.Tracing.EventSourceOptions" RefType="ref" />
        <Parameter Name="activityId" Type="System.Guid" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" RefType="ref" />
        <Parameter Name="data" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo che definisce l'evento e i relativi dati associati. Questo tipo deve essere anonimo o contrassegnato con l'attributo <see cref="T:System.Diagnostics.Tracing.EventSourceAttribute" />.</typeparam>
        <param name="eventName">Nome dell'evento.</param>
        <param name="options">Opzioni dell'evento.</param>
        <param name="activityId">ID dell'attività associata all'evento.</param>
        <param name="relatedActivityId">ID di un'attività associata oppure <see cref="F:System.Guid.Empty" /> se non esiste alcuna attività associata.</param>
        <param name="data">Dati dell'evento. Questo tipo deve essere anonimo o contrassegnato con l'attributo <see cref="T:System.Diagnostics.Tracing.EventDataAttribute" />.</param>
        <summary>Scrive un evento con il nome, le opzioni, le attività correlate e i dati specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `eventName` viene `null`, il nome dell'evento verrà derivato automaticamente dai dati di evento di tipo "T" (<xref:System.Diagnostics.Tracing.EventDataAttribute.Name%2A>) o viene determinata in base al nome del tipo `T`. Proprietà di istanza pubblico `data` verrà scritto in modo ricorsivo per creare i campi evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti facoltativi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `WriteEvent` metodo fornisce gli overload con combinazioni di argomenti stringa e integer. Se nessuna di queste combinazioni corrispondono ai parametri per la chiamata, il compilatore utilizza il <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%28System.Int32%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> esegue l'overload, che è decisamente più lento rispetto gli altri overload. Vedere la pagina di overload per i dettagli.  
  
 In tutti i casi, il `eventid` parametro deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 È anche possibile creare un overload personalizzato usando il <xref:System.Diagnostics.Tracing.EventSource.WriteEventCore%2A> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int -&gt; unit" Usage="eventSource.WriteEvent eventId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento. Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare questo overload del metodo per scrivere un evento. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Diagnostics.Tracing.EventSource> classe.  
  
 [!code-csharp[ETWTrace#5](~/samples/snippets/csharp/VS_Snippets_CLR/etwtrace/cs/program.cs#5)]
 [!code-vb[ETWTrace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/etwtrace/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, byte[] arg1);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, unsigned int8[] arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As Byte())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, cli::array &lt;System::Byte&gt; ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * byte[] -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento della matrice di byte.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti di matrice di byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(byte[] arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, int arg1);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, int32 arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, int arg1);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * int -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento di intero.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e un argomento di intero a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(int  arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare questo overload del metodo per scrivere un evento. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Diagnostics.Tracing.EventSource> classe.  
  
 [!code-csharp[ETWTrace#8](~/samples/snippets/csharp/VS_Snippets_CLR/etwtrace/cs/program.cs#8)]
 [!code-vb[ETWTrace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/etwtrace/vb/program.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, long arg1);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, int64 arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, long arg1);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * int64 -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento di intero a 64 bit.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e un argomento di intero a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * obj[] -&gt; unit" Usage="eventSource.WriteEvent (eventId, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="args">Matrice di oggetti.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e la matrice di argomenti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il compilatore chiama questo overload se i parametri per la chiamata non corrispondono a uno degli altri overload del metodo. Questo overload è molto più lento rispetto gli altri overload, perché esegue le seguenti:  
  
1.  Alloca una matrice per contenere l'argomento della variabile.  
  
2.  Viene eseguito il cast di ogni parametro a un oggetto (che fa sì che le allocazioni per i tipi primitivi).  
  
3.  Assegna questi oggetti nella matrice.  
  
4.  Chiama la funzione, che quindi determina il tipo di ciascun argomento può essere serializzato per ETW.  
  
 L'overhead elevato per questo overload non è significativo durante la traccia eventi scarso, perché il metodo viene utilizzato solo quando il provider è abilitato. Tuttavia, per gli eventi con volumi elevati, l'overhead delle prestazioni può essere significativo.  È possibile evitare di usare <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A?displayProperty=nameWithType> per i payload di grandi volumi creando un overload di nuovo e più rapido con il <xref:System.Diagnostics.Tracing.EventSource.WriteEventCore%2A> (metodo).  
  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, string arg1);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, string arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, System::String ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * string -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento stringa.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti di stringa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare questo overload del metodo per scrivere un evento. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Diagnostics.Tracing.EventSource> classe.  
  
 [!code-csharp[ETWTrace#5](~/samples/snippets/csharp/VS_Snippets_CLR/etwtrace/cs/program.cs#5)]
 [!code-vb[ETWTrace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/etwtrace/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, int arg1, int arg2);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, int32 arg1, int32 arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As Integer, arg2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, int arg1, int arg2);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * int * int -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.Int32" />
        <Parameter Name="arg2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento di intero.</param>
        <param name="arg2">Argomento di intero.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti interi a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(int arg1, int arg2, int arg3)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, int arg1, string arg2);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, int32 arg1, string arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As Integer, arg2 As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, int arg1, System::String ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * int * string -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.Int32" />
        <Parameter Name="arg2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento. Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento di intero a 32 bit.</param>
        <param name="arg2">Argomento stringa.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti di stringa e interi a 32 bit.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, long arg1, byte[] arg2);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, int64 arg1, unsigned int8[] arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Int64,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As Long, arg2 As Byte())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, long arg1, cli::array &lt;System::Byte&gt; ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * int64 * byte[] -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.Int64" />
        <Parameter Name="arg2" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento di intero a 64 bit.</param>
        <param name="arg2">Argomento della matrice di byte.</param>
        <summary>Scrive i dati dell'evento usando l'identificatore e gli argomenti di matrice di byte e di interi a 64 bit specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(Int64 arg1, Byte[] arg2)  
{  
 base.WriteEvent(2, arg1, arg2);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, long arg1, long arg2);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, int64 arg1, int64 arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As Long, arg2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, long arg1, long arg2);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * int64 * int64 -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.Int64" />
        <Parameter Name="arg2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento di intero a 64 bit.</param>
        <param name="arg2">Argomento di intero a 64 bit.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, long arg1, string arg2);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, int64 arg1, string arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Int64,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As Long, arg2 As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, long arg1, System::String ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * int64 * string -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.Int64" />
        <Parameter Name="arg2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento di intero a 64 bit.</param>
        <param name="arg2">Argomento stringa.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti di stringa e interi a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(Int64 arg1, string arg2)  
{  
 base.WriteEvent(2, arg1, arg2);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, string arg1, int arg2);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, string arg1, int32 arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As String, arg2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, System::String ^ arg1, int arg2);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * string * int -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.String" />
        <Parameter Name="arg2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento stringa.</param>
        <param name="arg2">Argomento di intero a 32 bit.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, string arg1, long arg2);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, string arg1, int64 arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As String, arg2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, System::String ^ arg1, long arg2);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * string * int64 -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.String" />
        <Parameter Name="arg2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento stringa.</param>
        <param name="arg2">Argomento di intero a 64 bit.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, string arg1, string arg2);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, string arg1, string arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As String, arg2 As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, System::String ^ arg1, System::String ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * string * string -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.String" />
        <Parameter Name="arg2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento stringa.</param>
        <param name="arg2">Argomento stringa.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti di stringa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, int arg1, int arg2, int arg3);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, int32 arg1, int32 arg2, int32 arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As Integer, arg2 As Integer, arg3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, int arg1, int arg2, int arg3);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * int * int * int -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.Int32" />
        <Parameter Name="arg2" Type="System.Int32" />
        <Parameter Name="arg3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento di intero.</param>
        <param name="arg2">Argomento di intero.</param>
        <param name="arg3">Argomento di intero.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti interi a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, long arg1, long arg2, long arg3);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, int64 arg1, int64 arg2, int64 arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As Long, arg2 As Long, arg3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, long arg1, long arg2, long arg3);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * int64 * int64 * int64 -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.Int64" />
        <Parameter Name="arg2" Type="System.Int64" />
        <Parameter Name="arg3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento di intero a 64 bit.</param>
        <param name="arg2">Argomento di intero a 64 bit.</param>
        <param name="arg3">Argomento di intero a 64 bit.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, string arg1, int arg2, int arg3);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, string arg1, int32 arg2, int32 arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As String, arg2 As Integer, arg3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, System::String ^ arg1, int arg2, int arg3);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * string * int * int -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.String" />
        <Parameter Name="arg2" Type="System.Int32" />
        <Parameter Name="arg3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento stringa.</param>
        <param name="arg2">Argomento di intero a 32 bit.</param>
        <param name="arg3">Argomento di intero a 32 bit.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected void WriteEvent (int eventId, string arg1, string arg2, string arg3);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEvent(int32 eventId, string arg1, string arg2, string arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEvent (eventId As Integer, arg1 As String, arg2 As String, arg3 As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEvent(int eventId, System::String ^ arg1, System::String ^ arg2, System::String ^ arg3);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : int * string * string * string -&gt; unit" Usage="eventSource.WriteEvent (eventId, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="arg1" Type="System.String" />
        <Parameter Name="arg2" Type="System.String" />
        <Parameter Name="arg3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.  Questo valore dovrebbe essere compreso tra 0 e 65535.</param>
        <param name="arg1">Argomento stringa.</param>
        <param name="arg2">Argomento stringa.</param>
        <param name="arg3">Argomento stringa.</param>
        <summary>Scrive un evento usando l'identificatore evento fornito e gli argomenti di stringa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Quando si implementa un metodo che viene identificato come un evento ETW in un <xref:System.Diagnostics.Tracing.EventSource>-classe derivata. È necessario chiamare la classe di base <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> metodo passando la <xref:System.Diagnostics.Tracing.EventAttribute.EventId%2A> e gli stessi argomenti come il metodo implementato simile all'esempio seguente.  
  
```csharp  
[Event(2, Level = EventLevel.Informational)]  
public void Info1(string arg1)  
{  
 base.WriteEvent(2, arg1);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEventCore">
      <MemberSignature Language="C#" Value="protected void WriteEventCore (int eventId, int eventDataCount, System.Diagnostics.Tracing.EventSource.EventData* data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEventCore(int32 eventId, int32 eventDataCount, valuetype System.Diagnostics.Tracing.EventSource/EventData* data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEventCore(System.Int32,System.Int32,System.Diagnostics.Tracing.EventSource.EventData*)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEventCore(int eventId, int eventDataCount, System::Diagnostics::Tracing::EventSource::EventData* data);" />
      <MemberSignature Language="F#" Value="member this.WriteEventCore : int * int * nativeptr&lt;System.Diagnostics.Tracing.EventSource.EventData&gt; -&gt; unit" Usage="eventSource.WriteEventCore (eventId, eventDataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" />
        <Parameter Name="eventDataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.Diagnostics.Tracing.EventSource+EventData*" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore dell'evento.</param>
        <param name="eventDataCount">Numero di elementi dei dati dell'evento.</param>
        <param name="data">Struttura che contiene i dati dell'evento.</param>
        <summary>Crea un nuovo overload di <see cref="Overload:System.Diagnostics.Tracing.EventSource.WriteEvent" /> tramite l'identificatore evento e i dati dell'evento forniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `eventid` deve essere maggiore di 0 o inferiore a 65535 o possono verificarsi errori nell'operazione. Se si verificano errori, è possibile ottenere altre informazioni sull'origine dell'errore controllando il flusso di output del debugger, se si dispone di un debugger collegato al processo di generazione di eventi. È inoltre possibile cercare gli errori segnalati nel flusso di eventi ETW, se è presente un listener ETW sull'origine dell'evento in cui si verifica l'errore.  
  
 Tale metodo protetto consente agli utenti di definire nuove <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> overload che sono più veloci rispetto a overload specificato.   Creazione di un nuovo overload implica il codice unsafe.  La procedura di base è stack-allocare una matrice di descrittori di eventi dati che corrisponda al numero di elementi di payload.   Per ogni elemento di payload, impostare la dimensione corretta e il valore dell'evento matrice di dati. Chiamare <xref:System.Diagnostics.Tracing.EventSource.WriteEventCore%2A> con la matrice inizializzata.  
  
 Nell'esempio seguente viene illustrato come aggiungere un <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> overload che accetta quattro argomenti. Un esempio sarebbe se si dispone di un evento di registrazione che registra una stringa e interi a 3.  
  
```csharp  
  
[Event(1)]  
public void LogTime(string tag, int hour, int minute, int second)   
{  
    WriteEvent(1, tag, hour, minute, second);  
}  
  
```  
  
 È possibile eseguire questa operazione senza chiamare <xref:System.Diagnostics.Tracing.EventSource.WriteEventCore%2A>, ma sarebbe più lenta rispetto a dovrà essere aggiornato. Ciò avviene perché vengono usate matrici e reflection per capire cosa fare. Se si registrano gli URL in un tasso elevato (> 1000 / sec), può essere la pena di fare un helper veloce, come illustrato nell'esempio seguente. Il metodo nasconde esistente <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A>. In questo modo il codice chiamante originale (LogTime) non venga modificata, ma il compilatore c# userà la versione più specializzata che risulterà più veloce.  
  
 Per compilare codice unsafe, è necessario specificare il [-unsafe (opzioni del compilatore c#)](~/docs/csharp/language-reference/compiler-options/unsafe-compiler-option.md) opzione del compilatore.  
  
```csharp  
class AnotherEventSource : EventSource {  
  
    [NonEvent]  
    public unsafe void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4)  
    {  
  
        fixed (char* arg1Ptr = arg1)  
        {  
            EventData* dataDesc = stackalloc EventData[4];  
  
            dataDesc[0].DataPointer = (IntPtr)arg1Ptr;  
            dataDesc[0].Size = (arg1.Length + 1) * 2; // Size in bytes, including a null terminator.   
            dataDesc[1].DataPointer = (IntPtr)(&arg2);  
            dataDesc[1].Size = 4;  
            dataDesc[2].DataPointer = (IntPtr)(&arg3);  
            dataDesc[2].Size = 4;  
            dataDesc[3].DataPointer = (IntPtr)(&arg4);  
            dataDesc[3].Size = 4;  
  
            WriteEventCore(eventId, 4, dataDesc);  
        }  
    }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteEventWithRelatedActivityId">
      <MemberSignature Language="C#" Value="protected void WriteEventWithRelatedActivityId (int eventId, Guid relatedActivityId, params object[] args);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEventWithRelatedActivityId(int32 eventId, valuetype System.Guid relatedActivityId, object[] args) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityId(System.Int32,System.Guid,System.Object[])" FrameworkAlternate="netframework-4.5;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEventWithRelatedActivityId (eventId As Integer, relatedActivityId As Guid, ParamArray args As Object())" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, ... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="protected void WriteEventWithRelatedActivityId (int eventId, Guid childActivityID, params object[] args);" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netstandard-1.2" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEventWithRelatedActivityId(int32 eventId, valuetype System.Guid childActivityID, object[] args) cil managed" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netstandard-1.2" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteEventWithRelatedActivityId (eventId As Integer, childActivityID As Guid, ParamArray args As Object())" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEventWithRelatedActivityId(int eventId, Guid childActivityID, ... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netstandard-1.2" />
      <MemberSignature Language="F#" Value="member this.WriteEventWithRelatedActivityId : int * Guid * obj[] -&gt; unit" Usage="eventSource.WriteEventWithRelatedActivityId (eventId, relatedActivityId, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" Index="0" />
        <Parameter Name="relatedActivityId" Type="System.Guid" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="childActivityID" Type="System.Guid" Index="1" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netstandard-1.2" />
        <Parameter Name="args" Type="System.Object[]" Index="2">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore che identifica in modo univoco questo evento nell'oggetto <see cref="T:System.Diagnostics.Tracing.EventSource" />.</param>
        <param name="relatedActivityId">Identificatore dell'attività correlata.</param>
        <param name="childActivityID">To be added.</param>
        <param name="args">Matrice di oggetti che contiene i dati relativi all'evento.</param>
        <summary>[Supportato in .NET Framework 4.5.1 e versioni successive] 
Scrive un evento che indica che l'attività corrente è correlata a un'altra attività.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityId%2A> metodo registra un evento di trasferimento. L'attività del thread corrente viene registrata con l'evento e in questo modo due attività devono essere correlate da un consumer di eventi.  
  
 Il metodo di eventi ETW chiamare questa funzione deve seguire queste linee guida:  
  
1.  Specificare il primo parametro come un <xref:System.Guid> denominato `relatedActivityId`.  
  
2.  Specificare il parametro <xref:System.Diagnostics.Tracing.EventOpcode.Send> oppure <xref:System.Diagnostics.Tracing.EventOpcode.Receive> come il <xref:System.Diagnostics.Tracing.EventAttribute.Opcode%2A?displayProperty=nameWithType> proprietà.  
  
3.  Chiamare <xref:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityId%2A> passaggio nel caso in cui ID, aggiungendo il GUID ID correlati, seguito da tutti i parametri del metodo dell'evento viene passato, nello stesso ordine.  
  
 Se `args` è inutilizzato, viene convertito in una matrice vuota per la chiamata risulta a ETW.  
  
   
  
## Examples  
 Esempio di codice seguente mostra come potrebbe essere possibile specificare un'origine evento che chiama <xref:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityId%2A>.  
  
 [!code-csharp[System.Diagnostics.EventSource.WriteEventWithId#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.diagnostics.eventsource.writeeventwithid/cs/program.cs#1)]
 [!code-vb[System.Diagnostics.EventSource.WriteEventWithId#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.diagnostics.eventsource.writeeventwithid/vb/module1.vb#1)]  
[!code-csharp[System.Diagnostics.EventSource.WriteEventWithId#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.diagnostics.eventsource.writeeventwithid/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEventWithRelatedActivityIdCore">
      <MemberSignature Language="C#" Value="protected void WriteEventWithRelatedActivityIdCore (int eventId, Guid* relatedActivityId, int eventDataCount, System.Diagnostics.Tracing.EventSource.EventData* data);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEventWithRelatedActivityIdCore(int32 eventId, valuetype System.Guid* relatedActivityId, int32 eventDataCount, valuetype System.Diagnostics.Tracing.EventSource/EventData* data) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityIdCore(System.Int32,System.Guid*,System.Int32,System.Diagnostics.Tracing.EventSource.EventData*)" FrameworkAlternate="netframework-4.5;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, System::Diagnostics::Tracing::EventSource::EventData* data);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="protected void WriteEventWithRelatedActivityIdCore (int eventId, Guid* childActivityID, int eventDataCount, System.Diagnostics.Tracing.EventSource.EventData* data);" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netstandard-1.2" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteEventWithRelatedActivityIdCore(int32 eventId, valuetype System.Guid* childActivityID, int32 eventDataCount, valuetype System.Diagnostics.Tracing.EventSource/EventData* data) cil managed" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteEventWithRelatedActivityIdCore(int eventId, Guid* childActivityID, int eventDataCount, System::Diagnostics::Tracing::EventSource::EventData* data);" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netstandard-1.2" />
      <MemberSignature Language="F#" Value="member this.WriteEventWithRelatedActivityIdCore : int * nativeptr&lt;Guid&gt; * int * nativeptr&lt;System.Diagnostics.Tracing.EventSource.EventData&gt; -&gt; unit" Usage="eventSource.WriteEventWithRelatedActivityIdCore (eventId, relatedActivityId, eventDataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Tracing</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventId" Type="System.Int32" Index="0" />
        <Parameter Name="relatedActivityId" Type="System.Guid*" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="childActivityID" Type="System.Guid*" Index="1" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netstandard-1.2" />
        <Parameter Name="eventDataCount" Type="System.Int32" Index="2" />
        <Parameter Name="data" Type="System.Diagnostics.Tracing.EventSource+EventData*" Index="3" />
      </Parameters>
      <Docs>
        <param name="eventId">Identificatore che identifica in modo univoco questo evento nell'oggetto <see cref="T:System.Diagnostics.Tracing.EventSource" />.</param>
        <param name="relatedActivityId">Puntatore al GUID dell'ID attività correlato.</param>
        <param name="childActivityID">To be added.</param>
        <param name="eventDataCount">Numero di elementi presenti nel campo <c>dati</c>.</param>
        <param name="data">Puntatore al primo elemento nel campo dati evento.</param>
        <summary>[Supportato in .NET Framework 4.5.1 e versioni successive] 
Scrive un evento che indica che l'attività corrente è correlata a un'altra attività.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityIdCore%2A> è simile al <xref:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityId%2A> metodo ma offre prestazioni migliori, che è necessario eseguire la conversione unboxing bevcause il `childActivityID` e `data` argomenti.  
  
 Il metodo di eventi ETW chiamare questa funzione deve seguire queste linee guida:  
  
1.  Specificare il primo parametro come un <xref:System.Guid> denominato `relatedActivityId`.  
  
2.  Specificare il parametro <xref:System.Diagnostics.Tracing.EventOpcode.Send> oppure <xref:System.Diagnostics.Tracing.EventOpcode.Receive> come il <xref:System.Diagnostics.Tracing.EventAttribute.Opcode%2A?displayProperty=nameWithType> proprietà.  
  
3.  Chiamare <xref:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityIdCore%2A> passaggio nel caso in cui ID, aggiungendo il GUID ID correlati, seguito da tutti i parametri del metodo dell'evento viene passato, nello stesso ordine.  
  
   
  
## Examples  
 Esempio di codice c# seguente viene illustrato come definire un overload del metodo che chiama <xref:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityIdCore%2A>.  
  
 [!code-csharp[System.Diagnostics.EventSource.WriteEventWithId#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.diagnostics.eventsource.writeeventwithid/cs/program.cs#5)]
 [!code-vb[System.Diagnostics.EventSource.WriteEventWithId#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.diagnostics.eventsource.writeeventwithid/vb/module1.vb#5)]  
[!code-csharp[System.Diagnostics.EventSource.WriteEventWithId#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.diagnostics.eventsource.writeeventwithid/cs/program.cs#3)]
[!code-vb[System.Diagnostics.EventSource.WriteEventWithId#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.diagnostics.eventsource.writeeventwithid/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>