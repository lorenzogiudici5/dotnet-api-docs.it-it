<Type Name="PipeStream" FullName="System.IO.Pipes.PipeStream">
  <TypeSignature Language="C#" Value="public abstract class PipeStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PipeStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.PipeStream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PipeStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class PipeStream abstract : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="79a18-101">Espone un oggetto <see cref="T:System.IO.Stream" /> di una pipe, che supporta pipe sia unnamed che named.</span><span class="sxs-lookup"><span data-stu-id="79a18-101">Exposes a <see cref="T:System.IO.Stream" /> object around a pipe, which supports both anonymous and named pipes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-102">La <xref:System.IO.Pipes.PipeStream> classe fornisce la classe di base per le operazioni di unnamed e named pipe in .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="79a18-102">The <xref:System.IO.Pipes.PipeStream> class provides the base class for named and anonymous pipes operations in the .NET Framework.</span></span> <span data-ttu-id="79a18-103">Utilizzare il <xref:System.IO.Pipes.NamedPipeServerStream> e <xref:System.IO.Pipes.NamedPipeClientStream> classi per operazioni di named pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-103">Use the <xref:System.IO.Pipes.NamedPipeServerStream> and <xref:System.IO.Pipes.NamedPipeClientStream> classes for named pipe operations.</span></span> <span data-ttu-id="79a18-104">Utilizzare il <xref:System.IO.Pipes.AnonymousPipeServerStream> e <xref:System.IO.Pipes.AnonymousPipeClientStream> classi per le operazioni di pipe anonime.</span><span class="sxs-lookup"><span data-stu-id="79a18-104">Use the <xref:System.IO.Pipes.AnonymousPipeServerStream> and <xref:System.IO.Pipes.AnonymousPipeClientStream> classes for anonymous pipe operations.</span></span>  
  
 <span data-ttu-id="79a18-105">Per ulteriori informazioni su pipe, vedere [pipe](~/docs/standard/io/pipe-operations.md).</span><span class="sxs-lookup"><span data-stu-id="79a18-105">For more information about pipes, see [Pipes](~/docs/standard/io/pipe-operations.md).</span></span> <span data-ttu-id="79a18-106">Per un esempio di pipe anonime, vedere [procedura: utilizzare le unnamed pipe per la comunicazione locale Interprocess](~/docs/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication.md).</span><span class="sxs-lookup"><span data-stu-id="79a18-106">For an example of anonymous pipes, see [How to: Use Anonymous Pipes for Local Interprocess Communication](~/docs/standard/io/how-to-use-anonymous-pipes-for-local-interprocess-communication.md).</span></span> <span data-ttu-id="79a18-107">Per un esempio di named pipe, vedere [How to: Use Named Pipes per la comunicazione di rete Interprocess](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md).</span><span class="sxs-lookup"><span data-stu-id="79a18-107">For an example of named pipes, see [How to: Use Named Pipes for Network Interprocess Communication](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md).</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="79a18-108">per l'attendibilità totale per gli eredi.</span><span class="sxs-lookup"><span data-stu-id="79a18-108">for full trust for inheritors.</span></span> <span data-ttu-id="79a18-109">Questa classe non può essere ereditata da codice parzialmente attendibile.</span><span class="sxs-lookup"><span data-stu-id="79a18-109">This class cannot be inherited by partially trusted code.</span></span></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79a18-110">Inizializza una nuova istanza della classe <see cref="T:System.IO.Pipes.PipeStream" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-110">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.#ctor(System.IO.Pipes.PipeDirection,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (direction As PipeDirection, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PipeStream(System::IO::Pipes::PipeDirection direction, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="79a18-111">Uno dei valori <see cref="T:System.IO.Pipes.PipeDirection" /> che indica la direzione dell'oggetto pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-111">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="79a18-112">Valore positivo <see cref="T:System.Int32" /> maggiore o uguale a 0, che indica le dimensioni del buffer.</span><span class="sxs-lookup"><span data-stu-id="79a18-112">A positive <see cref="T:System.Int32" /> value greater than or equal to 0 that indicates the buffer size.</span></span></param>
        <summary><span data-ttu-id="79a18-113">Inizializza una nuova istanza della classe <see cref="T:System.IO.Pipes.PipeStream" /> usando il valore e le dimensioni del buffer specificati di <see cref="T:System.IO.Pipes.PipeDirection" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-113">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" /> value and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-114">Questo costruttore utilizza una modalità di trasmissione della pipe di <xref:System.IO.Pipes.PipeTransmissionMode.Byte>.</span><span class="sxs-lookup"><span data-stu-id="79a18-114">This constructor uses a pipe transmission mode of <xref:System.IO.Pipes.PipeTransmissionMode.Byte>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="79a18-115"><paramref name="direction" /> non è un valore valido di <see cref="T:System.IO.Pipes.PipeDirection" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-115"><paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</span></span>  
  
 <span data-ttu-id="79a18-116">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-116">-or-</span></span>  
  
 <span data-ttu-id="79a18-117"><paramref name="bufferSize" /> è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="79a18-117"><paramref name="bufferSize" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PipeStream (System.IO.Pipes.PipeDirection direction, System.IO.Pipes.PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, int32 outBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeTransmissionMode,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (direction As PipeDirection, transmissionMode As PipeTransmissionMode, outBufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PipeStream(System::IO::Pipes::PipeDirection direction, System::IO::Pipes::PipeTransmissionMode transmissionMode, int outBufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="79a18-118">Uno dei valori <see cref="T:System.IO.Pipes.PipeDirection" /> che indica la direzione dell'oggetto pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-118">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</span></span></param>
        <param name="transmissionMode"><span data-ttu-id="79a18-119">Uno dei valori di <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> che indica la modalità di trasmissione dell'oggetto pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-119">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode of the pipe object.</span></span></param>
        <param name="outBufferSize"><span data-ttu-id="79a18-120">Valore positivo <see cref="T:System.Int32" /> maggiore o uguale a 0, che indica le dimensioni del buffer.</span><span class="sxs-lookup"><span data-stu-id="79a18-120">A positive <see cref="T:System.Int32" /> value greater than or equal to 0 that indicates the buffer size.</span></span></param>
        <summary><span data-ttu-id="79a18-121">Inizializza una nuova istanza della classe <see cref="T:System.IO.Pipes.PipeStream" /> usando gli oggetti <see cref="T:System.IO.Pipes.PipeDirection" />, <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> e le dimensioni del buffer specificati.</span><span class="sxs-lookup"><span data-stu-id="79a18-121">Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" />, <see cref="T:System.IO.Pipes.PipeTransmissionMode" />, and buffer size.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="79a18-122"><paramref name="direction" /> non è un valore valido di <see cref="T:System.IO.Pipes.PipeDirection" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-122"><paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</span></span>  
  
 <span data-ttu-id="79a18-123">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-123">-or-</span></span>  
  
 <span data-ttu-id="79a18-124"><paramref name="transmissionMode" /> non è un valore valido di <see cref="T:System.IO.Pipes.PipeTransmissionMode" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-124"><paramref name="transmissionMode" /> is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.</span></span>  
  
 <span data-ttu-id="79a18-125">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-125">-or-</span></span>  
  
 <span data-ttu-id="79a18-126"><paramref name="bufferSize" /> è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="79a18-126"><paramref name="bufferSize" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79a18-127">Buffer in cui leggere i dati.</span><span class="sxs-lookup"><span data-stu-id="79a18-127">The buffer to read data into.</span></span></param>
        <param name="offset"><span data-ttu-id="79a18-128">Offset dei byte in <c>buffer</c> in corrispondenza del quale iniziare la lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-128">The byte offset in <c>buffer</c> at which to begin reading.</span></span></param>
        <param name="count"><span data-ttu-id="79a18-129">Numero massimo di byte da leggere.</span><span class="sxs-lookup"><span data-stu-id="79a18-129">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="79a18-130">Metodo da chiamare quando l'operazione di lettura asincrona viene completata.</span><span class="sxs-lookup"><span data-stu-id="79a18-130">The method to call when the asynchronous read operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="79a18-131">Oggetto fornito dall'utente che distingue questa specifica richiesta di lettura asincrona da altre richieste.</span><span class="sxs-lookup"><span data-stu-id="79a18-131">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="79a18-132">Inizia un'operazione di lettura asincrona.</span><span class="sxs-lookup"><span data-stu-id="79a18-132">Begins an asynchronous read operation.</span></span></summary>
        <returns><span data-ttu-id="79a18-133">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla lettura asincrona.</span><span class="sxs-lookup"><span data-stu-id="79a18-133">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-134">Passare l'oggetto restituito <xref:System.IAsyncResult> dell'oggetto per il <xref:System.IO.Pipes.PipeStream.EndRead%2A> metodo per determinare il numero di byte letti e rilasciare le risorse di sistema operativo utilizzate per la lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-134">Pass the returned <xref:System.IAsyncResult> object to the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="79a18-135"><xref:System.IO.Pipes.PipeStream.EndRead%2A> deve essere chiamato una volta per ogni chiamata a <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-135"><xref:System.IO.Pipes.PipeStream.EndRead%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span> <span data-ttu-id="79a18-136">Questa operazione può essere eseguita nello stesso codice che ha chiamato <xref:System.IO.Pipes.PipeStream.BeginRead%2A> o in un callback che viene passato a <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-136">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginRead%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="79a18-137">Utilizzare il <xref:System.IO.Pipes.PipeStream.CanRead%2A> proprietà per determinare se l'oggetto corrente <xref:System.IO.Pipes.PipeStream> oggetto supporta le operazioni di lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-137">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="79a18-138">Se la pipe è chiusa, oppure un argomento non valido viene passato a <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, le eccezioni appropriate vengono generate immediatamente.</span><span class="sxs-lookup"><span data-stu-id="79a18-138">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="79a18-139">Si verificano errori che si verificano durante una richiesta di lettura asincrona sul thread del pool che sta eseguendo la richiesta.</span><span class="sxs-lookup"><span data-stu-id="79a18-139">Errors that occur during an asynchronous read request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="79a18-140">Le eccezioni vengono generate quando il codice chiama il <xref:System.IO.Pipes.PipeStream.EndRead%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="79a18-140">The exceptions are raised when the code calls the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="79a18-141"><paramref name="buffer" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-141"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="79a18-142"><paramref name="offset" /> è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="79a18-142"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="79a18-143">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-143">-or-</span></span>  
  
 <span data-ttu-id="79a18-144"><paramref name="count" /> è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="79a18-144"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79a18-145"><paramref name="count" /> è maggiore del numero di byte disponibili in <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-145"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-146">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-146">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-147">La pipe non supporta le operazioni di lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-147">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-148">La pipe è disconnessa, in attesa della connessione o l'handle non è stato impostato.</span><span class="sxs-lookup"><span data-stu-id="79a18-148">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-149">La pipe è interrotta oppure si è verificato un altro errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-149">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79a18-150">Buffer che contiene i dati da scrivere nel flusso corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-150">The buffer that contains the data to write to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="79a18-151">Offset di byte in base zero in <c>buffer</c> da cui iniziare la copia dei byte nel flusso corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-151">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="79a18-152">Numero massimo di byte da scrivere.</span><span class="sxs-lookup"><span data-stu-id="79a18-152">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="79a18-153">Metodo da chiamare quando l'operazione di scrittura asincrona viene completata.</span><span class="sxs-lookup"><span data-stu-id="79a18-153">The method to call when the asynchronous write operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="79a18-154">Oggetto fornito dall'utente che distingue questa specifica richiesta di scrittura asincrona da altre richieste.</span><span class="sxs-lookup"><span data-stu-id="79a18-154">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="79a18-155">Inizia un'operazione di scrittura asincrona.</span><span class="sxs-lookup"><span data-stu-id="79a18-155">Begins an asynchronous write operation.</span></span></summary>
        <returns><span data-ttu-id="79a18-156">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento all'operazione di scrittura asincrona.</span><span class="sxs-lookup"><span data-stu-id="79a18-156">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-157"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> deve essere chiamato una volta per ogni chiamata a <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-157"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span> <span data-ttu-id="79a18-158">Questa operazione può essere eseguita nello stesso codice che ha chiamato <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> o in un callback che viene passato a <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-158">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="79a18-159">Utilizzare il <xref:System.IO.Pipes.PipeStream.CanWrite%2A> proprietà per determinare se l'oggetto corrente <xref:System.IO.Pipes.PipeStream> oggetto supporta le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-159">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="79a18-160">Se la pipe è chiusa, oppure un argomento non valido viene passato a <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, le eccezioni appropriate vengono generate immediatamente.</span><span class="sxs-lookup"><span data-stu-id="79a18-160">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="79a18-161">Nel pool di thread che sta eseguendo la richiesta si verificano errori che si verificano durante una richiesta di scrittura asincrona.</span><span class="sxs-lookup"><span data-stu-id="79a18-161">Errors that occur during an asynchronous write request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="79a18-162">Le eccezioni vengono generate quando il codice chiama il <xref:System.IO.Pipes.PipeStream.EndWrite%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="79a18-162">The exceptions are raised when the code calls the  <xref:System.IO.Pipes.PipeStream.EndWrite%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="79a18-163"><paramref name="buffer" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-163"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="79a18-164"><paramref name="offset" /> è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="79a18-164"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="79a18-165">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-165">-or-</span></span>  
  
 <span data-ttu-id="79a18-166"><paramref name="count" /> è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="79a18-166"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79a18-167"><paramref name="count" /> è maggiore del numero di byte disponibili in <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-167"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-168">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-168">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-169">La pipe non supporta le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-169">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-170">La pipe è disconnessa, in attesa della connessione o l'handle non è stato impostato.</span><span class="sxs-lookup"><span data-stu-id="79a18-170">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-171">La pipe è interrotta oppure si è verificato un altro errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-171">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-172">Ottiene un valore che indica se il flusso corrente supporta o meno le operazioni di lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-172">Gets a value indicating whether the current stream supports read operations.</span></span></summary>
        <value>
          <span data-ttu-id="79a18-173"><see langword="true" /> se il flusso supporta le operazioni di lettura; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-173"><see langword="true" /> if the stream supports read operations; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-174">Se il <xref:System.IO.Pipes.PipeStream> oggetto è chiuso, questa proprietà restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="79a18-174">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-175">Ottiene un valore che indica se il flusso corrente supporta o meno le operazioni di ricerca.</span><span class="sxs-lookup"><span data-stu-id="79a18-175">Gets a value indicating whether the current stream supports seek operations.</span></span></summary>
        <value>
          <span data-ttu-id="79a18-176"><see langword="false" /> in tutti i casi.</span><span class="sxs-lookup"><span data-stu-id="79a18-176"><see langword="false" /> in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-177">Se il <xref:System.IO.Pipes.PipeStream> oggetto è chiuso, questa proprietà restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="79a18-177">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-178">Ottiene un valore che indica se il flusso corrente supporta o meno le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-178">Gets a value indicating whether the current stream supports write operations.</span></span></summary>
        <value>
          <span data-ttu-id="79a18-179"><see langword="true" /> se il flusso supporta le operazioni di scrittura; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-179"><see langword="true" /> if the stream supports write operations; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-180">Se il <xref:System.IO.Pipes.PipeStream> oggetto è chiuso, questa proprietà restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="79a18-180">If the <xref:System.IO.Pipes.PipeStream> object is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckPipePropertyOperations">
      <MemberSignature Language="C#" Value="protected internal virtual void CheckPipePropertyOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CheckPipePropertyOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckPipePropertyOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CheckPipePropertyOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CheckPipePropertyOperations();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79a18-181">Verifica che la pipe si trovi in uno stato appropriato per ottenere o impostare le proprietà.</span><span class="sxs-lookup"><span data-stu-id="79a18-181">Verifies that the pipe is in a proper state for getting or setting properties.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckReadOperations">
      <MemberSignature Language="C#" Value="protected internal void CheckReadOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckReadOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckReadOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CheckReadOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CheckReadOperations();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79a18-182">Verifica che la pipe sia connessa per le operazioni di lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-182">Verifies that the pipe is in a connected state for read operations.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckWriteOperations">
      <MemberSignature Language="C#" Value="protected internal void CheckWriteOperations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CheckWriteOperations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.CheckWriteOperations" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CheckWriteOperations ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CheckWriteOperations();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79a18-183">Verifica che la pipe sia connessa per le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-183">Verifies that the pipe is in a connected state for write operations.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="79a18-184"><see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="79a18-184"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="79a18-185">Rilascia le risorse non gestite usate dalla classe <see cref="T:System.IO.Pipes.PipeStream" /> e facoltativamente le risorse gestite.</span><span class="sxs-lookup"><span data-stu-id="79a18-185">Releases the unmanaged resources used by the <see cref="T:System.IO.Pipes.PipeStream" /> class and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-186">Questo metodo viene chiamato dal metodo pubblico <xref:System.ComponentModel.Component.Dispose%2A> (metodo) e <xref:System.Object.Finalize%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="79a18-186">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="79a18-187"><xref:System.ComponentModel.Component.Dispose%2A> richiama il metodo protetto <xref:System.IO.Pipes.PipeStream.Dispose%2A> metodo con il `disposing` parametro impostato su `true`.</span><span class="sxs-lookup"><span data-stu-id="79a18-187"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.Pipes.PipeStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="79a18-188"><xref:System.Object.Finalize%2A> richiama <xref:System.IO.Pipes.PipeStream.Dispose%2A> con `disposing` impostato su `false`.</span><span class="sxs-lookup"><span data-stu-id="79a18-188"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.Pipes.PipeStream.Dispose%2A> with `disposing` set to `false`.</span></span> <span data-ttu-id="79a18-189">Quando il parametro di eliminazione è `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti da questo <xref:System.IO.Pipes.PipeStream> i riferimenti all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="79a18-189">When the disposing parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.Pipes.PipeStream> object references.</span></span> <span data-ttu-id="79a18-190">Il metodo richiama il metodo <xref:System.IO.Pipes.PipeStream.Dispose%2A> di ciascun oggetto cui viene fatto riferimento.</span><span class="sxs-lookup"><span data-stu-id="79a18-190">This method invokes the <xref:System.IO.Pipes.PipeStream.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="79a18-191">Nelle classi derivate, inserire tutte <see cref="T:System.IO.Stream" /> logica di pulizia nel <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> metodo.</span><span class="sxs-lookup"><span data-stu-id="79a18-191">In derived classes, put all <see cref="T:System.IO.Stream" /> cleanup logic in the <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" /> method.</span></span>  
  
 <span data-ttu-id="79a18-192">Il metodo <see cref="M:System.ComponentModel.Component.Dispose" /> può essere chiamato più volte da altri oggetti.</span><span class="sxs-lookup"><span data-stu-id="79a18-192"><see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="79a18-193">In caso di override di <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, non fare riferimento a oggetti già eliminati in una chiamata precedente a <see cref="M:System.ComponentModel.Component.Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-193">When overriding <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="79a18-194">Per ulteriori informazioni su come implementare <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="79a18-194">For more information about how to implement <see cref="M:System.IO.Pipes.PipeStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
 <span data-ttu-id="79a18-195">Per ulteriori informazioni su <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="79a18-195">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="79a18-196">Riferimento alla richiesta asincrona in sospeso.</span><span class="sxs-lookup"><span data-stu-id="79a18-196">The reference to the pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="79a18-197">Termina una richiesta di lettura asincrona in sospeso.</span><span class="sxs-lookup"><span data-stu-id="79a18-197">Ends a pending asynchronous read request.</span></span></summary>
        <returns><span data-ttu-id="79a18-198">Numero di byte letti.</span><span class="sxs-lookup"><span data-stu-id="79a18-198">The number of bytes that were read.</span></span> <span data-ttu-id="79a18-199">Un valore restituito di 0 indica la fine del flusso (la pipe è stata chiusa).</span><span class="sxs-lookup"><span data-stu-id="79a18-199">A return value of 0 indicates the end of the stream (the pipe has been closed).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-200">Questo metodo restituisce il numero di byte letti nella matrice di byte specificata da una chiamata precedente a <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-200">This method returns the number of bytes read into the byte array specified by the earlier call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="79a18-201">Passare l'oggetto restituito <xref:System.IAsyncResult> dell'oggetto per il <xref:System.IO.Pipes.PipeStream.EndRead%2A> metodo per determinare il numero di byte letti e rilasciare le risorse di sistema operativo utilizzate per la lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-201">Pass the returned <xref:System.IAsyncResult> object to the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="79a18-202"><xref:System.IO.Pipes.PipeStream.EndRead%2A> deve essere chiamato una volta per ogni chiamata a <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-202"><xref:System.IO.Pipes.PipeStream.EndRead%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span> <span data-ttu-id="79a18-203">Questa operazione può essere eseguita nello stesso codice che ha chiamato <xref:System.IO.Pipes.PipeStream.BeginRead%2A> o in un callback che viene passato a <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-203">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginRead%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="79a18-204">Utilizzare il <xref:System.IO.Pipes.PipeStream.CanRead%2A> proprietà per determinare se l'oggetto corrente <xref:System.IO.Pipes.PipeStream> oggetto supporta le operazioni di lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-204">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="79a18-205">Se la pipe è chiusa, oppure un argomento non valido viene passato a <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, le eccezioni appropriate vengono generate immediatamente.</span><span class="sxs-lookup"><span data-stu-id="79a18-205">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginRead%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="79a18-206">Si verificano errori che si verificano durante una richiesta di lettura asincrona sul thread del pool che sta eseguendo la richiesta.</span><span class="sxs-lookup"><span data-stu-id="79a18-206">Errors that occur during an asynchronous read request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="79a18-207">Le eccezioni vengono generate quando il codice chiama il <xref:System.IO.Pipes.PipeStream.EndRead%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="79a18-207">The exceptions are raised when the code calls the <xref:System.IO.Pipes.PipeStream.EndRead%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="79a18-208"><paramref name="asyncResult" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-208"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79a18-209"><paramref name="asyncResult" /> non è stato generato da un metodo <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> nel flusso corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-209"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-210">Il flusso è chiuso o si è verificato un errore interno.</span><span class="sxs-lookup"><span data-stu-id="79a18-210">The stream is closed or an internal error has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="79a18-211">Riferimento alla richiesta asincrona in sospeso.</span><span class="sxs-lookup"><span data-stu-id="79a18-211">The reference to the pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="79a18-212">Termina una richiesta di scrittura asincrona in sospeso.</span><span class="sxs-lookup"><span data-stu-id="79a18-212">Ends a pending asynchronous write request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-213"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> deve essere chiamato una volta per ogni chiamata a <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-213"><xref:System.IO.Pipes.PipeStream.EndWrite%2A> must be called once for every call to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span> <span data-ttu-id="79a18-214">Questa operazione può essere eseguita nello stesso codice che ha chiamato <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> o in un callback che viene passato a <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-214">This can be done either in the same code that called <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> or in a callback that is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="79a18-215">Utilizzare il <xref:System.IO.Pipes.PipeStream.CanWrite%2A> proprietà per determinare se l'oggetto corrente <xref:System.IO.Pipes.PipeStream> oggetto supporta le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-215">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="79a18-216">Se la pipe è chiusa, oppure un argomento non valido viene passato a <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, le eccezioni appropriate vengono generate immediatamente.</span><span class="sxs-lookup"><span data-stu-id="79a18-216">If the pipe is closed or an invalid argument is passed to <xref:System.IO.Pipes.PipeStream.BeginWrite%2A>, the appropriate exceptions are raised immediately.</span></span> <span data-ttu-id="79a18-217">Nel pool di thread che sta eseguendo la richiesta si verificano errori che si verificano durante una richiesta di scrittura asincrona.</span><span class="sxs-lookup"><span data-stu-id="79a18-217">Errors that occur during an asynchronous write request occur on the thread pool thread that is performing the request.</span></span> <span data-ttu-id="79a18-218">Le eccezioni vengono generate quando il codice le chiamate <xref:System.IO.Pipes.PipeStream.EndWrite%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="79a18-218">The exceptions are raised when the code the calls <xref:System.IO.Pipes.PipeStream.EndWrite%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="79a18-219"><paramref name="asyncResult" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-219"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79a18-220"><paramref name="asyncResult" /> non è stato generato da un metodo <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> nel flusso corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-220"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-221">Il flusso è chiuso o si è verificato un errore interno.</span><span class="sxs-lookup"><span data-stu-id="79a18-221">The stream is closed or an internal error has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79a18-222">Cancella i dati del buffer del flusso corrente e consente la scrittura dei dati memorizzati nel buffer nel dispositivo sottostante.</span><span class="sxs-lookup"><span data-stu-id="79a18-222">Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-223">Il <xref:System.IO.Pipes.PipeStream.Flush%2A> metodo non è supportato nel <xref:System.IO.Pipes.PipeStream> classe e non nothing quando viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="79a18-223">The <xref:System.IO.Pipes.PipeStream.Flush%2A> method is not supported in the <xref:System.IO.Pipes.PipeStream> class and does nothing when it is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-224">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-224">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-225">La pipe non supporta le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-225">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-226">La pipe è interrotta oppure si è verificato un altro errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-226">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.Pipes.PipeSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Pipes.PipeSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As PipeSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Pipes::PipeSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79a18-227">Ottiene un oggetto <see cref="T:System.IO.Pipes.PipeSecurity" /> che incapsula le voci dell'elenco di controllo di accesso (ACL) per la pipe descritta dall'oggetto <see cref="T:System.IO.Pipes.PipeStream" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-227">Gets a <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <returns><span data-ttu-id="79a18-228">Oggetto <see cref="T:System.IO.Pipes.PipeSecurity" /> che incapsula le voci dell'elenco di controllo di accesso (ACL) per la pipe descritta dall'oggetto <see cref="T:System.IO.Pipes.PipeStream" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-228">A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-229">Un elenco di controllo di accesso (ACL) descrive i singoli utenti o gruppi che hanno o non si dispone dei diritti per eseguire azioni specifiche in un file specificato.</span><span class="sxs-lookup"><span data-stu-id="79a18-229">An access control list (ACL) describes individuals and/or groups that have, or do not have, rights to perform specific actions on a specified file.</span></span> <span data-ttu-id="79a18-230">Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span><span class="sxs-lookup"><span data-stu-id="79a18-230">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-231">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-231">The pipe is closed.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="79a18-232">La chiamata sottostante per impostare le informazioni di sicurezza non è riuscita.</span><span class="sxs-lookup"><span data-stu-id="79a18-232">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-233">La chiamata sottostante per impostare le informazioni di sicurezza non è riuscita.</span><span class="sxs-lookup"><span data-stu-id="79a18-233">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-234">La chiamata sottostante per impostare le informazioni di sicurezza non è riuscita.</span><span class="sxs-lookup"><span data-stu-id="79a18-234">The underlying call to set security information failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="InBufferSize">
      <MemberSignature Language="C#" Value="public virtual int InBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.InBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property InBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int InBufferSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-235">Ottiene la dimensione, in byte, del buffer in ingresso per una pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-235">Gets the size, in bytes, of the inbound buffer for a pipe.</span></span></summary>
        <value><span data-ttu-id="79a18-236">Valore intero che rappresenta le dimensioni del buffer in ingresso, in byte.</span><span class="sxs-lookup"><span data-stu-id="79a18-236">An integer value that represents the inbound buffer size, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-237">Se <xref:System.IO.Pipes.PipeStream.InBufferSize%2A> è 0, la dimensione del buffer viene allocata in base alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="79a18-237">If <xref:System.IO.Pipes.PipeStream.InBufferSize%2A> is 0, the buffer size is allocated as needed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-238">Il flusso è illeggibile.</span><span class="sxs-lookup"><span data-stu-id="79a18-238">The stream is unreadable.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-239">La pipe è in attesa di connessione.</span><span class="sxs-lookup"><span data-stu-id="79a18-239">The pipe is waiting to connect.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-240">La pipe è interrotta oppure si è verificato un altro errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-240">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeHandle">
      <MemberSignature Language="C#" Value="protected void InitializeHandle (Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeHandle(class Microsoft.Win32.SafeHandles.SafePipeHandle handle, bool isExposed, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.InitializeHandle(Microsoft.Win32.SafeHandles.SafePipeHandle,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeHandle (handle As SafePipeHandle, isExposed As Boolean, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeHandle(Microsoft::Win32::SafeHandles::SafePipeHandle ^ handle, bool isExposed, bool isAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
        <Parameter Name="isExposed" Type="System.Boolean" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="79a18-241">Oggetto <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> della pipe da inizializzare.</span><span class="sxs-lookup"><span data-stu-id="79a18-241">The <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object of the pipe to initialize.</span></span></param>
        <param name="isExposed">
          <span data-ttu-id="79a18-242"><see langword="true" /> per esporre l'handle; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-242"><see langword="true" /> to expose the handle; otherwise, <see langword="false" />.</span></span></param>
        <param name="isAsync">
          <span data-ttu-id="79a18-243"><see langword="true" /> per indicare che l'handle è stato aperto in modo asincrono; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-243"><see langword="true" /> to indicate that the handle was opened asynchronously; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="79a18-244">Inizializza un oggetto <see cref="T:System.IO.Pipes.PipeStream" /> dall'oggetto <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> specificato.</span><span class="sxs-lookup"><span data-stu-id="79a18-244">Initializes a <see cref="T:System.IO.Pipes.PipeStream" /> object from the specified <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-245">Se la pipe è in uno stato di connessione, questo metodo imposta inoltre il <xref:System.IO.Pipes.PipeStream.IsConnected%2A> proprietà `true`.</span><span class="sxs-lookup"><span data-stu-id="79a18-245">If the pipe is in a connected state, this method also sets the <xref:System.IO.Pipes.PipeStream.IsConnected%2A> property to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-246">Impossibile associare un handle alla pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-246">A handle cannot be bound to the pipe.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-247">Ottiene un valore che indica se un oggetto <see cref="T:System.IO.Pipes.PipeStream" /> è stato aperto in modalità sincrona o asincrona.</span><span class="sxs-lookup"><span data-stu-id="79a18-247">Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously or synchronously.</span></span></summary>
        <value>
          <span data-ttu-id="79a18-248"><see langword="true" /> se l'oggetto <see cref="T:System.IO.Pipes.PipeStream" /> è stato aperto in modalità asincrona; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-248"><see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-249">Questa proprietà consente l'utilizzo nel codice il <xref:System.IO.Pipes.PipeStream.SafePipeHandle%2A> proprietà correttamente.</span><span class="sxs-lookup"><span data-stu-id="79a18-249">This property enables your code to use the <xref:System.IO.Pipes.PipeStream.SafePipeHandle%2A> property correctly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConnected">
      <MemberSignature Language="C#" Value="public bool IsConnected { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConnected" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Property IsConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:  property bool IsConnected {  public:&#xA;bool get(); protected:&#xA; void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-250">Ottiene o imposta un valore che indica se un oggetto <see cref="T:System.IO.Pipes.PipeStream" /> è connesso.</span><span class="sxs-lookup"><span data-stu-id="79a18-250">Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object is connected.</span></span></summary>
        <value>
          <span data-ttu-id="79a18-251"><see langword="true" /> se l'oggetto <see cref="T:System.IO.Pipes.PipeStream" /> è connesso; in caso contrario <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-251"><see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object is connected; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-252">Il <xref:System.IO.Pipes.PipeStream.IsConnected%2A> restituisce proprietà `true` solo se il <xref:System.IO.Pipes.PipeStream> è connesso l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="79a18-252">The <xref:System.IO.Pipes.PipeStream.IsConnected%2A> property returns `true` only if the <xref:System.IO.Pipes.PipeStream> object is connected.</span></span> <span data-ttu-id="79a18-253">Se questa proprietà restituisce `false`, la pipe può essere in attesa della connessione, può essere disconnesso, chiuso o interrotta.</span><span class="sxs-lookup"><span data-stu-id="79a18-253">If this property returns `false`, the pipe may be waiting to connect, or may be disconnected, closed, or broken.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHandleExposed">
      <MemberSignature Language="C#" Value="protected bool IsHandleExposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleExposed" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsHandleExposed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsHandleExposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsHandleExposed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-254">Ottiene un valore che indica se viene esposto un handle a un oggetto <see cref="T:System.IO.Pipes.PipeStream" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-254">Gets a value indicating whether a handle to a <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed.</span></span></summary>
        <value>
          <span data-ttu-id="79a18-255"><see langword="true" /> se viene esposto l'handle all'oggetto <see cref="T:System.IO.Pipes.PipeStream" />, in caso contrario <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-255"><see langword="true" /> if a handle to the <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-256">Il valore di questa proprietà è impostato quando si ottiene un handle alla pipe incapsulata dall'oggetto corrente <xref:System.IO.Pipes.PipeStream> oggetto.</span><span class="sxs-lookup"><span data-stu-id="79a18-256">The value of this property is set when obtaining a handle to the pipe that is encapsulated by the current <xref:System.IO.Pipes.PipeStream> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMessageComplete">
      <MemberSignature Language="C#" Value="public bool IsMessageComplete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMessageComplete" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.IsMessageComplete" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMessageComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMessageComplete { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-257">Ottiene un valore indica se esistono altri dati nel messaggio restituito dalla più recente operazione di lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-257">Gets a value indicating whether there is more data in the message returned from the most recent read operation.</span></span></summary>
        <value>
          <span data-ttu-id="79a18-258"><see langword="true" /> se non ci sono più caratteri da leggere nel messaggio; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-258"><see langword="true" /> if there are no more characters to read in the message; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-259">Questa proprietà è rilevante se la pipe <xref:System.IO.Pipes.PipeStream.ReadMode%2A> è stata impostata su <xref:System.IO.Pipes.PipeTransmissionMode.Message> dell'ultima chiamata a <xref:System.IO.Pipes.PipeStream.Read%2A> o <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-259">This property is relevant if the pipe's <xref:System.IO.Pipes.PipeStream.ReadMode%2A> property was set to <xref:System.IO.Pipes.PipeTransmissionMode.Message> by the most recent call to <xref:System.IO.Pipes.PipeStream.Read%2A> or <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-260">La pipe non è connessa.</span><span class="sxs-lookup"><span data-stu-id="79a18-260">The pipe is not connected.</span></span>  
  
 <span data-ttu-id="79a18-261">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-261">-or-</span></span>  
  
 <span data-ttu-id="79a18-262">L'handle di pipe non è stato impostato.</span><span class="sxs-lookup"><span data-stu-id="79a18-262">The pipe handle has not been set.</span></span>  
  
 <span data-ttu-id="79a18-263">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-263">-or-</span></span>  
  
 <span data-ttu-id="79a18-264">Il valore della proprietà <see cref="P:System.IO.Pipes.PipeStream.ReadMode" /> della pipe non è <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-264">The pipe's <see cref="P:System.IO.Pipes.PipeStream.ReadMode" /> property value is not <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-265">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-265">The pipe is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-266">Ottiene la lunghezza di un flusso, in byte.</span><span class="sxs-lookup"><span data-stu-id="79a18-266">Gets the length of a stream, in bytes.</span></span></summary>
        <value><span data-ttu-id="79a18-267">0 in tutti i casi.</span><span class="sxs-lookup"><span data-stu-id="79a18-267">0 in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-268">La classe <xref:System.IO.Pipes.PipeStream> non supporta la proprietà <xref:System.IO.Pipes.PipeStream.Length%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-268">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.Length%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-269">Sempre generato.</span><span class="sxs-lookup"><span data-stu-id="79a18-269">Always thrown.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OutBufferSize">
      <MemberSignature Language="C#" Value="public virtual int OutBufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.OutBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OutBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int OutBufferSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-270">Ottiene la dimensione, in byte, del buffer in uscita per una pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-270">Gets the size, in bytes, of the outbound buffer for a pipe.</span></span></summary>
        <value><span data-ttu-id="79a18-271">Dimensioni del buffer in uscita, in byte.</span><span class="sxs-lookup"><span data-stu-id="79a18-271">The outbound buffer size, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-272">Se <xref:System.IO.Pipes.PipeStream.OutBufferSize%2A> è 0, la dimensione del buffer viene allocata in base alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="79a18-272">If <xref:System.IO.Pipes.PipeStream.OutBufferSize%2A> is 0, the buffer size is allocated as needed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-273">Impossibile scrivere nel flusso.</span><span class="sxs-lookup"><span data-stu-id="79a18-273">The stream is unwriteable.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-274">La pipe è in attesa di connessione.</span><span class="sxs-lookup"><span data-stu-id="79a18-274">The pipe is waiting to connect.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-275">La pipe è interrotta oppure si è verificato un altro errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-275">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-276">Ottiene o imposta la posizione corrente dell'attuale flusso.</span><span class="sxs-lookup"><span data-stu-id="79a18-276">Gets or sets the current position of the current stream.</span></span></summary>
        <value><span data-ttu-id="79a18-277">0 in tutti i casi.</span><span class="sxs-lookup"><span data-stu-id="79a18-277">0 in all cases.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-278">La classe <xref:System.IO.Pipes.PipeStream> non supporta la proprietà <xref:System.IO.Pipes.PipeStream.Position%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-278">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.Position%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-279">Sempre generato.</span><span class="sxs-lookup"><span data-stu-id="79a18-279">Always thrown.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([in]unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79a18-280">Quando questo metodo viene restituito, contiene la matrice di byte specificata con i valori compresi tra <c>offset</c> e (<c>offset</c> + <c>count</c> - 1) sostituiti con i byte letti dall'origine corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-280">When this method returns, contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c> - 1) replaced by the bytes read from the current source.</span></span></param>
        <param name="offset"><span data-ttu-id="79a18-281">Offset di byte nella matrice <c>buffer</c> in corrispondenza del quale verranno inseriti i byte letti.</span><span class="sxs-lookup"><span data-stu-id="79a18-281">The byte offset in the <c>buffer</c> array at which the bytes that are read will be placed.</span></span></param>
        <param name="count"><span data-ttu-id="79a18-282">Numero massimo di byte da leggere.</span><span class="sxs-lookup"><span data-stu-id="79a18-282">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="79a18-283">Legge un blocco di byte da un flusso e scrive i dati in un buffer specificato.</span><span class="sxs-lookup"><span data-stu-id="79a18-283">Reads a block of bytes from a stream and writes the data to a specified buffer.</span></span></summary>
        <returns><span data-ttu-id="79a18-284">Il numero complessivo di byte letti in <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-284">The total number of bytes that are read into <paramref name="buffer" />.</span></span> <span data-ttu-id="79a18-285">È possibile che questo numero sia inferiore a quello dei byte richiesti se tale quantità di byte non è attualmente disponibile oppure 0 se è stata raggiunta la fine del flusso.</span><span class="sxs-lookup"><span data-stu-id="79a18-285">This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-286">Utilizzare il <xref:System.IO.Pipes.PipeStream.CanRead%2A> proprietà per determinare se l'oggetto corrente <xref:System.IO.Pipes.PipeStream> oggetto supporta le operazioni di lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-286">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 <span data-ttu-id="79a18-287">La chiamata di <xref:System.IO.Pipes.PipeStream.Read%2A> metodo si blocca fino a `count` vengono letti i byte o viene raggiunta la fine del flusso.</span><span class="sxs-lookup"><span data-stu-id="79a18-287">Calling the <xref:System.IO.Pipes.PipeStream.Read%2A> method blocks until `count` bytes are read or the end of the stream is reached.</span></span> <span data-ttu-id="79a18-288">Per le operazioni di lettura asincrona, vedere <xref:System.IO.Pipes.PipeStream.BeginRead%2A> e <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-288">For asynchronous read operations, see <xref:System.IO.Pipes.PipeStream.BeginRead%2A> and <xref:System.IO.Pipes.PipeStream.EndRead%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79a18-289">L'esempio seguente crea un pipe anonime client e il server pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-289">The following example creates an anonymous pipe client and pipe server.</span></span> <span data-ttu-id="79a18-290">Il server pipe utilizza il <xref:System.IO.Pipes.PipeStream.Read%2A> metodo per leggere una serie di byte dal client pipe come codice di convalida.</span><span class="sxs-lookup"><span data-stu-id="79a18-290">The pipe server uses the <xref:System.IO.Pipes.PipeStream.Read%2A> method to read a series of bytes from the pipe client as a validation code.</span></span> <span data-ttu-id="79a18-291">Il client sia nel server pipe fanno parte dell'esempio stesso.</span><span class="sxs-lookup"><span data-stu-id="79a18-291">Both the pipe client and the pipe server are part of the same example.</span></span> <span data-ttu-id="79a18-292">La parte del server dell'esempio creato un processo client e passa un handle di pipe anonime come argomento.</span><span class="sxs-lookup"><span data-stu-id="79a18-292">The server portion of the example creates a client process and passes it an anonymous pipe handle as an argument.</span></span>  
  
 [!code-cpp[System.IO.Pipes.PipeStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.io.pipes.pipestream/cpp/sample.cpp#1)]
 [!code-csharp[System.IO.Pipes.PipeStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.pipes.pipestream/cs/sample.cs#1)]
 [!code-vb[System.IO.Pipes.PipeStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.pipes.pipestream/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="79a18-293"><paramref name="buffer" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-293"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="79a18-294"><paramref name="offset" /> è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="79a18-294"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="79a18-295">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-295">-or-</span></span>  
  
 <span data-ttu-id="79a18-296"><paramref name="count" /> è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="79a18-296"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79a18-297"><paramref name="count" /> è maggiore del numero di byte disponibili in <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-297"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-298">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-298">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-299">La pipe non supporta le operazioni di lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-299">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-300">La pipe è disconnessa, in attesa della connessione o l'handle non è stato impostato.</span><span class="sxs-lookup"><span data-stu-id="79a18-300">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-301">Errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-301">Any I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79a18-302">Legge un byte da una pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-302">Reads a byte from a pipe.</span></span></summary>
        <returns><span data-ttu-id="79a18-303">Byte, cast a <see cref="T:System.Int32" /> o -1 indica che è stata raggiunta la fine del flusso (la pipe è stata chiusa).</span><span class="sxs-lookup"><span data-stu-id="79a18-303">The byte, cast to <see cref="T:System.Int32" />, or -1 indicates the end of the stream (the pipe has been closed).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-304">Utilizzare il <xref:System.IO.Pipes.PipeStream.CanRead%2A> proprietà per determinare se l'oggetto corrente <xref:System.IO.Pipes.PipeStream> oggetto supporta le operazioni di lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-304">Use the <xref:System.IO.Pipes.PipeStream.CanRead%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports read operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-305">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-305">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-306">La pipe non supporta le operazioni di lettura.</span><span class="sxs-lookup"><span data-stu-id="79a18-306">The pipe does not support read operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-307">La pipe è disconnessa, in attesa della connessione o l'handle non è stato impostato.</span><span class="sxs-lookup"><span data-stu-id="79a18-307">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-308">Errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-308">Any I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode ReadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode ReadMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.ReadMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode ReadMode { System::IO::Pipes::PipeTransmissionMode get(); void set(System::IO::Pipes::PipeTransmissionMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-309">Ottiene o imposta la modalità di lettura per un oggetto <see cref="T:System.IO.Pipes.PipeStream" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-309">Gets or sets the reading mode for a <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <value><span data-ttu-id="79a18-310">Uno dei valori <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> che indica come l'oggetto <see cref="T:System.IO.Pipes.PipeStream" /> esegue la lettura dalla pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-310">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates how the <see cref="T:System.IO.Pipes.PipeStream" /> object reads from the pipe.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-311">Le unnamed pipe non supportano <xref:System.IO.Pipes.PipeTransmissionMode.Message> la trasmissione di messaggi in modalità.</span><span class="sxs-lookup"><span data-stu-id="79a18-311">Anonymous pipes do not support <xref:System.IO.Pipes.PipeTransmissionMode.Message> mode message transmission.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79a18-312">Il valore specificato non è un valore <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> valido.</span><span class="sxs-lookup"><span data-stu-id="79a18-312">The supplied value is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-313">Il valore specificato non è un valore <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> supportato per questo flusso di pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-313">The supplied value is not a supported <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value for this pipe stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-314">L'handle non è stato impostato.</span><span class="sxs-lookup"><span data-stu-id="79a18-314">The handle has not been set.</span></span>  
  
 <span data-ttu-id="79a18-315">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-315">-or-</span></span>  
  
 <span data-ttu-id="79a18-316">La pipe è in attesa di connessione con un client denominato.</span><span class="sxs-lookup"><span data-stu-id="79a18-316">The pipe is waiting to connect with a named client.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-317">La pipe è interrotta oppure si è verificato un altro errore di I/O con un client denominato.</span><span class="sxs-lookup"><span data-stu-id="79a18-317">The pipe is broken or an I/O error occurred with a named client.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SafePipeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafePipeHandle SafePipeHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.SafePipeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafePipeHandle As SafePipeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafePipeHandle ^ SafePipeHandle { Microsoft::Win32::SafeHandles::SafePipeHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafePipeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-318">Ottiene l'handle sicuro per l'estremità locale della pipe incapsulata dall'oggetto <see cref="T:System.IO.Pipes.PipeStream" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-318">Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="79a18-319">Oggetto <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> per la pipe che viene incapsulata dall'oggetto <see cref="T:System.IO.Pipes.PipeStream" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-319">A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-320">L'handle di pipe non è stato impostato.</span><span class="sxs-lookup"><span data-stu-id="79a18-320">The pipe handle has not been set.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-321">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-321">The pipe is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="79a18-322">Punto rispetto a <c>origin</c> da cui avviare la ricerca.</span><span class="sxs-lookup"><span data-stu-id="79a18-322">The point, relative to <c>origin</c>, to begin seeking from.</span></span></param>
        <param name="origin"><span data-ttu-id="79a18-323">Specifica l'inizio, la fine o la posizione corrente come punto di riferimento per <c>offset</c>, usando un valore di tipo <see cref="T:System.IO.SeekOrigin" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-323">Specifies the beginning, the end, or the current position as a reference point for <c>offset</c>, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span></span></param>
        <summary><span data-ttu-id="79a18-324">Imposta la posizione corrente dell'attuale flusso sul valore specificato.</span><span class="sxs-lookup"><span data-stu-id="79a18-324">Sets the current position of the current stream to the specified value.</span></span></summary>
        <returns><span data-ttu-id="79a18-325">Nuova posizione all'interno del flusso.</span><span class="sxs-lookup"><span data-stu-id="79a18-325">The new position in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-326">Il <xref:System.IO.Pipes.PipeStream.Seek%2A> metodo non è supportato nelle pipe e genera un <xref:System.NotSupportedException> quando viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="79a18-326">The <xref:System.IO.Pipes.PipeStream.Seek%2A> method is not supported in pipes and raises a <xref:System.NotSupportedException> when it is called.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.SetAccessControl(System.IO.Pipes.PipeSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::Pipes::PipeSecurity ^ pipeSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
      </Parameters>
      <Docs>
        <param name="pipeSecurity"><span data-ttu-id="79a18-327">Oggetto <see cref="T:System.IO.Pipes.PipeSecurity" /> che specifica una voce dell’elenco di controllo di accesso (ACL) da applicare alla pipe corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-327">A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that specifies an access control list (ACL) entry to apply to the current pipe.</span></span></param>
        <summary><span data-ttu-id="79a18-328">Applica le voci dell'elenco di controllo di accesso (ACL) specificate da un oggetto <see cref="T:System.IO.Pipes.PipeSecurity" /> nella pipe specificata dall'oggetto <see cref="T:System.IO.Pipes.PipeStream" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-328">Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" /> object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-329">Un elenco di controllo di accesso (ACL) descrive i singoli utenti o gruppi che hanno o non si dispone dei diritti per eseguire azioni specifiche in un file specificato.</span><span class="sxs-lookup"><span data-stu-id="79a18-329">An access control list (ACL) describes individuals and/or groups that have, or do not have, rights to perform specific actions on a specified file.</span></span> <span data-ttu-id="79a18-330">Per altre informazioni, vedere [Procedura: aggiungere o rimuovere voci dell'elenco di controllo di accesso (ACL)](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span><span class="sxs-lookup"><span data-stu-id="79a18-330">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-331">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-331">The pipe is closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="79a18-332"><paramref name="pipeSecurity" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-332"><paramref name="pipeSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="79a18-333">La chiamata sottostante per impostare le informazioni di sicurezza non è riuscita.</span><span class="sxs-lookup"><span data-stu-id="79a18-333">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-334">La chiamata sottostante per impostare le informazioni di sicurezza non è riuscita.</span><span class="sxs-lookup"><span data-stu-id="79a18-334">The underlying call to set security information failed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-335">La chiamata sottostante per impostare le informazioni di sicurezza non è riuscita.</span><span class="sxs-lookup"><span data-stu-id="79a18-335">The underlying call to set security information failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="79a18-336">Nuova lunghezza del flusso.</span><span class="sxs-lookup"><span data-stu-id="79a18-336">The new length of the stream.</span></span></param>
        <summary><span data-ttu-id="79a18-337">Imposta la lunghezza del flusso corrente sul valore specificato.</span><span class="sxs-lookup"><span data-stu-id="79a18-337">Sets the length of the current stream to the specified value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-338">Il <xref:System.IO.Pipes.PipeStream> classe non supporta il <xref:System.IO.Pipes.PipeStream.SetLength%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="79a18-338">The <xref:System.IO.Pipes.PipeStream> class does not support the <xref:System.IO.Pipes.PipeStream.SetLength%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransmissionMode">
      <MemberSignature Language="C#" Value="public virtual System.IO.Pipes.PipeTransmissionMode TransmissionMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Pipes.PipeTransmissionMode TransmissionMode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Pipes.PipeStream.TransmissionMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TransmissionMode As PipeTransmissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Pipes::PipeTransmissionMode TransmissionMode { System::IO::Pipes::PipeTransmissionMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Pipes.PipeTransmissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79a18-339">Ottiene la modalità di trasmissione della pipe supportata dalla pipe corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-339">Gets the pipe transmission mode supported by the current pipe.</span></span></summary>
        <value><span data-ttu-id="79a18-340">Uno dei valori di <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> che indica la modalità di trasmissione supportata dalla pipe corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-340">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode supported by the current pipe.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-341">Le unnamed pipe non supportano <xref:System.IO.Pipes.PipeTransmissionMode.Message> la trasmissione di messaggi in modalità.</span><span class="sxs-lookup"><span data-stu-id="79a18-341">Anonymous pipes do not support <xref:System.IO.Pipes.PipeTransmissionMode.Message> mode message transmission.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-342">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-342">The pipe is closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-343">L'handle non è stato impostato.</span><span class="sxs-lookup"><span data-stu-id="79a18-343">The handle has not been set.</span></span>  
  
 <span data-ttu-id="79a18-344">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-344">-or-</span></span>  
  
 <span data-ttu-id="79a18-345">La pipe è in attesa della connessione in un'operazione client/server anonima o con client denominato.</span><span class="sxs-lookup"><span data-stu-id="79a18-345">The pipe is waiting to connect in an anonymous client/server operation or with a named client.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-346">La pipe è interrotta oppure si è verificato un altro errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-346">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForPipeDrain">
      <MemberSignature Language="C#" Value="public void WaitForPipeDrain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForPipeDrain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WaitForPipeDrain" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForPipeDrain ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForPipeDrain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79a18-347">Aspetta l'altra estremità della pipe per leggere tutti i byte inviati.</span><span class="sxs-lookup"><span data-stu-id="79a18-347">Waits for the other end of the pipe to read all sent bytes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-348">Il <xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A> metodo si blocca fino a altra estremità della pipe ha letto tutti i byte inviati.</span><span class="sxs-lookup"><span data-stu-id="79a18-348">The <xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A> method blocks until the other end of the pipe has read all sent bytes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-349">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-349">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-350">La pipe non supporta le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-350">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-351">La pipe è interrotta oppure si è verificato un altro errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-351">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79a18-352">Buffer che contiene i dati da scrivere nella pipe.</span><span class="sxs-lookup"><span data-stu-id="79a18-352">The buffer that contains data to write to the pipe.</span></span></param>
        <param name="offset"><span data-ttu-id="79a18-353">Offset di byte in base zero in <c>buffer</c> da cui iniziare la copia dei byte nel flusso corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-353">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="79a18-354">Numero massimo di byte da scrivere nel flusso corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-354">The maximum number of bytes to write to the current stream.</span></span></param>
        <summary><span data-ttu-id="79a18-355">Scrive un blocco di byte nel flusso corrente usando dati da un buffer.</span><span class="sxs-lookup"><span data-stu-id="79a18-355">Writes a block of bytes to the current stream using data from a buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-356">Utilizzare il <xref:System.IO.Pipes.PipeStream.CanWrite%2A> proprietà per determinare se l'oggetto corrente <xref:System.IO.Pipes.PipeStream> oggetto supporta le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-356">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 <span data-ttu-id="79a18-357">La chiamata di <xref:System.IO.Pipes.PipeStream.Write%2A> metodo si blocca fino a `count` vengono letti i byte o viene raggiunta la fine del flusso.</span><span class="sxs-lookup"><span data-stu-id="79a18-357">Calling the <xref:System.IO.Pipes.PipeStream.Write%2A> method blocks until `count` bytes are read or the end of the stream is reached.</span></span> <span data-ttu-id="79a18-358">Per le operazioni di lettura asincrona, vedere <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> e <xref:System.IO.Pipes.PipeStream.EndWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="79a18-358">For asynchronous read operations, see <xref:System.IO.Pipes.PipeStream.BeginWrite%2A> and <xref:System.IO.Pipes.PipeStream.EndWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="79a18-359"><paramref name="buffer" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-359"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="79a18-360"><paramref name="offset" /> è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="79a18-360"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="79a18-361">oppure</span><span class="sxs-lookup"><span data-stu-id="79a18-361">-or-</span></span>  
  
 <span data-ttu-id="79a18-362"><paramref name="count" /> è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="79a18-362"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79a18-363"><paramref name="count" /> è maggiore del numero di byte disponibili in <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="79a18-363"><paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-364">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-364">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-365">La pipe non supporta le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-365">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-366">La pipe è interrotta oppure si è verificato un altro errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-366">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.PipeStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="79a18-367">Byte da scrivere nel flusso.</span><span class="sxs-lookup"><span data-stu-id="79a18-367">The byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="79a18-368">Scrive un byte nel flusso corrente.</span><span class="sxs-lookup"><span data-stu-id="79a18-368">Writes a byte to the current stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79a18-369">Utilizzare il <xref:System.IO.Pipes.PipeStream.CanWrite%2A> proprietà per determinare se l'oggetto corrente <xref:System.IO.Pipes.PipeStream> oggetto supporta le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-369">Use the <xref:System.IO.Pipes.PipeStream.CanWrite%2A> property to determine whether the current <xref:System.IO.Pipes.PipeStream> object supports write operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79a18-370">La pipe è chiusa.</span><span class="sxs-lookup"><span data-stu-id="79a18-370">The pipe is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79a18-371">La pipe non supporta le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="79a18-371">The pipe does not support write operations.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79a18-372">La pipe è disconnessa, in attesa della connessione o l'handle non è stato impostato.</span><span class="sxs-lookup"><span data-stu-id="79a18-372">The pipe is disconnected, waiting to connect, or the handle has not been set.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79a18-373">La pipe è interrotta oppure si è verificato un altro errore di I/O.</span><span class="sxs-lookup"><span data-stu-id="79a18-373">The pipe is broken or another I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>