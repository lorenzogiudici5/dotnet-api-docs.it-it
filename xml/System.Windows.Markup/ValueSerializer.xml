<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="deb82c5b53a5c55ea081cfeba0b39c6ff4cbc1bc" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37502620" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <TypeSignature Language="F#" Value="type ValueSerializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Classe astratta che definisce il comportamento di conversione per la serializzazione da una rappresentazione di oggetto.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La stringa restituita da un convertitore per la serializzazione deve essere senza perdita di dati e il convertitore deve restituire sempre la stessa stringa di un valore specifico.  Se un convertitore di tipi (derivata da <xref:System.ComponentModel.TypeConverter>) non soddisfa questi requisiti nel relativo `ConvertTo` implementazioni per output di tipo stringa, un oggetto personalizzato <xref:System.Windows.Markup.ValueSerializer> deve essere dichiarato. Entrambi i <xref:System.Windows.Markup.ValueSerializer> deve soddisfare i requisiti, o un valore null <xref:System.Windows.Markup.ValueSerializer> deve essere associata al tipo. Oggetto <xref:System.Windows.Markup.ValueSerializer> viene associata a un tipo applicando il <xref:System.Windows.Markup.ValueSerializerAttribute> attributo.  
  
 Un valore null <xref:System.Windows.Markup.ValueSerializer> indica il convertitore di tipi deve essere ignorato per le conversioni a convert-string nell'oggetto grafico.  
  
> [!IMPORTANT]
>  Implementazione di <xref:System.Windows.Markup.ValueSerializer> non deve generare eccezioni. Tutte le eccezioni generate è stato possibile terminare la serializzazione.  
  
 <xref:System.Windows.Markup.IValueSerializerContext> per un <xref:System.Windows.Markup.ValueSerializer> e le relative API sono analoga a <xref:System.ComponentModel.ITypeDescriptorContext> per un <xref:System.ComponentModel.TypeConverter>. In realtà <xref:System.Windows.Markup.IValueSerializerContext> eredita <xref:System.ComponentModel.ITypeDescriptorContext>. Quando un <xref:System.Windows.Markup.ValueSerializer> API della classe derivata viene chiamato, il chiamante (in genere un processo di serializzatore) passa un contesto che può fornire determinati servizi. A causa di linee guida generali che un <xref:System.Windows.Markup.ValueSerializer> non devono generare eccezioni. Mancata restituzione di un servizio specifico dal contesto deve inoltre non genera eccezioni.  
  
 Nelle versioni precedenti di .NET Framework, questa classe era presente nell'assembly WindowsBase di specifiche di WPF. Nelle [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.ValueSerializer> è incluso nell'assembly System. Xaml. Per altre informazioni, vedere [tipi migrati da WPF a System. XAML](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il corpo di questo costruttore è vuoto; il <xref:System.Windows.Markup.ValueSerializer> classe non contiene valori che richiedono un'inizializzazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da valutare per la conversione.</param>
        <param name="context">Informazioni di contesto utilizzate per la conversione.</param>
        <summary>In caso di override in una classe derivata, determina se l'oggetto <see cref="T:System.String" /> specificato può essere convertito in un'istanza del tipo supportato dall'implementazione di <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>
          <see langword="true" /> se il valore può essere convertito. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione di base restituisce sempre `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto di cui valutare la conversione.</param>
        <param name="context">Informazioni di contesto utilizzate per la conversione.</param>
        <summary>In caso di override in una classe derivata, determina se l'oggetto specificato può essere convertito in un oggetto <see cref="T:System.String" />.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <paramref name="value" /> può essere convertito in un oggetto <see cref="T:System.String" />. In caso contrario, <see langword="false." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione di base restituisce sempre `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj&#xA;override this.ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj" Usage="valueSerializer.ConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da convertire.</param>
        <param name="context">Informazioni di contesto utilizzate per la conversione.</param>
        <summary>In caso di override in una classe derivata, converte un oggetto <see cref="T:System.String" /> in un'istanza del tipo che l'implementazione di <see cref="T:System.Windows.Markup.ValueSerializer" /> supporta.</summary>
        <returns>Nuova istanza del tipo che l'implementazione di <see cref="T:System.Windows.Markup.ValueSerializer" /> supporta in base all'oggetto <paramref name="value" /> fornito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione di base sempre genera un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'oggetto <paramref name="value" /> non può essere convertito.</exception>
        <block subset="none" type="overrides">
          <para>Non generare eccezioni dalle implementazioni. Vedere <see cref="T:System.Windows.Markup.ValueSerializer" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string&#xA;override this.ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string" Usage="valueSerializer.ConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da convertire in una stringa.</param>
        <param name="context">Informazioni di contesto utilizzate per la conversione.</param>
        <summary>In caso di override in una classe derivata, converte l'oggetto specificato in un oggetto <see cref="T:System.String" />.</summary>
        <returns>Rappresentazione di stringa dell'oggetto specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione di base sempre genera un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'oggetto <paramref name="value" /> non può essere convertito.</exception>
        <block subset="none" type="overrides">
          <para>Non generare eccezioni dalle implementazioni. Vedere <see cref="T:System.Windows.Markup.ValueSerializer" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="valueSerializer.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto che non è stato possibile convertire.</param>
        <summary>Restituisce un'eccezione da generare quando non è possibile eseguire una conversione.</summary>
        <returns>Oggetto <see cref="T:System.Exception" /> per l'eccezione da generare quando non è possibile eseguire una conversione <see langword="ConvertFrom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'effettivo `throw` parola chiave non viene richiamato da questo metodo, pertanto l'utilizzo tipico è `throw GetConvertFromException` (con i parametri forniti).  
  
 L'eccezione specifica restituito è <xref:System.InvalidOperationException>, con `value` passato nel messaggio di eccezione. Il modello di utilizzo è identico a quello di utilità di eccezione in <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="valueSerializer.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto che non è stato possibile convertire.</param>
        <param name="destinationType">Tipo che rappresenta il tipo in cui è stata tentata la conversione.</param>
        <summary>Restituisce un'eccezione da generare quando non è possibile eseguire una conversione.</summary>
        <returns>Oggetto <see cref="T:System.Exception" /> per l'eccezione da generare quando non è possibile eseguire una conversione <see langword="ConvertTo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'effettivo `throw` parola chiave non viene richiamato da questo metodo, pertanto l'utilizzo tipico prevede `throw GetConvertToException` (con `value` parametro fornito).  
  
 L'eccezione specifica restituito è <xref:System.InvalidOperationException>, con `value` passato nel messaggio di eccezione. Il modello di utilizzo è identico a quello di utilità di eccezione in <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene il <see cref="T:System.Windows.Markup.ValueSerializer" /> per un oggetto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="descriptor">Descrittore per la proprietà CLR da serializzare.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Windows.Markup.ValueSerializer" /> dichiarato per una proprietà, passando un descrittore della proprietà CLR per la proprietà.</summary>
        <returns>Serializzatore associato alla proprietà specificata. Può restituire <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Markup.ValueSerializer> è indicato per una proprietà o per un tipo che viene utilizzato come valore per una proprietà, applicando il <xref:System.Windows.Markup.ValueSerializerAttribute> attributo nella dichiarazione del tipo o proprietà. Il <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> è un metodo di utilità che legge le informazioni sul sistema di tipo Common Language Runtime e restituisce un nuovo <xref:System.Windows.Markup.ValueSerializer> classe basato sull'attributo, se trovato nella proprietà o se viene trovato nel tipo della proprietà. `null` potrebbe essere restituito se non esiste alcun serializzatore questo tipo. `null` potrebbe essere restituito anche se un tipo di proprietà viene attribuito intenzionalmente con un valore null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Un'altra modalità che <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> restituisce l'oggetto interno supporta `TypeConverterValueSerializer` (classe), ovvero un <xref:System.Windows.Markup.ValueSerializer> implementazione che esegue il wrapping di un <xref:System.ComponentModel.TypeConverter> e lo converte il `Convert` metodi per `Convert*String` metodi (ad esempio <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>viene chiamato con l'input del <xref:System.String> digitare, quindi si traduce in <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Questa operazione viene eseguita solo nei casi in cui tutti gli elementi seguenti sono vere:  
  
-   Oggetto <xref:System.ComponentModel.TypeConverterAttribute> viene trovato nella proprietà pertinente o tipo di proprietà pertinenti.  
  
-   Il functoid <xref:System.ComponentModel.TypeConverter> può essere costruita correttamente.  
  
-   Il <xref:System.ComponentModel.TypeConverter> restituisce `true` per <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, denominato che fa riferimento il <xref:System.String> tipo.  
  
-   Il <xref:System.ComponentModel.TypeConverter> restituisce `true` per <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, denominato che fa riferimento il <xref:System.String> tipo.  
  
-   Il <xref:System.ComponentModel.TypeConverter> restituisce `true` per <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, denominato che fa riferimento il <xref:System.String> tipo.  
  
> [!NOTE]
>  Di seguito sono casi speciali: <xref:System.DateTime> tipi restituiscono un <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> tipi di restituiscono un serializzatore interno, ma funzionale (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="descriptor" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Il tipo per il quale ottenere il <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <summary>Ottiene il <see cref="T:System.Windows.Markup.ValueSerializer" /> dichiarato per il tipo specificato.</summary>
        <returns>Serializzatore associato al tipo specificato. Può restituire <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Markup.ValueSerializer> per un tipo è indicato applicando il <xref:System.Windows.Markup.ValueSerializerAttribute> attributo nella dichiarazione del tipo. Il <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> è un metodo di utilità che legge le informazioni sul sistema di tipo Common Language Runtime e restituisce un nuovo <xref:System.Windows.Markup.ValueSerializer> classe basato sull'attributo, se trovato nell'oggetto specificato `type`. `null` potrebbe essere restituito se non esiste alcun serializzatore questo tipo. `null` potrebbe essere restituito anche se un tipo viene attribuito intenzionalmente con un valore null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Un'altra modalità che <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> restituisce l'oggetto interno supporta `TypeConverterValueSerializer` (classe), ovvero un <xref:System.Windows.Markup.ValueSerializer> implementazione che esegue il wrapping di un <xref:System.ComponentModel.TypeConverter> e lo converte il `Convert` metodi per `Convert*String` metodi (ad esempio <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>viene chiamato con l'input del <xref:System.String> digitare, quindi si traduce in <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Questa operazione viene eseguita solo nei casi in cui tutti gli elementi seguenti sono vere:  
  
-   Oggetto <xref:System.ComponentModel.TypeConverterAttribute> si trova `type`.  
  
-   Il functoid <xref:System.ComponentModel.TypeConverter> può essere costruita correttamente.  
  
-   Il <xref:System.ComponentModel.TypeConverter> restituisce `true` per <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, denominato che fa riferimento il <xref:System.String> tipo.  
  
-   Il <xref:System.ComponentModel.TypeConverter> restituisce `true` per <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, denominato che fa riferimento il <xref:System.String> tipo.  
  
-   Il <xref:System.ComponentModel.TypeConverter> restituisce `true` per <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, denominato che fa riferimento il <xref:System.String> tipo.  
  
> [!NOTE]
>  Di seguito sono casi speciali: <xref:System.DateTime> tipi restituiscono un <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> tipi di restituiscono un serializzatore interno, ma funzionale (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (descriptor, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="descriptor">Descrittore della proprietà da serializzare.</param>
        <param name="context">Informazioni di contesto utilizzate per la conversione.</param>
        <summary>Ottiene il <see cref="T:System.Windows.Markup.ValueSerializer" /> dichiarato per la proprietà specificata, utilizzando il contesto specificato.</summary>
        <returns>Serializzatore associato alla proprietà specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anziché basarsi esclusivamente sugli attributi segnalati nel sistema di tipi CLR, questo overload viene utilizzato il `context` come servizio e chiama l'implementazione del servizio di <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. Il <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> implementazione sarebbe in genere si basano sempre sul `descriptor`, ma potrebbe implementare un comportamento speciale per alcuni contesti.  
  
 Questo metodo deve essere chiamato quando il chiamante è disponibile un <xref:System.Windows.Markup.IValueSerializerContext> da un servizio.  Questo garantisce che i valori corretti <xref:System.Windows.Markup.ValueSerializer> viene restituito per il contesto specifico.  
  
 Se il contesto non restituisce `null` dal relativo <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> per l'oggetto specificato `descriptor`, o se il contesto è specificare `null`, il comportamento è identico alla chiamata il <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> overload.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="descriptor" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="type">Il tipo per il quale ottenere il <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <param name="context">Informazioni di contesto utilizzate per la conversione.</param>
        <summary>Ottiene il <see cref="T:System.Windows.Markup.ValueSerializer" /> dichiarato per il tipo specificato, utilizzando il contesto specificato.</summary>
        <returns>Serializzatore associato al tipo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anziché basarsi esclusivamente sugli attributi segnalati nel sistema di tipi CLR, questo overload viene utilizzato il `context` come servizio e chiama l'implementazione del servizio di <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. Il <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> implementazione sarebbe in genere si basano sempre sul `type`, ma potrebbe implementare un comportamento speciale per alcuni contesti.  
  
 Questo metodo deve essere chiamato quando il chiamante è disponibile un <xref:System.Windows.Markup.IValueSerializerContext> da un servizio. Questo garantisce che i valori corretti <xref:System.Windows.Markup.ValueSerializer> viene restituito per il contesto specifico.  
  
 Se il contesto non restituisce `null` dal relativo <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> per l'oggetto specificato `type`, o se il contesto è specificare `null`, il comportamento è identico alla chiamata il <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> overload.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;&#xA;override this.TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;" Usage="valueSerializer.TypeReferences (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Valore da serializzare.</param>
        <param name="context">Informazioni di contesto utilizzate per la conversione.</param>
        <summary>Ottiene un'enumerazione dei tipi ai quali fa riferimento il <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Tipi convertiti da questo serializzatore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti i tipi una <xref:System.Windows.Markup.ValueSerializer> converte devono essere inclusi nell'enumerazione restituita.  In questo modo un serializzatore garantire che un de-serializzatore ha informazioni sufficienti per valutare i tipi converte questo serializzatore.  
  
 L'override di questo metodo è uno scenario avanzato. Si esegue l'override solo non è necessario se si implementa un sistema in cui CLR sistema TipoProprietario-proprietà relazioni tra i tipi disponibili per un contesto dello schema XAML non segnala le informazioni necessarie.  
  
## <a name="wpf-usage-notes"></a>Note sull'utilizzo di WPF  
 Il [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà implementa un serializzatore di valori interni che esegue l'override <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> perché una proprietà di dipendenza è un concetto che può avere i proprietari aggiunti. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] espressioni hanno anche la gestione interna speciali.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>