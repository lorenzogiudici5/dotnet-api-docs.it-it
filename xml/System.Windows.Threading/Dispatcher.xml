<Type Name="Dispatcher" FullName="System.Windows.Threading.Dispatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4625f3f8124bac0fece57c48f2d1850b72d04bbe" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51924835" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Dispatcher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Dispatcher extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.Dispatcher" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Dispatcher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Dispatcher sealed" />
  <TypeSignature Language="F#" Value="type Dispatcher = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce i servizi per la gestione della coda di elementi di lavoro per un thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Threading.Dispatcher> mantiene una coda con priorità degli elementi di lavoro per un thread specifico.  
  
 Quando un <xref:System.Windows.Threading.Dispatcher> viene creato su un thread, diventa l'unico <xref:System.Windows.Threading.Dispatcher> che possono essere associate al thread, anche se il <xref:System.Windows.Threading.Dispatcher> è stato arrestato.  
  
 Se si prova a ottenere il <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> per il thread corrente e un <xref:System.Windows.Threading.Dispatcher> non è associato al thread, un <xref:System.Windows.Threading.Dispatcher> verrà creato. Oggetto <xref:System.Windows.Threading.Dispatcher> viene creato anche quando si crea un <xref:System.Windows.Threading.DispatcherObject>. Se si crea un <xref:System.Windows.Threading.Dispatcher> su un thread in background, assicurarsi di arrestare il dispatcher prima di uscire il thread.  
  
 Se un <xref:System.Windows.Threading.Dispatcher> è arrestato, non può essere riavviata.  
  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], un <xref:System.Windows.Threading.DispatcherObject> sono accessibili solo dal <xref:System.Windows.Threading.Dispatcher> è associato.  Ad esempio, un thread in background non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> che è associato il <xref:System.Windows.Threading.Dispatcher> nel [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] thread.  Affinché il thread in background accedere la <xref:System.Windows.Controls.ContentControl.Content%2A> proprietà del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato il [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] thread.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> viene chiamato su una <xref:System.Windows.Threading.Dispatcher> che ha interrotto l'esecuzione, la proprietà status dell'oggetto restituito <xref:System.Windows.Threading.DispatcherOperation> è impostata su <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 Tutti i metodi sul <xref:System.Windows.Threading.Dispatcher>, ad eccezione di <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, sono a thread libero.  
  
 Gli oggetti che derivano da <xref:System.Windows.Threading.DispatcherObject> presentano affinità di thread.  
  
 Gli oggetti che derivano da <xref:System.Windows.Freezable> sono a thread libero quando sono bloccati.  Per altre informazioni, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come inserire un'operazione in un <xref:System.Windows.Threading.Dispatcher>.  Per il codice sorgente completo di questo esempio, vedere [applicazione Single-Threaded con calcolo a esecuzione prolungata](https://go.microsoft.com/fwlink/?LinkID=160038).  
  
 In primo luogo, viene creato un delegato che non accetta argomenti.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Successivamente, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> viene chiamato.  Questa chiamata a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> accetta due parametri: la priorità, che è impostata su <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>e il callback, che viene passato un'istanza del delegato `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Applicazione a thread singolo con calcolo a esecuzione prolungata</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue in modo asincrono un delegato sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona; di conseguenza, controllo viene restituito immediatamente all'oggetto chiamante dopo la chiamata.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Restituisce un <xref:System.Windows.Threading.DispatcherOperation> oggetto che può essere utilizzato per interagire con il delegato quando il delegato è nell'evento della coda.  
  
 Il <xref:System.Windows.Threading.DispatcherOperation> oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> può essere usato in diversi modi per interagire con il delegato specificato, ad esempio:  
  
-   Modifica il <xref:System.Windows.Threading.DispatcherPriority> del delegato perché è in sospeso l'esecuzione nella coda degli eventi.  
  
-   Rimozione del delegato dalla coda degli eventi.  
  
-   In attesa per il delegato da restituire.  
  
-   Viene eseguito il recupero del valore restituito dal delegato dopo di esso.  
  
 Se più <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> chiamate alla stessa <xref:System.Windows.Threading.DispatcherPriority>, verranno eseguite nell'ordine in cui sono state effettuate.  
  
 Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> viene chiamato su una <xref:System.Windows.Threading.Dispatcher> che ha interrotto l'esecuzione, la proprietà status dell'oggetto restituito <xref:System.Windows.Threading.DispatcherOperation> è impostata su <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegato a un metodo che accetta i parametri specificati in <c>args</c>, inserito nella coda di eventi <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato. Può essere <see langword="null" />.</param>
        <summary>Esegue in modo asincrono il delegato specificato con gli argomenti specificati sul thread in cui è stato creato l'oggetto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda degli eventi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Threading.DispatcherOperation> oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> può essere usato in diversi modi per interagire con il delegato specificato, ad esempio:  
  
-   Modifica il <xref:System.Windows.Threading.DispatcherPriority> del delegato perché è in sospeso l'esecuzione nella coda degli eventi.  
  
-   Rimozione del delegato dalla coda degli eventi.  
  
-   In attesa per il delegato da restituire.  
  
-   Viene eseguito il recupero del valore restituito dal delegato dopo di esso.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona; di conseguenza, controllo viene restituito immediatamente all'oggetto chiamante dopo la chiamata.  
  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto. Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente. Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente. Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona. L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> viene chiamato su una <xref:System.Windows.Threading.Dispatcher> che ha interrotto l'esecuzione, la proprietà status dell'oggetto restituito <xref:System.Windows.Threading.DispatcherOperation> è impostata su <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="method">Delegato a un metodo che non accetta argomenti, inserito nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Esegue in modo asincrono il delegato specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda degli eventi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se più <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> chiamate alla stessa <xref:System.Windows.Threading.DispatcherPriority>, verranno eseguite nell'ordine in cui sono state effettuate.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Restituisce un <xref:System.Windows.Threading.DispatcherOperation> oggetto che può essere utilizzato per interagire con il delegato quando il delegato è nell'evento della coda.  
  
 Il <xref:System.Windows.Threading.DispatcherOperation> oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> può essere usato in diversi modi per interagire con il delegato specificato, ad esempio:  
  
-   Modifica il <xref:System.Windows.Threading.DispatcherPriority> del delegato perché è in sospeso l'esecuzione nella coda degli eventi.  
  
-   Rimozione del delegato dalla coda degli eventi.  
  
-   In attesa per il delegato da restituire.  
  
-   Viene eseguito il recupero del valore restituito dal delegato dopo di esso.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona; di conseguenza, controllo viene restituito immediatamente all'oggetto chiamante dopo la chiamata.  
  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> viene chiamato su una <xref:System.Windows.Threading.Dispatcher> che ha interrotto l'esecuzione, la proprietà status dell'oggetto restituito <xref:System.Windows.Threading.DispatcherOperation> è impostata su <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come inserire un'operazione in un <xref:System.Windows.Threading.Dispatcher>.  Per il codice sorgente completo di questo esempio, vedere [applicazione Single-Threaded con calcolo a esecuzione prolungata](https://go.microsoft.com/fwlink/?LinkID=160038).  
  
 In primo luogo, viene creato un delegato che non accetta argomenti.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Successivamente, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> viene chiamato.  Poiché ogni <xref:System.Windows.Threading.DispatcherObject> ha una proprietà che restituisce il <xref:System.Windows.Threading.Dispatcher> associato, il valore desiderato <xref:System.Windows.Threading.Dispatcher> viene ottenuto eseguendo una query il <xref:System.Windows.Threading.DispatcherObject>, in questo caso un <xref:System.Windows.Controls.Button> denominato `startStopButton`.   La chiamata a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> accetta due parametri: la priorità, che è impostata su <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>e il callback, che viene passato un'istanza del delegato `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> non è un oggetto <see cref="T:System.Windows.Threading.DispatcherPriority" /> valido.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Applicazione a thread singolo con calcolo a esecuzione prolungata</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegato a un metodo che accetta i parametri specificati in <c>args</c>, inserito nella coda di eventi <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato. Può essere <see langword="null" />.</param>
        <summary>Esegue in modo asincrono il delegato specificato con gli argomenti specificati, con la priorità specificata, sul thread in cui è stato creato l'oggetto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda degli eventi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Threading.DispatcherOperation> oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> può essere usato in diversi modi per interagire con il delegato specificato, ad esempio:  
  
-   Modifica il <xref:System.Windows.Threading.DispatcherPriority> del delegato perché è in sospeso l'esecuzione nella coda degli eventi.  
  
-   Rimozione del delegato dalla coda degli eventi.  
  
-   In attesa per il delegato da restituire.  
  
-   Viene eseguito il recupero del valore restituito dal delegato dopo di esso.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona; di conseguenza, controllo viene restituito immediatamente all'oggetto chiamante dopo la chiamata.  
  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto. Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente. Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente. Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona. L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> viene chiamato su una <xref:System.Windows.Threading.Dispatcher> che ha interrotto l'esecuzione, la proprietà status dell'oggetto restituito <xref:System.Windows.Threading.DispatcherOperation> è impostata su <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="method">Delegato a un metodo che accetta un argomento, inserito nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Oggetto da passare come argomento al metodo specificato.</param>
        <summary>Esegue in modo asincrono il delegato specificato con la priorità e l'argomento specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda degli eventi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` può essere `null` se non sono necessari argomenti.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Restituisce un <xref:System.Windows.Threading.DispatcherOperation> oggetto che può essere utilizzato per interagire con il delegato quando il delegato è nell'evento della coda.  
  
 Il <xref:System.Windows.Threading.DispatcherOperation> oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> può essere usato in diversi modi per interagire con il delegato specificato, ad esempio:  
  
-   Modifica il <xref:System.Windows.Threading.DispatcherPriority> del delegato perché è in sospeso l'esecuzione nella coda degli eventi.  
  
-   Rimozione del delegato dalla coda degli eventi.  
  
-   In attesa per il delegato da restituire.  
  
-   Viene eseguito il recupero del valore restituito dal delegato dopo di esso.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona; di conseguenza, controllo viene restituito immediatamente all'oggetto chiamante dopo la chiamata.  
  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Se più <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> chiamate alla stessa <xref:System.Windows.Threading.DispatcherPriority>, verranno eseguite nell'ordine in cui sono state effettuate.  
  
 Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> viene chiamato su una <xref:System.Windows.Threading.Dispatcher> che ha interrotto l'esecuzione, la proprietà status dell'oggetto restituito <xref:System.Windows.Threading.DispatcherOperation> è impostata su <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come inserire un'operazione in un <xref:System.Windows.Threading.Dispatcher>.  
  
 In primo luogo, viene creato un delegato che accetta un solo argomento, in questo caso una stringa.  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdelegates)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdelegates)]  
  
 Successivamente, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> viene chiamato.  Poiché ogni <xref:System.Windows.Threading.DispatcherObject> ha una proprietà che restituisce il <xref:System.Windows.Threading.Dispatcher> associato, il valore desiderato <xref:System.Windows.Threading.Dispatcher> viene ottenuto eseguendo una query il <xref:System.Windows.Threading.DispatcherObject>, in questo caso un <xref:System.Windows.Controls.Grid> denominato `tomorrowsWeather`. La chiamata a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> accetta tre parametri: la priorità, che è impostata su <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>; i callback, che viene passato un'istanza del delegato `OneArgDelegate`; e una stringa denominata `weather`, ovvero l'argomento per il callback.  
  
 [!code-csharp[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdispatcheronearge)]
 [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdispatcheronearge)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> non è un oggetto <see cref="T:System.Windows.Threading.DispatcherPriority" /> valido.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Applicazione a thread singolo con calcolo a esecuzione prolungata</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="method">Delegato a un metodo che accetta più argomenti, inserito nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Oggetto da passare come argomento al metodo specificato.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato.</param>
        <summary>Esegue in modo asincrono il delegato specificato con la priorità e la matrice di argomenti specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda di <see cref="T:System.Windows.Threading.Dispatcher" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `arg` parametro può essere `null` se non sono necessari argomenti.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Restituisce un <xref:System.Windows.Threading.DispatcherOperation> oggetto che può essere utilizzato per interagire con il delegato quando il delegato è nell'evento della coda.  
  
 Il <xref:System.Windows.Threading.DispatcherOperation> oggetto restituito da <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> può essere usato in diversi modi per interagire con il delegato specificato, ad esempio:  
  
-   Modifica il <xref:System.Windows.Threading.DispatcherPriority> del delegato perché è in sospeso l'esecuzione nella coda degli eventi.  
  
-   Rimozione del delegato dalla coda degli eventi.  
  
-   In attesa per il delegato da restituire.  
  
-   Viene eseguito il recupero del valore restituito dal delegato dopo di esso.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona; di conseguenza, controllo viene restituito immediatamente all'oggetto chiamante dopo la chiamata.  
  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Se più <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> chiamate alla stessa <xref:System.Windows.Threading.DispatcherPriority>, verranno eseguite nell'ordine in cui sono state effettuate.  
  
 Se <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> viene chiamato su una <xref:System.Windows.Threading.Dispatcher> che ha interrotto l'esecuzione, la proprietà status dell'oggetto restituito <xref:System.Windows.Threading.DispatcherOperation> è impostata su <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="T:System.Windows.Threading.DispatcherPriority" /> non è una priorità valida.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Applicazione a thread singolo con calcolo a esecuzione prolungata</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeShutdown">
      <MemberSignature Language="C#" Value="public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginInvokeShutdown(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInvokeShutdown (priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginInvokeShutdown(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.BeginInvokeShutdown : System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.BeginInvokeShutdown priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Priorità con la quale iniziare ad arrestare il dispatcher.</param>
        <summary>Inizia in modo asincrono l'arresto di <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.BeginInvokeShutdown%2A> le richieste di autorizzazioni dell'interfaccia utente senza restrizioni.  
  
 Quando la <xref:System.Windows.Threading.Dispatcher> inizia l'arresto, il <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> è impostata su `true`.  
  
 Il <xref:System.Windows.Threading.Dispatcher> si arresta completamente fino a quando la coda degli eventi viene rimosso.  
  
 Quando il Dispatcher termina l'arresto, la <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> viene generato l'evento e il <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> è impostata su `true`.  
  
 Una volta avviato il processo di arresto, tutto lavoro in sospeso vengono interrotte elementi nella coda.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Per arrestare il dispatcher.  Enumerazioni associate:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public bool CheckAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckAccess () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckAccess();" />
      <MemberSignature Language="F#" Value="member this.CheckAccess : unit -&gt; bool" Usage="dispatcher.CheckAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se il thread chiamante è il thread associato a questo oggetto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>
          <see langword="true" /> se il thread chiamante è il thread associato a <see cref="T:System.Windows.Threading.Dispatcher" />, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo le <xref:System.Windows.Threading.Dispatcher> che un <xref:System.Windows.Threading.DispatcherObject> viene creato nella può accedere all'oggetto.  Uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> per accedere all'oggetto da un thread diverso.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> può essere chiamato da qualsiasi thread.  
  
 La differenza tra <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> e <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> viene <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> restituisce un valore booleano che indica se il thread chiamante ha accesso per il <xref:System.Windows.Threading.Dispatcher> e <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> genera un'eccezione.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> per determinare se un thread può accedere a un <xref:System.Windows.Controls.Button>.  Il <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> metodo sul <xref:System.Windows.Threading.Dispatcher> associato il <xref:System.Windows.Controls.Button> viene chiamato per verificare l'accesso al thread.  Se il thread chiamante può accedere al <xref:System.Windows.Threading.Dispatcher>, il <xref:System.Windows.Controls.Button> viene aggiornata tramite l'accesso a membri del <xref:System.Windows.Controls.Button>; in caso contrario, un delegato che accetta un <xref:System.Windows.Controls.Button> come argomento, viene inserito nel <xref:System.Windows.Threading.Dispatcher>.  Il <xref:System.Windows.Threading.Dispatcher> delegherà l'operazione di aggiornamento di <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccesscheckaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccesscheckaccess)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDispatcher">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Threading.Dispatcher CurrentDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDispatcher As Dispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Threading::Dispatcher ^ CurrentDispatcher { System::Windows::Threading::Dispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDispatcher : System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene <see cref="T:System.Windows.Threading.Dispatcher" /> per il thread attualmente in esecuzione e crea un nuovo <see cref="T:System.Windows.Threading.Dispatcher" /> se al thread non ne è già associato uno.</summary>
        <value>Dispatcher associato al thread corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un <xref:System.Windows.Threading.Dispatcher> non è associato il thread corrente, un nuovo <xref:System.Windows.Threading.Dispatcher> verrà creato.  Non è il caso del metodo <xref:System.Windows.Threading.Dispatcher.FromThread%2A>.  <xref:System.Windows.Threading.Dispatcher.FromThread%2A> restituirà `null` se non esiste un dispatcher associato al thread specificato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableProcessing">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.DisableProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Function DisableProcessing () As DispatcherProcessingDisabled" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherProcessingDisabled DisableProcessing();" />
      <MemberSignature Language="F#" Value="member this.DisableProcessing : unit -&gt; System.Windows.Threading.DispatcherProcessingDisabled" Usage="dispatcher.DisableProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherProcessingDisabled</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disabilita l'elaborazione della coda di <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Struttura utilizzata per attivare nuovamente l'elaborazione del dispatcher.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Disabilitare l'elaborazione del dispatcher è un metodo avanzato che consente di eliminare le probabilità di reentrancy non correlate.  
  
 Gli effetti della disabilitazione dell'elaborazione sono i seguenti:  
  
-   I blocchi CLR non saranno il message pump internamente.  
  
-   <xref:System.Windows.Threading.DispatcherFrame> gli oggetti non sono consentiti per il push.  
  
-   L'elaborazione dei messaggi non è consentito.  
  
 Il <xref:System.Windows.Threading.DispatcherProcessingDisabled> struttura <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> restituisce quando viene chiamata può essere utilizzato per abilitare di nuovo l'elaborazione del dispatcher.  La chiamata <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> nella <xref:System.Windows.Threading.DispatcherProcessingDisabled> struttura riabilita l'elaborazione.  
  
 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> può essere chiamato solo sul thread di <xref:System.Windows.Threading.Dispatcher> è associato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come disabilitare e riabilitare l'elaborazione del dispatcher.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> viene chiamato un **usando** istruzione.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> Restituisce un <xref:System.Windows.Threading.DispatcherProcessingDisabled> struttura utilizzata come oggetto di essere eliminato quando il **usando** blocca al termine della.  Quando <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> viene chiamato sul <xref:System.Windows.Threading.DispatcherProcessingDisabled> struttura, l'elaborazione del dispatcher viene riabilitato.  
  
 [!code-csharp[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdisableprocessing)]
 [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdisableprocessing)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitAllFrames">
      <MemberSignature Language="C#" Value="public static void ExitAllFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitAllFrames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitAllFrames ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitAllFrames();" />
      <MemberSignature Language="F#" Value="static member ExitAllFrames : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ExitAllFrames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Richiede l'uscita di tutti i frame, inclusi i frame annidati.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per chiamare questo metodo. Enumerazioni associate:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
        <altmember cref="T:System.Windows.Threading.DispatcherFrame" />
      </Docs>
    </Member>
    <Member MemberName="FromThread">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Threading.Dispatcher FromThread(class System.Threading.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::Dispatcher ^ FromThread(System::Threading::Thread ^ thread);" />
      <MemberSignature Language="F#" Value="static member FromThread : System.Threading.Thread -&gt; System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.FromThread thread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="System.Threading.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">Thread dal quale ottenere <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Ottiene <see cref="T:System.Windows.Threading.Dispatcher" /> per il thread specificato.</summary>
        <returns>Dispatcher per <paramref name="thread" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non è disponibile per il thread specificato, un dispatcher `null` verranno restituiti.  
  
 <xref:System.Windows.Threading.Dispatcher.FromThread%2A> non crea una <xref:System.Windows.Threading.Dispatcher> su un thread che non ha un <xref:System.Windows.Threading.Dispatcher>.   Una nuova <xref:System.Windows.Threading.Dispatcher> viene creato su un thread che non dispone già di un <xref:System.Windows.Threading.Dispatcher> quando si prova a ottenere il <xref:System.Windows.Threading.Dispatcher> utilizzando il <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownFinished">
      <MemberSignature Language="C#" Value="public bool HasShutdownFinished { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownFinished" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownFinished As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownFinished { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownFinished : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se <see cref="T:System.Windows.Threading.Dispatcher" /> ha terminato l'arresto.</summary>
        <value>
          <see langword="true" /> se il dispatcher ha concluso l'arresto, in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando la <xref:System.Windows.Threading.Dispatcher> inizia l'arresto, il <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> è impostata su `true`.  
  
 Il <xref:System.Windows.Threading.Dispatcher> non si arresta completamente fino a quando la coda degli eventi viene rimosso.  
  
 Quando il Dispatcher termina l'arresto, la <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> viene generato l'evento e il <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> è impostata su `true`.  
  
 Una volta avviato il processo di arresto, tutto lavoro in sospeso vengono interrotte elementi nella coda.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se <see cref="T:System.Windows.Threading.Dispatcher" /> si stia arrestando.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Windows.Threading.Dispatcher" /> ha iniziato l'arresto, in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando la <xref:System.Windows.Threading.Dispatcher> inizia l'arresto, il <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> è impostata su `true`.  
  
 Il <xref:System.Windows.Threading.Dispatcher> si arresta completamente fino a quando la coda degli eventi viene rimosso.  
  
 Quando il Dispatcher termina l'arresto, la <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> viene generato l'evento e il <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> è impostata su `true`.  
  
 Una volta avviato il processo di arresto, tutto lavoro in sospeso vengono interrotte elementi nella coda.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hooks">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherHooks Hooks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Threading.DispatcherHooks Hooks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Hooks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hooks As DispatcherHooks" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Threading::DispatcherHooks ^ Hooks { System::Windows::Threading::DispatcherHooks ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Hooks : System.Windows.Threading.DispatcherHooks" Usage="System.Windows.Threading.Dispatcher.Hooks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherHooks</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di hook che forniscono informazioni aggiuntive sull'evento relativamente a <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <value>Hook associato a <see cref="T:System.Windows.Threading.Dispatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Threading.DispatcherHooks> classe vengono fornite informazioni aggiuntive sull'evento sul <xref:System.Windows.Threading.Dispatcher>, ad esempio, quando il <xref:System.Windows.Threading.Dispatcher> è inattiva o quando un'operazione è stata completata.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Per ottenere questa proprietà.  Enumerazioni associate:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue in modo sincrono il delegato specificato sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
   
  
## Examples  
 L'esempio seguente viene inserito un delegato in un <xref:System.Windows.Threading.Dispatcher> alla <xref:System.Windows.Threading.DispatcherPriority.Normal> usando <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action -&gt; unit" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <summary>Esegue in modo sincrono il <see cref="T:System.Action" /> specificato sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action, priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <param name="priority">La priorità che determina l'ordine con cui il callback specificato viene richiamato rispetto alle altre operazioni in sospeso in <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Esegue in modo sincrono il <see cref="T:System.Action" /> specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Un delegato a un metodo che accetta i parametri specificati in <c>args</c>, inserito nella coda di eventi <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato. Può essere <see langword="null" />.</param>
        <summary>Esegue in modo asincrono il delegato specificato con gli argomenti specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto. Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente. Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente. Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona. L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="method">Delegato a un metodo che non accetta argomenti, inserito nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Esegue in modo sincrono il delegato specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
   
  
## Examples  
 L'esempio seguente viene inserito un delegato in un <xref:System.Windows.Threading.Dispatcher> alla <xref:System.Windows.Threading.DispatcherPriority.Normal> usando <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> è uguale a <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> non è una priorità valida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <param name="priority">La priorità che determina l'ordine con cui il callback specificato viene richiamato rispetto alle altre operazioni in sospeso in <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Oggetto che indica se annullare l'azione.</param>
        <summary>Esegue in modo sincrono il <see cref="T:System.Action" /> specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Un delegato a un metodo che accetta i parametri specificati in <c>args</c>, inserito nella coda di eventi <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="timeout">Periodo di tempo massimo di attesa del completamento dell'operazione.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato. Può essere <see langword="null" />.</param>
        <summary>Esegue in modo sincrono il delegato specificato entro l'intervallo di tempo designato con la priorità e gli argomenti specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto. Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente. Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente. Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona. L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Un delegato a un metodo che accetta i parametri specificati in <c>args</c>, inserito nella coda di eventi <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato. Può essere <see langword="null" />.</param>
        <summary>Esegue in modo sincrono il delegato specificato con la priorità e gli argomenti specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto. Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente. Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente. Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona. L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="method">Delegato a un metodo che accetta un argomento, inserito nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Oggetto da passare come argomento al metodo specificato.</param>
        <summary>Esegue in modo sincrono il delegato specificato con la priorità e l'argomento specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` può essere `null` se non è necessario un argomento  
  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> è uguale a <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> non è una priorità valida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="timeout">Tempo massimo di attesa del termine dell'operazione.</param>
        <param name="method">Delegato a un metodo che non accetta argomenti, inserito nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Esegue in modo sincrono il delegato specificato con la priorità e il valore di timeout specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <param name="priority">La priorità che determina l'ordine con cui il callback specificato viene richiamato rispetto alle altre operazioni in sospeso in <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Oggetto che indica se annullare l'azione.</param>
        <param name="timeout">Periodo di tempo minimo di attesa dell'avvio dell'operazione.</param>
        <summary>Esegue in modo sincrono il <see cref="T:System.Action" /> specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Un delegato a un metodo che accetta i parametri specificati in <c>args</c>, inserito nella coda di eventi <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="timeout">Periodo di tempo massimo di attesa del completamento dell'operazione.</param>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato. Può essere <see langword="null" />.</param>
        <summary>Esegue in modo sincrono il delegato specificato entro l'intervallo di tempo designato con la priorità e gli argomenti specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto. Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente. Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente. Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona. L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="method">Delegato a un metodo che accetta più argomenti, inserito nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Oggetto da passare come argomento al metodo specificato.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato.</param>
        <summary>Esegue in modo sincrono il delegato specificato con la priorità e gli argomenti specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` può essere `null` se non è necessario un argomento  
  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> è uguale a <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> non è una priorità valida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="timeout">Tempo massimo di attesa del termine dell'operazione.</param>
        <param name="method">Delegato a un metodo che accetta più argomenti, inserito nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Oggetto da passare come argomento al metodo specificato. Se non sono richiesti argomenti, può corrispondere a <see langword="null" />.</param>
        <summary>Esegue in modo sincrono il delegato specificato con la priorità e l'argomento specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` può essere `null` se non è necessario un argomento  
  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> è uguale a <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> non è una priorità valida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Priorità, rispetto alle altre operazioni in sospeso nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />, con la quale viene richiamato il metodo specificato.</param>
        <param name="timeout">Tempo massimo di attesa del termine dell'operazione.</param>
        <param name="method">Delegato a un metodo che accetta più argomenti, inserito nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Oggetto da passare come argomento al metodo specificato.</param>
        <param name="args">Matrice di oggetti da passare come argomenti al metodo specificato.</param>
        <summary>Esegue in modo sincrono il delegato specificato con la priorità e gli argomenti specificati sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Valore restituito dal delegato richiamato oppure <see langword="null" /> se il delegato non restituisce alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` può essere `null` se un argomento non è necessaria.  
  
 Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], solo i thread che ha creato un <xref:System.Windows.Threading.DispatcherObject> può accedere a quell'oggetto.  Ad esempio, un thread in background che viene attivato dal thread principale dell'interfaccia utente non è possibile aggiornare il contenuto di un <xref:System.Windows.Controls.Button> creato sul thread dell'interfaccia utente.  Affinché il thread in background accedere alla proprietà Content del <xref:System.Windows.Controls.Button>, il thread in background deve delegare il lavoro dal <xref:System.Windows.Threading.Dispatcher> associato al thread dell'interfaccia utente.  Questa operazione viene eseguita tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è sincrono e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrona.  L'operazione viene aggiunta alla coda degli eventi dei <xref:System.Windows.Threading.Dispatcher> corrispondente all'oggetto specificato <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> è un'operazione sincrona. Pertanto, controllo non verrà restituito all'oggetto chiamante fino a dopo che viene restituito il callback.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> è uguale a <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> non è un oggetto <see cref="T:System.Windows.Threading.DispatcherPriority" /> valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; -&gt; 'Result" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Il tipo del valore restituito del delegato specificato.</typeparam>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <summary>Esegue in modo sincrono il <see cref="T:System.Func`1" /> specificato sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Il tipo del valore restituito del delegato specificato.</typeparam>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <param name="priority">La priorità che determina l'ordine con cui il callback specificato viene richiamato rispetto alle altre operazioni in sospeso in <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Esegue in modo sincrono il <see cref="T:System.Func`1" /> specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Il tipo del valore restituito del delegato specificato.</typeparam>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <param name="priority">La priorità che determina l'ordine con cui il callback specificato viene richiamato rispetto alle altre operazioni in sospeso in <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Oggetto che indica se annullare l'operazione.</param>
        <summary>Esegue in modo sincrono il <see cref="T:System.Func`1" /> specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Il tipo del valore restituito del delegato specificato.</typeparam>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <param name="priority">La priorità che determina l'ordine con cui il callback specificato viene richiamato rispetto alle altre operazioni in sospeso in <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Oggetto che indica se annullare l'operazione.</param>
        <param name="timeout">Periodo di tempo minimo di attesa dell'avvio dell'operazione.</param>
        <summary>Esegue in modo sincrono il <see cref="T:System.Func`1" /> specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue in modo asincrono il delegato specificato sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <summary>Esegue in modo asincrono il <see cref="T:System.Action" /> specificato sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda degli eventi.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action, priority As DispatcherPriority) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <param name="priority">La priorità che determina l'ordine con cui il callback specificato viene richiamato rispetto alle altre operazioni in sospeso in <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Esegue in modo asincrono il <see cref="T:System.Action" /> specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda degli eventi.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <param name="priority">La priorità che determina l'ordine con cui il callback specificato viene richiamato rispetto alle altre operazioni in sospeso in <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Oggetto che indica se annullare l'azione.</param>
        <summary>Esegue in modo asincrono il <see cref="T:System.Action" /> specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda degli eventi.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult)) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Il tipo del valore restituito del delegato specificato.</typeparam>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <summary>Esegue in modo asincrono il <see cref="T:System.Func`1" /> specificato sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda degli eventi.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Il tipo del valore restituito del delegato specificato.</typeparam>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <param name="priority">La priorità che determina l'ordine con cui il callback specificato viene richiamato rispetto alle altre operazioni in sospeso in <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Esegue in modo asincrono il <see cref="T:System.Func`1" /> specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda degli eventi.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Il tipo del valore restituito del delegato specificato.</typeparam>
        <param name="callback">Un delegato da richiamare tramite il dispatcher.</param>
        <param name="priority">La priorità che determina l'ordine con cui il callback specificato viene richiamato rispetto alle altre operazioni in sospeso in <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Oggetto che indica se annullare l'operazione.</param>
        <summary>Esegue in modo asincrono il <see cref="T:System.Func`1" /> specificato con la priorità specificata sul thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <returns>Oggetto, restituito immediatamente dopo la chiamata a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />, utilizzabile per l'interazione con il delegato mentre è in attesa di esecuzione nella coda degli eventi.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeShutdown">
      <MemberSignature Language="C#" Value="public void InvokeShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeShutdown();" />
      <MemberSignature Language="F#" Value="member this.InvokeShutdown : unit -&gt; unit" Usage="dispatcher.InvokeShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizia il processo di arresto di <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.InvokeShutdown%2A> le richieste di autorizzazioni dell'interfaccia utente senza restrizioni.  
  
 Quando la <xref:System.Windows.Threading.Dispatcher> inizia l'arresto, il <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> è impostata su `true`.  
  
 Il <xref:System.Windows.Threading.Dispatcher> si arresta completamente fino a quando la coda degli eventi viene rimosso.  
  
 Quando il Dispatcher termina l'arresto, la <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> viene generato l'evento e il <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> è impostata su `true`.  
  
 Una volta avviato il processo di arresto, tutto lavoro in sospeso vengono interrotte elementi nella coda.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Per arrestare il dispatcher.  Enumerazioni associate:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PushFrame">
      <MemberSignature Language="C#" Value="public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PushFrame(class System.Windows.Threading.DispatcherFrame frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PushFrame (frame As DispatcherFrame)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PushFrame(System::Windows::Threading::DispatcherFrame ^ frame);" />
      <MemberSignature Language="F#" Value="static member PushFrame : System.Windows.Threading.DispatcherFrame -&gt; unit" Usage="System.Windows.Threading.Dispatcher.PushFrame frame" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Windows.Threading.DispatcherFrame" />
      </Parameters>
      <Docs>
        <param name="frame">Frame per il dispatcher da elaborare.</param>
        <summary>Immette un ciclo di esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Threading.DispatcherFrame> rappresenta un ciclo che elabora gli elementi di lavoro in sospeso.  
  
 Il Dispatcher elabora la coda di elementi di lavoro in un ciclo.  Il ciclo si intende un frame.  Il ciclo iniziale viene in genere avviato dall'applicazione chiamando <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> entra in un ciclo rappresentato dal parametro `frame`.  A ogni iterazione del ciclo, il <xref:System.Windows.Threading.Dispatcher> controllerà il <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> proprietà di <xref:System.Windows.Threading.DispatcherFrame> classe per determinare se il ciclo deve continuare o se deve essere arrestata.  
  
 <xref:System.Windows.Threading.DispatcherFrame> consente il <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> rispetta la proprietà da impostare in modo esplicito ed è il <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> proprietà di <xref:System.Windows.Threading.Dispatcher>.  Ciò significa che, quando la <xref:System.Windows.Threading.Dispatcher> inizia l'arresto, frame che utilizzano il valore predefinito <xref:System.Windows.Threading.DispatcherFrame> implementazione terminerà, che consente tutti i frame annidati uscire.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare un <xref:System.Windows.Threading.DispatcherFrame> per ottenere risultati simili come i [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> (metodo).  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="frame" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" /> è <see langword="true" />  
  
oppure 
 <paramref name="frame" /> è in esecuzione su un oggetto <see cref="T:System.Windows.Threading.Dispatcher" /> diverso.  
  
oppure 
L'elaborazione del dispatcher è stata disabilitata.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Per effettuare il push di un frame di esecuzione.  Enumerazioni associate:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserisce il frame di esecuzione principale nella coda degli eventi di <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Threading.Dispatcher> elabora la coda degli eventi in un ciclo.  Il ciclo si intende un frame.  Il ciclo iniziale viene in genere avviato dall'applicazione chiamando <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 Il frame di esecuzione principale continuerà finché il <xref:System.Windows.Threading.Dispatcher> viene arrestato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownFinished">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownFinished" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownFinished As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownFinished;" />
      <MemberSignature Language="F#" Value="member this.ShutdownFinished : EventHandler " Usage="member this.ShutdownFinished : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando <see cref="T:System.Windows.Threading.Dispatcher" /> termina l'arresto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il processo di arresto di un <xref:System.Windows.Threading.Dispatcher> viene avviato, il <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> è impostata su `true`.  
  
 Il <xref:System.Windows.Threading.Dispatcher> non si arresta completamente fino a quando la coda degli eventi viene rimosso.  
  
 Quando il Dispatcher termina l'arresto, la <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> viene generato l'evento e il <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> è impostata su `true`.  
  
 Una volta avviato il processo di arresto, tutto lavoro in sospeso vengono interrotte elementi nella coda.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStarted">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownStarted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownStarted;" />
      <MemberSignature Language="F#" Value="member this.ShutdownStarted : EventHandler " Usage="member this.ShutdownStarted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando <see cref="T:System.Windows.Threading.Dispatcher" /> inizia l'arresto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il processo di arresto di un <xref:System.Windows.Threading.Dispatcher> viene avviato, il <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento viene generato e <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> è impostata su `true`.  
  
 Il <xref:System.Windows.Threading.Dispatcher> non si arresta completamente fino a quando la coda degli eventi viene rimosso.  
  
 Quando il Dispatcher termina l'arresto, la <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> viene generato l'evento e il <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> è impostata su `true`.  
  
 Una volta avviato il processo di arresto, tutto lavoro in sospeso vengono interrotte elementi nella coda.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public System.Threading.Thread Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Thread Thread" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Thread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Thread ^ Thread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thread : System.Threading.Thread" Usage="System.Windows.Threading.Dispatcher.Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il thread al quale <see cref="T:System.Windows.Threading.Dispatcher" /> è associato.</summary>
        <value>Thread.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Event UnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene generata un'eccezione del thread non intercettata durante l'esecuzione di un delegato mediante <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> o <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato quando un'eccezione generata durante l'esecuzione di un delegato tramite <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> viene intercettata.  
  
 Un gestore può contrassegnare l'eccezione come gestito, che verrà impedire venga chiamato il gestore dell'eccezione interna.  
  
 I gestori eventi per questo evento devono essere scritto con attenzione per evitare di creare eccezioni secondarie e per intercettare qualsiasi che si verificano. È consigliabile evitare l'allocazione di memoria o per eseguire operazioni con uso intensivo nel gestore di tutte le risorse.  
  
 Il <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> eventi fornisce un mezzo per non generare la <xref:System.Windows.Threading.Dispatcher.UnhandledException> evento.  Il <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> evento viene generato prima di tutto e, se <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> nel <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> è impostata su `false`, il <xref:System.Windows.Threading.Dispatcher.UnhandledException> evento non verrà generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledExceptionFilter">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledExceptionFilter As DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionFilterEventHandler ^ UnhandledExceptionFilter;" />
      <MemberSignature Language="F#" Value="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " Usage="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene generata un'eccezione del thread non intercettata durante l'esecuzione di un delegato mediante <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> o <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> in fase di filtro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento viene generato durante la fase di filtro per un'eccezione generata durante l'esecuzione per mezzo di un delegato <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> e non viene intercettata.  
  
 Lo stack di chiamate non viene rimosso a questo punto (eccezioni first-chance).  
  
 I gestori eventi per questo evento devono essere scritto con attenzione per evitare di creare eccezioni secondarie e per intercettare qualsiasi che si verificano.  È consigliabile evitare l'allocazione di memoria o per eseguire operazioni con uso intensivo nel gestore di tutte le risorse.  
  
 Il <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> eventi fornisce un mezzo per non generare la <xref:System.Windows.Threading.Dispatcher.UnhandledException> evento.  Il <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> evento viene generato prima di tutto e, se <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> nel <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> è impostata su `false`, il <xref:System.Windows.Threading.Dispatcher.UnhandledException> evento non verrà generato.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per l'aggiunta o rimozione di un gestore per questo evento.  Enumerazioni associate:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ValidatePriority">
      <MemberSignature Language="C#" Value="public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ValidatePriority(valuetype System.Windows.Threading.DispatcherPriority priority, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ValidatePriority (priority As DispatcherPriority, parameterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ValidatePriority(System::Windows::Threading::DispatcherPriority priority, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="static member ValidatePriority : System.Windows.Threading.DispatcherPriority * string -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ValidatePriority (priority, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="priority">Priorità da controllare.</param>
        <param name="parameterName">Stringa che verrà restituita dall'eccezione che si verifica se la priorità non è valida.</param>
        <summary>Determina se la priorità stabilita dall'oggetto <see cref="T:System.Windows.Threading.DispatcherPriority" /> specificato sia valida.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> non è un oggetto <see cref="T:System.Windows.Threading.DispatcherPriority" /> valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyAccess">
      <MemberSignature Language="C#" Value="public void VerifyAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyAccess();" />
      <MemberSignature Language="F#" Value="member this.VerifyAccess : unit -&gt; unit" Usage="dispatcher.VerifyAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se il thread chiamante ha accesso a <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo il thread di <xref:System.Windows.Threading.Dispatcher> viene creato sarà accessibile il <xref:System.Windows.Threading.Dispatcher>.  
  
 Questo metodo è pubblico; di conseguenza, qualsiasi thread può verificare se dispone dell'accesso al <xref:System.Windows.Threading.Dispatcher>.  
  
 La differenza tra <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> e <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> viene <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> restituisce un valore booleano se il thread chiamante non ha accesso per il <xref:System.Windows.Threading.Dispatcher> e <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> genera un'eccezione.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> per determinare se un thread abbia accesso al thread che un <xref:System.Windows.Controls.Button> è stato creato.  Il metodo accetta un oggetto come argomento, che viene eseguito il cast a un <xref:System.Windows.Controls.Button>.  Il <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> metodo sul <xref:System.Windows.Threading.Dispatcher> del <xref:System.Windows.Controls.Button> viene chiamato per verificare l'accesso al thread.  
  
 Se il thread chiamante può accedere al <xref:System.Windows.Threading.Dispatcher>, il <xref:System.Windows.Controls.Button> viene aggiornata tramite l'accesso solo i membri del <xref:System.Windows.Controls.Button>.  
  
 Se il thread chiamante non ha accesso, un <xref:System.InvalidOperationException> viene generata un'eccezione.  In questo esempio rileva l'eccezione e inserisce un delegato che accetta un <xref:System.Windows.Controls.Button> come argomento, nelle <xref:System.Windows.Threading.Dispatcher> del <xref:System.Windows.Controls.Button>.  Ciò <xref:System.Windows.Threading.Dispatcher> eseguirà l'operazione di aggiornamento di <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccessverifyaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccessverifyaccess)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il thread chiamante non ha accesso a <see cref="T:System.Windows.Threading.Dispatcher" />.</exception>
        <altmember cref="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Yield">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un oggetto awaitable che restituisce in modo asincrono il controllo al dispatcher corrente e offre al dispatcher la possibilità di elaborare altri eventi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un oggetto awaitable che restituisce in modo asincrono il controllo al dispatcher corrente e offre al dispatcher la possibilità di elaborare altri eventi.</summary>
        <returns>Oggetto awaitable che restituisce in modo asincrono il controllo al dispatcher corrente e consente a quest'ultimo di elaborare altri eventi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo fornisce un modo per rilasciare temporaneamente il controllo dell'esecuzione al dispatcher corrente in modo che è possibile eseguire altre operazioni, ad esempio elaborare altri eventi. Usare la `await`, o `Await` in Visual Basic, operatore sul valore restituito per restituire il controllo al dispatcher corrente. Usare questo metodo se vuole permettere all'app di elaborare gli eventi mentre l'app esegue molte operazioni sul thread UI. Ad esempio, è possibile utilizzare questo metodo in un ciclo di esecuzione prolungata che aggiorna un controllo.  
  
 Questo metodo è equivalente alla chiamata di <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29> metodo e passando <xref:System.Windows.Threading.DispatcherPriority.Background?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield (priority As DispatcherPriority) As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="static member Yield : System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Priorità con cui pianificare la continuazione.</param>
        <summary>Crea un oggetto awaitable che restituisce in modo asincrono il controllo al dispatcher corrente e offre al dispatcher la possibilità di elaborare altri eventi.  Il lavoro che si verifica quando il controllo ritorna al codice in attesa del risultato di questo metodo viene pianificato in base alla priorità specificata.</summary>
        <returns>Oggetto awaitable che restituisce in modo asincrono il controllo al dispatcher corrente e consente a quest'ultimo di elaborare altri eventi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo fornisce un modo per rilasciare temporaneamente il controllo dell'esecuzione al dispatcher corrente in modo che è possibile eseguire altre operazioni, ad esempio elaborare altri eventi. Usare la `await`, o `Await` in Visual Basic, operatore sul valore restituito per restituire il controllo al dispatcher corrente. Usare questo metodo se vuole permettere all'app di elaborare gli eventi mentre l'app esegue molte operazioni sul thread UI. Ad esempio, è possibile utilizzare questo metodo in un ciclo di esecuzione prolungata che aggiorna un controllo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>