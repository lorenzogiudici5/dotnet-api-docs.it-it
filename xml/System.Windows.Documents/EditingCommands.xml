<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="84b5572cf9ba0ae76ee1c5c3bb7375f8ce499c04" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37521574" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <TypeSignature Language="F#" Value="type EditingCommands = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce un insieme standard di comandi di modifica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente illustra i comandi di modifica e il valore predefinito associato movimenti chiave (con i nomi delle chiavi dal <xref:System.Windows.Input.Key> e <xref:System.Windows.Input.ModifierKeys> enumerazioni).  
  
|Comando di modifica|Tasti di scelta|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|Nessuna combinazione di tasti predefinita|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|Nessuna combinazione di tasti predefinita|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 I comandi di spostamento del punto di inserimento e la selezione di espansione comandi condividono un set comune di combinazioni di tasti predefinite, la differenza generale in corso l'aggiunta del <xref:System.Windows.Input.ModifierKeys.Shift> chiave per distinguere i comandi di selezione da comandi di spostamento del punto di inserimento.  Ad esempio, il <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> comando è una combinazione di tasti predefinita di <xref:System.Windows.Input.Key.Left>e le corrispondenti <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> command include una combinazione di tasti predefinita di <xref:System.Windows.Input.ModifierKeys.Shift> + <xref:System.Windows.Input.Key.Left>.  
  
 In generale, le definizioni dei comandi fornite dal <xref:System.Windows.Documents.EditingCommands> classe non dovrà inserire usare parametri dei comandi (la `parameter` previsto dal parametro il <xref:System.Windows.Input.ICommand.Execute%2A> (metodo)).  
  
 Per altre informazioni sui comandi e l'esecuzione di comandi, vedere [Cenni preliminari sull'Input](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignCenter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />, il quale richiede che il paragrafo corrente o una selezione di paragrafi vengano allineati al centro.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="E" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando opera il <xref:System.Windows.Documents.Paragraph> livello.  Se questo comando viene richiamato su una selezione parziale del contenuto all'interno di un paragrafo (inclusa una selezione vuota in cui si trova il cursore all'interno di un paragrafo), l'effetto richiesto viene applicato all'intero paragrafo.  Se questo comando viene richiamato su una selezione che si estende su più paragrafi, l'effetto viene applicato a tutto il contenuto di ogni paragrafo che fa parte della selezione.  
  
 La figura seguente mostra un esempio del contenuto al centro.  
  
 ![Schermata: Valore della proprietà TextAlign del centro](~/add/media/flowdoc-textalign-center.png "schermata: valore Center della proprietà TextAlign")  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignJustify : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />, il quale richiede che il paragrafo corrente o una selezione di paragrafi vengano giustificati.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="J" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando opera il <xref:System.Windows.Documents.Paragraph> livello.  Se questo comando viene richiamato su una selezione parziale del contenuto all'interno di un paragrafo (inclusa una selezione vuota in cui si trova il cursore all'interno di un paragrafo), l'effetto richiesto viene applicato all'intero paragrafo.  Se questo comando viene richiamato su una selezione che si estende su più paragrafi, l'effetto viene applicato a tutti i paragrafi nella selezione.  
  
 Il contenuto è giustificato, la spaziatura orizzontale all'interno di ogni riga del contenuto è allineata in modo che le righe giustificate sono di larghezza uguale o quasi uguale.  Il contenuto viene giustificato in genere per creare con angoli smussati sui lati del contenuto.  
  
 Poiché spesso è più breve rispetto al resto, l'ultima riga del paragrafo può rimanere giustificata dopo questo comando viene richiamato.  
  
 La figura seguente mostra contenuto non giustificato (allineata a sinistra).  
  
 ![Schermata: Contenuto non giustificato](~/add/media/content-unjustified.png "schermata: contenuto non giustificato")  
  
 La figura seguente mostra lo stesso contenuto dopo che è stata motivata.  
  
 ![Screenshot del contenuto giustificato testo](~/add/media/content-justified.png "Screenshot del contenuto giustificato testo")  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />, il quale richiede che una selezione di contenuto venga allineata a sinistra.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando opera il <xref:System.Windows.Documents.Paragraph> livello.  Se questo comando viene richiamato su una selezione parziale del contenuto all'interno di un paragrafo (inclusa una selezione vuota in cui si trova il cursore all'interno di un paragrafo), l'effetto richiesto viene applicato all'intero paragrafo.  Se questo comando viene richiamato su una selezione che si estende su più paragrafi, l'effetto viene applicato a tutto il contenuto di ogni paragrafo che fa parte della selezione.  
  
 La figura seguente mostra un esempio del contenuto allineato a sinistra.  
  
 ![Schermata: Valore della proprietà TextAlign di rimasti](~/add/media/flowdoc-textalign-left.png "schermata: valore Left della proprietà TextAlign")  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" />, il quale richiede che una selezione di contenuto venga allineata a destra.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="R" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando opera il <xref:System.Windows.Documents.Paragraph> livello.  Se questo comando viene richiamato su una selezione parziale del contenuto all'interno di un paragrafo (inclusa una selezione vuota in cui si trova il cursore all'interno di un paragrafo), l'effetto richiesto viene applicato all'intero paragrafo.  Se questo comando viene richiamato su una selezione che si estende su più paragrafi, l'effetto viene applicato a tutto il contenuto di ogni paragrafo che fa parte della selezione.  
  
 La figura seguente mostra un esempio del contenuto allineato a destra.  
  
 ![Schermata: Valore della destra TextAlign](~/add/media/flowdoc-textalign-right.png "Screenshot: TextAlign pari a destra")  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Backspace : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Backspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.Backspace" />, il quale richiede che un carattere backspace venga inserito nella posizione corrente o sulla selezione corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene richiamato su una selezione vuota, questo comando Elimina il separatore di paragrafo o caratteri che precede il cursore. Quando viene richiamato su una selezione non vuota, questo comando Elimina la selezione.  
  
 Questo comando consente di mantenere eventuali impostazioni di formattazione dalla selezione eliminata per il contenuto inserito nella stessa posizione immediatamente dopo questo comando viene richiamato.  Si differenzia il <xref:System.Windows.Documents.EditingCommands.Delete%2A> comando, che non mantiene la formattazione precedente.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorrectSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />, il quale richiede la correzione delle parole digitate in modo non corretto nella posizione corrente.</summary>
        <value>Comando richiesto.  Questo comando non dispone di una combinazione di tasti predefinita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />, il quale richiede che le dimensioni del carattere per la selezione corrente vengano ridotte di 1 punto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="OemOpenBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo comando viene richiamato su una selezione vuota in cui si trova il cursore all'interno di una parola, la selezione viene automaticamente espanso per applicare il comando per l'intera parola.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />, il quale richiede che il rientro per il paragrafo corrente venga ridotto di una tabulazione.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  Questo comando non ha effetto su un elemento di testo, a meno che il <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> dell'elemento di testo viene impostata su `true`.  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Delete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.Delete" />, il quale richiede che la selezione corrente venga eliminata.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando rimuove qualsiasi formattazione dalla selezione eliminata.  Si differenzia il <xref:System.Windows.Documents.EditingCommands.Backspace%2A> comando, che mantiene la formattazione dalla selezione eliminata per il contenuto inserito nella stessa posizione immediatamente dopo questo comando viene richiamato.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteNextWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />, il quale richiede che la parola successiva in relazione alla posizione corrente venga eliminata.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il cursore si trova all'interno di una parola, viene eliminato il resto della parola tra la posizione corrente e la fine della parola.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeletePreviousWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />, il quale richiede che la parola precedente in relazione alla posizione corrente venga eliminata.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il cursore si trova all'interno di una parola, viene eliminato il resto della parola tra la posizione corrente e l'inizio della parola.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterLineBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />, il quale richiede l'inserimento di un'interruzione di riga nella posizione corrente o sulla selezione corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Shift" /> + <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per gli editor che supportano contenuto dinamico, ad esempio <xref:System.Windows.Controls.RichTextBox>, questo comando fa sì che un <xref:System.Windows.Documents.LineBreak> elemento da inserire in corrispondenza della posizione corrente.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox> e <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterParagraphBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />, il quale richiede l'inserimento di un'interruzione di paragrafo nella posizione corrente o sulla selezione corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando è equivalente alla pressione del tasto Invio dell'utente.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox> e <xref:System.Windows.Controls.TextBox> (quando il <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> è di proprietà `true`).  
  
> [!IMPORTANT]
>  Questo comando non ha effetto su un elemento di testo, a meno che il <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> dell'elemento di testo viene impostata su `true`.  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />, il quale richiede che le istanze di parole digitate in modo non corretto nella posizione o selezione corrente vengano ignorate.</summary>
        <value>Comando richiesto.  Questo comando non dispone di una combinazione di tasti predefinita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />, il quale richiede che le dimensioni del carattere per la selezione corrente vengano aumentate di 1 punto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="OemCloseBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo comando viene richiamato su una selezione vuota in cui si trova il cursore all'interno di una parola, la selezione viene espanso per applicare il comando per l'intera parola.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />, il quale richiede che il rientro per il paragrafo corrente venga aumentato di una tabulazione.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  Questo comando non ha effetto su un elemento di testo, a meno che il <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> dell'elemento di testo viene impostata su `true`.  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />, il quale richiede che il cursore venga spostato di una riga verso il basso.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox> e <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />, il quale richiede che il cursore venga spostato di una pagina verso il basso.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox> e <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />, il quale richiede che il cursore venga spostato di un paragrafo verso il basso.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando posiziona l'accento circonflesso all'inizio del paragrafo successivo.  
  
 Questo comando si comporta come <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> quando viene richiamato su un <xref:System.Windows.Controls.TextBox>.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox> e <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />, il quale richiede che il cursore venga spostato di un carattere verso sinistra.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />, il quale richiede che il cursore venga spostato di una parola verso sinistra.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il cursore si trova all'interno di una parola, questo comando Sposta il cursore all'inizio della parola.  In caso contrario, questo comando Sposta il punto di inserimento all'inizio della parola precedente.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />, il quale richiede che il cursore venga spostato di un carattere verso destra.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />, il quale richiede che il cursore venga spostato di una parola verso destra.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il cursore si trova all'interno di una parola, questo comando Sposta il cursore alla fine della parola.  In caso contrario, questo comando Sposta il punto di inserimento all'inizio della parola successiva.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />, il quale richiede che il cursore venga spostato alla fine del contenuto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto *contenitore di testo* è l'elemento che costituisce il bordo finale per il contenuto in questione.  <xref:System.Windows.Controls.TextBlock> e <xref:System.Windows.Documents.FlowDocument> sono esempi di contenitori di testo.  Il contenuto collettivamente all'interno di un contenitore di testo viene considerato un *documento*.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />, il quale richiede che il cursore venga spostato all'inizio del contenuto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto *contenitore di testo* è l'elemento che costituisce il bordo finale per il contenuto in questione.  <xref:System.Windows.Controls.TextBlock> e <xref:System.Windows.Documents.FlowDocument> sono esempi di contenitori di testo.  Il contenuto collettivamente all'interno di un contenitore di testo viene considerato un *documento*.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />, il quale richiede che il cursore venga spostato alla fine della riga corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />, il quale richiede che il cursore venga spostato all'inizio della riga corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />, il quale richiede che il cursore venga spostato di una riga verso l'alto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox> e <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />, il quale richiede che il cursore venga spostato di una pagina verso l'alto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox> e <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />, il quale richiede che il cursore venga spostato di un paragrafo verso l'alto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando posiziona l'accento circonflesso all'inizio del paragrafo successivo.  
  
 Questo comando si comporta come <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> quando viene richiamato su un <xref:System.Windows.Controls.TextBox>.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox> e <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />, il quale richiede che la selezione corrente venga espansa di una riga verso il basso.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />, il quale richiede che la selezione corrente venga espansa di una pagina verso il basso.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Shift" /> + <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />, il quale richiede che la selezione corrente venga espansa di un paragrafo verso il basso.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando consente di espandere la selezione all'inizio del paragrafo successivo.  In caso contrario, questo comando consente di espandere la selezione alla fine del paragrafo corrente.  La selezione espansa includerà l'interruzione di paragrafo che contrassegna la fine del paragrafo.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />, il quale richiede che la selezione corrente venga espansa di un carattere verso sinistra.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />, il quale richiede che la selezione corrente venga espansa di una parola verso sinistra.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il cursore si trova all'interno di una parola, questo comando consente di espandere la selezione all'inizio della parola.  In caso contrario, questo comando consente di espandere la selezione all'inizio della parola precedente.  
  
 La selezione espansa non include i delimitatori di parola.  Si differenzia <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, che include i delimitatori di parola nella selezione espansa.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />, il quale richiede che la selezione corrente venga espansa di un carattere verso destra.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />, il quale richiede che la selezione corrente venga espansa di una parola verso destra.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il cursore si trova all'interno di una parola, questo comando consente di espandere la selezione alla fine della parola.  In caso contrario, questo comando consente di espandere la selezione alla fine della parola successiva.  
  
 La selezione espansa include i delimitatori di parola.  Si differenzia <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> che non include i delimitatori di parola nella selezione espansa.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />, il quale richiede che la selezione corrente venga espansa alla fine del contenuto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto *contenitore di testo* è l'elemento che costituisce il bordo finale per il contenuto in questione.  <xref:System.Windows.Controls.TextBlock> e <xref:System.Windows.Documents.FlowDocument> sono esempi di contenitori di testo.  Il contenuto collettivamente all'interno di un contenitore di testo viene considerato un *documento*.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />, il quale richiede che la selezione corrente venga espansa all'inizio del contenuto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto *contenitore di testo* è l'elemento che costituisce il bordo finale per il contenuto in questione.  <xref:System.Windows.Controls.TextBlock> e <xref:System.Windows.Documents.FlowDocument> sono esempi di contenitori di testo.  Il contenuto collettivamente all'interno di un contenitore di testo viene considerato un *documento*.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />, il quale richiede che la selezione corrente venga espansa alla fine della riga corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />, il quale richiede che la selezione corrente venga espansa all'inizio della riga corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />, il quale richiede che la selezione corrente venga espansa di una riga verso l'alto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />, il quale richiede che la selezione corrente venga espansa di una pagina verso l'alto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Shift" /> + <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />, il quale richiede che la selezione corrente venga espansa di un paragrafo verso l'alto.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si trova il cursore all'inizio di un paragrafo, questo comando consente di espandere la selezione all'inizio del paragrafo precedente.  In caso contrario, questo comando consente di espandere la selezione all'inizio del paragrafo corrente.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabBackward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" />.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Shift" /> + <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento per questo comando dipende dalla selezione corrente. Se la selezione è non vuoto, questo comando è equivalente a <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>. Se il cursore si trova in una cella della tabella (rappresentato dal <xref:System.Windows.Documents.TableCell> elemento), questo comando Sposta il cursore nella cella precedente. In caso contrario, viene inserito un carattere di tabulazione nella posizione corrente.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox> e <xref:System.Windows.Controls.TextBox> (quando il <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> è di proprietà `true`).  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabForward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.TabForward" />.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento per questo comando dipende dalla selezione corrente. Se la selezione non è vuoto o se la selezione è vuota e la posizione corrente del cursore all'inizio di un paragrafo, questo comando è equivalente a <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>. Se il cursore si trova in una cella della tabella (rappresentato dal <xref:System.Windows.Documents.TableCell> elemento), questo comando Sposta il punto di inserimento alla cella successiva. Se il cursore si trova nell'ultima cella di una tabella, questo comando determina una nuova riga da aggiungere alla tabella, il cursore viene posizionato nella prima cella della nuova riga.  In caso contrario, viene inserito un carattere di tabulazione nella posizione corrente.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox> e <xref:System.Windows.Controls.TextBox> (quando il <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> è di proprietà `true`).  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBold : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />, il quale richiede che la formattazione <see cref="T:System.Windows.Documents.Bold" /> venga attivata o disattivata sulla selezione corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="B" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.FontWeight> per la selezione corrente è compreso nell'intervallo tra <xref:System.Windows.FontWeights.Thin%2A> al <xref:System.Windows.FontWeights.SemiBold%2A>, <xref:System.Windows.FontWeights.Bold%2A> viene applicata alla selezione corrente.  In caso contrario, <xref:System.Windows.FontWeights.Normal%2A> viene applicato.  Per un elenco di comparativo <xref:System.Windows.FontWeight> valori, vedere <xref:System.Windows.FontWeights>.  
  
 Quando la selezione è vuota e il cursore si trova all'interno di una parola, la selezione viene espanso per includere la parola intera.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBullets : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" />, il quale richiede che la formattazione di elenco non ordinato, definito anche elenco puntato, venga attivata o disattivata sulla selezione corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando opera il <xref:System.Windows.Documents.Paragraph> livello.  Se questo comando viene richiamato su una selezione parziale del contenuto all'interno di un paragrafo (inclusa una selezione vuota in cui si trova il cursore all'interno di un paragrafo), l'effetto richiesto viene applicato all'intero paragrafo.  Se questo comando viene richiamato su una selezione che si estende su più paragrafi, l'effetto viene applicato a tutto il contenuto di ogni paragrafo che fa parte della selezione.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleInsert : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" />, il quale passa dalla modalità di digitazione Inserisci a Sovrascrivi, o viceversa.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando è <see langword="Insert" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, e <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleItalic : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />, il quale richiede che la formattazione <see cref="T:System.Windows.Documents.Italic" /> venga attivata o disattivata sulla selezione corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="I" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.FontStyle> per la selezione corrente è <xref:System.Windows.FontStyles.Normal%2A>, <xref:System.Windows.FontStyles.Italic%2A> viene applicata alla selezione corrente.  In caso contrario, <xref:System.Windows.FontStyles.Normal%2A> viene applicato.  
  
 Quando la selezione è vuota e il cursore si trova all'interno di una parola, la selezione viene espanso per includere la parola intera.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleNumbering : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />, il quale richiede che la formattazione di elenco ordinato, definito anche elenco numerato, venga attivata o disattivata sulla selezione corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="N" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo comando opera il <xref:System.Windows.Documents.Paragraph> livello.  Se questo comando viene richiamato su una selezione parziale del contenuto all'interno di un paragrafo (inclusa una selezione vuota in cui si trova il cursore all'interno di un paragrafo), l'effetto richiesto viene applicato all'intero paragrafo.  Se questo comando viene richiamato su una selezione che si estende su più paragrafi, l'effetto viene applicato a tutto il contenuto di ogni paragrafo che fa parte della selezione.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSubscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />, il quale richiede che la formattazione in pedice venga attivata o disattivata sulla selezione corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSuperscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />, il quale richiede che la formattazione in apice venga attivata o disattivata sulla selezione corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleUnderline : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />, il quale richiede che la formattazione <see cref="T:System.Windows.Documents.Underline" /> venga attivata o disattivata sulla selezione corrente.</summary>
        <value>Comando richiesto.  La combinazione di tasti predefinita per questo comando viene <see langword="Ctrl" /> + <see langword="U" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando la selezione è vuota e il cursore si trova all'interno di una parola, la selezione viene espanso per includere la parola intera.  
  
 Non esiste necessariamente un'implementazione effettiva che risponde a questo comando in qualsiasi oggetto specificato. in molti casi l'implementazione che risponde a un comando è responsabilità del writer dell'applicazione.  
  
 Questo comando è supportato da <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come richiamare un comando di modifica su un oggetto che supporta il comando.  
  
 Per questo esempio, un <xref:System.Windows.Controls.RichTextBox> funge da destinazione del comando.  Si noti che <xref:System.Windows.Controls.RichTextBox> implementa la <xref:System.Windows.IInputElement> interface (ereditata da <xref:System.Windows.FrameworkElement>), e che include il supporto nativo per molti comandi di modifica.  
  
 Il primo argomento per il <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodo è un parametro del comando.  I comandi di modifica più ignorano parametro del comando. In generale, questo parametro deve essere `null` per i comandi di modifica.  
  
 Il secondo argomento specifica l'oggetto a cui verrà instradato il comando.  Questo oggetto deve implementare il <xref:System.Windows.IInputElement> interfaccia e deve includere un gestore per il comando specificato.  In genere, un comando viene ignorato quando viene richiamato su un oggetto che non gestisce il comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>