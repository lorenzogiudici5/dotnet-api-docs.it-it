<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d374acbfa59bece9a23ff4841ba74263d0c6fa42" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30630715" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Rappresenta una posizione all'interno di un oggetto <see cref="T:System.Windows.Documents.FlowDocument" /> o <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Documents.TextPointer> classe introduce la seguente terminologia:  
  
-   Posizione - per definizione, un <xref:System.Windows.Documents.TextPointer> fa sempre riferimento a un *posizione* nel contenuto.  Le posizioni si trovano tra i caratteri nel contenuto o dal flusso di contenuto elemento tag che definiscono la struttura del contenuto.  
  
-   Posizione corrente - poiché un <xref:System.Windows.Documents.TextPointer> indica sempre una posizione e poiché molte delle operazioni che possono essere eseguite tramite un <xref:System.Windows.Documents.TextPointer> rispetto a quella attualmente a cui fa riferimento il <xref:System.Windows.Documents.TextPointer>, è opportuno fare riferimento il posizione indicata da una <xref:System.Windows.Documents.TextPointer> come il *posizione corrente*.  
  
-   Posizione di inserimento - un *posizione di inserimento* è una posizione in cui è possibile aggiungere il nuovo contenuto senza interrompere tutte le regole semantiche per il contenuto associato.  In pratica, la posizione di inserimento è un punto qualsiasi nel contenuto in cui non può essere posizionato un punto di inserimento.  Un esempio di un oggetto valido <xref:System.Windows.Documents.TextPointer> posizione che non è una posizione di inserimento è la posizione tra due adiacenti <xref:System.Windows.Documents.Paragraph> tag (vale a dire tra il tag di chiusura del paragrafo precedente e il tag di apertura del paragrafo successivo).  
  
-   Simbolo - ai fini di <xref:System.Windows.Documents.TextPointer> operazioni che includono simboli, una delle seguenti viene considerato un *simbolo*:  
  
    -   Tag di apertura o chiusura di un <xref:System.Windows.Documents.TextElement> elemento.  
  
    -   Oggetto <xref:System.Windows.UIElement> elemento contenuto all'interno di un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali un <xref:System.Windows.UIElement> vengono conteggiate come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
    -   Ogni 16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
-   Contenitore di testo - A *contenitore di testo* è l'elemento che forma il bordo finale per il contenuto di flusso vicino; la posizione indicata da una <xref:System.Windows.Documents.TextPointer> rientra sempre all'interno di un contenitore di testo.  Attualmente, un contenitore di testo deve essere un <xref:System.Windows.Documents.FlowDocument> o <xref:System.Windows.Controls.TextBlock>.  In generale, le operazioni tra <xref:System.Windows.Documents.TextPointer> in contenitori di testo diversi non sono supportate.  
  
-   Documento - il contenuto in un contenitore di testo è definito un *documento*, come nel <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> (metodo) e <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> e <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> proprietà.  
  
 Il <xref:System.Windows.Documents.TextPointer> classe è destinata a facilitare l'attraversamento e la modifica del contenuto che è rappresentato da [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] elementi di contenuto del flusso; in genere, tali elementi derivano da <xref:System.Windows.Documents.TextElement>.  Alcune delle operazioni che <xref:System.Windows.Documents.TextPointer> facilita includono quanto segue:  
  
-   Eseguire un confronto ordinale della posizione corrente con una seconda posizione specificata.  Vedere il <xref:System.Windows.Documents.TextPointer.CompareTo%2A> metodo.  
  
-   Determinare il tipo di contenuto adiacente alla posizione corrente in una direzione specificata.  Vedere il <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> (metodo) e <xref:System.Windows.Documents.TextPointerContext> enumerazione.  
  
-   Ottenere il <xref:System.Windows.Documents.TextElement> che definisce l'ambito o non è adiacente alla posizione corrente.  Vedere <xref:System.Windows.Documents.Paragraph> e <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> metodo.  
  
-   Ottenere il contenitore di testo che definisce l'ambito del documento corrente.  Vedere la proprietà <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Ottenere un numero specificato di caratteri che precedono o seguono la posizione corrente.  Vedere il <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> metodo.  
  
-   Inserire una stringa di caratteri in corrispondenza della posizione corrente.  Vedere il <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> metodo.  
  
-   Trovare i limiti di riga nel contenuto.  Vedere il <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> (metodo) e <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> proprietà.  
  
-   La conversione tra <xref:System.Windows.Documents.TextPointer> posizioni e il simbolo viene eseguito l'offset nel contenuto.  Vedere il <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metodi.  
  
-   Eseguire l'hit testing visivo effettuando la conversione tra un <xref:System.Windows.Documents.TextPointer> posizione e un <xref:System.Windows.Point> che rappresenta le coordinate relative.  
  
-   Individuare una posizione di inserimento nelle vicinanze, oppure controllare se la posizione corrente è una posizione di inserimento.  Vedere il <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> metodi e <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> proprietà.  
  
 La posizione e <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> indicato da un <xref:System.Windows.Documents.TextPointer> oggetto non sono modificabili.  Quando il contenuto viene modificato, la posizione indicata da una <xref:System.Windows.Documents.TextPointer> rimane invariato rispetto al testo circostante; piuttosto, l'offset di tale posizione a partire dall'inizio del contenuto viene regolato in proporzione per riflettere la nuova posizione relativa nella contenuto.  Ad esempio, un <xref:System.Windows.Documents.TextPointer> che indica una posizione all'inizio di un paragrafo specificato continua a puntare all'inizio di questo paragrafo, anche quando il contenuto viene inserito o eliminato prima o dopo il paragrafo.  
  
 La <xref:System.Windows.Documents.TextPointer> classe non fornisce alcun costruttore pubblico.  Un'istanza di <xref:System.Windows.Documents.TextPointer> viene creato utilizzando le proprietà o metodi di altri oggetti (inclusi altri <xref:System.Windows.Documents.TextPointer> oggetti). Nell'elenco seguente fornisce alcuni esempi di metodi e proprietà che crea e restituisce un <xref:System.Windows.Documents.TextPointer>.  Questo elenco non è completo:  
  
-   Da un <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> e <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   Da un <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, e <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   Da un <xref:System.Windows.Controls.TextBlock> (contenitore di testo): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, e <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   Da un <xref:System.Windows.Documents.FlowDocument> (contenitore di testo): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, e <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Da un oggetto esistente <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare un <xref:System.Windows.Documents.TextPointer> per cercare una posizione all'interno del primo <xref:System.Windows.Documents.Run> elemento in un contenitore di testo specificato.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 Nell'esempio seguente implementa un algoritmo di ricerca semplicistico utilizzando <xref:System.Windows.Documents.TextPointer> strutture.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che specifica una posizione da confrontare con la posizione corrente.</param>
        <summary>Esegue un confronto ordinale tra le posizioni specificate dall'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e un secondo oggetto <see cref="T:System.Windows.Documents.TextPointer" /> specificato.</summary>
        <returns>–1 se l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente precede <paramref name="position" />; 0 se le posizioni sono uguali; +1 se l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente segue <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore -1 indica che la posizione specificata dall'oggetto corrente <xref:System.Windows.Documents.TextPointer> precede la posizione specificata da `position`.  Il valore 0 indica che le posizioni indicate sono uguali.  Un valore positivo + 1 indica che la posizione specificata dall'oggetto corrente <xref:System.Windows.Documents.TextPointer> segue la posizione specificata da `position`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo di questo metodo.  Nell'esempio di <xref:System.Windows.Documents.TextPointer.CompareTo%2A> metodo viene utilizzato in combinazione con il <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> metodo per verificare se un oggetto specificato <xref:System.Windows.Documents.TextElement> è vuoto.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> specifica una posizione esterna al contenitore di testo associato alla posizione corrente.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Numero di caratteri da eliminare, iniziando dalla posizione corrente. Specificare un valore positivo per eliminare i caratteri che seguono la posizione corrente; specificare un valore negativo per eliminare i caratteri che precedono la posizione corrente.</param>
        <summary>Elimina il numero di caratteri specificato dalla posizione indicata dall'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente.</summary>
        <returns>Numero di caratteri realmente eliminati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specificare un valore positivo per eliminare i caratteri che seguono la posizione corrente (come in <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); specificare un valore negativo per eliminare i caratteri che precedono la posizione corrente (come in <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Il numero di caratteri effettivamente eliminati può essere inferiore al numero specificato da `count`.  Ciò si verifica nei casi in cui `count` specifica più caratteri di quelli esistenti da eliminare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo viene chiamato in una posizione nella quale il testo non è consentito.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> alla fine del contenuto nel contenitore di testo associato alla posizione corrente.</summary>
        <value>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> alla fine del contenuto nel contenitore di testo associato alla posizione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Documents.TextPointer.Parent%2A> per l'oggetto restituito <xref:System.Windows.Documents.TextPointer> è sempre un contenitore di testo (<xref:System.Windows.Controls.TextBlock> o <xref:System.Windows.Documents.FlowDocument>), anziché da un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio del contenuto nel contenitore di testo associato alla posizione corrente.</summary>
        <value>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio del contenuto nel contenitore di testo associato alla posizione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la posizione restituita da questa proprietà in una posizione di base da cui lavorare con gli offset relativi in altre posizioni.  Il <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metodi forniscono un modo per convertire tra posizioni e posizione dell'offset.  
  
 Il <xref:System.Windows.Documents.TextPointer.Parent%2A> per l'oggetto restituito <xref:System.Windows.Documents.TextPointer> è sempre un contenitore di testo (<xref:System.Windows.Controls.TextBlock> o <xref:System.Windows.Documents.FlowDocument>), anziché da un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare un elemento adiacente.</param>
        <summary>Restituisce l'elemento, se presente, che delimita l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente nella direzione logica specificata.</summary>
        <returns>L'elemento adiacente nella <paramref name="direction" /> specificata, oppure <see langword="null" /> se non esiste alcun elemento adiacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'elemento restituito è in genere un <xref:System.Windows.Documents.TextElement>.  Oggetto <xref:System.Windows.UIElement> può essere restituito quando il <xref:System.Windows.Documents.TextPointer> indica una posizione all'interno di un <xref:System.Windows.Documents.BlockUIContainer> elemento o un <xref:System.Windows.Documents.InlineUIContainer> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare un riquadro delimitatore del testo del contenuto.</param>
        <summary>Restituisce un riquadro delimitatore del testo (<see cref="T:System.Windows.Rect" />) per il contenuto che delimita l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente nella direzione logica specificata.</summary>
        <returns>Un riquadro delimitatore del testo per il contenuto che delimita l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente nella direzione specificata, oppure <see cref="P:System.Windows.Rect.Empty" /> se non sono disponibili informazioni valide correnti sul layout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> bordi non sono considerati contenuto ai fini di questo metodo.  Se il <xref:System.Windows.Documents.TextPointer> precede un <xref:System.Windows.Documents.TextElement> bordo, il valore restituito è un rettangolo di selezione per il successivo non<xref:System.Windows.Documents.TextElement> contenuto nella direzione specificata.  Se non è disponibile contenuto nella direzione specificata, a larghezza zero <xref:System.Windows.Rect> viene restituito con un'altezza corrispondente all'altezza del precedente del contenuto.  
  
 L'operazione eseguita da questo metodo dipende da un layout valido.  Se necessario, questo metodo tenta di rigenerare automaticamente un layout valido prima di procedere con l'operazione.  La rigenerazione di un layout può essere un'operazione relativamente costosa.  Utilizzare il <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> proprietà per cercare un layout valido prima di eseguire operazioni che possono rigenerare il layout.  Per ulteriori informazioni, vedere [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare la posizione di inserimento più vicina.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione di inserimento più vicina, nella direzione logica specificata.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione di inserimento più vicina nella direzione specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizione di inserimento è una posizione in cui è possibile aggiungere il nuovo contenuto senza interrompere tutte le regole semantiche per il contenuto associato.  In pratica, la posizione di inserimento è un punto qualsiasi nel contenuto in cui non può essere posizionato un punto di inserimento.  Un esempio di un oggetto valido <xref:System.Windows.Documents.TextPointer> posizione che non è una posizione di inserimento è la posizione tra due adiacenti <xref:System.Windows.Documents.Paragraph> tag (vale a dire tra il tag di chiusura del paragrafo precedente e il tag di apertura del paragrafo successivo).  
  
 Se il <xref:System.Windows.Documents.TextPointer> fa già riferimento a una posizione di inserimento valida, ma il tag di chiusura per una sequenza di formattazione non vuota segue direttamente tale posizione nella direzione specificata, il <xref:System.Windows.Documents.TextPointer> restituito da questo metodo viene regolato punto di inserimento posizione immediatamente successiva alla chiusura della sequenza di formattazione. Si consideri ad esempio la sequenza di markup `<Bold>a</Bold>b`. Si noti che esistono due posizioni di inserimento tra le lettere `a` e `b` : uno che precede la chiusura `Bold` tag e una direttamente dopo la chiusura `Bold` tag. Se <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> viene chiamato su un <xref:System.Windows.Documents.TextPointer> alla posizione immediatamente dopo la lettera `a` e prima della chiusura `Bold` tag e con un `direction` di <xref:System.Windows.Documents.LogicalDirection.Forward>, restituito <xref:System.Windows.Documents.TextPointer> viene regolata per scegliere il posizione precedente la lettera `b`, dopo la chiusura `Bold` tag. Per l'apertura di tag di formattazione quando si lavora nella direzione opposta logica viene eseguita una regolazione di simile. Questo metodo è destinato a fornire un sistema di risoluzione dell'ambiguità tra posizioni di inserimento in casi simili.  
  
 Questo metodo può essere utilizzato anche per selezionare i punti di inserimento quando è coinvolto nella sequenza di tag strutturali. Ad esempio, quando si trova in una posizione tra i tag di apertura e di chiusura, il parametro direzione può essere utilizzato per selezionare il punto di inserimento più vicino all'inizio del paragrafo seguente (specificando <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) o alla fine del paragrafo (precedente specificando <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Se il puntatore si trova già nella posizione di inserimento e non sono adiacenti tag di formattazione nell'oggetto specificato `direction`, restituito <xref:System.Windows.Documents.TextPointer> fa riferimento alla stessa posizione dell'oggetto chiamante <xref:System.Windows.Documents.TextPointer>.  
  
 È presente alcuna posizione di inserimento valido rispetto alla posizione a cui fa riferimento un <xref:System.Windows.Documents.TextPointer>.  Questa situazione può verificarsi se il contenuto di riferimento è strutturalmente incompleto, come in una tabella vuota o un elenco.  In questi casi, questo metodo restituisce semplicemente un <xref:System.Windows.Documents.TextPointer> nella stessa posizione come il <xref:System.Windows.Documents.TextPointer> da cui è stato chiamato questo metodo.  Questo metodo restituisce sempre un valore valido <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare il <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> metodo per verificare se un oggetto <xref:System.Windows.Documents.TextElement> è privo di contenuto stampabile.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio di una riga specificata in relazione all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Numero di marcatori di inizio riga da ignorare quando si determina la riga per la quale restituire la posizione iniziale. I valori negativi specificano le righe precedenti, 0 specifica la riga corrente, mentre i valori positivi specificano le righe successive.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio di una riga specificata in relazione all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che punta all'inizio della riga specificata, con <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> impostato su <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />, oppure <see langword="null" /> se la riga specificata è esterna all'intervallo o se risulta impossibile individuarla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Documents.TextPointer> punta a una posizione ambigua, ad esempio, tra due righe, la riga nella direzione specificata da <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> sia selezionato come riga iniziale relativa.  
  
 L'operazione eseguita da questo metodo dipende da un layout valido.  Se necessario, questo metodo tenta di rigenerare automaticamente un layout valido prima di procedere con l'operazione.  La rigenerazione di un layout può essere un'operazione relativamente costosa.  Utilizzare <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> per cercare un layout valido prima di eseguire operazioni che possono rigenerare il layout.  Per ulteriori informazioni, vedere [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">Numero di marcatori di inizio riga da ignorare quando si determina la riga per la quale restituire la posizione iniziale. I valori negativi specificano le righe precedenti, 0 specifica la riga corrente, mentre i valori positivi specificano le righe successive.</param>
        <param name="actualCount">La restituzione di questo metodo contiene il numero effettivo di marcatori di inizio riga ignorati quando si determina la riga per la quale restituire la posizione iniziale.  Questo valore può essere inferiore a <c>count</c> se si incontra l'inizio o la fine del contenuto prima che il numero di righe specificato sia ignorato. Questo parametro viene passato non inizializzato.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio di una riga specificata in relazione all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e segnala quante righe sono state ignorate.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che punta all'inizio della riga specificata, con <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> impostato su <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />, oppure all'inizio della riga più vicina alla riga specificata se quest'ultima è esterna all'intervallo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Documents.TextPointer> punta a una posizione ambigua, ad esempio, tra due righe, la riga nella direzione specificata per il <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> proprietà è selezionata come riga iniziale relativa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare il simbolo successivo.</param>
        <summary>Restituisce un puntatore al simbolo successivo nella direzione logica specificata.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> al simbolo successivo nella direzione richiesta, oppure <see langword="null" /> se l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente delimita l'inizio o la fine del contenuto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno dei seguenti è considerato un simbolo:  
  
-   Tag di apertura o chiusura di un <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Oggetto <xref:System.Windows.UIElement> elemento contenuto un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali un <xref:System.Windows.UIElement> vengono conteggiate come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
-   16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
 Se il simbolo successivo è stato categorizzato come <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, o <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (identificato con il <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> (metodo)), il <xref:System.Windows.Documents.TextPointer> restituito da questo metodo viene avanzato esattamente di un simbolo dalla posizione corrente.  
  
 Se il simbolo successivo è stato categorizzato come <xref:System.Windows.Documents.TextPointerContext.Text>, il <xref:System.Windows.Documents.TextPointer> restituito da questo metodo è avanzato oltre il testo per il simbolo non di testo successivo (vale a dire la posizione successiva nel <xref:System.Windows.Documents.TextPointerContext> non <xref:System.Windows.Documents.TextPointerContext.Text>).  Il conteggio esatto dei simboli attraversati può essere calcolato in anticipo chiamando il <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo di questo metodo.  Nell'esempio viene utilizzato il <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> metodo in combinazione con il <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metodo per attraversare ed estrarre i simboli in un oggetto specificato <xref:System.Windows.Documents.TextElement>.  
  
 Mentre l'esempio può essere utilizzato per estrarre un [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] struttura per il contenuto di un determinato <xref:System.Windows.Documents.TextElement>, è destinato solo a scopo illustrativo e non deve essere utilizzato nel codice di produzione.  Vedere il <xref:System.Xml> spazio dei nomi per un set completo di tipi progettati per l'utilizzo e l'elaborazione di XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare la posizione di inserimento successiva.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione di inserimento successiva nella direzione logica specificata.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che identifica la posizione di inserimento successiva nella direzione richiesta, oppure <see langword="null" /> se risulta impossibile trovare una posizione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *posizione di inserimento* è una posizione in cui è possibile aggiungere il nuovo contenuto senza interrompere tutte le regole semantiche per il contenuto associato.  In pratica, la posizione di inserimento è un punto qualsiasi nel contenuto in cui non può essere posizionato un punto di inserimento.  Un esempio di un oggetto valido <xref:System.Windows.Documents.TextPointer> posizione che non è una posizione di inserimento è la posizione tra due adiacenti <xref:System.Windows.Documents.Paragraph> tag (vale a dire tra il tag di chiusura del paragrafo precedente e il tag di apertura del paragrafo successivo).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo di questo metodo. Nell'esempio viene utilizzato il <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> metodo attraversare i limiti degli elementi di contenuto per contare il numero di <xref:System.Windows.Documents.Paragraph> gli elementi presentano tra due <xref:System.Windows.Documents.TextPointer> istanze.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che specifica una posizione dalla quale cercare la distanza (in simboli).</param>
        <summary>Restituisce il conteggio dei simboli tra l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e un secondo oggetto <see cref="T:System.Windows.Documents.TextPointer" /> specificato.</summary>
        <returns>Numero di simboli relativo tra l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e <paramref name="position" />.  Un valore negativo indica che l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente segue la posizione specificata da <paramref name="position" />; 0 indica che le posizioni sono uguali; un valore positivo indica che l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente precede la posizione specificata da <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno dei seguenti è considerato un simbolo:  
  
-   Tag di apertura o chiusura di un <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Oggetto <xref:System.Windows.UIElement> elemento contenuto un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali un <xref:System.Windows.UIElement> vengono conteggiate come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
-   16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo di questo metodo. Nell'esempio viene utilizzato il <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> metodo per trovare gli offset per due <xref:System.Windows.Documents.TextPointer> istanze e quindi utilizza queste informazioni per salvare e ripristinare la selezione in un <xref:System.Windows.Controls.RichTextBox>.  Nell'esempio si presuppone che il contenuto del <xref:System.Windows.Controls.RichTextBox> non sono stati modificati tra una selezione di salvataggio e il ripristino di selezione.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> specifica una posizione esterna al contenitore di testo associato alla posizione corrente.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale determinare la categoria per il contenuto adiacente.</param>
        <summary>Restituisce un indicatore di categoria per il contenuto adiacente all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente nella direzione logica specificata.</summary>
        <returns>Uno dei valori <see cref="T:System.Windows.Documents.TextPointerContext" /> che indica la categoria per il contenuto adiacente nella direzione logica specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo di questo metodo. Nell'esempio viene utilizzato il <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metodo per implementare un algoritmo per calcolare il saldo di apertura e chiusura dei tag di elementi tra due <xref:System.Windows.Documents.TextPointer> posizioni.  Ogni elemento tag di apertura viene conteggiato come + 1, mentre ogni elemento tag di chiusura viene conteggiato come -1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione indicata dall'offset specificato, in simboli, dall'inizio del contenuto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Offset, in simboli, per il quale calcolare e restituire la posizione.  Se l'offset è negativo, la posizione viene calcolata nella direzione logica opposta a quella indicata dalla proprietà <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione indicata dall'offset specificato, in simboli, dall'inizio dell'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione indicata dall'offset specificato o <see langword="null" /> se non viene trovata una posizione corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno dei seguenti è considerato un simbolo:  
  
-   Tag di apertura o chiusura per il <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Oggetto <xref:System.Windows.UIElement> elemento contenuto un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali un <xref:System.Windows.UIElement> vengono conteggiate come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
-   16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo di questo metodo. Nell'esempio viene utilizzato il <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metodo per implementare una coppia di metodi, uno per calcolare l'offset in una posizione specificata rispetto a un paragrafo di hosting e l'altro per restituire un <xref:System.Windows.Documents.TextPointer> a un offset specificato in un paragrafo specificato.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Offset, in simboli, per il quale calcolare e restituire la posizione.  Se l'offset è negativo, l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> restituito precede l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente; in caso contrario, lo segue.</param>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specificano la direzione logica dell'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> restituito.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione indicata dall'offset specificato, in simboli, dall'inizio dell'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e nella direzione specificata.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione indicata dall'offset specificato o <see langword="null" /> se l'offset si estende oltre la fine del contenuto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno dei seguenti è considerato un simbolo:  
  
-   Tag di apertura o chiusura per il <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Oggetto <xref:System.Windows.UIElement> elemento contenuto un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali un <xref:System.Windows.UIElement> vengono conteggiate come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
-   16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il testo adiacente all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare e restituire il testo adiacente.</param>
        <summary>Restituisce una stringa contenente il testo adiacente all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente nella direzione logica specificata.</summary>
        <returns>Stringa contenente il testo adiacente nella direzione logica specificata, oppure <see cref="F:System.String.Empty" /> se risulta impossibile trovare un testo adiacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce solo viene eseguito senza interruzioni di testo.  Non viene restituito se un tipo di simbolo diverso da <xref:System.Windows.Documents.TextPointerContext.Text> adiacente all'oggetto corrente <xref:System.Windows.Documents.TextPointer> nella direzione specificata.  Analogamente, verrà restituito testo solo fino al successivo simbolo non di testo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo di questo metodo. Nell'esempio viene utilizzato il <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> metodo per implementare un semplice estrattore di testo.  Il metodo restituisce una concatenazione di stringhe di tutto il testo tra due <xref:System.Windows.Documents.TextPointer> istanze.  
  
 Mentre l'esempio può essere utilizzato per estrarre il testo compreso tra due <xref:System.Windows.Documents.TextPointer> istanze, è destinato solo a scopo illustrativo e non deve essere utilizzato nel codice di produzione.  In alternativa, usare la proprietà <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare e copiare il testo adiacente.</param>
        <param name="textBuffer">Buffer nel quale viene copiato il testo.</param>
        <param name="startIndex">Indice in <c>textBuffer</c> in corrispondenza del quale iniziare a scrivere il testo copiato.</param>
        <param name="count">Numero massimo di caratteri da copiare.</param>
        <summary>Copia il numero di caratteri massimo specificato da un testo adiacente nella direzione specificata in una matrice di caratteri fornita dal chiamante.</summary>
        <returns>Numero di caratteri realmente copiati in <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce solo viene eseguito senza interruzioni di testo.  Non viene restituito se un tipo di simbolo diverso da <xref:System.Windows.Documents.TextPointerContext.Text> adiacente all'oggetto corrente <xref:System.Windows.Documents.TextPointer> nella direzione specificata.  Analogamente, verrà restituito testo solo fino al successivo simbolo non di testo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> è inferiore a 0 o superiore alla proprietà <see cref="P:System.Array.Length" /> di <paramref name="textBuffer" />.  
  
 oppure  
  
 <paramref name="count" /> è minore di 0 o maggiore dello spazio rimanente in <paramref name="textBuffer" /> (<paramref name="textBuffer" />,<see cref="P:System.Array.Length" /> meno <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale contare il numero di caratteri.</param>
        <summary>Restituisce il numero di caratteri Unicode tra l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e il simbolo non testuale successivo, nella direzione logica specificata.</summary>
        <returns>Numero di caratteri Unicode tra l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e il simbolo non testuale successivo.  Questo numero può essere 0 in assenza di un testo adiacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno dei seguenti è considerato un simbolo:  
  
-   Tag di apertura o chiusura per il <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Oggetto <xref:System.Windows.UIElement> elemento contenuto un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali un <xref:System.Windows.UIElement> vengono conteggiate come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
-   16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il contenitore di testo associato alla posizione corrente ha un layout valido (aggiornato).</summary>
        <value>
          <see langword="true" /> se il layout è aggiornato e valido; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando necessario, le operazioni che dipendono da un layout valido (ad esempio il <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> (metodo), <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> (metodo), e <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> proprietà) tentano di rigenerare automaticamente un layout valido prima di procedere con l'operazione.  La rigenerazione di un layout può essere un'operazione relativamente costosa.  Utilizzare questa proprietà per cercare un layout valido prima di eseguire operazioni che possono rigenerare il layout.  Per ulteriori informazioni, vedere [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserisce un'interruzione di riga nella posizione corrente.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> posizionato immediatamente dopo l'elemento <see cref="T:System.Windows.Documents.LineBreak" /> inserito da questo metodo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserisce un'interruzione di paragrafo nella posizione corrente.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) del nuovo paragrafo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo metodo viene chiamato quando la posizione corrente si trova all'interno di un oggetto esistente <xref:System.Windows.Documents.Paragraph> elemento, il paragrafo esistente e il contenuto viene suddivisa in due paragrafi in corrispondenza della posizione corrente.  Se questo metodo viene chiamato quando la posizione corrente non è presente all'interno di un paragrafo esistente, viene inserito un paragrafo di nuovo e vuoto.  Se questo metodo viene chiamato in una posizione non è adatto per la suddivisione o l'inserimento di un paragrafo (ad esempio, se la posizione corrente si trova all'interno di un <xref:System.Windows.Documents.Hyperlink> elemento), viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questo metodo viene chiamato in una posizione che non può essere divisa per contenere un nuovo paragrafo, ad esempio nell'ambito di un oggetto <see cref="T:System.Windows.Documents.Hyperlink" /> o <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Testo da inserire.</param>
        <summary>Inserisce il testo specificato nell'elemento <see cref="T:System.Windows.Documents.Run" /> del testo nella posizione corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Documents.TextPointer> non ha l'ambito da un <xref:System.Windows.Documents.Run> elemento, un <xref:System.Windows.Documents.Run> viene inserito insieme con il `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La posizione corrente non si trova all'interno di un elemento <see cref="T:System.Windows.Documents.Run" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la posizione corrente è una posizione di inserimento.</summary>
        <value>
          <see langword="true" /> se la posizione corrente è una posizione di inserimento. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizione di inserimento è una posizione in cui è possibile aggiungere il nuovo contenuto senza interrompere tutte le regole semantiche per il contenuto associato.  In pratica, la posizione di inserimento è un punto qualsiasi nel contenuto in cui non può essere posizionato un punto di inserimento.  Un esempio di un oggetto valido <xref:System.Windows.Documents.TextPointer> posizione che non è una posizione di inserimento è la posizione tra due adiacenti <xref:System.Windows.Documents.Paragraph> tag (vale a dire tra il tag di chiusura del paragrafo precedente e il tag di apertura del paragrafo successivo).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la posizione corrente è all'inizio di una riga.</summary>
        <value>
          <see langword="true" /> se la posizione corrente è all'inizio di una riga; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Documents.TextPointer> punta a una posizione ambigua, ad esempio, tra due righe, la riga nella direzione specificata per il <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> proprietà è selezionata come riga iniziale relativa.  
  
 L'operazione eseguita da questa proprietà dipende da un layout valido.  Se necessario, questo metodo tenta di rigenerare automaticamente un layout valido prima di procedere con l'operazione.  La rigenerazione di un layout può essere un'operazione relativamente costosa.  Utilizzare il <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> proprietà per cercare un layout valido prima di eseguire operazioni che possono rigenerare il layout.  Per ulteriori informazioni, vedere [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che specifica una posizione da confrontare con la posizione corrente.</param>
        <summary>Indica se la posizione specificata si trova nello stesso contenitore di testo della posizione corrente.</summary>
        <returns>
          <see langword="true" /> se <paramref name="textPosition" /> indica una posizione che si trova nello stesso contenitore di testo della posizione corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La maggior parte delle operazioni che implicano più <xref:System.Windows.Documents.TextPointer> istanze sono valide solo se le istanze in questione indicano le posizioni che sono nell'ambito del contenitore di testo stesso.  Ad esempio il <xref:System.Windows.Documents.TextPointer.CompareTo%2A> e <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> non possono essere utilizzati con un <xref:System.Windows.Documents.TextPointer> in una posizione di fuori del contenitore di testo associato alla posizione corrente.  Utilizzare questo metodo per verificare che un oggetto specificato <xref:System.Windows.Documents.TextPointer> è compatibile con la posizione corrente per tali operazioni.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo di questo metodo.  Nell'esempio viene utilizzato il <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> metodo per verificare se un oggetto <xref:System.Windows.Documents.TextPointer> posizionato tra due altri <xref:System.Windows.Documents.TextPointer> istanze in una situazione in cui non c'è garanzia che le tre posizioni appartengano allo stesso contenitore di testo.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la direzione logica associata alla posizione corrente e utilizzata per risolvere le ambiguità del contenuto associato alla posizione corrente.</summary>
        <value>Valore <see cref="T:System.Windows.Documents.LogicalDirection" /> associato alla posizione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio dell'utilizzo di questa proprietà, il <xref:System.Windows.Documents.LogicalDirection> del <xref:System.Windows.Documents.TextPointer> restituito da un hit test metodo fornisce un riscontro tra due caratteri del testo. La direzione logica specifica quale dei due caratteri effettivamente raggiunto, sinistra o destra.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il paragrafo che fornisce l'ambito alla posizione corrente, se presente.</summary>
        <value>Il <see cref="T:System.Windows.Documents.Paragraph" /> la posizione corrente, che fornisce l'ambito o <see langword="null" /> se tali paragrafo non esiste.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il padre logico che fornisce l'ambito alla posizione corrente.</summary>
        <value>Padre logico che fornisce l'ambito alla posizione corrente.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Questo tipo o membro supporta l'infrastruttura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e non deve essere usato direttamente dal codice.</summary>
        <returns>Stringa che rappresenta l'oggetto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>