<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="78ff844e35266523e6ae9c280abf018a54b675de" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39877532" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Rappresenta una posizione all'interno di un oggetto <see cref="T:System.Windows.Documents.FlowDocument" /> o <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Documents.TextPointer> classe introduce la terminologia seguente:  
  
-   Posizione - per definizione, un <xref:System.Windows.Documents.TextPointer> fa sempre riferimento a un *posizione* nel contenuto.  Le posizioni si trovano tra i caratteri nel contenuto o tra flusso di contenuto elemento tag che definiscono la struttura del contenuto.  
  
-   Posizione corrente - poiché una <xref:System.Windows.Documents.TextPointer> sempre indica una posizione e poiché molte delle operazioni che possono essere eseguite tramite un <xref:System.Windows.Documents.TextPointer> riguardano la posizione a cui puntata il <xref:System.Windows.Documents.TextPointer>, è opportuno fare riferimento al posizione indicata da una <xref:System.Windows.Documents.TextPointer> come il *posizione corrente*.  
  
-   Posizione di inserimento - un' *posizione di inserimento* è una posizione in cui possono essere aggiunti nuovi contenuti senza interrompere tutte le regole semantiche per il contenuto associato.  In pratica, una posizione di inserimento è in un punto qualsiasi nel contenuto in cui non può essere posizionato un punto di inserimento.  Un esempio di un oggetto valido <xref:System.Windows.Documents.TextPointer> che non è una posizione di inserimento si trova la posizione tra due adiacenti <xref:System.Windows.Documents.Paragraph> tag (vale a dire, tra il tag di chiusura del precedente paragrafo e il tag di apertura del paragrafo successivo).  
  
-   Simbolo - per quanto riguarda <xref:System.Windows.Documents.TextPointer> operazioni che coinvolgono i simboli, uno dei seguenti viene considerato un *simbolo*:  
  
    -   Tag di apertura o chiusura di un <xref:System.Windows.Documents.TextElement> elemento.  
  
    -   Oggetto <xref:System.Windows.UIElement> elemento contenuto all'interno di un' <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali una <xref:System.Windows.UIElement> viene sempre conteggiato come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
    -   Ogni 16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
-   Contenitore di testo - A *contenitore di testo* è l'elemento che costituisce il bordo finale per il contenuto del flusso in questione; nella posizione indicata da un <xref:System.Windows.Documents.TextPointer> sempre rientra in un contenitore di testo.  Attualmente, un contenitore di testo deve essere un <xref:System.Windows.Documents.FlowDocument> o un <xref:System.Windows.Controls.TextBlock>.  In generale, le operazioni tra <xref:System.Windows.Documents.TextPointer> istanze nei contenitori di testo diversi non sono supportate.  
  
-   Documento - il contenuto in un contenitore di testo viene definito un *documento*, come nel <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> metodo e il <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> e <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> proprietà.  
  
 Il <xref:System.Windows.Documents.TextPointer> classe è destinata a facilitare l'attraversamento e manipolazione di contenuto rappresentato da [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] elementi di contenuto del flusso; in genere, tali elementi derivano da <xref:System.Windows.Documents.TextElement>.  Alcune delle operazioni che <xref:System.Windows.Documents.TextPointer> facilita includono quanto segue:  
  
-   Eseguire un confronto ordinale della posizione corrente con una seconda posizione specificata.  Vedere il <xref:System.Windows.Documents.TextPointer.CompareTo%2A> (metodo).  
  
-   Determinare il tipo di contenuto adiacente nella posizione corrente in una direzione specificata.  Vedere le <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metodo e <xref:System.Windows.Documents.TextPointerContext> enumerazione.  
  
-   Ottenere il <xref:System.Windows.Documents.TextElement> che definisce l'ambito o adiacente nella posizione corrente.  Visualizzare <xref:System.Windows.Documents.Paragraph> e il <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> (metodo).  
  
-   Ottenere il contenitore di testo che definisce l'ambito del documento corrente.  Vedere la proprietà <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Ottenere un numero specificato di caratteri che precedono o seguono la posizione corrente.  Vedere il <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> (metodo).  
  
-   Inserire una stringa di caratteri in corrispondenza della posizione corrente.  Vedere il <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> (metodo).  
  
-   Cercare i limiti di riga nel contenuto.  Vedere le <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> metodo e <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> proprietà.  
  
-   Conversione tra <xref:System.Windows.Documents.TextPointer> le posizioni e il simbolo viene eseguito l'offset nel contenuto.  Vedere le <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metodi.  
  
-   Eseguire l'hit testing visivo traducendo tra un <xref:System.Windows.Documents.TextPointer> posizione e un <xref:System.Windows.Point> che rappresenta le coordinate relative.  
  
-   Trovare una posizione di inserimento nelle vicinanze o verificare se la posizione corrente è una posizione di inserimento.  Vedere le <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> metodi e le <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> proprietà.  
  
 La posizione e <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> indicata da un <xref:System.Windows.Documents.TextPointer> oggetto non sono modificabili.  Quando il contenuto viene modificato, nella posizione indicata da un <xref:System.Windows.Documents.TextPointer> rimane invariato rispetto al testo circostante; piuttosto l'offset di tale posizione dall'inizio del contenuto viene regolato di conseguenza in modo da riflettere la nuova posizione relativa nella contenuto.  Ad esempio, un <xref:System.Windows.Documents.TextPointer> che indica una posizione all'inizio di un determinato paragrafo continua in modo che punti all'inizio del paragrafo, anche quando il contenuto viene inserito o eliminato prima o dopo il paragrafo.  
  
 Il <xref:System.Windows.Documents.TextPointer> classe non fornisce alcun costruttore pubblici.  Un'istanza di <xref:System.Windows.Documents.TextPointer> viene creato usando i metodi o proprietà di altri oggetti (inclusi altri <xref:System.Windows.Documents.TextPointer> oggetti). Nell'elenco seguente offre alcuni esempi di metodi e proprietà che crea e restituisce un <xref:System.Windows.Documents.TextPointer>.  Questo elenco non è completo:  
  
-   Da un <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> e <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   Da un <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, e <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   Da un <xref:System.Windows.Controls.TextBlock> (contenitore di testo): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, e <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   Da un <xref:System.Windows.Documents.FlowDocument> (contenitore di testo): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, e <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Da un oggetto esistente <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare un <xref:System.Windows.Documents.TextPointer> per cercare una posizione all'interno del primo <xref:System.Windows.Documents.Run> elemento in un contenitore di testo specificato.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 L'esempio seguente implementa un algoritmo di ricerca semplicistico usando <xref:System.Windows.Documents.TextPointer> strutture.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che specifica una posizione da confrontare con la posizione corrente.</param>
        <summary>Esegue un confronto ordinale tra le posizioni specificate dall'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e un secondo oggetto <see cref="T:System.Windows.Documents.TextPointer" /> specificato.</summary>
        <returns>–1 se l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente precede <paramref name="position" />; 0 se le posizioni sono uguali; +1 se l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente segue <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valore pari a – 1 indica che la posizione specificata dall'oggetto corrente <xref:System.Windows.Documents.TextPointer> precede quella specificata da `position`.  Il valore 0 indica che le posizioni indicate sono uguali.  Un valore positivo + 1 indica che la posizione specificata dall'oggetto corrente <xref:System.Windows.Documents.TextPointer> segue quella specificata da `position`.  
  
   
  
## Examples  
 L'esempio seguente illustra un uso di questo metodo.  Nell'esempio, il <xref:System.Windows.Documents.TextPointer.CompareTo%2A> metodo viene utilizzato in combinazione con il <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> metodo per verificare se un determinato <xref:System.Windows.Documents.TextElement> è vuoto.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> specifica una posizione esterna al contenitore di testo associato alla posizione corrente.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Numero di caratteri da eliminare, iniziando dalla posizione corrente. Specificare un valore positivo per eliminare i caratteri che seguono la posizione corrente; specificare un valore negativo per eliminare i caratteri che precedono la posizione corrente.</param>
        <summary>Elimina il numero di caratteri specificato dalla posizione indicata dall'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente.</summary>
        <returns>Numero di caratteri realmente eliminati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specificare un valore positivo per eliminare i caratteri che seguono la posizione corrente (come in <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); specificare un valore negativo per eliminare i caratteri che precedono la posizione corrente (come in <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Il numero di caratteri effettivamente eliminato può essere inferiore al numero specificato da `count`.  Ciò si verifica nei casi in cui `count` specifica più caratteri di quelli disponibili per essere eliminato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo viene chiamato in una posizione nella quale il testo non è consentito.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> alla fine del contenuto nel contenitore di testo associato alla posizione corrente.</summary>
        <value>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> alla fine del contenuto nel contenitore di testo associato alla posizione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Documents.TextPointer.Parent%2A> per l'oggetto restituito <xref:System.Windows.Documents.TextPointer> è sempre un contenitore di testo (<xref:System.Windows.Controls.TextBlock> oppure <xref:System.Windows.Documents.FlowDocument>), anziché un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio del contenuto nel contenitore di testo associato alla posizione corrente.</summary>
        <value>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio del contenuto nel contenitore di testo associato alla posizione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la posizione restituita da questa proprietà in una posizione della linea di base di partenza per lavorare con offset relativi in altre posizioni.  Il <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metodi consentono di eseguire la conversione tra le posizioni e la posizione viene eseguito l'offset.  
  
 Il <xref:System.Windows.Documents.TextPointer.Parent%2A> per l'oggetto restituito <xref:System.Windows.Documents.TextPointer> è sempre un contenitore di testo (<xref:System.Windows.Controls.TextBlock> oppure <xref:System.Windows.Documents.FlowDocument>), anziché un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare un elemento adiacente.</param>
        <summary>Restituisce l'elemento, se presente, che delimita l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente nella direzione logica specificata.</summary>
        <returns>L'elemento adiacente nella <paramref name="direction" /> specificata, oppure <see langword="null" /> se non esiste alcun elemento adiacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'elemento restituito è in genere un <xref:System.Windows.Documents.TextElement>.  Oggetto <xref:System.Windows.UIElement> può essere restituito quando il <xref:System.Windows.Documents.TextPointer> indica una posizione all'interno di un <xref:System.Windows.Documents.BlockUIContainer> elemento o un <xref:System.Windows.Documents.InlineUIContainer> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare un riquadro delimitatore del testo del contenuto.</param>
        <summary>Restituisce un riquadro delimitatore del testo (<see cref="T:System.Windows.Rect" />) per il contenuto che delimita l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente nella direzione logica specificata.</summary>
        <returns>Un riquadro delimitatore del testo per il contenuto che delimita l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente nella direzione specificata, oppure <see cref="P:System.Windows.Rect.Empty" /> se non sono disponibili informazioni valide correnti sul layout.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> i bordi non sono considerati contenuti ai fini di questo metodo.  Se il <xref:System.Windows.Documents.TextPointer> precede una <xref:System.Windows.Documents.TextElement> edge, il valore restituito è un rettangolo per il successivo non<xref:System.Windows.Documents.TextElement> contenuto nella direzione specificata.  Se non è contenuto nella direzione specificata, a larghezza zero <xref:System.Windows.Rect> vengono restituiti con un'altezza corrispondente all'altezza del precedente del contenuto.  
  
 L'operazione eseguita da questo metodo è dipende da un layout valido.  Se necessario, questo metodo tenta automaticamente rigenerare un layout valido prima di procedere con l'operazione.  La rigenerazione di un layout può essere un'operazione relativamente costosa.  Usare il <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> proprietà da controllare per un layout valido prima di eseguire operazioni che possono rigenerare il layout.  Per altre informazioni, vedere [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare la posizione di inserimento più vicina.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione di inserimento più vicina, nella direzione logica specificata.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione di inserimento più vicina nella direzione specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizione di inserimento è una posizione in cui possono essere aggiunti nuovi contenuti senza interrompere tutte le regole semantiche per il contenuto associato.  In pratica, una posizione di inserimento è in un punto qualsiasi nel contenuto in cui non può essere posizionato un punto di inserimento.  Un esempio di un oggetto valido <xref:System.Windows.Documents.TextPointer> che non è una posizione di inserimento si trova la posizione tra due adiacenti <xref:System.Windows.Documents.Paragraph> tag (vale a dire, tra il tag di chiusura del precedente paragrafo e il tag di apertura del paragrafo successivo).  
  
 Se il <xref:System.Windows.Documents.TextPointer> punta già a una posizione di inserimento valido, ma il tag di chiusura per una sequenza di formattazione non vuoto segue direttamente tale posizione nella direzione specificata, il <xref:System.Windows.Documents.TextPointer> restituito da questo metodo viene regolato in modo da puntare dell'operazione di inserimento posizione immediatamente successiva alla chiusura della sequenza di formattazione. Ad esempio, considerare la sequenza di markup `<Bold>a</Bold>b`. Si noti che esistono due posizioni di inserimento tra le lettere `a` e `b` , ovvero uno che precede la chiusura `Bold` tag e uno subito dopo la chiusura `Bold` tag. Se <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> viene chiamato su una <xref:System.Windows.Documents.TextPointer> alla posizione immediatamente dopo la lettera `a` e prima della chiusura `Bold` tag e con un `direction` del <xref:System.Windows.Documents.LogicalDirection.Forward>, restituito <xref:System.Windows.Documents.TextPointer> viene regolata in modo da puntare al posizione immediatamente precedente la lettera `b`, dopo la chiusura `Bold` tag. Viene eseguito un adattamento simile per l'apertura di tag di formattazione quando si lavora nella direzione logica opposta. Questo metodo è destinato a fornire un sistema di risoluzione dell'ambiguità tra le posizioni di inserimento in casi simili.  
  
 Questo metodo è anche utilizzabile per selezionare i punti di inserimento quando una sequenza di tag strutturale coinvolta. Ad esempio, quando si trova in una posizione tra i tag di apertura e di chiusura, il parametro di direzione può essere utilizzato per selezionare il punto di inserimento più vicino all'inizio del paragrafo seguente (specificando <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) o alla fine del precedente paragrafo ( specificando <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Se il puntatore si trova già nella posizione di inserimento e sono presenti tag di formattazione adiacenti nell'oggetto specificato `direction`, l'oggetto restituito <xref:System.Windows.Documents.TextPointer> fa riferimento nella stessa posizione dell'oggetto chiamante <xref:System.Windows.Documents.TextPointer>.  
  
 È possibile che non esista alcuna posizione di inserimento valido rispetto alla posizione a cui punta un <xref:System.Windows.Documents.TextPointer>.  Questa situazione può verificarsi se il contenuto di riferimento è strutturalmente incompleto, come in una tabella vuota o un elenco.  In questi casi, questo metodo restituisce semplicemente un <xref:System.Windows.Documents.TextPointer> nella stessa posizione come il <xref:System.Windows.Documents.TextPointer> dal quale è stato chiamato questo metodo.  Questo metodo restituisce sempre un valore valido <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Questo esempio illustra come usare il <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> metodo per verificare se un elemento <xref:System.Windows.Documents.TextElement> è privo di contenuto stampabile.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio di una riga specificata in relazione all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Numero di marcatori di inizio riga da ignorare quando si determina la riga per la quale restituire la posizione iniziale. I valori negativi specificano le righe precedenti, 0 specifica la riga corrente, mentre i valori positivi specificano le righe successive.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio di una riga specificata in relazione all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che punta all'inizio della riga specificata, con <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> impostato su <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />, oppure <see langword="null" /> se la riga specificata è esterna all'intervallo o se risulta impossibile individuarla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Documents.TextPointer> punta a una posizione ambigua, ad esempio, tra due righe, la riga nella direzione specificata da <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> è selezionato come la relativa riga iniziale.  
  
 L'operazione eseguita da questo metodo è dipende da un layout valido.  Se necessario, questo metodo tenta automaticamente rigenerare un layout valido prima di procedere con l'operazione.  La rigenerazione di un layout può essere un'operazione relativamente costosa.  Usare <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> per verificare la presenza di un layout valido prima di eseguire operazioni che possono rigenerare il layout.  Per altre informazioni, vedere [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">Numero di marcatori di inizio riga da ignorare quando si determina la riga per la quale restituire la posizione iniziale. I valori negativi specificano le righe precedenti, 0 specifica la riga corrente, mentre i valori positivi specificano le righe successive.</param>
        <param name="actualCount">La restituzione di questo metodo contiene il numero effettivo di marcatori di inizio riga ignorati quando si determina la riga per la quale restituire la posizione iniziale.  Questo valore può essere inferiore a <c>count</c> se si incontra l'inizio o la fine del contenuto prima che il numero di righe specificato sia ignorato. Questo parametro viene passato non inizializzato.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio di una riga specificata in relazione all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e segnala quante righe sono state ignorate.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che punta all'inizio della riga specificata, con <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> impostato su <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />, oppure all'inizio della riga più vicina alla riga specificata se quest'ultima è esterna all'intervallo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Documents.TextPointer> punta a una posizione ambigua, ad esempio, tra due righe, la riga nella direzione specificata dal <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> proprietà è selezionata come la relativa riga iniziale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare il simbolo successivo.</param>
        <summary>Restituisce un puntatore al simbolo successivo nella direzione logica specificata.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> al simbolo successivo nella direzione richiesta, oppure <see langword="null" /> se l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente delimita l'inizio o la fine del contenuto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno dei seguenti viene considerato un simbolo:  
  
-   Tag di apertura o chiusura di un <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Oggetto <xref:System.Windows.UIElement> elemento contenuto in un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali una <xref:System.Windows.UIElement> viene sempre conteggiato come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
-   16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
 Se il simbolo successivo è stato categorizzato come <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, o <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (come identificato dal <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metodo), il <xref:System.Windows.Documents.TextPointer> restituito da questo metodo verrà spostata in avanti esattamente una di simboli dalla posizione corrente.  
  
 Se il simbolo successivo è stato categorizzato come <xref:System.Windows.Documents.TextPointerContext.Text>, il <xref:System.Windows.Documents.TextPointer> restituito da questo metodo è avanzato oltre il testo per il simbolo non testuale successivo (vale a dire la posizione successiva nel <xref:System.Windows.Documents.TextPointerContext> non è <xref:System.Windows.Documents.TextPointerContext.Text>).  Il conteggio esatto dei simboli incrociato può essere calcolato in anticipo chiamando il <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente illustra un uso di questo metodo.  L'esempio Usa la <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> metodo in combinazione con il <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metodo attraversare ed estrarre i simboli in un determinato <xref:System.Windows.Documents.TextElement>.  
  
 Mentre l'esempio può essere utilizzato per estrarre un [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] struttura per il contenuto di un determinato <xref:System.Windows.Documents.TextElement>, è destinato solo a scopo illustrativo e non deve essere utilizzato nel codice di produzione.  Vedere il <xref:System.Xml> dello spazio dei nomi per una vasta gamma di tipi progettati per l'utilizzo e l'elaborazione di XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare la posizione di inserimento successiva.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione di inserimento successiva nella direzione logica specificata.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che identifica la posizione di inserimento successiva nella direzione richiesta, oppure <see langword="null" /> se risulta impossibile trovare una posizione di inserimento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un' *posizione di inserimento* è una posizione in cui possono essere aggiunti nuovi contenuti senza interrompere tutte le regole semantiche per il contenuto associato.  In pratica, una posizione di inserimento è in un punto qualsiasi nel contenuto in cui non può essere posizionato un punto di inserimento.  Un esempio di un oggetto valido <xref:System.Windows.Documents.TextPointer> che non è una posizione di inserimento si trova la posizione tra due adiacenti <xref:System.Windows.Documents.Paragraph> tag (vale a dire, tra il tag di chiusura del precedente paragrafo e il tag di apertura del paragrafo successivo).  
  
   
  
## Examples  
 L'esempio seguente illustra un uso di questo metodo. L'esempio Usa la <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> metodo per attraversare i limiti di elemento di contenuto per contare il numero di <xref:System.Windows.Documents.Paragraph> gli elementi presentano tra due <xref:System.Windows.Documents.TextPointer> istanze.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che specifica una posizione dalla quale cercare la distanza (in simboli).</param>
        <summary>Restituisce il conteggio dei simboli tra l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e un secondo oggetto <see cref="T:System.Windows.Documents.TextPointer" /> specificato.</summary>
        <returns>Numero di simboli relativo tra l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e <paramref name="position" />.  Un valore negativo indica che l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente segue la posizione specificata da <paramref name="position" />; 0 indica che le posizioni sono uguali; un valore positivo indica che l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente precede la posizione specificata da <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno dei seguenti viene considerato un simbolo:  
  
-   Tag di apertura o chiusura di un <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Oggetto <xref:System.Windows.UIElement> elemento contenuto in un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali una <xref:System.Windows.UIElement> viene sempre conteggiato come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
-   16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 L'esempio seguente illustra un uso di questo metodo. L'esempio Usa la <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> metodo per trovare gli offset per due <xref:System.Windows.Documents.TextPointer> istanze e quindi Usa queste informazioni per salvare e ripristinare la selezione in un <xref:System.Windows.Controls.RichTextBox>.  L'esempio presuppone che il contenuto del <xref:System.Windows.Controls.RichTextBox> non sono stati modificati tra una selezione di salvataggio e il ripristino di selezione.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> specifica una posizione esterna al contenitore di testo associato alla posizione corrente.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale determinare la categoria per il contenuto adiacente.</param>
        <summary>Restituisce un indicatore di categoria per il contenuto adiacente all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente nella direzione logica specificata.</summary>
        <returns>Uno dei valori <see cref="T:System.Windows.Documents.TextPointerContext" /> che indica la categoria per il contenuto adiacente nella direzione logica specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente illustra un uso di questo metodo. L'esempio Usa la <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> metodo per implementare un algoritmo per calcolare il saldo di apertura e chiusura di tag di elemento tra due specificato <xref:System.Windows.Documents.TextPointer> posizioni.  Ogni elemento tag di apertura viene conteggiato come + 1, mentre ogni elemento tag di chiusura viene conteggiato come -1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione indicata dall'offset specificato, in simboli, dall'inizio del contenuto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Offset, in simboli, per il quale calcolare e restituire la posizione.  Se l'offset è negativo, la posizione viene calcolata nella direzione logica opposta a quella indicata dalla proprietà <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione indicata dall'offset specificato, in simboli, dall'inizio dell'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione indicata dall'offset specificato o <see langword="null" /> se non viene trovata una posizione corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno dei seguenti viene considerato un simbolo:  
  
-   Tag di apertura o chiusura per il <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Oggetto <xref:System.Windows.UIElement> elemento contenuto in un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali una <xref:System.Windows.UIElement> viene sempre conteggiato come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
-   16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 L'esempio seguente illustra un uso di questo metodo. L'esempio Usa la <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> metodo per implementare una coppia di metodi, uno per la quale calcolare l'offset in una posizione specificata rispetto a un paragrafo di hosting e l'altro per restituire un <xref:System.Windows.Documents.TextPointer> a un offset specificato in un paragrafo specificato.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Offset, in simboli, per il quale calcolare e restituire la posizione.  Se l'offset è negativo, l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> restituito precede l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente; in caso contrario, lo segue.</param>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specificano la direzione logica dell'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> restituito.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione indicata dall'offset specificato, in simboli, dall'inizio dell'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e nella direzione specificata.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> nella posizione indicata dall'offset specificato o <see langword="null" /> se l'offset si estende oltre la fine del contenuto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno dei seguenti viene considerato un simbolo:  
  
-   Tag di apertura o chiusura per il <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Oggetto <xref:System.Windows.UIElement> elemento contenuto in un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali una <xref:System.Windows.UIElement> viene sempre conteggiato come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
-   16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il testo adiacente all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare e restituire il testo adiacente.</param>
        <summary>Restituisce una stringa contenente il testo adiacente all'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente nella direzione logica specificata.</summary>
        <returns>Stringa contenente il testo adiacente nella direzione logica specificata, oppure <see cref="F:System.String.Empty" /> se risulta impossibile trovare un testo adiacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce solo le esecuzioni senza interruzioni di testo.  Se un tipo di simbolo diverso da Nothing viene restituito <xref:System.Windows.Documents.TextPointerContext.Text> adiacente all'oggetto corrente <xref:System.Windows.Documents.TextPointer> nella direzione specificata.  Analogamente, il testo viene restituito solo un massimo di simbolo non testuale successivo.  
  
   
  
## Examples  
 L'esempio seguente illustra un uso di questo metodo. Nell'esempio viene usato il <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> metodo per implementare un estrattore di testo semplice.  Il metodo restituisce una concatenazione di stringhe di tutto il testo tra due specificato <xref:System.Windows.Documents.TextPointer> istanze.  
  
 Mentre l'esempio può essere utilizzato per estrarre qualsiasi testo tra due <xref:System.Windows.Documents.TextPointer> istanze, è destinato solo a scopo illustrativo e non deve essere utilizzato nel codice di produzione.  In alternativa, usare la proprietà <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale cercare e copiare il testo adiacente.</param>
        <param name="textBuffer">Buffer nel quale viene copiato il testo.</param>
        <param name="startIndex">Indice in <c>textBuffer</c> in corrispondenza del quale iniziare a scrivere il testo copiato.</param>
        <param name="count">Numero massimo di caratteri da copiare.</param>
        <summary>Copia il numero di caratteri massimo specificato da un testo adiacente nella direzione specificata in una matrice di caratteri fornita dal chiamante.</summary>
        <returns>Numero di caratteri realmente copiati in <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce solo le esecuzioni senza interruzioni di testo.  Se un tipo di simbolo diverso da Nothing viene restituito <xref:System.Windows.Documents.TextPointerContext.Text> adiacente all'oggetto corrente <xref:System.Windows.Documents.TextPointer> nella direzione specificata.  Analogamente, il testo viene restituito solo un massimo di simbolo non testuale successivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> è inferiore a 0 o superiore alla proprietà <see cref="P:System.Array.Length" /> di <paramref name="textBuffer" />.  
  
oppure 
 <paramref name="count" /> è minore di 0 o maggiore dello spazio rimanente in <paramref name="textBuffer" /> (<paramref name="textBuffer" />,<see cref="P:System.Array.Length" /> meno <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno dei valori <see cref="T:System.Windows.Documents.LogicalDirection" /> che specifica la direzione logica nella quale contare il numero di caratteri.</param>
        <summary>Restituisce il numero di caratteri Unicode tra l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e il simbolo non testuale successivo, nella direzione logica specificata.</summary>
        <returns>Numero di caratteri Unicode tra l'oggetto <see cref="T:System.Windows.Documents.TextPointer" /> corrente e il simbolo non testuale successivo.  Questo numero può essere 0 in assenza di un testo adiacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno dei seguenti viene considerato un simbolo:  
  
-   Tag di apertura o chiusura per il <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Oggetto <xref:System.Windows.UIElement> elemento contenuto in un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Si noti che tali una <xref:System.Windows.UIElement> viene sempre conteggiato come un solo simbolo; qualsiasi contenuto aggiuntivo o gli elementi contenuti dal <xref:System.Windows.UIElement> non vengono conteggiati come simboli.  
  
-   16 bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carattere all'interno di un testo <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il contenitore di testo associato alla posizione corrente ha un layout valido (aggiornato).</summary>
        <value>
          <see langword="true" /> se il layout è aggiornato e valido; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se necessario, operazioni che dipendono da un layout valido (, ad esempio il <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> metodo, <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> metodo, e <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> proprietà) tenta di rigenerare automaticamente un layout valido prima di procedere con l'operazione.  La rigenerazione di un layout può essere un'operazione relativamente costosa.  Utilizzare questa proprietà per verificare la presenza di un layout valido prima di eseguire operazioni che possono rigenerare il layout.  Per altre informazioni, vedere [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserisce un'interruzione di riga nella posizione corrente.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> posizionato immediatamente dopo l'elemento <see cref="T:System.Windows.Documents.LineBreak" /> inserito da questo metodo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserisce un'interruzione di paragrafo nella posizione corrente.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> all'inizio (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) del nuovo paragrafo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo metodo viene chiamato quando la posizione corrente è all'interno di un oggetto esistente <xref:System.Windows.Documents.Paragraph> elemento, il paragrafo esistente e qualsiasi contenuto che contiene vengono suddivise in due paragrafi in corrispondenza della posizione corrente.  Se questo metodo viene chiamato quando la posizione corrente non è presente all'interno di un paragrafo esistente, viene inserito un nuovo paragrafo vuoto.  Se questo metodo viene chiamato in una posizione non idoneo per la suddivisione o l'inserimento di un paragrafo (ad esempio, se la posizione corrente è all'interno di un <xref:System.Windows.Documents.Hyperlink> elemento), viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questo metodo viene chiamato in una posizione che non può essere divisa per contenere un nuovo paragrafo, ad esempio nell'ambito di un oggetto <see cref="T:System.Windows.Documents.Hyperlink" /> o <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Testo da inserire.</param>
        <summary>Inserisce il testo specificato nell'elemento <see cref="T:System.Windows.Documents.Run" /> del testo nella posizione corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Documents.TextPointer> non ha l'ambito da un <xref:System.Windows.Documents.Run> elemento, un <xref:System.Windows.Documents.Run> viene inserito insieme con il `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La posizione corrente non si trova all'interno di un elemento <see cref="T:System.Windows.Documents.Run" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la posizione corrente è una posizione di inserimento.</summary>
        <value>
          <see langword="true" /> se la posizione corrente è una posizione di inserimento. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizione di inserimento è una posizione in cui possono essere aggiunti nuovi contenuti senza interrompere tutte le regole semantiche per il contenuto associato.  In pratica, una posizione di inserimento è in un punto qualsiasi nel contenuto in cui non può essere posizionato un punto di inserimento.  Un esempio di un oggetto valido <xref:System.Windows.Documents.TextPointer> che non è una posizione di inserimento si trova la posizione tra due adiacenti <xref:System.Windows.Documents.Paragraph> tag (vale a dire, tra il tag di chiusura del precedente paragrafo e il tag di apertura del paragrafo successivo).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la posizione corrente è all'inizio di una riga.</summary>
        <value>
          <see langword="true" /> se la posizione corrente è all'inizio di una riga; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Windows.Documents.TextPointer> punta a una posizione ambigua, ad esempio, tra due righe, la riga nella direzione specificata dal <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> proprietà è selezionata come la relativa riga iniziale.  
  
 L'operazione eseguita da questa proprietà dipende da un layout valido.  Se necessario, questo metodo tenta automaticamente rigenerare un layout valido prima di procedere con l'operazione.  La rigenerazione di un layout può essere un'operazione relativamente costosa.  Usare il <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> proprietà da controllare per un layout valido prima di eseguire operazioni che possono rigenerare il layout.  Per altre informazioni, vedere [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">Oggetto <see cref="T:System.Windows.Documents.TextPointer" /> che specifica una posizione da confrontare con la posizione corrente.</param>
        <summary>Indica se la posizione specificata si trova nello stesso contenitore di testo della posizione corrente.</summary>
        <returns>
          <see langword="true" /> se <paramref name="textPosition" /> indica una posizione che si trova nello stesso contenitore di testo della posizione corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La maggior parte delle operazioni che implicano più <xref:System.Windows.Documents.TextPointer> istanze sono valide solo se le istanze in questione indicano le posizioni che sono nell'ambito del contenitore di testo stesso.  Ad esempio la <xref:System.Windows.Documents.TextPointer.CompareTo%2A> e <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> non possono essere utilizzati con un <xref:System.Windows.Documents.TextPointer> a una posizione esterna al contenitore di testo associato alla posizione corrente.  Utilizzare questo metodo per verificare che un determinato <xref:System.Windows.Documents.TextPointer> è compatibile con la posizione corrente per tali operazioni.  
  
   
  
## Examples  
 L'esempio seguente illustra un uso di questo metodo.  L'esempio Usa il <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> metodo per verificare se un determinato <xref:System.Windows.Documents.TextPointer> posizionato tra due altri determinati <xref:System.Windows.Documents.TextPointer> istanze in una situazione in cui non è garantito che tutti i tre posizioni appartengano allo stesso contenitore di testo.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la direzione logica associata alla posizione corrente e utilizzata per risolvere le ambiguità del contenuto associato alla posizione corrente.</summary>
        <value>Valore <see cref="T:System.Windows.Documents.LogicalDirection" /> associato alla posizione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Come esempio di come utilizzare questa proprietà, il <xref:System.Windows.Documents.LogicalDirection> del <xref:System.Windows.Documents.TextPointer> restituito da un hit test metodo offre un riscontro compreso tra due caratteri del testo. La direzione logica specifica quale dei due caratteri effettivamente raggiunto, sinistra o destra.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il paragrafo che fornisce l'ambito alla posizione corrente, se presente.</summary>
        <value>Il <see cref="T:System.Windows.Documents.Paragraph" /> che definisce l'ambito alla posizione corrente, o <see langword="null" /> se è presente alcun simile paragrafo.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il padre logico che fornisce l'ambito alla posizione corrente.</summary>
        <value>Padre logico che fornisce l'ambito alla posizione corrente.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Questo tipo o membro supporta l'infrastruttura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e non deve essere usato direttamente dal codice.</summary>
        <returns>Stringa che rappresenta l'oggetto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>