<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2e5254feb605b3070ee54e08c4b1dcb9e4e565f9" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37557545" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Storyboard&#xA;Inherits ParallelTimeline" />
  <TypeSignature Language="C++ CLI" Value="public ref class Storyboard : System::Windows::Media::Animation::ParallelTimeline" />
  <TypeSignature Language="F#" Value="type Storyboard = class&#xA;    inherit ParallelTimeline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Sequenza temporale di un contenitore che fornisce informazioni sulla destinazione di oggetti e proprietà per le animazioni figlio.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Controllo interattivo di storyboard  
 Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel markup, si specifica la <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> proprietà del <xref:System.Windows.Media.Animation.BeginStoryboard> dell'oggetto che lo crea; per un esempio, vedere [come: usare i trigger di evento per controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md). Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="data-binding-and-animating-timelines"></a>Data Binding e animazione sequenze temporali  
 La maggior parte delle proprietà della sequenza temporale può essere associata a dati o animata; Tuttavia, a causa della modalità di funzionamento del sistema di temporizzazione, dati associate o animate sequenze temporali non si comportano come gli altri dati associato o aggiungendo un'animazione di oggetti. Per comprendere il comportamento, è utile per capire il significato per l'attivazione di una sequenza temporale.  
  
 Quando una sequenza temporale è attivata, vengono effettuate copie della sequenza temporale e le sequenze temporali figlio. Queste copie vengono bloccate (rese di sola lettura) e <xref:System.Windows.Media.Animation.Clock> vengono creati oggetti da esse. che animano effettivamente le proprietà di destinazione. Se una sequenza temporale è associato a dati o animata, uno snapshot dei relativi valori correnti viene eseguito quando l'orologio viene creato. Anche se la sequenza temporale originale potrebbe continuare a modificare, l'orologio non lo consente.  
  
 Per una sequenza temporale in modo da riflettere le modifiche di animazione o di associazione dei dati, l'orologio deve essere ricreato. Gli orologi non vengono nuovamente creati per l'utente automaticamente. Di seguito vengono indicate diverse modalità per applicare le modifiche alla sequenza temporale:  
  
-   Se la sequenza temporale è o appartiene a un <xref:System.Windows.Media.Animation.Storyboard>, è possibile renderlo riflettere le modifiche tramite una nuova applicazione dello storyboard, utilizzando un <xref:System.Windows.Media.Animation.BeginStoryboard> o il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (metodo). Come effetto collaterale, l'animazione viene riavviata. Nel codice, è possibile usare il <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> eseguire il metodo per riportare lo storyboard alla posizione precedente.  
  
-   Se è applicata un'animazione direttamente a una proprietà utilizzando il <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> metodo, chiamare il <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> nuovo metodo e passare l'animazione che è stato modificato.  
  
-   Se si lavora direttamente a livello di orologio, creare e applicare un nuovo set di orologi e usarli per sostituire il set di orologi creati.  
  
 Per animazione associata a un esempio di dati, vedere [Key Spline Animation Sample](http://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Storyboard();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia l'insieme delle animazioni associate a questo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin();" />
      <MemberSignature Language="F#" Value="member this.Begin : unit -&gt; unit" Usage="storyboard.Begin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Applica le animazioni associate a questo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni e le avvia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto contenuto nello stesso ambito dei nomi delle destinazioni delle animazioni di questo storyboard. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> vengono applicate a <c>containingObject</c>.</param>
        <summary>Applica le animazioni associate a questo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni e le avvia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le proprietà di destinazione sono già animate, vengono sostituiti con i <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento di continuità.  
  
 Storyboard avviato con questo metodo non può essere messo in pausa, riprendere o controllati in modo interattivo dopo l'avvio. Per rendere uno storyboard controllabile, usare il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (metodo).  
  
 Inizio di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventi.  
  
   
  
## Examples  
 Nell'esempio seguente usa uno storyboard per animare un <xref:System.Windows.Media.TextEffect>. Il <xref:System.Windows.Media.TextEffect> è contenuta all'interno di un <xref:System.Windows.FrameworkContentElement>del nome ambito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto contenuto nello stesso ambito dei nomi delle destinazioni delle animazioni di questo storyboard. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> vengono applicate a <c>containingObject</c>.</param>
        <summary>Applica le animazioni associate a questo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni e le avvia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le proprietà di destinazione sono già animate, vengono sostituiti con i <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento di continuità.  
  
 Storyboard avviato con questo metodo non può essere messo in pausa, riprendere o controllati in modo interattivo dopo l'avvio. Per rendere uno storyboard controllabile, usare il <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> o <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29> (metodo).  
  
 Inizio di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto contenuto nello stesso ambito dei nomi delle destinazioni delle animazioni di questo storyboard. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> vengono applicate a <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> se l'oggetto storyboard deve essere controllabile in modo interattivo; in caso contrario, <see langword="false" />.</param>
        <summary>Applica le animazioni associate a questo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni e le avvia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le proprietà di destinazione sono già animate, vengono sostituiti con i <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento di continuità.  
  
 Per controllare in modo interattivo lo storyboard, è necessario specificare gli stessi `containingObject` quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard  
  
 Quando questo metodo viene chiamato, <xref:System.Windows.Media.Animation.Clock> gli oggetti vengono creati per storyboard e le sequenze in essa contenute. Questi orologi vengono archiviati con `containingObject`.  
  
 Inizio di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventi.  
  
   
  
## Examples  
 L'esempio seguente usa uno storyboard controllabile animare un <xref:System.Windows.Media.TextEffect>. Il <xref:System.Windows.Media.TextEffect> è contenuta all'interno di un <xref:System.Windows.FrameworkContentElement>del nome ambito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto contenuto nello stesso ambito dei nomi delle destinazioni delle animazioni di questo storyboard. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> vengono applicate a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Il comportamento che la nuova animazione deve utilizzare per interagire con qualsiasi animazione corrente.</param>
        <summary>Applica le animazioni associate con questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni e le avvia, utilizzando l'oggetto <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si applica un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una proprietà utilizzando la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualsiasi <xref:System.Windows.Media.Animation.Clock> oggetti associati in precedenza a tale proprietà continueranno a utilizzare le risorse di sistema, ma non dal sistema di temporizzazione rimuovere automaticamente questi orologi.  
  
 Per evitare problemi di prestazioni quando si applica un numero elevato di orologi usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, è necessario rimuovere gli orologi di composizione dalla proprietà animata una volta completati. Esistono diverse modalità di rimozione di un orologio.  
  
-   Per rimuovere tutti gli orologi da una proprietà, usare il <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metodo dell'oggetto animato. Specificare la proprietà animata come primo parametro, e `null` come il secondo. Questo rimuove tutti gli orologi di animazione la proprietà.  
  
-   Per rimuovere uno specifico <xref:System.Windows.Media.Animation.AnimationClock> da un elenco di orologi, usare il <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà delle <xref:System.Windows.Media.Animation.AnimationClock> per recuperare un <xref:System.Windows.Media.Animation.ClockController>, quindi chiamare il <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodo del <xref:System.Windows.Media.Animation.ClockController>. Ciò avviene in genere il <xref:System.Windows.Media.Animation.Clock.Completed> gestore eventi per un orologio. Si noti che solo gli orologi di radice possono essere controllati da un <xref:System.Windows.Media.Animation.ClockController>; la <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà di un orologio figlio restituirà `null`. Si noti inoltre che il <xref:System.Windows.Media.Animation.Clock.Completed> evento non viene chiamato se la durata effettiva dell'orologio è infinita.  In tal caso, l'utente deve determinare quando chiamare <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Si tratta principalmente di un problema relativo alle animazioni su oggetti di lunga durata.  Quando un oggetto viene sottoposto a garbage collection, gli orologi vengono disconnessi anche e sottoposti a garbage collection.  
  
 Per altre informazioni sugli oggetti orologio, vedere [Panoramica sistema di temporizzazione e animazione](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> per aggiungere un'animazione quando l'utente effettua e il <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> quando l'utente fa clic.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto contenuto nello stesso ambito dei nomi delle destinazioni delle animazioni di questo storyboard. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> vengono applicate a <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> se l'oggetto storyboard deve essere controllabile in modo interattivo; in caso contrario, <see langword="false" />.</param>
        <summary>Applica le animazioni associate a questo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni e le avvia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le proprietà di destinazione sono già animate, vengono sostituiti con i <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento di continuità.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard  
  
 Quando questo metodo viene chiamato, <xref:System.Windows.Media.Animation.Clock> gli oggetti vengono creati per storyboard e le sequenze in essa contenute. Questi orologi vengono archiviati con `containingObject`.  
  
 Inizio di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto a cui è stato applicato l'oggetto <c>frameworkTemplate</c> specificato. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> vengono applicate a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Modello da animare.</param>
        <summary>Applica le animazioni associate con questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni all'interno del modello specificato e le avvia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le proprietà di destinazione sono già animate, vengono sostituiti con i <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento di continuità.  
  
 Quando questo metodo viene chiamato, <xref:System.Windows.Media.Animation.Clock> gli oggetti vengono creati per storyboard e le sequenze in essa contenute. Questi orologi vengono archiviati con `containingObject`.  
  
 Inizio di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto contenuto nello stesso ambito dei nomi delle destinazioni delle animazioni di questo storyboard. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> specificato vengono applicate a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Il comportamento che la nuova animazione deve utilizzare per interagire con qualsiasi animazione corrente.</param>
        <summary>Applica le animazioni associate con questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni e le avvia, utilizzando l'oggetto <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente usa il <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> per aggiungere un'animazione quando l'utente effettua e il <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> quando l'utente fa clic.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto contenuto nello stesso ambito dei nomi delle destinazioni delle animazioni di questo storyboard. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> specificato vengono applicate a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Il comportamento che la nuova animazione deve utilizzare per interagire con qualsiasi animazione corrente.</param>
        <param name="isControllable">Dichiara se l'animazione è controllabile (può essere sospesa) una volta avviata.</param>
        <summary>Applica le animazioni associate con questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni e le avvia, utilizzando l'oggetto <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le proprietà di destinazione sono già animate, vengono sostituiti con il comportamento di continuità specificato.  
  
 Per controllare in modo interattivo lo storyboard, è necessario specificare gli stessi `containingObject` quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard  
  
 Quando questo metodo viene chiamato, <xref:System.Windows.Media.Animation.Clock> gli oggetti vengono creati per storyboard e le sequenze in essa contenute. Questi orologi vengono archiviati con `containingObject`.  
  
 Inizio di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventi.  
  
## <a name="using-the-compose-handoffbehavior"></a>Utilizzo di Compose HandoffBehavior  
 Quando si applica un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una proprietà utilizzando la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualsiasi <xref:System.Windows.Media.Animation.Clock> oggetti associati in precedenza a tale proprietà continueranno a utilizzare le risorse di sistema, ma non dal sistema di temporizzazione rimuovere automaticamente questi orologi.  
  
 Per evitare problemi di prestazioni quando si applica un numero elevato di orologi usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, è necessario rimuovere gli orologi di composizione dalla proprietà animata una volta completati. Esistono diverse modalità di rimozione di un orologio.  
  
-   Per rimuovere tutti gli orologi da una proprietà, usare il <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metodo dell'oggetto animato. Specificare la proprietà animata come primo parametro, e `null` come il secondo. Questo rimuove tutti gli orologi di animazione la proprietà.  
  
-   Per rimuovere uno specifico <xref:System.Windows.Media.Animation.AnimationClock> da un elenco di orologi, usare il <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà delle <xref:System.Windows.Media.Animation.AnimationClock> per recuperare un <xref:System.Windows.Media.Animation.ClockController>, quindi chiamare il <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodo del <xref:System.Windows.Media.Animation.ClockController>. Ciò avviene in genere il <xref:System.Windows.Media.Animation.Clock.Completed> gestore eventi per un orologio. Si noti che solo gli orologi di radice possono essere controllati da un <xref:System.Windows.Media.Animation.ClockController>; la <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà di un orologio figlio restituirà `null`. Si noti inoltre che il <xref:System.Windows.Media.Animation.Clock.Completed> evento non viene chiamato se la durata effettiva dell'orologio è infinita.  In tal caso, l'utente deve determinare quando chiamare <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Si tratta principalmente di un problema relativo alle animazioni su oggetti di lunga durata.  Quando un oggetto viene sottoposto a garbage collection, gli orologi vengono disconnessi anche e sottoposti a garbage collection.  
  
 Per altre informazioni sugli oggetti orologio, vedere [Panoramica sistema di temporizzazione e animazione](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 L'esempio seguente usa uno storyboard controllabile animare un <xref:System.Windows.Media.TextEffect>. Il <xref:System.Windows.Media.TextEffect> è contenuta all'interno di un <xref:System.Windows.FrameworkContentElement>del nome ambito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 L'esempio seguente usa il <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> per aggiungere un'animazione quando l'utente effettua e il <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> quando l'utente fa clic.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto a cui è stato applicato l'oggetto <c>frameworkTemplate</c> specificato.  Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> vengono applicate a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Modello da animare.</param>
        <param name="isControllable">
          <see langword="true" /> se l'oggetto storyboard deve essere controllabile in modo interattivo; in caso contrario, <see langword="false" />.</param>
        <summary>Applica le animazioni associate con questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni all'interno del modello specificato e le avvia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le proprietà di destinazione sono già animate, vengono sostituiti con i <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento di continuità.  
  
 Per controllare in modo interattivo lo storyboard, è necessario specificare gli stessi `containingObject` quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard  
  
 Quando questo metodo viene chiamato, <xref:System.Windows.Media.Animation.Clock> gli oggetti vengono creati per storyboard e le sequenze in essa contenute. Questi orologi vengono archiviati con `containingObject`.  
  
 Inizio di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto a cui è stato applicato l'oggetto <c>frameworkTemplate</c> specificato. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> vengono applicate a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Modello da animare.</param>
        <param name="handoffBehavior">Il comportamento che la nuova animazione deve utilizzare per interagire con qualsiasi animazione corrente.</param>
        <summary>Applica le animazioni associate con questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni all'interno del modello specificato e le avvia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene chiamato, <xref:System.Windows.Media.Animation.Clock> gli oggetti vengono creati per storyboard e le sequenze in essa contenute. Questi orologi vengono archiviati con `containingObject`.  
  
 Inizio di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventi.  
  
## <a name="using-the-compose-handoffbehavior"></a>Utilizzo di Compose HandoffBehavior  
 Quando si applica un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una proprietà utilizzando la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualsiasi <xref:System.Windows.Media.Animation.Clock> oggetti associati in precedenza a tale proprietà continueranno a utilizzare le risorse di sistema, ma non dal sistema di temporizzazione rimuovere automaticamente questi orologi.  
  
 Per evitare problemi di prestazioni quando si applica un numero elevato di orologi usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, è necessario rimuovere gli orologi di composizione dalla proprietà animata una volta completati. Esistono diverse modalità di rimozione di un orologio.  
  
-   Per rimuovere tutti gli orologi da una proprietà, usare il <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metodo dell'oggetto animato. Specificare la proprietà animata come primo parametro, e `null` come il secondo. Questo rimuove tutti gli orologi di animazione la proprietà.  
  
-   Per rimuovere uno specifico <xref:System.Windows.Media.Animation.AnimationClock> da un elenco di orologi, usare il <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà delle <xref:System.Windows.Media.Animation.AnimationClock> per recuperare un <xref:System.Windows.Media.Animation.ClockController>, quindi chiamare il <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodo del <xref:System.Windows.Media.Animation.ClockController>. Ciò avviene in genere il <xref:System.Windows.Media.Animation.Clock.Completed> gestore eventi per un orologio. Si noti che solo gli orologi di radice possono essere controllati da un <xref:System.Windows.Media.Animation.ClockController>; la <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà di un orologio figlio restituirà `null`. Si noti inoltre che il <xref:System.Windows.Media.Animation.Clock.Completed> evento non viene chiamato se la durata effettiva dell'orologio è infinita.  In tal caso, l'utente deve determinare quando chiamare <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Si tratta principalmente di un problema relativo alle animazioni su oggetti di lunga durata.  Quando un oggetto viene sottoposto a garbage collection, gli orologi vengono disconnessi anche e sottoposti a garbage collection.  
  
 Per altre informazioni sugli oggetti orologio, vedere [Panoramica sistema di temporizzazione e animazione](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto contenuto nello stesso ambito dei nomi delle destinazioni delle animazioni di questo storyboard. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> specificato vengono applicate a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Il comportamento che la nuova animazione deve utilizzare per interagire con qualsiasi animazione corrente.</param>
        <param name="isControllable">Dichiara se l'animazione è controllabile (può essere sospesa) una volta avviata.</param>
        <summary>Applica le animazioni associate a questo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni e le avvia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard  
  
 Quando questo metodo viene chiamato, <xref:System.Windows.Media.Animation.Clock> gli oggetti vengono creati per storyboard e le sequenze in essa contenute. Questi orologi vengono archiviati con `containingObject`.  
  
 Inizio di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventi.  
  
## <a name="using-the-compose-handoffbehavior"></a>Utilizzo di Compose HandoffBehavior  
 Quando si applica un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una proprietà utilizzando la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualsiasi <xref:System.Windows.Media.Animation.Clock> oggetti associati in precedenza a tale proprietà continueranno a utilizzare le risorse di sistema, ma non dal sistema di temporizzazione rimuovere automaticamente questi orologi.  
  
 Per evitare problemi di prestazioni quando si applica un numero elevato di orologi usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, è necessario rimuovere gli orologi di composizione dalla proprietà animata una volta completati. Esistono diverse modalità di rimozione di un orologio.  
  
-   Per rimuovere tutti gli orologi da una proprietà, usare il <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metodo dell'oggetto animato. Specificare la proprietà animata come primo parametro, e `null` come il secondo. Questo rimuove tutti gli orologi di animazione la proprietà.  
  
-   Per rimuovere uno specifico <xref:System.Windows.Media.Animation.AnimationClock> da un elenco di orologi, usare il <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà delle <xref:System.Windows.Media.Animation.AnimationClock> per recuperare un <xref:System.Windows.Media.Animation.ClockController>, quindi chiamare il <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodo del <xref:System.Windows.Media.Animation.ClockController>. Ciò avviene in genere il <xref:System.Windows.Media.Animation.Clock.Completed> gestore eventi per un orologio. Si noti che solo gli orologi di radice possono essere controllati da un <xref:System.Windows.Media.Animation.ClockController>; la <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà di un orologio figlio restituirà `null`. Si noti inoltre che il <xref:System.Windows.Media.Animation.Clock.Completed> evento non viene chiamato se la durata effettiva dell'orologio è infinita.  In tal caso, l'utente deve determinare quando chiamare <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Si tratta principalmente di un problema relativo alle animazioni su oggetti di lunga durata.  Quando un oggetto viene sottoposto a garbage collection, gli orologi vengono disconnessi anche e sottoposti a garbage collection.  
  
 Per altre informazioni sugli oggetti orologio, vedere [Panoramica sistema di temporizzazione e animazione](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare uno storyboard controllabile.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 L'esempio seguente usa il <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> per aggiungere un'animazione quando l'utente effettua e il <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> quando l'utente fa clic.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto a cui è stato applicato l'oggetto <c>frameworkTemplate</c> specificato. Le animazioni senza un oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> vengono applicate a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Modello da animare.</param>
        <param name="handoffBehavior">Il comportamento che la nuova animazione deve utilizzare per interagire con qualsiasi animazione corrente.</param>
        <param name="isControllable">
          <see langword="true" /> se l'oggetto storyboard deve essere controllabile in modo interattivo; in caso contrario, <see langword="false" />.</param>
        <summary>Applica le animazioni associate con questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> alle destinazioni all'interno del modello specificato e le avvia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per controllare in modo interattivo lo storyboard, è necessario specificare gli stessi `containingObject` quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard  
  
 Quando questo metodo viene chiamato, <xref:System.Windows.Media.Animation.Clock> gli oggetti vengono creati per storyboard e le sequenze in essa contenute. Questi orologi vengono archiviati con `containingObject`.  
  
 Inizio di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventi.  
  
## <a name="using-the-compose-handoffbehavior"></a>Utilizzo di Compose HandoffBehavior  
 Quando si applica un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una proprietà utilizzando la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualsiasi <xref:System.Windows.Media.Animation.Clock> oggetti associati in precedenza a tale proprietà continueranno a utilizzare le risorse di sistema, ma non dal sistema di temporizzazione rimuovere automaticamente questi orologi.  
  
 Per evitare problemi di prestazioni quando si applica un numero elevato di orologi usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, è necessario rimuovere gli orologi di composizione dalla proprietà animata una volta completati. Esistono diverse modalità di rimozione di un orologio.  
  
-   Per rimuovere tutti gli orologi da una proprietà, usare il <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metodo dell'oggetto animato. Specificare la proprietà animata come primo parametro, e `null` come il secondo. Questo rimuove tutti gli orologi di animazione la proprietà.  
  
-   Per rimuovere uno specifico <xref:System.Windows.Media.Animation.AnimationClock> da un elenco di orologi, usare il <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà delle <xref:System.Windows.Media.Animation.AnimationClock> per recuperare un <xref:System.Windows.Media.Animation.ClockController>, quindi chiamare il <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodo del <xref:System.Windows.Media.Animation.ClockController>. Ciò avviene in genere il <xref:System.Windows.Media.Animation.Clock.Completed> gestore eventi per un orologio. Si noti che solo gli orologi di radice possono essere controllati da un <xref:System.Windows.Media.Animation.ClockController>; la <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà di un orologio figlio restituirà `null`. Si noti inoltre che il <xref:System.Windows.Media.Animation.Clock.Completed> evento non viene chiamato se la durata effettiva dell'orologio è infinita.  In tal caso, l'utente deve determinare quando chiamare <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Si tratta principalmente di un problema relativo alle animazioni su oggetti di lunga durata.  Quando un oggetto viene sottoposto a garbage collection, gli orologi vengono disconnessi anche e sottoposti a garbage collection.  
  
 Per altre informazioni sugli oggetti orologio, vedere [Panoramica sistema di temporizzazione e animazione](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Storyboard" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Storyboard ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Animation.Storyboard" Usage="storyboard.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clone modificabile di questo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" />, eseguendo copie complete dei valori dell'oggetto. Durante la copia delle proprietà di dipendenza, questo metodo copia i riferimenti alle risorse e i data binding (che potrebbero non essere più risolti), ma non le animazioni né i relativi valori correnti.</summary>
        <returns>Clone modificabile dell'oggetto corrente. La proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto clonato è <see langword="false" />, anche se la proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto di origine è <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per generare copie modificabili di bloccata <xref:System.Windows.Freezable> oggetti (o qualsiasi <xref:System.Windows.Freezable> oggetto). Per praticità, questo metodo nasconde la versione ereditata con un'implementazione fortemente tipizzata.  
  
 Per ulteriori informazioni, vedere <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="storyboard.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una nuova istanza della classe <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Nuova istanza di <see cref="T:System.Windows.Media.Animation.Storyboard" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato internamente dal <xref:System.Windows.Freezable.CreateInstance%2A> durante la creazione di nuove istanze del <xref:System.Windows.Media.Animation.Storyboard> classe per i vari metodi di duplicazione (ad esempio <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A>).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata un'implementazione tipica delle <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ogni <see cref="T:System.Windows.Media.Animation.Storyboard" /> sottoclasse deve implementare questo metodo. Implementazione tipica è sufficiente chiamare il costruttore predefinito della classe e restituiscono il risultato.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un orologio <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocità è la velocità in corrispondenza del quale il tempo sta attualmente procedendo, rispetto al tempo reale.  
  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentGlobalSpeed();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : unit -&gt; double" Usage="storyboard.GetCurrentGlobalSpeed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Velocità globale corrente o 0 se l'orologio viene arrestato.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Velocità globale corrente o <see langword="null" /> se l'orologio viene arrestato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un orologio <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocità è la velocità in corrispondenza del quale il tempo sta attualmente procedendo, rispetto al tempo reale.  
  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Velocità globale corrente o <see langword="null" /> se l'orologio viene arrestato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un orologio <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocità è la velocità in corrispondenza del quale il tempo sta attualmente procedendo, rispetto al tempo reale.  
  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentIteration">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCurrentIteration();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : unit -&gt; int" Usage="storyboard.GetCurrentIteration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>L'iterazione corrente di questo orologio all'interno del periodo di attività corrente, oppure <see langword="null" /> se questo orologio viene arrestato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima iterazione del clock ha un valore pari a 1.  
  
 Se questo storyboard è una <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> impostazione di `true`, un'iterazione completa è costituito da una coppia di bidirezionale, non solo uno di questi segmenti.  
  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkContentElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkContentElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>L'iterazione corrente di questo orologio all'interno del periodo di attività corrente, oppure <see langword="null" /> se questo orologio viene arrestato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima iterazione del clock ha un valore pari a 1.  
  
 Se questo storyboard è una <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> impostazione di `true`, un'iterazione completa è costituito da una coppia di bidirezionale, non solo uno di questi segmenti.  
  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>L'iterazione corrente di questo orologio all'interno del periodo di attività corrente, oppure <see langword="null" /> se questo orologio viene arrestato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima iterazione del clock ha un valore pari a 1.  
  
 Se temporale questa sequenza è un' <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> impostazione di `true`, un'iterazione completa è costituito da una coppia di bidirezionale, non solo uno di questi segmenti.  
  
 Indipendentemente dall'iterazione corrente, la ricerca di un orologio restituisce l'iterazione corrente su 1. Il riavvio di un orologio restituisce inoltre l'iterazione corrente su 1.  
  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentProgress">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentProgress();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : unit -&gt; double" Usage="storyboard.GetCurrentProgress " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Restituisce <see langword="null" /> se questo orologio è <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> oppure 0,0 se questo orologio è attivo e l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ha un valore di <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> pari a <see cref="P:System.Windows.Duration.Forever" />; in caso contrario, un valore tra 0,0 e 1,0 che indica lo stato di avanzamento corrente di questo orologio all'interno dell'iterazione corrente. Un valore pari a 0,0 indica nessuno stato di avanzamento, mentre un valore pari a 1,0 indica che l'orologio è alla fine dell'iterazione corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Restituisce <see langword="null" /> se questo orologio è <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> oppure 0,0 se questo orologio è attivo e l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ha un valore di <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> pari a <see cref="P:System.Windows.Duration.Forever" />; in caso contrario, un valore tra 0,0 e 1,0 che indica lo stato di avanzamento corrente di questo orologio all'interno dell'iterazione corrente. Un valore pari a 0,0 indica nessuno stato di avanzamento, mentre un valore pari a 1,0 indica che l'orologio è alla fine dell'iterazione corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Restituisce <see langword="null" /> se questo orologio è <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> oppure 0,0 se questo orologio è attivo e l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ha un valore di <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> pari a <see cref="P:System.Windows.Duration.Forever" />; in caso contrario, un valore tra 0,0 e 1,0 che indica lo stato di avanzamento corrente di questo orologio all'interno dell'iterazione corrente. Un valore pari a 0,0 indica nessuno stato di avanzamento, mentre un valore pari a 1,0 indica che l'orologio è alla fine dell'iterazione corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentState">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState () As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : unit -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Stato corrente dell'orologio creato per questo storyboard: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, o <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non indicano la sospensione di uno storyboard. Per determinare se uno storyboard è stata sospesa, usare il <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> (metodo).  
  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkContentElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkContentElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Stato corrente dell'orologio creato per questo storyboard: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, o <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non indicano la sospensione di uno storyboard. Per determinare se uno storyboard è stata sospesa, usare il <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> (metodo).  
  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Stato corrente dell'orologio creato per questo storyboard: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />, o <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non indicano la sospensione di uno storyboard. Per determinare se uno storyboard è stata sospesa, usare il <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> (metodo).  
  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentTime">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime () As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetCurrentTime();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : unit -&gt; TimeSpan" Usage="storyboard.GetCurrentTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> se l'orologio di questo storyboard è <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; in caso contrario, il tempo corrente dell'orologio dello storyboard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkContentElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkContentElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> se l'orologio di questo storyboard è <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; in caso contrario, il tempo corrente dell'orologio dello storyboard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera l'oggetto <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> se l'orologio di questo storyboard è <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; in caso contrario, il tempo corrente dell'orologio dello storyboard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetIsPaused">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera un valore che indica se l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> è sospeso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused();" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : unit -&gt; bool" Usage="storyboard.GetIsPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un valore che indica se l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> è sospeso.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> è sospeso; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkContentElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkContentElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera un valore che indica se l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> è sospeso.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> è sospeso; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Recupera un valore che indica se l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> è sospeso.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> è sospeso; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per usare questo metodo per recuperare le informazioni sull'orologio dello storyboard, lo storyboard deve essere controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTarget (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetTarget(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTarget : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Media.Animation.Storyboard.GetTarget element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Sequenza temporale da cui recuperare l'oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Recupera il valore <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Timeline" /> specificato.</summary>
        <returns>Oggetto di dipendenza indirizzato dall'oggetto <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Windows.Media.Animation.Storyboard.Target%2A> proprietà con sequenze temporali di animazioni per indicare l'oggetto di destinazione associata. Per altre informazioni sul funzionamento della destinazione dello storyboard, vedere <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Per altre informazioni sul funzionamento delle proprietà come associate, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetName (element As DependencyObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTargetName(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetName : System.Windows.DependencyObject -&gt; string" Usage="System.Windows.Media.Animation.Storyboard.GetTargetName element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Sequenza temporale da cui recuperare l'oggetto <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Recupera il valore <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Timeline" /> specificato.</summary>
        <returns>Nome dell'oggetto di dipendenza indirizzato dall'oggetto <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo ottiene il <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> collegato proprietà sull'oggetto specificato. Per altre informazioni sul funzionamento della destinazione dello storyboard, vedere <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Per altre informazioni sul funzionamento delle proprietà come associate, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetProperty (element As DependencyObject) As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PropertyPath ^ GetTargetProperty(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetProperty : System.Windows.DependencyObject -&gt; System.Windows.PropertyPath" Usage="System.Windows.Media.Animation.Storyboard.GetTargetProperty element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">L'oggetto di dipendenza dal quale ottenere la <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</param>
        <summary>Recupera il valore <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> dell'oggetto <see cref="T:System.Windows.Media.Animation.Timeline" /> specificato.</summary>
        <returns>Proprietà di destinazione dell'oggetto <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo ottiene il <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> collegato proprietà sull'oggetto specificato. Per altre informazioni sul funzionamento della destinazione dello storyboard, vedere <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> proprietà associata. Per altre informazioni sul funzionamento delle proprietà come associate, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Si noti che se il <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> è stato impostato nel markup, questo metodo restituisce un oggetto vuoto <xref:System.Windows.PropertyPath> perché è risolto e archiviato internamente, una volta analizzato il riferimento alla proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pause">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sospende l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberSignature Language="F#" Value="member this.Pause : unit -&gt; unit" Usage="storyboard.Pause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sospende l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo sospende lo storyboard, ma non ha alcun effetto visibile se non è attualmente sospesa o attiva. Come effetto collaterale, vengono sospesi anche tutti gli elementi figlio associati.  
  
 Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="beginning-a-paused-storyboard"></a>Avvio di uno Storyboard in pausa  
 Quando si <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> uno storyboard che è stata sospesa, viene visualizzato per riprendere e riavviare. Tuttavia, che è non che cosa succede effettivamente. Il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo sostituisce effettivamente l'oggetto sospeso <xref:System.Windows.Media.Animation.Storyboard> con una nuova versione non in pausa. Ogni volta che il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> viene chiamato il metodo, vengono creati oggetti clock per storyboard. Questi orologi vengono distribuiti a proprietà animate. Pertanto, quando il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> viene chiamato anche in questo caso, gli orologi non venga riavviato, li sostituisce con nuovo orologi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Sospende l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> dell'oggetto <see cref="T:System.Windows.FrameworkContentElement" /> associato a questo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo sospende lo storyboard, ma non ha alcun effetto visibile se non è attualmente sospesa o attiva. Come effetto collaterale, vengono sospesi anche tutti gli elementi figlio associati.  
  
 La ricerca di uno storyboard sospeso non lo riprende. L'unico modo per riprendere uno storyboard sospeso è usare il <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> (metodo). La chiamata di <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo sostituisce nuovamente lo storyboard sospeso con uno nuovo, che ha l'aspetto di riprenderlo.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Sospensione di orologio genera di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> evento.  
  
## <a name="beginning-a-paused-storyboard"></a>Avvio di uno Storyboard in pausa  
 Quando si <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> uno storyboard che è stata sospesa, viene visualizzato per riprendere e riavviare. Tuttavia, che è non che cosa succede effettivamente. Il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo sostituisce la stessa con una versione non in pausa. Ogni volta che il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> viene chiamato il metodo, vengono creati oggetti clock per storyboard. Questi orologi vengono distribuiti a proprietà animate. Pertanto, quando il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> viene chiamato anche in questo caso, gli orologi non venga riavviato, li sostituisce con nuovo orologi.  
  
   
  
## Examples  
 L'esempio seguente usa uno storyboard controllabile animare un <xref:System.Windows.Media.TextEffect>. Il <xref:System.Windows.Media.TextEffect> è contenuta all'interno di un <xref:System.Windows.FrameworkContentElement>del nome ambito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Sospende l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> dell'oggetto <see cref="T:System.Windows.FrameworkElement" /> associato a questo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo sospende lo storyboard, ma non ha alcun effetto visibile se non è attualmente sospesa o attiva. Come effetto collaterale, vengono sospesi anche tutti gli elementi figlio associati.  
  
 La ricerca di uno storyboard sospeso non lo riprende. L'unico modo per riprendere uno storyboard sospeso è usare il <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> (metodo). La chiamata di <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo sostituisce nuovamente lo storyboard sospeso con uno nuovo, che ha l'aspetto di riprenderlo.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Sospensione di orologio genera di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> evento.  
  
## <a name="beginning-a-paused-storyboard"></a>Avvio di uno Storyboard in pausa  
 Quando si <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> uno storyboard che è stata sospesa, viene visualizzato per riprendere e riavviare. Tuttavia, che è non che cosa succede effettivamente. Il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo sostituisce la stessa con una versione non in pausa. Ogni volta che il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> viene chiamato il metodo, vengono creati oggetti clock per storyboard. Questi orologi vengono distribuiti a proprietà animate. Pertanto, quando il <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> viene chiamato anche in questo caso, gli orologi non venga riavviato, li sostituisce con nuovo orologi.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rimuove gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />. Indipendentemente dall'impostazione del relativo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" />, le animazioni che appartengono a questo oggetto <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> non influiscono più sulle proprietà che animavano in precedenza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="storyboard.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />. Indipendentemente dall'impostazione del relativo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" />, le animazioni che appartengono a questo oggetto <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> non influiscono più sulle proprietà che animavano in precedenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Tutte le azioni interattive effettuate su un <xref:System.Windows.Media.Animation.Clock>e pertanto anche su un <xref:System.Windows.Media.Animation.Storyboard>, si verificano al tick successivo del motore di temporizzazione, che si verifica poco prima il rendering successivo. Ciò significa che il <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> metodo continua a influire sulle proprietà animate fino a questo momento. In altre parole, la volta successiva che il frame viene visualizzato, lo storyboard è stato rimosso. Se è necessario rimuovere l'associazione di un'animazione da una proprietà prima dell'ora, usare il <xref:System.Windows.UIElement.BeginAnimation%2A> metodo con un `animation` come valore del parametro `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Rimuove gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />. Indipendentemente dall'impostazione del relativo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" />, le animazioni che appartengono a questo oggetto <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> non influiscono più sulle proprietà che animavano in precedenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Rimozione di trigger di orologio dello storyboard di <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Rimuove gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />. Indipendentemente dall'impostazione del relativo oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" />, le animazioni che appartengono a questo oggetto <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" /> non influiscono più sulle proprietà che animavano in precedenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Rimozione di trigger di orologio dello storyboard di <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resume">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Riprende l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="storyboard.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riprende l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Riprende l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ripresa di uno storyboard che è stata sospesa non ha alcun effetto.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 La ricerca di uno storyboard sospeso non lo riprende. L'unico modo per riprendere uno storyboard sospeso è usare il <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> (metodo). La chiamata di <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo dopo l'avvio di storyboard sostituisce il vecchio storyboard, che ha l'aspetto di riprenderlo.  
  
 Ripresa di un orologio dello storyboard sospeso il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> evento.  
  
   
  
## Examples  
 L'esempio seguente usa uno storyboard controllabile animare un <xref:System.Windows.Media.TextEffect>. Il <xref:System.Windows.Media.TextEffect> è contenuta all'interno di un <xref:System.Windows.FrameworkContentElement>del nome ambito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Riprende l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ripresa di uno storyboard che è stata sospesa non ha alcun effetto.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 La ricerca di uno storyboard sospeso non lo riprende. L'unico modo per riprendere uno storyboard sospeso è usare il <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> (metodo). La chiamata di <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo dopo l'avvio di storyboard sostituisce il vecchio storyboard, che ha l'aspetto di riprenderlo.  
  
 Ripresa di un orologio dello storyboard sospeso il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ricerca questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> in una posizione nuova quando si verifica il ciclo macchina successivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan -&gt; unit" Usage="storyboard.Seek offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Valore positivo o negativo che descrive la quantità di spostamento in avanti o indietro della sequenza temporale.</param>
        <summary>Ricerca questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> fino alla posizione specificata. L'oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" /> esegue la ricerca richiesta quando si verifica il ciclo macchina successivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che le operazioni di ricerca non accettano lo storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> in considerazione le impostazioni. Lo storyboard viene trattato come se disponesse di un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> su 1 e nessun <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Valore positivo o negativo che descrive la quantità di spostamento in avanti o indietro della sequenza temporale rispetto al valore di <c>origin</c> specificato.</param>
        <param name="origin">Posizione di partenza per l'applicazione di <c>offset</c>.</param>
        <summary>Ricerca questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> fino alla posizione specificata. L'oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" /> esegue la ricerca richiesta quando si verifica il ciclo macchina successivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che le operazioni di ricerca non accettano lo storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> in considerazione le impostazioni. Lo storyboard viene trattato come se disponesse di un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> su 1 e nessun <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <param name="offset">Valore positivo o negativo che descrive la quantità di spostamento in avanti o indietro della sequenza temporale rispetto al valore di <c>origin</c> specificato.</param>
        <param name="origin">Posizione di partenza per l'applicazione di <c>offset</c>.</param>
        <summary>Ricerca questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> fino alla posizione specificata. L'oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" /> esegue la ricerca richiesta quando si verifica il ciclo macchina successivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che le operazioni di ricerca non accettano lo storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> in considerazione le impostazioni. Lo storyboard viene trattato come se disponesse di un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> su 1 e nessun <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Questo metodo modifica dell'orologio dello storyboard <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a <xref:System.Windows.Media.Animation.ClockState.Active>. Questo metodo non ha effetto sull'albero di temporizzazione fino alla successiva che elaborazione di un segno di graduazione. Come effetto collaterale, gli eventi appropriati inoltre non vengono generati fino a quel momento.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 La ricerca di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato sia la <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> e <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metodi.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <param name="offset">Valore positivo o negativo che descrive la quantità di spostamento in avanti o indietro della sequenza temporale rispetto al valore di <c>origin</c> specificato.</param>
        <param name="origin">Posizione di partenza per l'applicazione di <c>offset</c>.</param>
        <summary>Ricerca questo <see cref="T:System.Windows.Media.Animation.Storyboard" /> fino alla posizione specificata. L'oggetto <see cref="T:System.Windows.Media.Animation.Storyboard" /> esegue la ricerca richiesta quando si verifica il ciclo macchina successivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che le operazioni di ricerca non accettano lo storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> in considerazione le impostazioni. Lo storyboard viene trattato come se disponesse di un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> su 1 e nessun <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Questo metodo modifica dell'orologio dello storyboard <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a <xref:System.Windows.Media.Animation.ClockState.Active>. Questo metodo non ha effetto sull'albero di temporizzazione fino alla successiva che elaborazione di un segno di graduazione. Come effetto collaterale, gli eventi appropriati inoltre non vengono generati fino a quel momento.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare ed essere rimossa se renderlo controllabile. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 La ricerca di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come cercare di (Ignora) per un secondo dopo l'inizio di uno Storyboard.  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 L'esempio seguente viene illustrato sia la <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> e <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metodi.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SeekAlignedToLastTick">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ricerca immediatamente (in modo sincrono) lo <see cref="T:System.Windows.Media.Animation.Storyboard" /> in una posizione nuova.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan -&gt; unit" Usage="storyboard.SeekAlignedToLastTick offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Valore positivo o negativo che descrive la quantità di spostamento in avanti o indietro della sequenza temporale.</param>
        <summary>Ricerca immediatamente (in modo sincrono) lo <see cref="T:System.Windows.Media.Animation.Storyboard" /> in una posizione nuova.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Allinea il tempo di ricercato il <xref:System.Windows.Media.Animation.Storyboard> con l'ultimo ciclo macchina. I valori vengono immediatamente aggiornati per riflettere le modifiche a causa dell'errore <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, anche se la schermata non riflette le modifiche fino al successivo aggiornamento dello schermo.  
  
 Si noti che le operazioni di ricerca non accettano lo storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> in considerazione le impostazioni. Lo storyboard viene trattato come se disponesse di un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> su 1 e nessun <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Valore positivo o negativo che descrive la quantità di spostamento in avanti o indietro della sequenza temporale rispetto al valore di <c>origin</c> specificato.</param>
        <param name="origin">Posizione di partenza per l'applicazione di <c>offset</c>.</param>
        <summary>Ricerca immediatamente (in modo sincrono) lo <see cref="T:System.Windows.Media.Animation.Storyboard" /> in una posizione nuova.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Allinea il tempo di ricercato il <xref:System.Windows.Media.Animation.Storyboard> con l'ultimo ciclo macchina. I valori vengono immediatamente aggiornati per riflettere le modifiche a causa dell'errore <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, anche se la schermata non riflette le modifiche fino al successivo aggiornamento dello schermo.  
  
 Si noti che le operazioni di ricerca non accettano lo storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> in considerazione le impostazioni. Lo storyboard viene trattato come se disponesse di un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> su 1 e nessun <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <param name="offset">Valore positivo o negativo che descrive la quantità di spostamento in avanti o indietro della sequenza temporale rispetto al valore di <c>origin</c> specificato.</param>
        <param name="origin">Posizione di partenza per l'applicazione di <c>offset</c>.</param>
        <summary>Ricerca immediatamente (in modo sincrono) lo <see cref="T:System.Windows.Media.Animation.Storyboard" /> in una posizione nuova.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Allinea il tempo di ricercato il <xref:System.Windows.Media.Animation.Storyboard> con l'ultimo ciclo macchina. I valori vengono immediatamente aggiornati per riflettere le modifiche a causa dell'errore <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, anche se la schermata non riflette le modifiche fino al successivo aggiornamento dello schermo.  
  
 Si noti che le operazioni di ricerca non accettano lo storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> in considerazione le impostazioni. Lo storyboard viene trattato come se disponesse di un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> su 1 e nessun <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Questo metodo modifica dell'orologio dello storyboard <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 La ricerca di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventi.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato sia la <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> e <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metodi.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <param name="offset">Valore positivo o negativo che descrive la quantità di spostamento in avanti o indietro della sequenza temporale rispetto al valore di <c>origin</c> specificato.</param>
        <param name="origin">Posizione di partenza per l'applicazione di <c>offset</c>.</param>
        <summary>Ricerca immediatamente (in modo sincrono) lo <see cref="T:System.Windows.Media.Animation.Storyboard" /> in una posizione nuova.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Allinea il tempo di ricercato il <xref:System.Windows.Media.Animation.Storyboard> con l'ultimo ciclo macchina. I valori vengono immediatamente aggiornati per riflettere le modifiche a causa dell'errore <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, anche se la schermata non riflette le modifiche fino al successivo aggiornamento dello schermo.  
  
 Si noti che le operazioni di ricerca non accettano lo storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> in considerazione le impostazioni. Lo storyboard viene trattato come se disponesse di un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> su 1 e nessun <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Questo metodo modifica dell'orologio dello storyboard <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 La ricerca di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventi.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato sia la <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> e <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> metodi.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSpeedRatio">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta il rapporto di velocità interattivo dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : double -&gt; unit" Usage="storyboard.SetSpeedRatio speedRatio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Valore finito maggiore di zero che corrisponde al nuovo rapporto di velocità interattiva dello storyboard. Questo valore viene moltiplicato per il valore dell'oggetto <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> dello storyboard, per determinare la velocità effettiva dello storyboard. Questo valore non sovrascrive la proprietà <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> dello storyboard. Ad esempio, se si chiama questo metodo e si specifica un rapporto di velocità interattivo pari a 3, su uno storyboard con un valore <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> pari a 0,5, il risultato della velocità effettiva dello storyboard è pari a 1,5.</param>
        <summary>Imposta il rapporto di velocità interattivo dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkContentElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkContentElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkContentElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <param name="speedRatio">Valore finito maggiore di zero che corrisponde al nuovo rapporto di velocità interattiva dello storyboard. Questo valore viene moltiplicato per il valore dell'oggetto <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> dello storyboard, per determinare la velocità effettiva dello storyboard. Questo valore non sovrascrive la proprietà <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> dello storyboard. Ad esempio, se si chiama questo metodo e si specifica un rapporto di velocità interattivo pari a 3, su uno storyboard con un valore <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> pari a 0,5, il risultato della velocità effettiva dello storyboard è pari a 1,5.</param>
        <summary>Imposta il rapporto di velocità interattivo dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Chiamando questo metodo attiva il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> evento.  
  
   
  
## Examples  
 L'esempio seguente usa uno storyboard controllabile animare un <xref:System.Windows.Media.TextEffect>. Il <xref:System.Windows.Media.TextEffect> è contenuta all'interno di un <xref:System.Windows.FrameworkContentElement>del nome ambito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <param name="speedRatio">Valore finito maggiore di zero che corrisponde al nuovo rapporto di velocità interattiva dello storyboard. Questo valore viene moltiplicato per il valore dell'oggetto <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> dello storyboard, per determinare la velocità effettiva dello storyboard. Questo valore non sovrascrive la proprietà <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> dello storyboard. Ad esempio, se si chiama questo metodo e si specifica un rapporto di velocità interattivo pari a 3, su uno storyboard con un valore <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> pari a 0,5, il risultato della velocità effettiva dello storyboard è pari a 1,5.</param>
        <summary>Imposta il rapporto di velocità interattivo dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Chiamando questo metodo attiva il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTarget (element As DependencyObject, value As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTarget(System::Windows::DependencyObject ^ element, System::Windows::DependencyObject ^ value);" />
      <MemberSignature Language="F#" Value="static member SetTarget : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTarget (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Oggetto <see cref="T:System.Windows.Media.Animation.Timeline" /> che deve indirizzare l'oggetto di dipendenza specificato.</param>
        <param name="value">Oggetto di dipendenza di destinazione.</param>
        <summary>Fa in modo che l'oggetto <see cref="T:System.Windows.Media.Animation.Timeline" /> specificato indirizzi l'oggetto di dipendenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo imposta il <xref:System.Windows.Media.Animation.Storyboard.Target%2A> collegato proprietà sull'oggetto specificato. Per altre informazioni sul funzionamento della destinazione dello storyboard, vedere <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Per altre informazioni sul funzionamento delle proprietà come associate, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
> [!NOTE]
>  Il <xref:System.Windows.Media.Animation.Storyboard.Target%2A> proprietà non è serializzabile, poiché può essere impostata su qualsiasi <xref:System.Windows.DependencyObject>. Non è garantito che questo oggetto può far riferimento correttamente da XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetName (element As DependencyObject, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetName(System::Windows::DependencyObject ^ element, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member SetTargetName : System.Windows.DependencyObject * string -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetName (element, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element">Oggetto <see cref="T:System.Windows.Media.Animation.Timeline" /> che deve indirizzare l'oggetto di dipendenza specificato.</param>
        <param name="name">Nome dell'oggetto dipendenza di destinazione.</param>
        <summary>Fa in modo che l'oggetto <see cref="T:System.Windows.Media.Animation.Timeline" /> indirizzi l'oggetto di dipendenza col nome specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo imposta il <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> collegato proprietà sull'oggetto specificato. Per altre informazioni sul funzionamento della destinazione dello storyboard, vedere <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Per altre informazioni sul funzionamento delle proprietà come associate, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetProperty (element As DependencyObject, path As PropertyPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetProperty(System::Windows::DependencyObject ^ element, System::Windows::PropertyPath ^ path);" />
      <MemberSignature Language="F#" Value="static member SetTargetProperty : System.Windows.DependencyObject * System.Windows.PropertyPath -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetProperty (element, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">Oggetto <see cref="T:System.Windows.Media.Animation.Timeline" /> con il quale associare la proprietà di dipendenza specificata.</param>
        <param name="path">Percorso che descrive la proprietà di dipendenza da animare.</param>
        <summary>Fa in modo che l'oggetto <see cref="T:System.Windows.Media.Animation.Timeline" /> specificato indirizzi la proprietà di dipendenza specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo imposta il <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> collegato proprietà sull'oggetto specificato. Per altre informazioni sul funzionamento della destinazione dello storyboard, vedere <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A>. Per altre informazioni sul funzionamento delle proprietà come associate, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipToFill">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sposta il tempo corrente dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> di questo storyboard fino alla fine del periodo di attività.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill();" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : unit -&gt; unit" Usage="storyboard.SkipToFill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sposta il tempo corrente dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> di questo storyboard fino alla fine del periodo di attività.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Sposta il tempo corrente dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> di questo storyboard fino alla fine del periodo di attività.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo fa avanzare lo storyboard ora corrente alla fine del periodo attivo; a questo punto, il comportamento dello storyboard viene specificato dal relativo <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> impostazione. Se <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> è impostata su <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, si riempie lo storyboard; se la proprietà è impostata su <xref:System.Windows.Media.Animation.FillBehavior.Stop>, l'interruzione dello storyboard.  
  
 Chiamare questo metodo in uno storyboard con una durata infinita, un numero infinito di ripetizioni non ha effetto. Chiama questo metodo in uno storyboard inattivo non ha alcun effetto.  
  
 Spostare un orologio per il riempimento trigger periodo il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventi.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 L'esempio seguente usa uno storyboard controllabile animare un <xref:System.Windows.Media.TextEffect>. Il <xref:System.Windows.Media.TextEffect> è contenuta all'interno di un <xref:System.Windows.FrameworkContentElement>del nome ambito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Sposta il tempo corrente dell'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> di questo storyboard fino alla fine del periodo di attività.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo fa avanzare lo storyboard ora corrente alla fine del periodo attivo; a questo punto, il comportamento dello storyboard viene specificato dal relativo <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> impostazione. Se <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> è impostata su <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, si riempie lo storyboard; se la proprietà è impostata su <xref:System.Windows.Media.Animation.FillBehavior.Stop>, l'interruzione dello storyboard.  
  
 Chiamare questo metodo in uno storyboard con una durata infinita, un numero infinito di ripetizioni non ha effetto. Chiama questo metodo in uno storyboard inattivo non ha alcun effetto.  
  
 Spostare un orologio per il riempimento trigger periodo il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventi.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Stop">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Arresta l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="storyboard.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arresta l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che non venga attivato l'arresto di uno storyboard il <xref:System.Windows.Media.Animation.Timeline.Completed> evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Arresta l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Media.Animation.ClockState.Stopped> storyboard non influisce più sulle proprietà di destinazione: le proprietà che sono stati animate ripristino i valori precedenti.  
  
 L'arresto di un orologio il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventi, ma non la <xref:System.Windows.Media.Animation.Timeline.Completed> evento.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 L'esempio seguente usa uno storyboard controllabile animare un <xref:System.Windows.Media.TextEffect>. Il <xref:System.Windows.Media.TextEffect> è contenuta all'interno di un <xref:System.Windows.FrameworkContentElement>del nome ambito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Oggetto specificato quando il metodo <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> è stato chiamato. Questo oggetto contiene gli oggetti <see cref="T:System.Windows.Media.Animation.Clock" /> creati per questo storyboard e i relativi elementi figlio.</param>
        <summary>Arresta l'oggetto <see cref="T:System.Windows.Media.Animation.Clock" /> creato per questo <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Media.Animation.ClockState.Stopped> storyboard non influisce più sulle proprietà di destinazione: le proprietà che sono stati animate ripristino i valori precedenti.  
  
 L'arresto di un orologio il <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventi, ma non la <xref:System.Windows.Media.Animation.Timeline.Completed> evento.  
  
 Per controllare in modo interattivo lo storyboard, è necessario usare lo stesso `containingObject` parametro quando si chiamano i metodi interattivi che è utilizzato per avviare lo storyboard. Uno storyboard controllabile possibile sospendere, riprendere, seek e arrestare e da rimuovere. Per rendere uno storyboard controllabile nel codice, è necessario usare l'overload appropriato dello storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> metodo e specificare `true` per renderlo controllabile. Per un esempio, vedere [procedura: controllare un Storyboard dopo il relativo avvio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="ILAsm" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.Target" />
      <MemberSignature Language="VB.NET" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="F#" Value="see GetTarget, and SetTarget" Usage="see GetTarget, and SetTarget" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="ILAsm" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      <MemberSignature Language="VB.NET" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="F#" Value="see GetTargetName, and SetTargetName" Usage="see GetTargetName, and SetTargetName" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetNameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetNameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetNameProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà associata <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà associata <see cref="P:System.Windows.Media.Animation.Storyboard.Target" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetPropertyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetPropertyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetPropertyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà associata <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
  </Members>
</Type>