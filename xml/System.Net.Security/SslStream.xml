<Type Name="SslStream" FullName="System.Net.Security.SslStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bada0e51ffc8032cc2a85028ad35057a90420171" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911402" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SslStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SslStream extends System.Net.Security.AuthenticatedStream implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.SslStream" />
  <TypeSignature Language="VB.NET" Value="Public Class SslStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SslStream : System::Net::Security::AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce un flusso usato per la comunicazione client-server che usa il protocollo di sicurezza SSL (Secure Socket Layer) per autenticare il server ed eventualmente il client.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocolli SSL sono utili per garantire la riservatezza e integrità la verifica dei messaggi trasmessi utilizzando un <xref:System.Net.Security.SslStream>. Una connessione SSL, ad esempio quella fornita da <xref:System.Net.Security.SslStream>, deve essere utilizzato per la comunicazione di informazioni riservate tra un client e un server. Utilizzando un <xref:System.Net.Security.SslStream> utile per impedire che vengano letti e alterati mentre sono in transito sulla rete.  
  
 Un <xref:System.Net.Security.SslStream> istanza trasmette i dati utilizzando un flusso che viene fornito quando si crea il <xref:System.Net.Security.SslStream>. Quando si fornisce questo flusso sottostante, è possibile specificare se la chiusura di <xref:System.Net.Security.SslStream> e inoltre chiude il flusso sottostante. In genere, il <xref:System.Net.Security.SslStream> classe viene utilizzata con la <xref:System.Net.Sockets.TcpClient> e <xref:System.Net.Sockets.TcpListener> classi. Il <xref:System.Net.Sockets.TcpClient.GetStream%2A> metodo fornisce un <xref:System.Net.Sockets.NetworkStream> adatto per l'uso con la <xref:System.Net.Security.SslStream> classe.  
  
 Dopo aver creato un <xref:System.Net.Security.SslStream>, il server e, facoltativamente, il client deve essere autenticate. Il server deve fornire un X509 certificato che stabilisce la prova dell'identità e può richiedere che il client di eseguire. L'autenticazione deve essere eseguita prima della trasmissione di informazioni tramite un <xref:System.Net.Security.SslStream>. I client avviano l'autenticazione utilizzando sincroni <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> metodi, che blocca fino a quando non viene completata l'autenticazione, o asincrona <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> metodi, che non è bloccata in attesa del completamento dell'autenticazione. Server iniziano l'autenticazione utilizzando sincroni <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> o asincroni <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metodi. Client e server devono avviare l'autenticazione.  
  
 L'autenticazione viene gestito dal provider del canale Security Support Provider (SSPI). Il client ha la possibilità di controllare la convalida del certificato del server specificando un <xref:System.Net.Security.RemoteCertificateValidationCallback> delegato durante la creazione di un <xref:System.Net.Security.SslStream>. Il server può anche controllare convalida fornendo un <xref:System.Net.Security.RemoteCertificateValidationCallback> delegato. Il metodo a cui fa riferimento il delegato include certificato dell'entità remota e gli eventuali errori SSPI durante la convalida del certificato. Si noti che, se il server specifica di un delegato, indipendentemente dal fatto che il server ha richiesto l'autenticazione client viene richiamato il metodo del delegato. Se il server non ha richiesto l'autenticazione client, il metodo delegato del server riceve un certificato null e una matrice vuota di errori del certificato.  
  
 Se il server richiede l'autenticazione client, il client deve specificare uno o più certificati per l'autenticazione. Se il client ha più di un certificato, il client può fornire un <xref:System.Net.Security.LocalCertificateSelectionCallback> delegato per selezionare il certificato corretto per il server. I certificati del client devono trovarsi nell'archivio "My" certificato dell'utente corrente. L'autenticazione tramite certificati client non è supportata per il <xref:System.Security.Authentication.SslProtocols.Ssl2> protocollo (SSL versione 2).  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 Quando il processo di autenticazione, noto anche come l'handshake SSL, ha esito positivo, viene stabilita l'identità del server (e, facoltativamente, il client) e <xref:System.Net.Security.SslStream> utilizzabile dal client e server per lo scambio di messaggi. Prima di inviare o ricevere informazioni, il client e il server deve controllare i servizi di sicurezza e i livelli forniti dal <xref:System.Net.Security.SslStream> per determinare se il protocollo, gli algoritmi e i livelli selezionati soddisfano i requisiti di integrità e riservatezza. Se le impostazioni correnti non sono sufficienti, è necessario chiudere il flusso. È possibile controllare i servizi di sicurezza forniti dal <xref:System.Net.Security.SslStream> utilizzando il <xref:System.Net.Security.SslStream.IsEncrypted%2A> e <xref:System.Net.Security.SslStream.IsSigned%2A> proprietà. Nella tabella seguente mostra gli elementi che le impostazioni di crittografia utilizzate per l'autenticazione, crittografia e la firma dei dati del report.  
  
|Elemento|Membri|  
|-------------|-------------|  
|Il protocollo di sicurezza usato per autenticare il server e, facoltativamente, il client.|Il <xref:System.Net.Security.SslStream.SslProtocol%2A> associato e proprietà <xref:System.Security.Authentication.SslProtocols> enumerazione.|  
|L'algoritmo di scambio di chiave.|Il <xref:System.Net.Security.SslStream.KeyExchangeAlgorithm%2A> associato e proprietà <xref:System.Security.Authentication.ExchangeAlgorithmType> enumerazione.|  
|Algoritmo di integrità del messaggio.|Il <xref:System.Net.Security.SslStream.HashAlgorithm%2A> associato e proprietà <xref:System.Security.Authentication.HashAlgorithmType> enumerazione.|  
|Algoritmo di riservatezza del messaggio.|Il <xref:System.Net.Security.SslStream.CipherAlgorithm%2A> associato e proprietà <xref:System.Security.Authentication.CipherAlgorithmType> enumerazione.|  
|I punti di forza degli algoritmi selezionati.|Il <xref:System.Net.Security.SslStream.KeyExchangeStrength%2A>, <xref:System.Net.Security.SslStream.HashStrength%2A>, e <xref:System.Net.Security.SslStream.CipherStrength%2A> proprietà.|  
  
 Dopo il completamento dell'autenticazione, è possibile inviare dati tramite sincroni <xref:System.Net.Security.SslStream.Write%2A> o asincroni <xref:System.Net.Security.SslStream.BeginWrite%2A> metodi. È possibile ricevere i dati utilizzando sincroni <xref:System.Net.Security.SslStream.Read%2A> o asincroni <xref:System.Net.Security.SslStream.BeginRead%2A> metodi.  
  
 Se è stato specificato per il <xref:System.Net.Security.SslStream.%23ctor%2A> che il flusso sottostante deve essere lasciato aperto, è responsabili della chiusura di tale flusso al termine utilizzarlo.  
  
> [!NOTE]
>  Se l'applicazione che crea il <xref:System.Net.Security.SslStream> oggetto viene eseguito con le credenziali di un utente normale, l'applicazione non sarà in grado di accedere ai certificati installati nell'archivio del computer locale, a meno che l'autorizzazione è stata assegnata in modo esplicito all'utente a tale scopo.  
  
 <xref:System.Net.Security.SslStream> si presuppone che un timeout insieme agli altri <xref:System.IO.IOException> generato dal flusso interno verrà considerato come errore irreversibile dal chiamante. Riutilizzo di un <xref:System.Net.Security.SslStream> dopo un timeout restituirà garbage dell'istanza. Un'applicazione deve chiamare <xref:System.IO.Stream.Close%2A> il <xref:System.Net.Security.SslStream> e genera un'eccezione in questi casi.  
  
 .NET Framework 4.6 include una nuova funzionalità di sicurezza che blocca i pacchetti di crittografia non protetti e gli algoritmi per le connessioni di hash. Le applicazioni tramite TLS/SSL tramite le API, ad esempio HttpClient HttpWebRequest, FTPClient, SmtpClient, SslStream, e così via e destinato a .NET Framework 4.6 ottenere il comportamento più sicure per impostazione predefinita.  
  
 Gli sviluppatori potrebbero voler rifiutare esplicitamente questo comportamento per mantenere la compatibilità con i servizi esistenti SSL3 o TLS con servizi RC4. [In questo articolo](https://support.microsoft.com/kb/3069494) viene illustrato come modificare il codice in modo che il nuovo comportamento è disabilitato.  
  
 Il 4.7 di .NET Framework aggiunti nuovi overload per i metodi che eseguono l'autenticazione SslStreams che non si specifica una versione TLS, ma utilizzare invece definita come il valore predefinito di sistema in TLS versione [SCHANNEL](https://msdn.microsoft.com/library/windows/desktop/aa380123.aspx). Utilizzare questi metodi nell'applicazione in modo da poter successivamente si modificano le impostazioni predefinite come TLS versione best practice modifiche nel tempo, senza dover ricompilare e ridistribuire l'applicazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un <xref:System.Net.Sockets.TcpListener> che utilizza il <xref:System.Net.Security.SslStream> classe per comunicare con client.  
  
 [!code-cpp[NclSslServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#0)]
 [!code-csharp[NclSslServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#0)]  
  
 Esempio di codice seguente viene illustrato come creare un <xref:System.Net.Sockets.TcpClient> che utilizza il <xref:System.Net.Security.SslStream> classe per comunicare con un server.  
  
 [!code-cpp[NclSslClientSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#0)]
 [!code-csharp[NclSslClientSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Security.NegotiateStream" />
    <altmember cref="T:System.Net.Security.AuthenticatedStream" />
    <altmember cref="T:System.IO.IOException" />
    <altmember cref="T:System.IO.Stream" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Security.SslStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per evitare il <xref:System.Net.Security.SslStream> chiuda il flusso fornito, utilizzare il <xref:System.Net.Security.SslStream.%23ctor%2A> costruttore.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">L'oggetto <see cref="T:System.IO.Stream" /> utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" /> per inviare e ricevere dati.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Security.SslStream" /> usando il <see cref="T:System.IO.Stream" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non viene specificato un valore nel file di configurazione per encryptionpolicy, il <xref:System.Net.Security.EncryptionPolicy> per impostazione predefinita <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> per il <xref:System.Net.Security.SslStream> istanza che viene costruito.  
  
 L'utilizzo della crittografia Null è richiesto quando i criteri di crittografia sono impostato su <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> non è leggibile.  
  
 oppure  
  
 <paramref name="innerStream" /> non è scrivibile.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="innerStream" /> è uguale a <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">L'oggetto <see cref="T:System.IO.Stream" /> utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" /> per inviare e ricevere dati.</param>
        <param name="leaveInnerStreamOpen">Valore booleano indicante il comportamento di chiusura dell'oggetto <see cref="T:System.IO.Stream" /> utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" /> per inviare e ricevere dati. Questo parametro indica se il flusso interno viene lasciato aperto.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Security.SslStream" /> tramite l'oggetto <see cref="T:System.IO.Stream" /> specificato e il comportamento di chiusura del flusso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si specifica `true` per il `leaveStreamOpen` parametro, la chiusura di <xref:System.Net.Security.SslStream> non ha alcun effetto `innerStream` flusso; è necessario chiudere esplicitamente `innerStream` quando non è più necessario.  
  
 Se non viene specificato un valore nel file di configurazione per encryptionpolicy, il <xref:System.Net.Security.EncryptionPolicy> per impostazione predefinita <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> per il <xref:System.Net.Security.SslStream> istanza che viene costruito.  
  
 L'utilizzo della crittografia Null è richiesto quando i criteri di crittografia sono impostato su <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come chiamare questo costruttore.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> non è leggibile.  
  
 oppure  
  
 <paramref name="innerStream" /> non è scrivibile.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="innerStream" /> è uguale a <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">L'oggetto <see cref="T:System.IO.Stream" /> utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" /> per inviare e ricevere dati.</param>
        <param name="leaveInnerStreamOpen">Valore booleano indicante il comportamento di chiusura dell'oggetto <see cref="T:System.IO.Stream" /> utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" /> per inviare e ricevere dati. Questo parametro indica se il flusso interno viene lasciato aperto.</param>
        <param name="userCertificateValidationCallback">Delegato <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> responsabile della convalida del certificato emesso dalla parte remota.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Security.SslStream" /> tramite l'oggetto <see cref="T:System.IO.Stream" /> specificato, il comportamento di chiusura del flusso e il delegato di convalida del certificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si specifica `true` per il `leaveStreamOpen` parametro, la chiusura di <xref:System.Net.Security.SslStream> non ha alcun effetto `innerStream` flusso; è necessario chiudere esplicitamente `innerStream` quando non è più necessario.  
  
 Il `userCertificateValidationCallback` del delegato `certificateErrors` argomento contiene i codici di errore Windows restituiti dal canale Security Support Provider Interface (SSPI). Il valore restituito del metodo richiamato dal `userCertificateValidationCallback` delegato determina se l'autenticazione ha esito positivo.  
  
 Il protocollo di sicurezza e gli algoritmi di crittografia sono già selezionate quando il `userCertificateValidationCallback` viene richiamato il metodo del delegato. È possibile utilizzare il metodo per determinare se sono sufficienti per l'applicazione di algoritmi di crittografia selezionati e per i livelli. Se non, il metodo deve restituire `false` per impedire il <xref:System.Net.Security.SslStream> la creazione.  
  
 Se non viene specificato un valore nel file di configurazione per encryptionpolicy, il <xref:System.Net.Security.EncryptionPolicy> per impostazione predefinita <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> per il <xref:System.Net.Security.SslStream> istanza che viene costruito.  
  
 L'utilizzo della crittografia Null è richiesto quando i criteri di crittografia sono impostato su <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Il Framework memorizza nella cache le sessioni SSL quando vengono creati e tenta di riutilizzare una sessione memorizzati nella cache per una nuova richiesta, se possibile. Durante il tentativo di riutilizzare una sessione SSL, il Framework utilizza il primo elemento della <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (se è presente uno), o tenta di riutilizzare una sessione anonima se <xref:System.Net.HttpWebRequest.ClientCertificates%2A> è vuoto.  
  
> [!NOTE]
>  SSL versione 2 del protocollo non sono supportati i certificati di client.  
  
   
  
## Examples  
 L'esempio di codice seguente crea un <xref:System.Net.Security.SslStream> e avvia la parte client dell'autenticazione.  
  
 [!code-cpp[NclSslClientSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#4)]
 [!code-csharp[NclSslClientSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> non è leggibile.  
  
 oppure  
  
 <paramref name="innerStream" /> non è scrivibile.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="innerStream" /> è uguale a <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback, userCertificateSelectionCallback As LocalCertificateSelectionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">L'oggetto <see cref="T:System.IO.Stream" /> utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" /> per inviare e ricevere dati.</param>
        <param name="leaveInnerStreamOpen">Valore booleano indicante il comportamento di chiusura dell'oggetto <see cref="T:System.IO.Stream" /> utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" /> per inviare e ricevere dati. Questo parametro indica se il flusso interno viene lasciato aperto.</param>
        <param name="userCertificateValidationCallback">Delegato <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> responsabile della convalida del certificato emesso dalla parte remota.</param>
        <param name="userCertificateSelectionCallback">Delegato <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> responsabile della selezione del certificato utilizzato per l'autenticazione.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Security.SslStream" /> tramite l'oggetto <see cref="T:System.IO.Stream" /> specificato, il comportamento di chiusura del flusso, il delegato di convalida del certificato e il delegato di selezione del certificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si specifica `true` per il `leaveStreamOpen` parametro, la chiusura di <xref:System.Net.Security.SslStream> non ha alcun effetto `innerStream` flusso; è necessario chiudere esplicitamente `innerStream` quando non è più necessario.  
  
 Il `userCertificateValidationCallback` del delegato `certificateErrors` argomento contiene i codici di errore Windows restituiti dal canale Security Support Provider Interface (SSPI). Il valore restituito del metodo richiamato dal `userCertificateValidationCallback` delegato determina se l'autenticazione ha esito positivo.  
  
 Il protocollo di sicurezza e gli algoritmi di crittografia sono già selezionate quando il `userCertificateValidationCallback` viene richiamato il metodo del delegato. È possibile utilizzare il metodo per determinare se sono sufficienti per l'applicazione di algoritmi di crittografia selezionati e per i livelli. Se non, il metodo deve restituire `false` per impedire il <xref:System.Net.Security.SslStream> la creazione.  
  
 Il `userCertificateSelectionCallback` delegato è utile quando l'applicazione dispone di più certificati e sceglierne un certificato in modo dinamico. I certificati nell'archivio "MY" vengono passati al metodo richiamato dal delegato.  
  
 Se non viene specificato un valore nel file di configurazione per encryptionpolicy, il <xref:System.Net.Security.EncryptionPolicy> per impostazione predefinita <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> per il <xref:System.Net.Security.SslStream> istanza che viene costruito.  
  
 L'utilizzo della crittografia Null è richiesto quando i criteri di crittografia sono impostato su <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Il Framework memorizza nella cache le sessioni SSL quando vengono creati e tenta di riutilizzare una sessione memorizzati nella cache per una nuova richiesta, se possibile. Durante il tentativo di riutilizzare una sessione SSL, il Framework utilizza il primo elemento ClientCertificates (se presente), oppure tenta di riutilizzare una sessione anonima se ClientCertificates è vuota.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come chiamare questo costruttore. In questo esempio fa parte di un esempio più esaustivo disponibile per la <xref:System.Net.Security.SslStream> classe.  
  
 [!code-cpp[NclSslClientAsync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#6)]
 [!code-csharp[NclSslClientAsync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> non è leggibile.  
  
 oppure  
  
 <paramref name="innerStream" /> non è scrivibile.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="innerStream" /> è uguale a <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, System.Net.Security.EncryptionPolicy encryptionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, valuetype System.Net.Security.EncryptionPolicy encryptionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback, System::Net::Security::EncryptionPolicy encryptionPolicy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("encryptionPolicy is ignored")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
        <Parameter Name="encryptionPolicy" Type="System.Net.Security.EncryptionPolicy" />
      </Parameters>
      <Docs>
        <param name="innerStream">L'oggetto <see cref="T:System.IO.Stream" /> utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" /> per inviare e ricevere dati.</param>
        <param name="leaveInnerStreamOpen">Valore booleano indicante il comportamento di chiusura dell'oggetto <see cref="T:System.IO.Stream" /> utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" /> per inviare e ricevere dati. Questo parametro indica se il flusso interno viene lasciato aperto.</param>
        <param name="userCertificateValidationCallback">Delegato <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> responsabile della convalida del certificato emesso dalla parte remota.</param>
        <param name="userCertificateSelectionCallback">Delegato <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> responsabile della selezione del certificato utilizzato per l'autenticazione.</param>
        <param name="encryptionPolicy">Oggetto <see cref="T:System.Net.Security.EncryptionPolicy" /> da usare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Net.Security.SslStream" /> tramite l'oggetto <see cref="T:System.IO.Stream" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'utilizzo della crittografia Null è obbligatorio quando il `encryptionPolicy` parametro è impostato su <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> non è leggibile.  
  
 oppure  
  
 <paramref name="innerStream" /> non è scrivibile.  
  
 oppure  
  
 <paramref name="encryptionPolicy" /> non è valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="innerStream" /> è uguale a <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Autenticare il lato client della connessione client-server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nome del server che condivide questo oggetto <see cref="T:System.Net.Security.SslStream" />.</param>
        <summary>Chiamato dai client per autenticare il server e, facoltativamente, il client in una connessione client-server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Nessun certificato client viene utilizzato nell'autenticazione. L'elenco certificati revocati non è verificato durante l'autenticazione. Il valore specificato per `targetHost` deve corrispondere al nome sul certificato del server.  
  
 Quando l'autenticazione ha esito positivo, è necessario controllare il <xref:System.Net.Security.SslStream.IsEncrypted%2A> e <xref:System.Net.Security.SslStream.IsSigned%2A> le proprietà per determinare i servizi di sicurezza utilizzati per il <xref:System.Net.Security.SslStream>. Controllare il <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> proprietà per determinare se l'autenticazione reciproca.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del server con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nome del server che condividerà questo oggetto <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">Oggetto <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> che contiene i certificati client.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <summary>Chiamato dai client per autenticare il server e, facoltativamente, il client in una connessione client-server. Il processo di autenticazione usa la raccolta di certificati specificata e il protocollo SSL predefinito di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Quando l'autenticazione ha esito positivo, è necessario controllare il <xref:System.Net.Security.SslStream.IsEncrypted%2A> e <xref:System.Net.Security.SslStream.IsSigned%2A> le proprietà per determinare i servizi di sicurezza utilizzati per il <xref:System.Net.Security.SslStream>. Controllare il <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> proprietà per determinare se l'autenticazione reciproca.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
> [!NOTE]
>  SSL versione 2 del protocollo non sono supportati i certificati di client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nome del server che condividerà questo oggetto <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">Oggetto <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> che contiene i certificati client.</param>
        <param name="enabledSslProtocols">Valore <see cref="T:System.Security.Authentication.SslProtocols" /> che rappresenta il protocollo utilizzato per l'autenticazione.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <summary>Chiamato dai client per autenticare il server e, facoltativamente, il client in una connessione client-server. Nel processo di autenticazione vengono utilizzati l'insieme di certificati specificato e il protocollo SSL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Quando l'autenticazione ha esito positivo, è necessario controllare il <xref:System.Net.Security.SslStream.IsEncrypted%2A> e <xref:System.Net.Security.SslStream.IsSigned%2A> le proprietà per determinare i servizi di sicurezza utilizzati per il <xref:System.Net.Security.SslStream>. Controllare il <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> proprietà per determinare se l'autenticazione reciproca.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
> [!NOTE]
>  SSL versione 2 del protocollo non sono supportati i certificati di client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Autentica il lato client di una connessione client-server come operazione asincrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nome del server che condivide questo oggetto <see cref="T:System.Net.Security.SslStream" />.</param>
        <summary>Chiamato dai client per autenticare il server e, facoltativamente, il client in una connessione client-server come operazione asincrona.</summary>
        <returns>Restituisce <see cref="T:System.Threading.Tasks.Task" />.  
  
 Oggetto dell'attività che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Nessun certificato client viene utilizzato nell'autenticazione. L'elenco certificati revocati non è verificato durante l'autenticazione. Il valore specificato per `targetHost` deve corrispondere al nome sul certificato del server.  
  
 Quando l'autenticazione ha esito positivo, è necessario controllare il <xref:System.Net.Security.SslStream.IsEncrypted%2A> e <xref:System.Net.Security.SslStream.IsSigned%2A> le proprietà per determinare i servizi di sicurezza utilizzati per il <xref:System.Net.Security.SslStream>. Controllare il <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> proprietà per determinare se l'autenticazione reciproca.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del server con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.Net.Security.SslClientAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::Security::SslClientAuthenticationOptions ^ sslClientAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslClientAuthenticationOptions" Type="System.Net.Security.SslClientAuthenticationOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="sslClientAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nome del server che condividerà questo oggetto <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">Oggetto <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> che contiene i certificati client.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <summary>Chiamato dai client per autenticare il server e, facoltativamente, il client in una connessione client-server come operazione asincrona. Il processo di autenticazione usa la raccolta di certificati specificata e il protocollo SSL predefinito di sistema.</summary>
        <returns>Oggetto dell'attività che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Quando l'autenticazione ha esito positivo, è necessario controllare il <xref:System.Net.Security.SslStream.IsEncrypted%2A> e <xref:System.Net.Security.SslStream.IsSigned%2A> le proprietà per determinare i servizi di sicurezza utilizzati per il <xref:System.Net.Security.SslStream>. Controllare il <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> proprietà per determinare se l'autenticazione reciproca.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
> [!NOTE]
>  SSL versione 2 del protocollo non sono supportati i certificati di client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nome del server che condividerà questo oggetto <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">Oggetto <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> che contiene i certificati client.</param>
        <param name="enabledSslProtocols">Valore <see cref="T:System.Security.Authentication.SslProtocols" /> che rappresenta il protocollo utilizzato per l'autenticazione.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <summary>Chiamato dai client per autenticare il server e, facoltativamente, il client in una connessione client-server come operazione asincrona. Nel processo di autenticazione vengono utilizzati l'insieme di certificati specificato e il protocollo SSL.</summary>
        <returns>Restituisce <see cref="T:System.Threading.Tasks.Task" />.  
  
 Oggetto dell'attività che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Quando l'autenticazione ha esito positivo, è necessario controllare il <xref:System.Net.Security.SslStream.IsEncrypted%2A> e <xref:System.Net.Security.SslStream.IsSigned%2A> le proprietà per determinare i servizi di sicurezza utilizzati per il <xref:System.Net.Security.SslStream>. Controllare il <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> proprietà per determinare se l'autenticazione reciproca.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
> [!NOTE]
>  SSL versione 2 del protocollo non sono supportati i certificati di client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Viene chiamato dai server per l'autenticazione del server e, facoltativamente, del client, in una connessione client-server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificato utilizzato per autenticare il server.</param>
        <summary>Viene chiamato dai server per l'autenticazione del server e, facoltativamente, del client, in una connessione client-server che utilizza il certificato specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] L'elenco certificati revocati non è verificato durante l'autenticazione. Il client non è necessario fornire un certificato per l'autenticazione.  
  
 Questo metodo si blocca fino al completamento dell'operazione. Per evitare il blocco fino al completamento dell'operazione, utilizzare uno del <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> overload del metodo.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del client con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il metodo <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> non è supportato in Windows 95, Windows 98 o Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificato X509 usato per autenticare il server.</param>
        <param name="clientCertificateRequired">Valore di <see cref="T:System.Boolean" /> che specifica se al client viene richiesto un certificato per l'autenticazione. Trattandosi solo di una richiesta, se non viene fornito alcun certificato, il server accetta ancora la richiesta di connessione.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <summary>Chiamato dai server per autenticare il server e, facoltativamente, il client in una connessione client-server usando i certificati e i requisiti specificati nonché il protocollo di sicurezza predefinito del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Questo metodo si blocca fino al completamento dell'operazione. Per evitare il blocco fino al completamento dell'operazione, utilizzare uno del <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> overload del metodo.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del client con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il metodo <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> non è supportato in Windows 95, Windows 98 o Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificato X509 usato per autenticare il server.</param>
        <param name="clientCertificateRequired">Valore di <see cref="T:System.Boolean" /> che specifica se al client viene richiesto un certificato per l'autenticazione. Trattandosi solo di una richiesta, se non viene fornito alcun certificato, il server accetta ancora la richiesta di connessione.</param>
        <param name="enabledSslProtocols">Valore <see cref="T:System.Security.Authentication.SslProtocols" /> che rappresenta il protocollo utilizzato per l'autenticazione.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <summary>Chiamato dai server per autenticare il server ed eventualmente il client in una connessione client-server usando i certificati, i requisiti e il protocollo di sicurezza specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Questo metodo si blocca fino al completamento dell'operazione. Per evitare il blocco fino al completamento dell'operazione, utilizzare uno del <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> overload del metodo.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> non è un valore valido di <see cref="T:System.Security.Authentication.SslProtocols" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del client con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il metodo <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> non è supportato in Windows 95, Windows 98 o Windows Millennium.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Viene chiamato dai server per l'autenticazione del server e, facoltativamente, del client, in una connessione client-server come un'operazione asincrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificato utilizzato per autenticare il server.</param>
        <summary>Viene chiamato dai server per l'autenticazione del server e, facoltativamente, del client, in una connessione client-server che utilizza il certificato specificato come un'operazione asincrona.</summary>
        <returns>Restituisce <see cref="T:System.Threading.Tasks.Task" />.  
  
 Oggetto dell'attività che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Questo metodo esegue l'autenticazione utilizzando <xref:System.Security.Authentication.SslProtocols.Default>. L'elenco certificati revocati non è verificato durante l'autenticazione. Il client non è necessario fornire un certificato per l'autenticazione.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del client con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il metodo <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServerAsync" /> non è supportato in Windows 95, Windows 98 o Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Net.Security.SslServerAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::Security::SslServerAuthenticationOptions ^ sslServerAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslServerAuthenticationOptions" Type="System.Net.Security.SslServerAuthenticationOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="sslServerAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificato X509 usato per autenticare il server.</param>
        <param name="clientCertificateRequired">Valore di <see cref="T:System.Boolean" /> che specifica se al client viene richiesto un certificato per l'autenticazione. Trattandosi solo di una richiesta, se non viene fornito alcun certificato, il server accetta ancora la richiesta di connessione.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <summary>Chiamato dai server per autenticare il server ed eventualmente il client in una connessione client-server usando i certificati specificati, i requisiti e il protocollo di sicurezza come operazione asincrona.</summary>
        <returns>Oggetto dell'attività che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificato X509 usato per autenticare il server.</param>
        <param name="clientCertificateRequired">Valore di <see cref="T:System.Boolean" /> che specifica se al client viene richiesto un certificato per l'autenticazione. Trattandosi solo di una richiesta, se non viene fornito alcun certificato, il server accetta ancora la richiesta di connessione.</param>
        <param name="enabledSslProtocols">Valore <see cref="T:System.Security.Authentication.SslProtocols" /> che rappresenta il protocollo utilizzato per l'autenticazione.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <summary>Chiamato dai server per autenticare il server ed eventualmente il client in una connessione client-server usando i certificati specificati, i requisiti e il protocollo di sicurezza come operazione asincrona.</summary>
        <returns>Restituisce <see cref="T:System.Threading.Tasks.Task" />.  
  
 Oggetto dell'attività che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia un'operazione per autenticare il lato client di una connessione client-server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload di questo metodo non è bloccata durante l'autenticazione è in corso. Per il blocco durante l'attesa del completamento dell'autenticazione, utilizzare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> metodi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nome del server che condivide questo oggetto <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="asyncCallback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'autenticazione.</param>
        <param name="asyncState">Oggetto definito dall'utente che contiene informazioni sull'operazione. L'oggetto viene passato al delegato <c>asyncCallback</c> al completamento dell'operazione.</param>
        <summary>Viene chiamato dai client per avviare un'operazione asincrona di autenticazione del server e, facoltativamente, del client.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che indica lo stato dell'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Nessun certificato client viene utilizzato nell'autenticazione. L'elenco certificati revocati non è verificato durante l'autenticazione.  
  
 Il valore specificato per `targetHost` deve corrispondere al nome sul certificato del server.  
  
 L'operazione asincrona di autenticazione deve essere completata chiamando il <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metodo. In genere, il metodo viene richiamato dal `asyncCallback` delegato.  
  
 Questo metodo non blocca durante il completamento dell'operazione. Per il blocco fino al completamento dell'operazione, utilizzare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> overload del metodo.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Se si riceve un <xref:System.Security.Authentication.AuthenticationException>, questo <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del server con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nome del server che condivide questo oggetto <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">Oggetto <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> che contiene i certificati client.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <param name="asyncCallback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'autenticazione.</param>
        <param name="asyncState">Oggetto definito dall'utente che contiene informazioni sull'operazione. L'oggetto viene passato al delegato <c>asyncCallback</c> al completamento dell'operazione.</param>
        <summary>Chiamato dai client per avviare un'operazione asincrona per autenticare il server e, facoltativamente, il client usando i certificati specificati e il protocollo di sicurezza predefinito del sistema.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che indica lo stato dell'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Il valore specificato per `targetHost` deve corrispondere al nome sul certificato del server.  
  
 L'operazione asincrona di autenticazione deve essere completata chiamando il <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metodo. In genere, il metodo viene richiamato dal `asyncCallback` delegato.  
  
 Questo metodo non blocca durante il completamento dell'operazione. Per il blocco fino al completamento dell'operazione, utilizzare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> overload del metodo.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Se si riceve un <xref:System.Security.Authentication.AuthenticationException>, questo <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
> [!NOTE]
>  SSL versione 2 del protocollo non sono supportati i certificati di client.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del server con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nome del server che condivide questo oggetto <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">Oggetto <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> che contiene i certificati client.</param>
        <param name="enabledSslProtocols">Valore <see cref="T:System.Security.Authentication.SslProtocols" /> che rappresenta il protocollo utilizzato per l'autenticazione.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <param name="asyncCallback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'autenticazione.</param>
        <param name="asyncState">Oggetto definito dall'utente che contiene informazioni sull'operazione. L'oggetto viene passato al delegato <c>asyncCallback</c> al completamento dell'operazione.</param>
        <summary>Viene chiamato dai client per avviare un'operazione asincrona di autenticazione del server e, facoltativamente, del client, utilizzando i certificati e il protocollo di sicurezza specificati.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che indica lo stato dell'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Il valore specificato per `targetHost` deve corrispondere al nome sul certificato del server.  
  
 L'operazione asincrona di autenticazione deve essere completata chiamando il <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metodo. In genere, il metodo viene richiamato dal `asyncCallback` delegato.  
  
 Questo metodo non blocca durante il completamento dell'operazione. Per il blocco fino al completamento dell'operazione, utilizzare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> overload del metodo.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Se si riceve un <xref:System.Security.Authentication.AuthenticationException>, questo <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
> [!NOTE]
>  SSL versione 2 del protocollo non sono supportati i certificati di client.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> non è un valore valido di <see cref="T:System.Security.Authentication.SslProtocols" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del server con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia un'operazione asincrona per gestire il lato server dell'autenticazione di una connessione client-server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload di questo metodo non è bloccata durante l'autenticazione è in corso. Per il blocco durante l'attesa del completamento dell'autenticazione, utilizzare uno del <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> metodi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificato X509 usato per autenticare il server.</param>
        <param name="asyncCallback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'autenticazione.</param>
        <param name="asyncState">Oggetto definito dall'utente che contiene informazioni sull'operazione. L'oggetto viene passato al delegato <c>asyncCallback</c> al completamento dell'operazione.</param>
        <summary>Viene chiamato dai server per avviare un'operazione asincrona di autenticazione del client e, facoltativamente, del server, in una connessione client-server.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che indica lo stato dell'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] L'elenco certificati revocati non è verificato durante l'autenticazione. Il client non è necessario fornire un certificato per l'autenticazione.  
  
 L'operazione asincrona di autenticazione deve essere completata chiamando il <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metodo. In genere, il metodo viene richiamato dal `asyncCallback` delegato.  
  
 Questo metodo non blocca durante il completamento dell'operazione. Per il blocco fino al completamento dell'operazione, utilizzare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> overload del metodo.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Se si riceve un <xref:System.Security.Authentication.AuthenticationException>, questo <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del client con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il metodo <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> non è supportato in Windows 95, Windows 98 o Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificato X509 usato per autenticare il server.</param>
        <param name="clientCertificateRequired">Valore di <see cref="T:System.Boolean" /> che specifica se al client viene richiesto un certificato per l'autenticazione. Trattandosi solo di una richiesta, se non viene fornito alcun certificato, il server accetta ancora la richiesta di connessione.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <param name="asyncCallback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'autenticazione.</param>
        <param name="asyncState">Oggetto definito dall'utente che contiene informazioni sull'operazione. L'oggetto viene passato al delegato <c>asyncCallback</c> al completamento dell'operazione.</param>
        <summary>Chiamato dai server per avviare un'operazione asincrona per autenticare il server e, facoltativamente, il client usando i certificati e i requisiti specificati nonché il protocollo di sicurezza predefinito del sistema.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che indica lo stato dell'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 L'operazione asincrona di autenticazione deve essere completata chiamando il <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> metodo. In genere, il metodo viene richiamato dal `asyncCallback` delegato.  
  
 Questo metodo non blocca durante il completamento dell'operazione. Per il blocco fino al completamento dell'operazione, utilizzare uno del <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> overload del metodo.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Se si riceve un <xref:System.Security.Authentication.AuthenticationException>, questo <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del server con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il metodo <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> non è supportato in Windows 95, Windows 98 o Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificato X509 usato per autenticare il server.</param>
        <param name="clientCertificateRequired">Valore di <see cref="T:System.Boolean" /> che specifica se al client viene richiesto un certificato per l'autenticazione. Trattandosi solo di una richiesta, se non viene fornito alcun certificato, il server accetta ancora la richiesta di connessione.</param>
        <param name="enabledSslProtocols">Valore <see cref="T:System.Security.Authentication.SslProtocols" /> che rappresenta il protocollo utilizzato per l'autenticazione.</param>
        <param name="checkCertificateRevocation">Valore di <see cref="T:System.Boolean" /> che specifica se durante l'autenticazione viene controllato l'elenco di revoche di certificati.</param>
        <param name="asyncCallback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare al completamento dell'autenticazione.</param>
        <param name="asyncState">Oggetto definito dall'utente che contiene informazioni sull'operazione. L'oggetto viene passato al delegato <c>asyncCallback</c> al completamento dell'operazione.</param>
        <summary>Chiamato dai server per avviare un'operazione asincrona per autenticare il server ed eventualmente il client usando i certificati, i requisiti e il protocollo di sicurezza specificati.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che indica lo stato dell'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 L'operazione asincrona di autenticazione deve essere completata chiamando il <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> metodo. In genere, il metodo viene richiamato dal `asyncCallback` delegato.  
  
 Questo metodo non blocca durante il completamento dell'operazione. Per il blocco fino al completamento dell'operazione, utilizzare uno del <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> overload del metodo.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Se si riceve un <xref:System.Security.Authentication.AuthenticationException>, questo <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> non è un valore valido di <see cref="T:System.Security.Authentication.SslProtocols" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione è già stata effettuata.  
  
 oppure  
  
 L'autenticazione del server con la classe <see cref="T:System.Net.Security.SslStream" /> è stata già tentata.  
  
 oppure  
  
 L'autenticazione è già in corso.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Il metodo <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> non è supportato in Windows 95, Windows 98 o Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice <see cref="T:System.Byte" /> che riceve i byte letti dal flusso.</param>
        <param name="offset">Posizione in base zero in <c>buffer</c> da cui iniziare l'archiviazione dei dati letti da questo flusso.</param>
        <param name="count">Numero massimo di byte da leggere dal flusso.</param>
        <param name="asyncCallback">Delegato <see cref="T:System.AsyncCallback" /> cui fa riferimento il metodo da richiamare quando l'operazione di lettura è completa.</param>
        <param name="asyncState">Oggetto definito dall'utente contenente informazioni sull'operazione di lettura. L'oggetto viene passato al delegato <c>asyncCallback</c> al completamento dell'operazione.</param>
        <summary>Avvia un'operazione di lettura asincrona dei dati del flusso, archiviandoli nella matrice specificata.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che indica lo stato dell'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è abilitata la crittografia e firma, l'operazione di lettura legge i dati dal flusso sottostante, controlla l'integrità dei dati, e/o lo decrittografa. L'operazione di lettura asincrona deve essere completata chiamando il <xref:System.Net.Security.SslStream.EndRead%2A> metodo. In genere, il metodo viene richiamato dal `asyncCallback` delegato.  
  
 Questo metodo non blocca durante il completamento dell'operazione. Per il blocco fino al completamento dell'operazione, utilizzare il <xref:System.Net.Security.SslStream.Read%2A> metodo.  
  
 Per informazioni dettagliate sull'uso del modello di programmazione asincrono, vedere [la chiamata dei metodi sincroni](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 La <xref:System.Net.Security.SslStream> classe non supporta più operazioni di lettura simultanei.  
  
 È possibile chiamare questo metodo fino a quando non è stata effettuata l'autenticazione. Per l'autenticazione di chiamare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, o <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metodi.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come avviare un'operazione di lettura asincrona.  
  
 [!code-cpp[NclSslClientAsync#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#8)]
 [!code-csharp[NclSslClientAsync#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#8)]  
  
 [!code-cpp[NclSslClientAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#4)]
 [!code-csharp[NclSslClientAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#4)]  
  
 Il metodo seguente viene chiamato quando viene completata la lettura.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; lunghezza di <paramref name="buffer" />.  
  
 oppure  
  
 <paramref name="offset" /> + conteggio &gt; lunghezza di <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">L'operazione di lettura non è riuscita.  
  
 oppure  
  
 La crittografia è in uso, ma non è stato possibile decrittografare i dati.</exception>
        <exception cref="T:System.NotSupportedException">È già in corso un'operazione di lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione non è stata effettuata.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che fornisce i byte che devono essere scritti nel flusso.</param>
        <param name="offset">Posizione in base zero in <c>buffer</c> da cui iniziare la lettura dei byte che devono essere scritti nel flusso.</param>
        <param name="count">Valore <see cref="T:System.Int32" /> che specifica il numero di byte da leggere da <c>buffer</c>.</param>
        <param name="asyncCallback">Delegato <see cref="T:System.AsyncCallback" /> che fa riferimento al metodo da richiamare quando l'operazione di scrittura è completa.</param>
        <param name="asyncState">Oggetto definito dall'utente contenente informazioni sull'operazione di scrittura. L'oggetto viene passato al delegato <c>asyncCallback</c> al completamento dell'operazione.</param>
        <summary>Avvia un'operazione di scrittura asincrona che scrive i <see cref="T:System.Byte" /> dal buffer specificato nel flusso.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che indica lo stato dell'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come chiamare questo metodo.  
  
 [!code-cpp[NclSslServerAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#5)]
 [!code-csharp[NclSslServerAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; lunghezza di <paramref name="buffer" />.  
  
 oppure  
  
 <paramref name="offset" /> + conteggio &gt; lunghezza di <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Operazione di scrittura non riuscita.</exception>
        <exception cref="T:System.NotSupportedException">È già in corso un'operazione di scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione non è stata effettuata.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanRead</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" />che indica se il flusso sottostante è leggibile.</summary>
        <value>
          <see langword="true" /> se l'autenticazione è avvenuta e il flusso sottostante è leggibile; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si è verificato l'autenticazione ha esito positivo, questa proprietà restituisce il valore restituito richiamando <xref:System.IO.Stream.CanRead%2A> nel flusso sottostante.  
  
 Il flusso sottostante viene specificato quando si crea un'istanza di <xref:System.Net.Security.SslStream> classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se il flusso sottostante consente le ricerche.</summary>
        <value>Questa proprietà restituisce sempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non tentare di impostare la posizione del <xref:System.Net.Security.SslStream> oggetto o il flusso sottostante.  
  
 Il flusso sottostante viene specificato quando si crea un'istanza di <xref:System.Net.Security.SslStream> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.CanSeek" />
        <altmember cref="P:System.Net.Security.SslStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se il flusso sottostante supporta i timeout.</summary>
        <value>
          <see langword="true" /> se il flusso sottostante supporta i timeout; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce il valore restituito richiamando <xref:System.IO.Stream.CanTimeout%2A> nel flusso sottostante.  
  
 Il flusso sottostante viene specificato quando si crea un'istanza di <xref:System.Net.Security.SslStream> classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanWrite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se è possibile scrivere nel flusso sottostante.</summary>
        <value>
          <see langword="true" /> se l'autenticazione è avvenuta ed è possibile scrivere nel flusso sottostante; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si è verificato l'autenticazione ha esito positivo, questa proprietà restituisce il valore restituito richiamando <xref:System.IO.Stream.CanWrite%2A> nel flusso sottostante.  
  
 Il flusso sottostante viene specificato quando si crea un'istanza di <xref:System.Net.Security.SslStream> classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckCertRevocationStatus">
      <MemberSignature Language="C#" Value="public virtual bool CheckCertRevocationStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCertRevocationStatus" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CheckCertRevocationStatus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CheckCertRevocationStatus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CheckCertRevocationStatus { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CheckCertRevocationStatus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se l'elenco certificati revocati viene verificato durante il processo di convalida del certificato.</summary>
        <value>
          <see langword="true" /> se l'elenco certificati revocati è verificato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elenco di revoche di certificati contiene certificati sono stati revocati dall'autorità emittente. Controllando l'elenco negativamente influisce sulle prestazioni, ma migliora la sicurezza dell'applicazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CipherAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.CipherAlgorithmType CipherAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.CipherAlgorithmType CipherAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherAlgorithm As CipherAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::CipherAlgorithmType CipherAlgorithm { System::Security::Authentication::CipherAlgorithmType get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.CipherAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che identifica l'algoritmo di crittografia di massa utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Valore <see cref="T:System.Security.Authentication.CipherAlgorithmType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore <xref:System.Security.Authentication.CipherAlgorithmType.Null> è necessaria per il <xref:System.Net.Security.SslStream.CipherAlgorithm%2A> proprietà quando il <xref:System.Net.Security.EncryptionPolicy.NoEncryption> valore di enumerazione viene utilizzato per costruire un <xref:System.Net.Security.SslStream> istanza.  
  
 [!INCLUDE[winxpsvr](~/includes/winxpsvr-md.md)] e [!INCLUDE[winxp](~/includes/winxp-md.md)] non supportano il <xref:System.Security.Authentication.CipherAlgorithmType.Null> valore. Pertanto, anche se il <xref:System.Security.Authentication.CipherAlgorithmType.Null> valore viene utilizzato per costruire il <xref:System.Net.Security.SslStream> istanza, il <xref:System.Net.Security.EncryptionPolicy> proprietà sarà <xref:System.Security.Authentication.CipherAlgorithmType.None>. Il <xref:System.Security.Authentication.CipherAlgorithmType.Null> valore viene restituito solo in Windows Vista e versioni successive.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare le impostazioni di crittografia per il flusso specificato.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'accesso alla proprietà <see cref="P:System.Net.Security.SslStream.CipherAlgorithm" /> è stata eseguito prima del completamento del processo di autenticazione oppure il processo di autenticazione non è riuscito.</exception>
      </Docs>
    </Member>
    <Member MemberName="CipherStrength">
      <MemberSignature Language="C#" Value="public virtual int CipherStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CipherStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CipherStrength { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che identifica il livello dell'algoritmo di crittografia utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Valore <see cref="T:System.Int32" /> che specifica il livello dell'algoritmo, in bit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa proprietà è zero fino a quando non si verifica l'autenticazione.  
  
 Questa proprietà restituisce uno dei valori seguenti:  
  
-   0  
  
-   40  
  
-   56  
  
-   80  
  
-   128  
  
-   168  
  
-   192  
  
-   256  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare le impostazioni di crittografia per il flusso specificato.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate da <see cref="T:System.Net.Security.SslStream" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal metodo pubblico `Dispose()` (metodo) e <xref:System.Object.Finalize%2A> metodo. `Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama `Dispose` con `disposing` impostato su `false`.  
  
 Quando il `disposing` parametro è true, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti da questo <xref:System.Net.Security.SslStream> riferimenti. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            Il metodo <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see langword="Dispose(Boolean)" /> prestare attenzione a non fare riferimento a oggetti che sono stati eliminati in una precedente chiamata a <see langword="Dispose" />. Per ulteriori informazioni su come implementare <see langword="Dispose(Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Per ulteriori informazioni su <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [si esegue l'override del metodo Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsClient(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Istanza della classe <see cref="T:System.IAsyncResult" /> restituita da una chiamata di <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</param>
        <summary>Termina un'operazione di autenticazione server asincrona in sospeso avviata con una precedente chiamata del metodo <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione non è stata completata, questo metodo si blocca fino a quando non avviene. Quando l'autenticazione ha esito positivo, è necessario controllare il <xref:System.Net.Security.SslStream.IsEncrypted%2A> e <xref:System.Net.Security.SslStream.IsSigned%2A> le proprietà per determinare i servizi di sicurezza utilizzati per il <xref:System.Net.Security.SslStream>. Controllare il <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> proprietà per determinare se l'autenticazione reciproca.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 Per eseguire questa operazione in modo sincrono, utilizzare uno del <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> metodi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">Non esiste alcuna autenticazione server in sospeso da completare.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsServer(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Istanza della classe <see cref="T:System.IAsyncResult" /> restituita da una chiamata di <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</param>
        <summary>Termina un'operazione di autenticazione client asincrona in sospeso avviata con una precedente chiamata del metodo <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione non è stata completata, questo metodo si blocca fino a quando non avviene. Quando l'autenticazione ha esito positivo, è necessario controllare il <xref:System.Net.Security.SslStream.IsEncrypted%2A> e <xref:System.Net.Security.SslStream.IsSigned%2A> le proprietà per determinare i servizi di sicurezza utilizzati per il <xref:System.Net.Security.SslStream>. Controllare il <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> proprietà per determinare se l'autenticazione reciproca.  
  
 Se l'autenticazione non riesce, viene visualizzato un <xref:System.Security.Authentication.AuthenticationException>e ciò <xref:System.Net.Security.SslStream> non è più utilizzabile. È necessario chiudere questo oggetto e rimuovere tutti i riferimenti in modo che possono essere raccolti dal garbage collector.  
  
 Per eseguire questa operazione in modo sincrono, utilizzare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L'autenticazione ha avuto esito negativo, rendendo l'oggetto inutilizzabile.</exception>
        <exception cref="T:System.InvalidOperationException">Non esiste alcuna autenticazione del client in sospeso da completare.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndRead(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Istanza della classe <see cref="T:System.IAsyncResult" /> restituita da una chiamata del metodo <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</param>
        <summary>Termina un'operazione di lettura asincrona avviata con una precedente chiamata del metodo <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns>Valore <see cref="T:System.Int32" /> che specifica il numero di byte letti dal flusso sottostante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione non è stata completata, questo metodo si blocca fino a quando non avviene.  
  
 Per eseguire questa operazione in modo sincrono, utilizzare il <xref:System.Net.Security.SslStream.Read%2A> metodo.  
  
 È possibile chiamare questo metodo fino a quando non è stata effettuata l'autenticazione. Per l'autenticazione di chiamare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, o <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metodi.  
  
   
  
## Examples  
 L'esempio di codice seguente viene illustrato l'operazione di lettura asincrona di chiusura.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione non è stata effettuata.</exception>
        <exception cref="T:System.IO.IOException">L'operazione di lettura non è riuscita.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndWrite(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Istanza della classe <see cref="T:System.IAsyncResult" /> restituita da una chiamata del metodo <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</param>
        <summary>Termina un'operazione di scrittura asincrona avviata con una precedente chiamata del metodo <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'operazione non è stata completata, questo metodo si blocca fino a quando non avviene.  
  
 Un'applicazione non è possibile chiamare questo metodo fino a quando non è stata effettuata l'autenticazione. Per autenticare, chiamare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, o <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metodi.  
  
 Per eseguire questa operazione in modo sincrono, utilizzare il <xref:System.Net.Security.SslStream.Write%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato che termina un'operazione di scrittura asincrona.  
  
 [!code-cpp[NclSslServerAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#4)]
 [!code-csharp[NclSslServerAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> non è stato creato da una chiamata al metodo <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione non è stata effettuata.</exception>
        <exception cref="T:System.IO.IOException">Operazione di scrittura non riuscita.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente la scrittura dei dati memorizzati nel buffer nel dispositivo sottostante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo richiama <xref:System.IO.Stream.Flush%2A> nel flusso sottostante.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come chiamare questo metodo.  
  
 [!code-cpp[NclSslClientSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#5)]
 [!code-csharp[NclSslClientSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.HashAlgorithmType HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.HashAlgorithmType HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashAlgorithm As HashAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::HashAlgorithmType HashAlgorithm { System::Security::Authentication::HashAlgorithmType get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.HashAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'algoritmo utilizzato per generare codici di autenticazione MAC (Message Authentication Code).</summary>
        <value>Valore <see cref="T:System.Security.Authentication.HashAlgorithmType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli algoritmi di autenticazione messaggi generano hash e firme consente di rilevare manomissioni e false.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare le impostazioni di crittografia per il flusso specificato.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'accesso alla proprietà <see cref="P:System.Net.Security.SslStream.HashAlgorithm" /> è stata eseguito prima del completamento del processo di autenticazione oppure il processo di autenticazione non è riuscito.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashStrength">
      <MemberSignature Language="C#" Value="public virtual int HashStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HashStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int HashStrength { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che identifica il livello dell'algoritmo di hash utilizzato da questa istanza.</summary>
        <value>Valore <see cref="T:System.Int32" /> che specifica il livello dell'algoritmo <see cref="T:System.Security.Authentication.HashAlgorithmType" />, in bit. I valori validi sono 128 o 160.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa proprietà è zero fino a quando non si verifica l'autenticazione.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare le impostazioni di crittografia per il flusso specificato.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se l'autenticazione è stata effettuata con esito positivo.</summary>
        <value>
          <see langword="true" /> se l'autenticazione è stata effettuata con esito positivo; in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eseguire l'autenticazione client mediante la chiamata di <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> o <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> metodi. Eseguire l'autenticazione server chiamando il <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> o <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metodi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsEncrypted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se la classe <see cref="T:System.Net.Security.SslStream" /> utilizza la crittografia dei dati.</summary>
        <value>
          <see langword="true" /> se i dati vengono crittografati prima di essere trasmessi in rete e decrittografati quando raggiungono l'endpoint remoto; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La crittografia consente di proteggere la privacy dei dati, vale a dire consente di verificare che mentre i dati sono in transito, non può essere decrittato da terze parti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsMutuallyAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se il client e il server sono stati entrambi autenticati.</summary>
        <value>
          <see langword="true" /> se il server è stato autenticato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'autenticazione reciproca viene specificato dal server quando il server eseguirà il client di fornire un certificato per l'autenticazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />
        <altmember cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsServer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se il lato locale della connessione utilizzato da questa classe <see cref="T:System.Net.Security.SslStream" /> è stato autenticato come il server.</summary>
        <value>
          <see langword="true" /> se l'endpoint locale è stato autenticato con esito positivo come lato server della connessione autenticata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'autenticazione non riuscita o non è stata eseguita, questa proprietà restituisce `false`.  
  
 Per eseguire l'autenticazione del server, chiamare il <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> o <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metodi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsSigned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Boolean" /> che indica se i dati inviati utilizzando questo flusso vengono firmati.</summary>
        <value>
          <see langword="true" /> se i dati vengono firmati prima di essere trasmessi; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dati firma consente di proteggere l'integrità dei dati, vale a dire consente il destinatario determinare se sono stati alterati i dati in transito.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeAlgorithm As ExchangeAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::ExchangeAlgorithmType KeyExchangeAlgorithm { System::Security::Authentication::ExchangeAlgorithmType get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExchangeAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'algoritmo di scambio delle chiavi utilizzato dalla classe <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Valore <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa proprietà è <xref:System.Security.Authentication.ExchangeAlgorithmType.None> finché non si verifica l'autenticazione.  
  
 L'algoritmo di scambio delle chiavi consente di proteggere le informazioni utilizzate per generare le chiavi condivise.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare le impostazioni di crittografia per il flusso specificato.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeStrength">
      <MemberSignature Language="C#" Value="public virtual int KeyExchangeStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeyExchangeStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeyExchangeStrength { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che identifica il livello dell'algoritmo di scambio delle chiavi utilizzato da questa istanza.</summary>
        <value>Valore <see cref="T:System.Int32" /> che specifica il livello dell'algoritmo <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" />, in bit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa proprietà è zero fino a quando non si verifica l'autenticazione.  
  
 Negli scenari comuni, il valore di questa proprietà è uno dei valori seguenti:  
  
-   512  
  
-   768  
  
-   1024  
  
-   2048  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare le impostazioni di crittografia per il flusso specificato.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la lunghezza del flusso sottostante.</summary>
        <value>Oggetto <see cref="T:System.Int64" />.  
  
 Lunghezza del flusso sottostante.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce il valore restituito richiamando <xref:System.IO.Stream.Length%2A> nel flusso sottostante. Se il flusso sottostante non è ricercabile, questo metodo genera un'eccezione in genere di un'eccezione. Il tipo di runtime del flusso sottostante determina il tipo di runtime dell'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il recupero del valore di questa proprietà non è supportato quando il flusso sottostante è una classe <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.LocalCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LocalCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ LocalCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.LocalCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il certificato utilizzato per autenticare l'endpoint locale.</summary>
        <value>Oggetto X509Certificate che rappresenta il certificato fornito per l'autenticazione o <see langword="null" /> se non è stato fornito alcun certificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il certificato restituito da questa proprietà.  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'autenticazione non è riuscita o non è stata effettuata.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegotiatedApplicationProtocol">
      <MemberSignature Language="C#" Value="public System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.NegotiatedApplicationProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NegotiatedApplicationProtocol As SslApplicationProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::SslApplicationProtocol NegotiatedApplicationProtocol { System::Net::Security::SslApplicationProtocol get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.SslApplicationProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la posizione corrente nel flusso sottostante.</summary>
        <value>Oggetto <see cref="T:System.Int64" />.  
  
 Posizione corrente all'interno del flusso sottostante.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce il valore restituito richiamando <xref:System.IO.Stream.Position%2A> nel flusso sottostante. Se il flusso sottostante non è ricercabile, questo metodo genera un'eccezione in genere di un'eccezione. Il tipo di runtime del flusso sottostante determina il tipo di runtime dell'eccezione generata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'impostazione di questa proprietà non è supportata.  
  
 oppure  
  
 Il recupero del valore di questa proprietà non è supportato quando il flusso sottostante è una classe <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Read(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice <see cref="T:System.Byte" /> che riceve i byte letti da questo flusso.</param>
        <param name="offset">Valore <see cref="T:System.Int32" /> contenente la posizione in base zero in <c>buffer</c> da cui iniziare l'archiviazione dei dati letti da questo flusso.</param>
        <param name="count">Valore <see cref="T:System.Int32" /> contenente il numero massimo di byte da leggere da questo flusso.</param>
        <summary>Legge i dati da questo flusso e li archivia nella matrice specificata.</summary>
        <returns>Valore <see cref="T:System.Int32" /> che specifica il numero di byte letti. Se non sono presenti altri dati da leggere, viene restituito 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo legge un numero massimo di `count` byte dal flusso e li archivia in `buffer` a partire da `offset`. È possibile eseguire più operazioni di lettura simultanee.  
  
 È possibile chiamare questo metodo fino a quando non è stata effettuata l'autenticazione. Per l'autenticazione di chiamare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, o <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metodi.  
  
 Per eseguire questa operazione in modo asincrono, utilizzare il <xref:System.Net.Security.SslStream.BeginRead%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata la lettura da un <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslClientSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#6)]
 [!code-csharp[NclSslClientSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; lunghezza di <paramref name="buffer" />.  
  
 oppure  
  
 <paramref name="offset" /> + conteggio &gt; lunghezza di <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">L'operazione di lettura non è riuscita. Verificare l'eccezione interna, se presente, per determinare la causa dell'errore.</exception>
        <exception cref="T:System.NotSupportedException">È già in corso un'operazione di lettura.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione non è stata effettuata.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.ReadTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'intervallo di tempo per il quale un'operazione di lettura si blocca in attesa dei dati.</summary>
        <value>Valore <see cref="T:System.Int32" /> che specifica l'intervallo di tempo che deve trascorrere prima che l'operazione di lettura generi un errore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce il valore restituito richiamando <xref:System.IO.Stream.ReadTimeout%2A> nel flusso sottostante. Quando si imposta questa proprietà, il <xref:System.IO.Stream.ReadTimeout%2A> nel flusso sottostante è impostato sul valore specificato.  
  
 Se il flusso sottostante è un <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.SslStream.ReadTimeout%2A> è espresso in millisecondi e viene impostato su <xref:System.Threading.Timeout.Infinite> per impostazione predefinita, in modo che le operazioni di lettura non timeout.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'impostazione del valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.RemoteCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ RemoteCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.RemoteCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il certificato utilizzato per autenticare l'endpoint remoto.</summary>
        <value>Oggetto X509Certificate che rappresenta il certificato fornito per l'autenticazione o <see langword="null" /> se non è stato fornito alcun certificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come visualizzare il certificato restituito da questa proprietà.  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'autenticazione non è riuscita o non è stata effettuata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Questo valore viene ignorato.</param>
        <param name="origin">Questo valore viene ignorato.</param>
        <summary>Genera un oggetto <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Genera sempre un'eccezione <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non chiamare questo metodo. Viene ereditato, ma non è supportato dalla <xref:System.Net.Security.SslStream> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La ricerca non è supportata dagli oggetti della classe <see cref="T:System.Net.Security.SslStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.SetLength(System.Int64)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valore <see cref="T:System.Int64" /> che specifica la lunghezza del flusso.</param>
        <summary>Imposta la lunghezza del flusso sottostante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo richiama <xref:System.IO.Stream.SetLength%2A?displayProperty=nameWithType> nel flusso sottostante specificato quando questo <xref:System.Net.Security.SslStream> è stato creato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task ShutdownAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task ShutdownAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.ShutdownAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ShutdownAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ ShutdownAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arresta questo oggetto SslStream.</summary>
        <returns>Oggetto dell'attività che rappresenta l'operazione asincrona.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SslProtocol">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.SslProtocols SslProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.SslProtocols SslProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.SslProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SslProtocol As SslProtocols" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::SslProtocols SslProtocol { System::Security::Authentication::SslProtocols get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.SslProtocol</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.SslProtocols</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica il certificato di sicurezza utilizzato per autenticare questa connessione.</summary>
        <value>Valore <see cref="T:System.Security.Authentication.SslProtocols" /> che rappresenta il protocollo utilizzato per l'autenticazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocolli di sicurezza supportati vengono specificati quando il <xref:System.Net.Security.SslStream> viene creato. Se nessun protocollo di sicurezza è stato passato al costruttore, l'istanza viene creata utilizzando <xref:System.Security.Authentication.SslProtocols.Default>. Il protocollo utilizzato per l'autenticazione viene selezionato in base ai protocolli supportati dal client e server.  
  
   
  
## Examples  
 Nell'esempio seguente vengono visualizzate le proprietà di sicurezza del flusso specificato.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.TransportContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Net.TransportContext" /> utilizzato per l'autenticazione tramite la protezione estesa.</summary>
        <value>Oggetto <see cref="T:System.Net.TransportContext" /> contenente il token di binding di canale (CBT, Channel Binding Token) utilizzato per la protezione estesa.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive dati in questo flusso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che fornisce i byte scritti nel flusso.</param>
        <summary>Scrive i dati specificati in questo flusso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si blocca durante il completamento dell'operazione. Per evitare il blocco di completamento dell'operazione, utilizzare il <xref:System.Net.Security.SslStream.BeginWrite%2A> metodo.  
  
 È possibile chiamare questo metodo fino a quando non è stata effettuata l'autenticazione. Per l'autenticazione di chiamare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, o <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metodi.  
  
 La <xref:System.Net.Security.SslStream> classe non supporta più operazioni di scrittura simultanee.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come la scrittura in un oggetto autenticato <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Operazione di scrittura non riuscita.</exception>
        <exception cref="T:System.NotSupportedException">È già in corso un'operazione di scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione non è stata effettuata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di <see cref="T:System.Byte" /> che fornisce i byte scritti nel flusso.</param>
        <param name="offset">Valore <see cref="T:System.Int32" /> contenente la posizione in base zero in <c>buffer</c> in corrispondenza della quale iniziare la lettura dei byte che devono essere scritti nel flusso.</param>
        <param name="count">Valore <see cref="T:System.Int32" /> contenente il numero di byte da leggere da <c>buffer</c>.</param>
        <summary>Consente di scrivere il numero specificato di <see cref="T:System.Byte" /> nel flusso sottostante, utilizzando il buffer e l'offset specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si blocca durante il completamento dell'operazione. Per evitare il blocco durante l'operazione di completamento dell'operazione, utilizzare il <xref:System.Net.Security.SslStream.BeginWrite%2A> metodo.  
  
 È possibile chiamare questo metodo fino a quando non è stata effettuata l'autenticazione. Per l'autenticazione di chiamare uno del <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, o <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metodi.  
  
 La <xref:System.Net.Security.SslStream> classe non supporta più operazioni di scrittura simultanee.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; lunghezza di <paramref name="buffer" />.  
  
 oppure  
  
 <paramref name="offset" /> + conteggio &gt; lunghezza di <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Operazione di scrittura non riuscita.</exception>
        <exception cref="T:System.NotSupportedException">È già in corso un'operazione di scrittura.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è stato chiuso.</exception>
        <exception cref="T:System.InvalidOperationException">L'autenticazione non è stata effettuata.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.WriteTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'intervallo di tempo durante il quale un'operazione di scrittura si blocca in attesa dei dati.</summary>
        <value>Valore <see cref="T:System.Int32" /> che specifica l'intervallo di tempo che deve trascorrere prima che l'operazione di scrittura sincrona generi un errore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce il valore restituito richiamando <xref:System.IO.Stream.WriteTimeout%2A> nel flusso sottostante. Per le operazioni set, imposta il valore specificato di <xref:System.IO.Stream.WriteTimeout%2A> valore nel flusso sottostante.  
  
 Se il flusso sottostante è un <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.SslStream.WriteTimeout%2A> è espresso in millisecondi e viene impostato su <xref:System.Threading.Timeout.Infinite> per impostazione predefinita, in modo che le operazioni di scrittura non di timeout.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'impostazione del valore di questa proprietà.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>