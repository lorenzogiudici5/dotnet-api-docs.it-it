<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1d09a8a36ecb9900234c91bab02a146b88a0f72a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36471954" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="b20a4-101">Rappresenta un numero complesso.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b20a4-101">Represents a complex number.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-102">Un numero complesso è un numero che comprende una parte numerica reale e una parte numerica immaginaria.</span><span class="sxs-lookup"><span data-stu-id="b20a4-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="b20a4-103">Z un numero complesso vengono in genere scritti nel formato z = x + yi, dove *x* e *y* sono i numeri reali, e *si* è l'unità immaginaria che dispone della proprietà *i* <sup>2</sup> = -1.</span><span class="sxs-lookup"><span data-stu-id="b20a4-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="b20a4-104">La parte reale del numero complesso è rappresentata da *x*, e la parte immaginaria del numero complesso è rappresentata da *y*.</span><span class="sxs-lookup"><span data-stu-id="b20a4-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="b20a4-105">Il <xref:System.Numerics.Complex> tipo viene usato il sistema di coordinate cartesiano (reale, immaginario) quando un'istanza e la modifica di numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="b20a4-106">Un numero complesso può essere rappresentato come un punto in un sistema di coordinate bidimensionale, che è noto come il piano complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="b20a4-107">La parte reale del numero complesso è posizionata sull'asse x (l'asse orizzontale) e la parte immaginaria è posizionata sull'asse y (l'asse verticale).</span><span class="sxs-lookup"><span data-stu-id="b20a4-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="b20a4-108">Qualsiasi punto del piano complesso può essere espresse anche in base al valore assoluto, utilizzando il grafico polare sistema di coordinate, In coordinate polari, un punto di distribuzione è caratterizzato da due numeri:</span><span class="sxs-lookup"><span data-stu-id="b20a4-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="b20a4-109">La grandezza che è la distanza tra il punto dall'origine (vale a dire, 0,0, o il punto in cui l'asse x e y si intersecano).</span><span class="sxs-lookup"><span data-stu-id="b20a4-109">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="b20a4-110">La fase, ovvero l'angolo tra l'asse reale e la riga disegnata dall'origine al punto.</span><span class="sxs-lookup"><span data-stu-id="b20a4-110">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="b20a4-111">Creazione di un numero complesso</span><span class="sxs-lookup"><span data-stu-id="b20a4-111">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="b20a4-112">È possibile assegnare un valore in un numero complesso in uno dei modi seguenti:</span><span class="sxs-lookup"><span data-stu-id="b20a4-112">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="b20a4-113">Passando due <xref:System.Double> valori al rispettivo costruttore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-113">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="b20a4-114">Il primo valore rappresenta la parte reale del numero complesso e il secondo valore rappresenta la parte immaginaria.</span><span class="sxs-lookup"><span data-stu-id="b20a4-114">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="b20a4-115">Questi valori rappresentano la posizione del numero complesso nel sistema di coordinate cartesiano bidimensionale.</span><span class="sxs-lookup"><span data-stu-id="b20a4-115">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="b20a4-116">Chiamando il metodo statico (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> i metodi per creare un numero complesso dalle coordinate polari.</span><span class="sxs-lookup"><span data-stu-id="b20a4-116">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="b20a4-117">Tramite l'assegnazione di un <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, o <xref:System.Double> valore a un <xref:System.Numerics.Complex> oggetto.</span><span class="sxs-lookup"><span data-stu-id="b20a4-117">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="b20a4-118">Il valore diventa la parte reale del numero complesso e la parte immaginaria è uguale a 0.</span><span class="sxs-lookup"><span data-stu-id="b20a4-118">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="b20a4-119">Per eseguire il cast (in c#) o la conversione (in Visual Basic) un <xref:System.Decimal> oppure <xref:System.Numerics.BigInteger> valore per un <xref:System.Numerics.Complex> oggetto.</span><span class="sxs-lookup"><span data-stu-id="b20a4-119">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="b20a4-120">Il valore diventa la parte reale del numero complesso e la parte immaginaria è uguale a 0.</span><span class="sxs-lookup"><span data-stu-id="b20a4-120">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="b20a4-121">Assegnando il numero complesso che viene restituito da un metodo o un operatore per un <xref:System.Numerics.Complex> oggetto.</span><span class="sxs-lookup"><span data-stu-id="b20a4-121">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="b20a4-122">Ad esempio <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> è un metodo statico che restituisce un numero complesso che è la somma di due numeri complessi, e il <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operatore aggiunge due numeri complessi e restituisce il risultato.</span><span class="sxs-lookup"><span data-stu-id="b20a4-122">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="b20a4-123">Nell'esempio seguente viene illustrata ciascuna di queste cinque modalità di assegnazione di un valore in un numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-123">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="b20a4-124">Operazioni con numeri complessi</span><span class="sxs-lookup"><span data-stu-id="b20a4-124">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="b20a4-125">Il <xref:System.Numerics.Complex> in .NET Framework che include i membri che forniscono le funzionalità seguenti:</span><span class="sxs-lookup"><span data-stu-id="b20a4-125">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="b20a4-126">Metodi per confrontare due numeri complessi per determinare se sono uguali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-126">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="b20a4-127">Operatori per eseguire operazioni aritmetiche su numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-127">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="b20a4-128"><xref:System.Numerics.Complex> gli operatori consentono di eseguire l'addizione, sottrazione, moltiplicazione, divisione e negazione unaria con numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-128"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="b20a4-129">Metodi per eseguire altre operazioni numeriche su numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-129">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="b20a4-130">Oltre i quattro operazioni aritmetiche di base, è possibile generare un numero complesso alla potenza specificata, trovare la radice quadrata di un numero complesso e ottenere il valore assoluto di un numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-130">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="b20a4-131">Metodi per eseguire operazioni trigonometriche su numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-131">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="b20a4-132">Ad esempio, è possibile calcolare la tangente dell'angolo rappresentato da un numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-132">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="b20a4-133">Si noti che, perché il <xref:System.Numerics.Complex.Real%2A> e <xref:System.Numerics.Complex.Imaginary%2A> delle proprietà sono di sola lettura, non è possibile modificare il valore di un oggetto esistente <xref:System.Numerics.Complex> oggetto.</span><span class="sxs-lookup"><span data-stu-id="b20a4-133">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="b20a4-134">Tutti i metodi che eseguono un'operazione in un <xref:System.Numerics.Complex> numero, se al relativo valore restituito è di tipo <xref:System.Numerics.Complex>, restituire un nuovo <xref:System.Numerics.Complex> numero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-134">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="b20a4-135">Precisione e numeri complessi</span><span class="sxs-lookup"><span data-stu-id="b20a4-135">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="b20a4-136">Le parti reali e immaginarie di un numero complesso sono rappresentate da due valori a virgola mobile a precisione doppia.</span><span class="sxs-lookup"><span data-stu-id="b20a4-136">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="b20a4-137">Ciò significa che <xref:System.Numerics.Complex> valori, come i valori a virgola mobile a precisione doppia, possano perdita di precisione in seguito a operazioni numeriche.</span><span class="sxs-lookup"><span data-stu-id="b20a4-137">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="b20a4-138">Ciò significa che strict confronti di uguaglianza di due <xref:System.Numerics.Complex> valori potrebbero non riuscire, anche se la differenza tra i due valori a causa di una perdita di precisione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-138">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="b20a4-139">Per ulteriori informazioni, vedere <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-139">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="b20a4-140">L'esecuzione di elevamento a potenza nella logaritmo di un numero, ad esempio, deve restituire il numero originale.</span><span class="sxs-lookup"><span data-stu-id="b20a4-140">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="b20a4-141">In alcuni casi, tuttavia, la perdita di precisione dei valori a virgola mobile può causare lievi differenze tra i due valori, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-141">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="b20a4-142">Analogamente, nell'esempio seguente, che calcola la radice quadrata di un <xref:System.Numerics.Complex> number, produce risultati leggermente diversi sulle 32 bit e IA64 versioni di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b20a4-142">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="b20a4-143">Numeri complessi, valori infiniti e NaN</span><span class="sxs-lookup"><span data-stu-id="b20a4-143">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="b20a4-144">Le parti reali e immaginarie di un numero complesso sono rappresentate da <xref:System.Double> valori.</span><span class="sxs-lookup"><span data-stu-id="b20a4-144">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="b20a4-145">Oltre a compreso <xref:System.Double.MinValue?displayProperty=nameWithType> al <xref:System.Double.MaxValue?displayProperty=nameWithType>, la parte reale o immaginaria di un numero complesso può avere un valore di <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-145">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b20a4-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, e <xref:System.Double.NaN?displayProperty=nameWithType> si propagano in qualsiasi operazione aritmetica o eseguire funzioni trigonometriche tutte.</span><span class="sxs-lookup"><span data-stu-id="b20a4-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="b20a4-147">Nell'esempio seguente, la divisione per <xref:System.Numerics.Complex.Zero> produce un numero complesso le cui parti reale e immaginarie vengono entrambi <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-147">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b20a4-148">Di conseguenza, l'esecuzione di moltiplicazione con questo valore genera inoltre un numero complesso le cui parti reale e immaginarie vengono <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-148">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b20a4-149">Analogamente, l'esecuzione di una moltiplicazione che supera l'intervallo del <xref:System.Double> tipo produce un numero complesso di cui parte reale <xref:System.Double.NaN?displayProperty=nameWithType> e la parte immaginaria è <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-149">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b20a4-150">Successivamente si esegue una divisione con questo numero complesso restituisce un numero complesso di cui parte reale <xref:System.Double.NaN?displayProperty=nameWithType> e la parte immaginaria è <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-150">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="b20a4-151">Operazioni matematiche con numeri complessi che non sono valide o che superano l'intervallo del <xref:System.Double> tipo di dati non generano un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-151">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="b20a4-152">Invece, restituiscono un <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType> nelle condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="b20a4-152">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="b20a4-153">La divisione di un numero positivo per zero restituisce <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-153">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b20a4-154">Qualsiasi operazione che supera il limite superiore di <xref:System.Double> tipo di dati restituisce <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-154">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b20a4-155">La divisione di un numero negativo per zero restituisce <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-155">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b20a4-156">Qualsiasi operazione che supera il limite inferiore del <xref:System.Double> tipo di dati restituisce <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-156">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b20a4-157">La divisione di uno zero per zero restituisce <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-157">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b20a4-158">Qualsiasi operazione che viene eseguita su operandi i cui valori sono <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType> restituisce <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType>, a seconda dell'operazione specifica.</span><span class="sxs-lookup"><span data-stu-id="b20a4-158">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="b20a4-159">Si noti che questo si applica a tutti i calcoli intermedi eseguiti da un metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-159">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="b20a4-160">Ad esempio, la moltiplicazione di `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` viene utilizzata la formula (ac - bd) + (ad + bc) è possibile.</span><span class="sxs-lookup"><span data-stu-id="b20a4-160">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="b20a4-161">Il calcolo del componente reale risultante dalla moltiplicazione valuta l'espressione 9e308 * versione 2.5 - 9e308 * 3.5.</span><span class="sxs-lookup"><span data-stu-id="b20a4-161">The calculation of the real component that results from the multiplication evaluates the expression 9e308 * 2.5 - 9e308 * 3.5.</span></span> <span data-ttu-id="b20a4-162">Ogni moltiplicazione intermedi in questa espressione restituisce <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>e il tentativo di sottrarre <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> da <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> restituisce <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-162">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="b20a4-163">Formattazione di un numero complesso</span><span class="sxs-lookup"><span data-stu-id="b20a4-163">Formatting a Complex Number</span></span>  
 <span data-ttu-id="b20a4-164">Per impostazione predefinita, la rappresentazione di stringa di un numero complesso assume il formato `(` *reale* `,` *immaginaria*`)`, dove *reale* e *immaginaria* sono rappresentazioni di stringa del <xref:System.Double> valori che costituiscono i componenti reale e immaginaria del numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-164">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="b20a4-165">Alcuni overload del <xref:System.Numerics.Complex.ToString%2A> metodo consentono la personalizzazione di rappresentazioni di stringa di questi <xref:System.Double> valori riflettono le convenzioni di formattazione di una lingua specifica oppure vengono visualizzati in un determinato formato definito da un valore numerico standard o personalizzato stringa di formato.</span><span class="sxs-lookup"><span data-stu-id="b20a4-165">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="b20a4-166">(Per altre informazioni, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="b20a4-166">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="b20a4-167">Uno dei modi più comuni di esprimere la rappresentazione di stringa di un numero complesso assume il formato a + bi, dove un componente reale del numero complesso e b è componente immaginario del numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-167">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="b20a4-168">In elettrotecnica, un numero complesso è in genere espresso come un + bj.</span><span class="sxs-lookup"><span data-stu-id="b20a4-168">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="b20a4-169">È possibile restituire la rappresentazione di stringa di un numero complesso in uno di questi due formati.</span><span class="sxs-lookup"><span data-stu-id="b20a4-169">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="b20a4-170">A tale scopo, definire un provider di formato personalizzato implementando il <xref:System.ICustomFormatter> e <xref:System.IFormatProvider> interfacce e quindi chiamare il <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-170">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b20a4-171">L'esempio seguente definisce un `ComplexFormatter` classe che rappresenta un numero complesso sotto forma di stringa in formato a + bi o + bj.</span><span class="sxs-lookup"><span data-stu-id="b20a4-171">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="b20a4-172">Nell'esempio seguente usa quindi il formattatore personalizzato per visualizzare la rappresentazione di stringa di un numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-172">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">
          <span data-ttu-id="b20a4-173">Parte reale del numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-173">The real part of the complex number.</span>
          </span>
        </param>
        <param name="imaginary">
          <span data-ttu-id="b20a4-174">Parte immaginaria del numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-174">The imaginary part of the complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-175">Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.Complex" /> usando i valori reali e immaginari specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-175">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-176">Il `real` oppure `imaginary` argomenti possono perdita di precisione se sono tipi di dati che richiedono un cast esplicito a <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-176">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-177">Nell'esempio seguente viene creata un'istanza di due numeri complessi e quindi utilizzati nelle operazioni di addizione, sottrazione, moltiplicazione e divisione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-177">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-178">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-178">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-179">Ottiene il valore assoluto (o grandezza) di un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-179">Gets the absolute value (or magnitude) of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-180">Valore assoluto di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-180">The absolute value of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-181">Il valore assoluto di un numero complesso è equivalente al relativo <xref:System.Numerics.Complex.Magnitude%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="b20a4-181">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="b20a4-182">Il valore assoluto di un numero reale un + bi viene calcolata come segue:</span><span class="sxs-lookup"><span data-stu-id="b20a4-182">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="b20a4-183">Se b = 0, il risultato è 0.</span><span class="sxs-lookup"><span data-stu-id="b20a4-183">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="b20a4-184">Se un > b, il risultato è un \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="b20a4-184">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="b20a4-185">Se b >, il risultato è b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 +<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="b20a4-185">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="b20a4-186">Se il calcolo del valore assoluto produce un overflow, il metodo restituisce <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-186">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b20a4-187">Se il <xref:System.Numerics.Complex.Real%2A> o <xref:System.Numerics.Complex.Imaginary%2A> è di proprietà <xref:System.Double.NaN?displayProperty=nameWithType> e l'altra proprietà non è né <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> né <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, il metodo restituisce <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-187">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-188">Nell'esempio seguente calcola il valore assoluto di un numero complesso e viene illustrato che è equivalente al valore del <xref:System.Numerics.Complex.Magnitude%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="b20a4-188">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-189">Numero complesso che rappresenta un coseno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-189">A complex number that represents a cosine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-190">Restituisce l'angolo che costituisce l'arcocoseno del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-190">Returns the angle that is the arc cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-191">Angolo espresso in radianti che costituisce l'arcocoseno di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-191">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-192">Il <xref:System.Numerics.Complex.Acos%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Acos%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-192">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b20a4-193">Il <xref:System.Numerics.Complex.Acos%2A> metodo utilizza la formula seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-193">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="b20a4-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="b20a4-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="b20a4-195">Nell'esempio seguente viene illustrato il <xref:System.Numerics.Complex.Acos%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-195">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="b20a4-196">Viene illustrato il valore restituito da tale passaggio il <xref:System.Numerics.Complex.Acos%2A> metodo per il <xref:System.Numerics.Complex.Cos%2A> metodo viene restituito originale <xref:System.Numerics.Complex> valore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-196">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b20a4-197">Primo numero complesso da sommare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-197">The first complex number to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b20a4-198">Secondo numero complesso da sommare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-198">The second complex number to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-199">Somma due numeri complessi e restituisce il risultato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-199">Adds two complex numbers and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-200">Somma di <paramref name="left" /> e <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-200">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-201">L'aggiunta di un oggetto complesso numero, a + bi, e un secondo numero complesso, c + di, assume il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-201">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b20a4-202">(a + c) + (b + d) è possibile.</span><span class="sxs-lookup"><span data-stu-id="b20a4-202">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="b20a4-203">Se il chiamata al metodo restituisce un overflow il componente immaginario o reale, il valore del componente può essere <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-203">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b20a4-204">I linguaggi che non supportano gli operatori personalizzati possono utilizzare il <xref:System.Numerics.Complex.Add%2A> metodo per eseguire l'addizione di numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-204">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-205">L'esempio seguente illustra l'addizione di numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-205">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-206">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-206">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-207">Restituisce l'angolo che costituisce l'arcoseno del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-207">Returns the angle that is the arc sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-208">Angolo che costituisce l'arcoseno di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-208">The angle which is the arc sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-209">Il <xref:System.Numerics.Complex.Asin%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Asin%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-209">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b20a4-210">Il <xref:System.Numerics.Complex.Asin%2A> metodo utilizza la formula seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-210">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="b20a4-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* valore + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -valore \* valore))</span><span class="sxs-lookup"><span data-stu-id="b20a4-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="b20a4-212">Nell'esempio seguente viene illustrato il <xref:System.Numerics.Complex.Asin%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-212">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="b20a4-213">Viene illustrato il valore restituito da tale passaggio il <xref:System.Numerics.Complex.Asin%2A> metodo per il <xref:System.Numerics.Complex.Sin%2A> metodo viene restituito originale <xref:System.Numerics.Complex> valore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-213">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-214">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-214">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-215">Restituisce l'angolo che costituisce l'arcotangente del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-215">Returns the angle that is the arc tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-216">Angolo che costituisce l'arcotangente di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-216">The angle that is the arc tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-217">Il <xref:System.Numerics.Complex.Atan%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Atan%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-217">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b20a4-218">Il <xref:System.Numerics.Complex.Atan%2A> metodo utilizza la formula seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-218">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="b20a4-219"><xref:System.Numerics.Complex.ImaginaryOne> / nuovo complesso (2.0, 0,0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* valore)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* valore)</span><span class="sxs-lookup"><span data-stu-id="b20a4-219"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="b20a4-220">Nell'esempio seguente viene illustrato il <xref:System.Numerics.Complex.Atan%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-220">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="b20a4-221">Viene illustrato il valore restituito da tale passaggio il <xref:System.Numerics.Complex.Atan%2A> metodo per il <xref:System.Numerics.Complex.Tan%2A> metodo viene restituito originale <xref:System.Numerics.Complex> valore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-221">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-222">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-222">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-223">Calcola il coniugato di un numero complesso e restituisce il risultato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-223">Computes the conjugate of a complex number and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-224">Coniugato di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-224">The conjugate of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-225">Il coniugato di un numero complesso inverte il segno del componente immaginario; vale a dire, negazione unaria viene applicato per il componente immaginario.</span><span class="sxs-lookup"><span data-stu-id="b20a4-225">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="b20a4-226">Se un + bi è un numero complesso, il relativo coniugato-bi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-226">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-227">L'esempio seguente mostra il coniugato di due numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-227">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-228">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-228">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-229">Restituisce il coseno del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-229">Returns the cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-230">Coseno di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-230">The cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-231">Il <xref:System.Numerics.Complex.Cos%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Cos%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-231">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b20a4-232">Il <xref:System.Numerics.Complex.Cos%2A> metodo utilizza la formula seguente per calcolare il coseno del numero complesso a + bi:</span><span class="sxs-lookup"><span data-stu-id="b20a4-232">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="b20a4-233">(<xref:System.Math.Cos%2A>() * <xref:System.Math.Cosh%2A>(b),-(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="b20a4-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-234">Nell'esempio seguente viene illustrato il <xref:System.Numerics.Complex.Acos%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-234">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="b20a4-235">Viene illustrato il valore restituito da tale passaggio il <xref:System.Numerics.Complex.Acos%2A> metodo per il <xref:System.Numerics.Complex.Cos%2A> metodo viene restituito originale <xref:System.Numerics.Complex> valore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-235">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-236">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-236">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-237">Restituisce il coseno iperbolico del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-237">Returns the hyperbolic cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-238">Coseno iperbolico di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-238">The hyperbolic cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-239">Il <xref:System.Numerics.Complex.Cosh%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Cosh%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-239">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b20a4-240">Il <xref:System.Numerics.Complex.Cosh%2A> metodo utilizza la formula seguente per calcolare il coseno iperbolico del numero complesso a + bi:</span><span class="sxs-lookup"><span data-stu-id="b20a4-240">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="b20a4-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="b20a4-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">
          <span data-ttu-id="b20a4-242">Numero complesso da dividere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-242">The complex number to be divided.</span>
          </span>
        </param>
        <param name="divisor">
          <span data-ttu-id="b20a4-243">Numero complesso per cui dividere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-243">The complex number to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-244">Divide un numero complesso per un altro e restituisce il risultato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-244">Divides one complex number by another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-245">Quoziente della divisione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-245">The quotient of the division.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-246">La divisione di un numero complesso, un + bi da un secondo numero complesso, numero, c + di, assume il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-246">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b20a4-247">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) è possibile</span><span class="sxs-lookup"><span data-stu-id="b20a4-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="b20a4-248">Se il calcolo del quoziente provoca un overflow il componente immaginario o reale, il valore di tale componente è uno <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-248">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b20a4-249">Il <xref:System.Numerics.Complex.Divide%2A> metodo può essere utilizzato dai linguaggi che non supportano gli operatori personalizzati.</span><span class="sxs-lookup"><span data-stu-id="b20a4-249">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="b20a4-250">Il comportamento è identico alla divisione utilizzando l'operatore di divisione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-250">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-251">Nell'esempio seguente divide un numero complesso per ogni elemento in una matrice di numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-251">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-252">Restituisce un valore che indica se due numeri complessi sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-252">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-253">Numero complesso da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-253">The complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-254">Restituisce un valore che indica se l'istanza corrente e un numero complesso specificato hanno lo stesso valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-254">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-255">
            <see langword="true" /> se questo numero complesso e <paramref name="value" /> presentano lo stesso valore. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-255">
              <see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-256">Il <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodo fornisce le <xref:System.IEquatable%601> implementazione per il <xref:System.Numerics.Complex> struttura.</span><span class="sxs-lookup"><span data-stu-id="b20a4-256">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="b20a4-257">Esegue leggermente migliore <xref:System.Numerics.Complex.Equals%28System.Object%29> metodo perché non è necessario convertire il parametro in un numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-257">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="b20a4-258">Due numeri complessi sono uguali se le parti reali sono uguali e quelle immaginarie sono uguali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-258">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="b20a4-259">Il <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodo è equivalente all'espressione seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-259">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="b20a4-260">
            <para>Utilizzare il <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> metodo con cautela, poiché i due valori che sono apparentemente equivalenti possono essere considerati non uguali a causa della diversa precisione dei relativi componenti reali e immaginarie. L'esempio seguente segnala che <c>(3.33333, 0.142857)</c> e <c>(10/3, 1/7)</c> non sono uguali.  [! code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  Si consiglia di adottare tecnica consiste nel definire un margine accettabile di differenza tra i due valori (ad esempio. 01% di uno dei componenti reali e immaginarie i valori) anziché confrontando i valori per verificarne l'uguaglianza. Se il valore assoluto della differenza tra i due valori è minore o uguale a margine, la differenza è probabile che sia dovuto a differenze di precisione e, pertanto, i valori sono probabile che siano uguali. L'esempio seguente usa questa tecnica per confrontare i due valori complessi che precedente esempio di codice trovato venga fatta. Trova i due numeri complessi siano uguali.  [! code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-260">
              <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.  [!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal. The following example uses this technique to compare the two complex values that the previous code example found to be unequal. It finds the two complex numbers to be equal.  [!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="b20a4-261">Oggetto da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-261">The object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-262">Restituisce un valore che indica se l'istanza corrente e un oggetto specificato hanno lo stesso valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-262">Returns a value that indicates whether the current instance and a specified object have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-263">
            <see langword="true" /> se il parametro <paramref name="obj" /> è un oggetto <see cref="T:System.Numerics.Complex" /> o un tipo in grado di eseguire la conversione implicita in un oggetto <see cref="T:System.Numerics.Complex" /> e il relativo valore è uguale all'oggetto <see cref="T:System.Numerics.Complex" /> corrente. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-263">
              <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-264">Due numeri complessi sono uguali se le parti reali sono uguali e quelle immaginarie sono uguali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-264">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="b20a4-265">Il <xref:System.Numerics.Complex.Equals%28System.Object%29> metodo è equivalente all'espressione seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-265">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="b20a4-266">Se il `obj` parametro non è un <xref:System.Numerics.Complex> oggetto, ma è un tipo di dati per cui è definita una conversione implicita, il <xref:System.Numerics.Complex.Equals%28System.Object%29> metodo converte `obj` a un <xref:System.Numerics.Complex> oggetto la cui parte reale è uguale al valore di `obj`e la parte immaginaria è uguale a zero prima di eseguire il confronto.</span><span class="sxs-lookup"><span data-stu-id="b20a4-266">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="b20a4-267">Nell'esempio seguente questa condizione è illustrata mediante la ricerca di un numero complesso e un valore a virgola mobile a precisione doppia sono uguali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-267">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="b20a4-268">
            <para>Utilizzare il <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> metodo con cautela, poiché i due valori che sono apparentemente equivalenti possono essere considerati non uguali a causa della diversa precisione dei relativi componenti reali e immaginarie. Il problema può essere accentuato se <paramref name="obj" /> deve essere convertito in un <see cref="T:System.Double" /> prima di eseguire il confronto. L'esempio seguente confronta un numero complesso il cui componente reale sembra essere uguale a un <see cref="T:System.Single" /> valore con cui <see cref="T:System.Single" /> valore. Come illustrato nell'output, il confronto di uguaglianza restituisce <see langword="False" />.  [! code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  Si consiglia di adottare tecnica consiste nel definire un margine accettabile di differenza tra i due valori (ad esempio. 01% di uno dei componenti reali e immaginarie i valori) anziché confrontando i valori per verificarne l'uguaglianza. Se il valore assoluto della differenza tra i due valori è minore o uguale a margine, la differenza è probabilmente a causa di differenze di precisione e, pertanto, i valori sono probabile che siano uguali. L'esempio seguente usa questa tecnica per confrontare i due valori presenti nell'esempio di codice precedente venga fatta. Li trova ora siano uguali.  [! code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-268">
              <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison. The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value. As the output shows, the comparison for equality returns <see langword="False" />.  [!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal. The following example uses this technique to compare the two values that the previous code example found to be unequal. It now finds them to be equal.  [!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-269">Numero complesso che specifica una potenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-269">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-270">Restituisce <see langword="e" /> elevato alla potenza specificata da un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-270">Returns <see langword="e" /> raised to the power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-271">Numero <see langword="e" /> elevato alla potenza <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-271">The number <see langword="e" /> raised to the power <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-272">Utilizzare il <xref:System.Numerics.Complex.Pow%2A> metodo per calcolare le potenze di basi di altri.</span><span class="sxs-lookup"><span data-stu-id="b20a4-272">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="b20a4-273">Il <xref:System.Numerics.Complex.Exp%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Exp%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-273">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="b20a4-274"><xref:System.Numerics.Complex.Exp%2A> è l'inverso del <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-274"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-275">Nell'esempio seguente viene illustrato il <xref:System.Numerics.Complex.Exp%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-275">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="b20a4-276">Mostra che, con alcune concesso per la mancanza di precisione del <xref:System.Double> tipo di dati, passando il valore restituito dal <xref:System.Numerics.Complex.Log%2A> metodo per il <xref:System.Numerics.Complex.Exp%2A> metodo viene restituito originale <xref:System.Numerics.Complex> valore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-276">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">
          <span data-ttu-id="b20a4-277">La grandezza che è la distanza dall'origine (l'intersezione dell'asse x con l'asse y) al numero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-277">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span>
          </span>
        </param>
        <param name="phase">
          <span data-ttu-id="b20a4-278">La fase che è l'angolo dalla riga all'asse orizzontale, espresso nei radianti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-278">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-279">Crea un numero complesso dalle coordinate polari di un punto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-279">Creates a complex number from a point's polar coordinates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-280">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-280">A complex number.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-281">Il <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodo crea un'istanza di un numero complesso in base alle coordinate polari.</span><span class="sxs-lookup"><span data-stu-id="b20a4-281">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="b20a4-282">Poiché non esistono più rappresentazioni di un punto su un piano complesso, il valore restituito del <xref:System.Numerics.Complex.FromPolarCoordinates%2A> è normalizzato secondo metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-282">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="b20a4-283">La grandezza viene normalizzata su un numero positivo e la fase viene normalizzata su un valore compreso nell'intervallo -<xref:System.Math.PI> a <xref:System.Math.PI>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-283">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="b20a4-284">Di conseguenza, i valori del <xref:System.Numerics.Complex.Phase%2A> e <xref:System.Numerics.Complex.Magnitude%2A> delle proprietà del numero complesso risulta potrebbero non essere uguali i valori originali del `magnitude` e `phase` parametri.</span><span class="sxs-lookup"><span data-stu-id="b20a4-284">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="b20a4-285">Per convertire un valore i gradi in radianti per il `phase` parametro, moltiplicarlo per  <xref:System.Math.PI?displayProperty=nameWithType> /180.</span><span class="sxs-lookup"><span data-stu-id="b20a4-285">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-286">Nell'esempio seguente viene utilizzata la <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodo per creare un'istanza di un numero complesso in base alle coordinate polari e quindi Visualizza il valore della relativa <xref:System.Numerics.Complex.Magnitude%2A> e <xref:System.Numerics.Complex.Phase%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="b20a4-286">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-287">Restituisce il codice hash per l'oggetto <see cref="T:System.Numerics.Complex" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-287">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-288">Codice hash di un intero con segno a 32 bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-288">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-289">Ottiene il componente immaginario dell'oggetto <see cref="T:System.Numerics.Complex" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-289">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b20a4-290">Componente immaginario di un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-290">The imaginary component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-291">Dato un numero complesso a + bi, <xref:System.Numerics.Complex.Imaginary%2A> proprietà restituisce il valore di b.</span><span class="sxs-lookup"><span data-stu-id="b20a4-291">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-292">Nell'esempio seguente viene creata un'istanza di una matrice di <xref:System.Numerics.Complex> oggetti e visualizza i componenti reali e immaginari di ciascuno di essi in forma a + bi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-292">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-293">Restituisce una nuova istanza di <see cref="T:System.Numerics.Complex" /> con un numero reale uguale a zero e un numero immaginario uguale a uno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-293">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b20a4-294">Nell'esempio seguente crea un <xref:System.Numerics.Complex> valore utilizzando il <xref:System.Numerics.Complex.ImaginaryOne> proprietà.</span><span class="sxs-lookup"><span data-stu-id="b20a4-294">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="b20a4-295">Consente quindi di confrontare questo valore su un altro valore che viene creata un'istanza chiamando il <xref:System.Numerics.Complex> costruttore con una parte reale uguale a zero e una parte immaginaria uguale a uno.</span><span class="sxs-lookup"><span data-stu-id="b20a4-295">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="b20a4-296">Come illustrato nell'output dell'esempio, i due valori sono uguali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-296">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-297">Restituisce il logaritmo di un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-297">Returns the logarithm of a complex number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-298">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-298">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-299">Restituisce <see langword="e" />, la base del logaritmo naturale del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-299">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-300">Logaritmo naturale (base <see langword="e" />) di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-300">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-301">Il <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> metodo per i numeri complessi corrisponde alla <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-301">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-302">Nell'esempio seguente viene illustrato il <xref:System.Numerics.Complex.Log%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-302">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="b20a4-303">Mostra che, con alcune concesso per la mancanza di precisione del <xref:System.Double> tipo di dati, passando il valore restituito dal <xref:System.Numerics.Complex.Log%2A> metodo per il <xref:System.Numerics.Complex.Exp%2A> metodo viene restituito originale <xref:System.Numerics.Complex> valore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-303">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-304">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-304">A complex number.</span>
          </span>
        </param>
        <param name="baseValue">
          <span data-ttu-id="b20a4-305">Base del logaritmo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-305">The base of the logarithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-306">Restituisce il logaritmo del numero complesso specificato nella base specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-306">Returns the logarithm of a specified complex number in a specified base.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-307">Logaritmo di <paramref name="value" /> in base <paramref name="baseValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-307">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-308">Il <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> metodo per i numeri complessi corrisponde alla <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-308">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-309">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-309">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-310">Restituisce il logaritmo in base 10 del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-310">Returns the base-10 logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-311">Logaritmo in base 10 di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-311">The base-10 logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-312">Il <xref:System.Numerics.Complex.Log10%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Log10%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-312">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-313">Ottiene la grandezza (o valore assoluto) di un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-313">Gets the magnitude (or absolute value) of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b20a4-314">Grandezza dell'istanza corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-314">The magnitude of the current instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-315">Il <xref:System.Numerics.Complex.Magnitude%2A> proprietà è equivalente al valore assoluto di un numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-315">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="b20a4-316">Specifica la distanza dall'origine (l'intersezione dell'asse x e y nel sistema di coordinate cartesiano) per il punto bidimensionale rappresentato da un numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-316">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="b20a4-317">Il valore assoluto viene calcolato come segue:</span><span class="sxs-lookup"><span data-stu-id="b20a4-317">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="b20a4-318">&#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(un * un + b * b)</span><span class="sxs-lookup"><span data-stu-id="b20a4-318">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span></span>  
  
 <span data-ttu-id="b20a4-319">Se il calcolo del valore assoluto produce un overflow, questa proprietà restituisce <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-319">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b20a4-320">Il <xref:System.Numerics.Complex.Magnitude%2A> e il <xref:System.Numerics.Complex.Phase%2A> proprietà definiscono la posizione di un punto che rappresenta un numero complesso nel sistema di coordinate polari.</span><span class="sxs-lookup"><span data-stu-id="b20a4-320">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="b20a4-321">È possibile creare un'istanza di un numero complesso basato su coordinate polari anziché le coordinate Cartesiane chiamando il <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-321">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-322">Nell'esempio seguente calcola il valore assoluto di un numero complesso e viene illustrato che è equivalente al valore del <xref:System.Numerics.Complex.Magnitude%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="b20a4-322">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b20a4-323">Primo numero complesso da moltiplicare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-323">The first complex number to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b20a4-324">Secondo numero complesso da moltiplicare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-324">The second complex number to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-325">Restituisce il prodotto di due numeri complessi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-325">Returns the product of two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-326">Prodotto dei parametri <paramref name="left" /> e <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-326">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-327">La moltiplicazione di un oggetto complesso numero, a + bi, e un secondo numero complesso, c + di, assume il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-327">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b20a4-328">(ac - bd) + (ad + bc) è possibile</span><span class="sxs-lookup"><span data-stu-id="b20a4-328">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="b20a4-329">Se la moltiplicazione produce un overflow nel componente immaginario o reale, il valore di tale componente è uno <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-329">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b20a4-330">Il <xref:System.Numerics.Complex.Multiply%2A> metodo viene implementato per lingue che non supportano gli operatori personalizzati.</span><span class="sxs-lookup"><span data-stu-id="b20a4-330">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="b20a4-331">Il comportamento è identico alla moltiplicazione utilizzando l'operatore di moltiplicazione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-331">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-332">Nell'esempio seguente moltiplicato un numero complesso da ogni elemento in una matrice di numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-332">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-333">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-333">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-334">Restituisce l'inverso additivo di un numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-334">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-335">Risultato dei componenti <see cref="P:System.Numerics.Complex.Real" /> e <see cref="P:System.Numerics.Complex.Imaginary" /> del parametro <paramref name="value" /> moltiplicato per -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-335">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-336">L'inverso additivo di un numero complesso è un numero complesso che produce un valore di <xref:System.Numerics.Complex> quando questo viene aggiunto per il numero complesso originale.</span><span class="sxs-lookup"><span data-stu-id="b20a4-336">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="b20a4-337">Questo metodo restituisce un numero complesso in cui i componenti reali e immaginari del numero complesso originale vengono moltiplicati per -1.</span><span class="sxs-lookup"><span data-stu-id="b20a4-337">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="b20a4-338">Il <xref:System.Numerics.Complex.Negate%2A> metodo viene implementato per lingue che non supportano gli operatori personalizzati.</span><span class="sxs-lookup"><span data-stu-id="b20a4-338">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="b20a4-339">Il comportamento è identico alla negazione utilizzando l'operatore di negazione unario, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-339">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-340">Nell'esempio seguente si ottiene l'inverso additivo di ogni elemento nella matrice di numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-340">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-341">Restituisce una nuova istanza di <see cref="T:System.Numerics.Complex" /> con un numero reale uguale a uno e un numero immaginario uguale a zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-341">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b20a4-342">Nell'esempio seguente crea un <xref:System.Numerics.Complex> valore utilizzando il <xref:System.Numerics.Complex.One> proprietà.</span><span class="sxs-lookup"><span data-stu-id="b20a4-342">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="b20a4-343">Consente quindi di confrontare questo valore su un altro valore che viene creata un'istanza chiamando il <xref:System.Numerics.Complex> costruttore con una parte reale uguale a uno e una parte immaginaria uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-343">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="b20a4-344">Come illustrato nell'output dell'esempio, i due valori sono uguali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-344">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b20a4-345">Primo valore da sommare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-345">The first value to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b20a4-346">Secondo valore da sommare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-346">The second value to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-347">Somma due numeri complessi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-347">Adds two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-348">Somma di <paramref name="left" /> e <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-348">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-349">Il <xref:System.Numerics.Complex.op_Addition%2A> metodo consente di definire l'operazione di addizione per numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-349">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="b20a4-350">Permette inoltre il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-350">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="b20a4-351">L'aggiunta di un oggetto complesso numero, a + bi, e un secondo numero complesso, c + di, assume il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-351">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b20a4-352">(a + c) + (b + d) è possibile</span><span class="sxs-lookup"><span data-stu-id="b20a4-352">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="b20a4-353">Se il chiamata al metodo restituisce un overflow il componente immaginario o reale, il valore di tale componente può essere <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-353">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b20a4-354">Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.Complex.Add%2A> metodo invece.</span><span class="sxs-lookup"><span data-stu-id="b20a4-354">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="b20a4-355">Il metodo equivalente per l'operatore è <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b20a4-355">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="b20a4-356">L'esempio seguente illustra l'addizione di numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-356">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b20a4-357">Valore da dividere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-357">The value to be divided.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b20a4-358">Valore per cui dividere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-358">The value to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-359">Divide un numero complesso specificato per un altro numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-359">Divides a specified complex number by another specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-360">Risultato della divisione di <paramref name="left" /> in base a <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-360">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-361">Il <xref:System.Numerics.Complex.op_Division%2A> metodo consente di definire l'operazione di divisione per numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-361">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="b20a4-362">Permette inoltre il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-362">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="b20a4-363">La divisione di un oggetto complesso numero, a + bi, e un secondo numero complesso, c + di, assume il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-363">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b20a4-364">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) è possibile</span><span class="sxs-lookup"><span data-stu-id="b20a4-364">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="b20a4-365">Se la divisione produce un overflow nel componente immaginario o reale, il valore di tale componente è uno <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-365">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b20a4-366">Linguaggi che non supportano gli operatori personalizzati e l'overload degli operatori possono chiamare il <xref:System.Numerics.Complex.Divide%2A> metodo invece.</span><span class="sxs-lookup"><span data-stu-id="b20a4-366">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="b20a4-367">Il metodo equivalente per l'operatore è <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b20a4-367">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b20a4-368">Primo numero complesso da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-368">The first complex number to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b20a4-369">Secondo numero complesso da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-369">The second complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-370">Restituisce un valore che indica se due numeri complessi sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-370">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-371">
            <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-371">
              <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-372">Il <xref:System.Numerics.Complex.op_Equality%2A> metodo definisce il funzionamento dell'operatore di uguaglianza per <xref:System.Numerics.Complex> valori.</span><span class="sxs-lookup"><span data-stu-id="b20a4-372">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="b20a4-373">Permette inoltre il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-373">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="b20a4-374">Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodo invece.</span><span class="sxs-lookup"><span data-stu-id="b20a4-374">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="b20a4-375">Due numeri complessi sono uguali se le parti reali sono uguali e quelle immaginarie sono uguali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-375">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="b20a4-376">Il <xref:System.Numerics.Complex.op_Equality%2A> metodo è equivalente all'espressione seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-376">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="b20a4-377">Si noti che, a causa delle differenze nella precisione, due numeri complessi apparentemente equivalenti possono essere considerati non uguali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-377">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="b20a4-378">Per ulteriori informazioni e una possibile soluzione alternativa, vedere il <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-378">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="b20a4-379">Il metodo equivalente per l'operatore è <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b20a4-379">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-380">Definisce una conversione esplicita tra un oggetto <see cref="T:System.Numerics.Complex" /> e un altro tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-380">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-381">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-381">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-382">Definisce una conversione esplicita di un valore <see cref="T:System.Decimal" /> in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-382">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-383">Numero complesso contenente un componente reale uguale a <paramref name="value" /> e un componente immaginario uguale a zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-383">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-384">Operatori di conversione espliciti definiscono i tipi che possono essere convertiti in un <xref:System.Numerics.Complex> oggetto.</span><span class="sxs-lookup"><span data-stu-id="b20a4-384">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="b20a4-385">I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati.</span><span class="sxs-lookup"><span data-stu-id="b20a4-385">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="b20a4-386">Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` in Visual Basic) viene utilizzato.</span><span class="sxs-lookup"><span data-stu-id="b20a4-386">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="b20a4-387">Verranno inoltre visualizzati in caso contrario, un errore del compilatore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-387">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="b20a4-388">La conversione di un <xref:System.Decimal> valore per la parte reale di un numero complesso può comportare una perdita di precisione perché un <xref:System.Double>, ovvero il tipo del numero complesso <xref:System.Numerics.Complex.Real%2A> proprietà, ha meno cifre significative di un <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-388">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="b20a4-389">Nell'esempio seguente viene illustrata la conversione esplicita di <xref:System.Decimal> valori <xref:System.Numerics.Complex> valori.</span><span class="sxs-lookup"><span data-stu-id="b20a4-389">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-390">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-390">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-391">Definisce una conversione esplicita di un valore <see cref="T:System.Numerics.BigInteger" /> in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-391">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-392">Numero complesso contenente un componente reale uguale a <paramref name="value" /> e un componente immaginario uguale a zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-392">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-393">Operatori di conversione espliciti definiscono i tipi che possono essere convertiti in un <xref:System.Numerics.Complex> oggetto.</span><span class="sxs-lookup"><span data-stu-id="b20a4-393">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="b20a4-394">I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati.</span><span class="sxs-lookup"><span data-stu-id="b20a4-394">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="b20a4-395">Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` in Visual Basic) viene utilizzato.</span><span class="sxs-lookup"><span data-stu-id="b20a4-395">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="b20a4-396">Verranno inoltre visualizzati in caso contrario, un errore del compilatore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-396">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="b20a4-397">La conversione di un <xref:System.Numerics.BigInteger> valore per la parte reale di un numero complesso può comportare una perdita di precisione perché un <xref:System.Double>, ovvero il tipo del numero complesso <xref:System.Numerics.Complex.Real%2A> proprietà, ha meno cifre significative di un <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-397">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="b20a4-398">Se la conversione ha esito negativo perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Double> tipo, l'operazione non genera un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-398">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="b20a4-399">Al contrario, se `value` è minore <xref:System.Double.MinValue>, il risultato è un numero complesso con un <xref:System.Numerics.Complex.Real%2A> uguale al valore della proprietà <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-399">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="b20a4-400">Se `value` è maggiore <xref:System.Double.MaxValue>, il risultato è un numero complesso con un <xref:System.Numerics.Complex.Real%2A> uguale al valore della proprietà <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-400">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="b20a4-401">Nell'esempio seguente viene illustrata la conversione esplicita di <xref:System.Numerics.BigInteger> valori <xref:System.Numerics.Complex> valori.</span><span class="sxs-lookup"><span data-stu-id="b20a4-401">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-402">Definisce una conversione implicita tra un oggetto <see cref="T:System.Numerics.Complex" /> e un altro tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-402">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-403">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-403">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-404">Definisce una conversione implicita di un byte senza segno in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-404">Defines an implicit conversion of an unsigned byte to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-405">Oggetto contenente il valore del parametro <paramref name="value" /> come parte reale e zero come parte immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-405">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-406">Gli overload del <xref:System.Numerics.Complex.op_Implicit%2A> operatore di definire i tipi da cui un compilatore può convertire automaticamente un <xref:System.Numerics.Complex> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b20a4-406">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b20a4-407">Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-407">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b20a4-408">Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Byte> valore in un numero complesso, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-408">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="b20a4-409">Si noti che il risultato della conversione è un numero complesso di cui parte reale uguale al <xref:System.Byte> valore e la parte immaginaria è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-409">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-410">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-410">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-411">Definisce una conversione implicita di un numero a virgola mobile a precisione doppia in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-411">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-412">Oggetto contenente il valore del parametro <paramref name="value" /> come parte reale e zero come parte immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-412">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-413">Gli overload del <xref:System.Numerics.Complex.op_Implicit%2A> operatore di definire i tipi da cui un compilatore può convertire automaticamente un <xref:System.Numerics.Complex> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b20a4-413">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b20a4-414">Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-414">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b20a4-415">Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Double> valore in un numero complesso, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-415">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="b20a4-416">Si noti che il risultato della conversione è un numero complesso di cui parte reale uguale al <xref:System.Double> valore e la parte immaginaria è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-416">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-417">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-417">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-418">Definisce una conversione implicita di un intero con segno a 16 bit in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-418">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-419">Oggetto contenente il valore del parametro <paramref name="value" /> come parte reale e zero come parte immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-419">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-420">Gli overload del <xref:System.Numerics.Complex.op_Implicit%2A> operatore di definire i tipi da cui un compilatore può convertire automaticamente un <xref:System.Numerics.Complex> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b20a4-420">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b20a4-421">Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-421">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b20a4-422">Questo overload consente al compilatore di gestire le conversioni da un intero con segno a 16 bit in un numero complesso, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-422">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b20a4-423">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale a signed integer a 16 bit e la parte immaginaria è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-423">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-424">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-424">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-425">Definisce una conversione implicita di un Intero con segno a 32 bit in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-425">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-426">Oggetto contenente il valore del parametro <paramref name="value" /> come parte reale e zero come parte immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-426">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-427">Gli overload del <xref:System.Numerics.Complex.op_Implicit%2A> operatore di definire i tipi da cui un compilatore può convertire automaticamente un <xref:System.Numerics.Complex> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b20a4-427">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b20a4-428">Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-428">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b20a4-429">Questo overload consente al compilatore di gestire le conversioni da un intero con segno a 32 bit in un numero complesso, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-429">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b20a4-430">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale a signed integer a 32 bit e la parte immaginaria è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-430">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-431">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-431">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-432">Definisce una conversione implicita di un Intero con segno a 64 bit in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-432">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-433">Oggetto contenente il valore del parametro <paramref name="value" /> come parte reale e zero come parte immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-433">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-434">Gli overload del <xref:System.Numerics.Complex.op_Implicit%2A> operatore di definire i tipi da cui un compilatore può convertire automaticamente un <xref:System.Numerics.Complex> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b20a4-434">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b20a4-435">Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-435">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b20a4-436">Questo overload consente al compilatore di gestire le conversioni da un intero con segno a 64 bit in un numero complesso, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-436">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b20a4-437">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale a signed integer a 64 bit e la parte immaginaria è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-437">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-438">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-438">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-439">Definisce una conversione implicita di un byte con segno in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-439">Defines an implicit conversion of a signed byte to a complex number.</span>
          </span>
          <span data-ttu-id="b20a4-440">Questa API non è conforme a CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-440">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-441">Oggetto contenente il valore del parametro <paramref name="value" /> come parte reale e zero come parte immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-441">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-442">Gli overload del <xref:System.Numerics.Complex.op_Implicit%2A> operatore di definire i tipi da cui un compilatore può convertire automaticamente un <xref:System.Numerics.Complex> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b20a4-442">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b20a4-443">Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-443">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b20a4-444">Questo overload consente al compilatore di gestire le conversioni da un byte con segno in un numero complesso, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-444">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="b20a4-445">Si noti che il risultato della conversione è un numero complesso è uguale al byte con segno la cui parte reale e immaginaria è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-445">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-446">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-446">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-447">Definisce una conversione implicita di un numero a virgola mobile a precisione singola in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-447">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-448">Oggetto contenente il valore del parametro <paramref name="value" /> come parte reale e zero come parte immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-448">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-449">Gli overload del <xref:System.Numerics.Complex.op_Implicit%2A> operatore di definire i tipi da cui un compilatore può convertire automaticamente un <xref:System.Numerics.Complex> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b20a4-449">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b20a4-450">Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-450">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b20a4-451">Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Single> valore in un numero complesso, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-451">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="b20a4-452">Si noti che il risultato della conversione è un numero complesso di cui parte reale uguale al <xref:System.Single> valore e la parte immaginaria è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-452">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-453">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-453">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-454">Definisce una conversione implicita di un intero senza segno a 16 bit in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-454">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="b20a4-455">Questa API non è conforme a CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-455">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-456">Oggetto contenente il valore del parametro <paramref name="value" /> come parte reale e zero come parte immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-456">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-457">Gli overload del <xref:System.Numerics.Complex.op_Implicit%2A> operatore di definire i tipi da cui un compilatore può convertire automaticamente un <xref:System.Numerics.Complex> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b20a4-457">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b20a4-458">Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-458">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b20a4-459">Questo overload consente al compilatore di gestire le conversioni da un intero senza segno a 16 bit in un numero complesso, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-459">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b20a4-460">Si noti che il risultato della conversione è un numero complesso il cui parte reale uguale intero senza segno a 16 bit e la parte immaginaria è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-460">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-461">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-461">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-462">Definisce una conversione implicita di un intero senza segno a 32 bit in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-462">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="b20a4-463">Questa API non è conforme a CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-463">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-464">Oggetto contenente il valore del parametro <paramref name="value" /> come parte reale e zero come parte immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-464">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-465">Gli overload del <xref:System.Numerics.Complex.op_Implicit%2A> operatore di definire i tipi da cui un compilatore può convertire automaticamente un <xref:System.Numerics.Complex> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b20a4-465">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b20a4-466">Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-466">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b20a4-467">Questo overload consente al compilatore di gestire le conversioni da un intero senza segno a 32 bit in un numero complesso, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-467">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b20a4-468">Si noti che il risultato della conversione è un numero complesso il cui parte reale uguale intero senza segno a 32 bit e la parte immaginaria è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-468">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-469">Valore da convertire in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-469">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-470">Definisce una conversione implicita di un intero senza segno a 64 bit in un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-470">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="b20a4-471">Questa API non è conforme a CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-471">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-472">Oggetto contenente il valore del parametro <paramref name="value" /> come parte reale e zero come parte immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-472">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-473">Gli overload del <xref:System.Numerics.Complex.op_Implicit%2A> operatore di definire i tipi da cui un compilatore può convertire automaticamente un <xref:System.Numerics.Complex> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b20a4-473">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b20a4-474">Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-474">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b20a4-475">Questo overload consente al compilatore di gestire le conversioni da un intero senza segno a 64 bit in un numero complesso, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="b20a4-475">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b20a4-476">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale all'intero senza segno a 64 bit e la parte immaginaria è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-476">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b20a4-477">Primo valore da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-477">The first value to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b20a4-478">Secondo valore da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-478">The second value to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-479">Restituisce un valore che indica se due numeri complessi non sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-479">Returns a value that indicates whether two complex numbers are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-480">
            <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-480">
              <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-481">Il <xref:System.Numerics.Complex.op_Equality%2A> metodo consente di definire il funzionamento dell'operatore di disuguaglianza per numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-481">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="b20a4-482">Permette inoltre il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-482">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="b20a4-483">Linguaggi che non supportano gli operatori personalizzati possono verificare la disuguaglianza chiamando il <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> metodo e inversione del relativo valore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-483">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="b20a4-484">Si noti che, a causa delle differenze nella precisione, due numeri complessi apparentemente equivalenti possono essere considerati non uguali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-484">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="b20a4-485">Una possibile soluzione alternativa consiste nell'implementare un metodo di confronto che restituisce `true` solo se la differenza tra le due parti reali e immaginarie di numeri complessi supera una determinata soglia (ad esempio. 01% del valore del componente reale o immaginario della uno dei numeri complessi).</span><span class="sxs-lookup"><span data-stu-id="b20a4-485">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="b20a4-486">Per altre informazioni, vedere il metodo <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-486">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b20a4-487">Primo valore da moltiplicare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-487">The first value to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b20a4-488">Secondo valore da moltiplicare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-488">The second value to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-489">Moltiplica due numeri complessi specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-489">Multiplies two specified complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-490">Prodotto di <paramref name="left" /> e <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-490">The product of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-491">Il <xref:System.Numerics.Complex.op_Multiply%2A> metodo definisce il funzionamento dell'operatore di moltiplicazione per numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-491">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="b20a4-492">Permette inoltre il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-492">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="b20a4-493">La moltiplicazione di un oggetto complesso numero, a + bi, e un secondo numero complesso, c + di, assume il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-493">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b20a4-494">(ac - bd) + (ad + bc) è possibile</span><span class="sxs-lookup"><span data-stu-id="b20a4-494">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="b20a4-495">Se la moltiplicazione produce un overflow nel componente immaginario o reale, il valore di tale componente è uno <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-495">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b20a4-496">Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.Complex.Multiply%2A> metodo invece.</span><span class="sxs-lookup"><span data-stu-id="b20a4-496">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="b20a4-497">Il metodo equivalente per l'operatore è <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b20a4-497">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b20a4-498">Valore da cui sottrarre (minuendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-498">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b20a4-499">Valore da sottrarre (sottraendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-499">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-500">Sottrae un numero complesso da un altro numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-500">Subtracts a complex number from another complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-501">Risultato della sottrazione di <paramref name="right" /> da <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-501">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-502">Il <xref:System.Numerics.Complex.op_Subtraction%2A> metodo definisce il funzionamento dell'operatore di sottrazione di numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-502">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="b20a4-503">Permette inoltre il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-503">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="b20a4-504">Se il chiamata al metodo restituisce un overflow il componente immaginario o reale, il valore di tale componente può essere <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-504">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b20a4-505">La sottrazione di un numero complesso, c + di, da un altro numero complesso, un + bi, assume il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-505">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="b20a4-506">(a - c) + (b - 1!d) è possibile</span><span class="sxs-lookup"><span data-stu-id="b20a4-506">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="b20a4-507">Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.Complex.Subtract%2A> metodo invece.</span><span class="sxs-lookup"><span data-stu-id="b20a4-507">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="b20a4-508">Il metodo equivalente per l'operatore è <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b20a4-508">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-509">Valore da negare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-509">The value to negate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-510">Restituisce l'inverso additivo di un numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-510">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-511">Risultato dei componenti <see cref="P:System.Numerics.Complex.Real" /> e <see cref="P:System.Numerics.Complex.Imaginary" /> del parametro <paramref name="value" /> moltiplicato per -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-511">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-512">Il <xref:System.Numerics.Complex.op_UnaryNegation%2A> metodo consente di definire il funzionamento dell'operatore di negazione (inverso additivo) unario per numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-512">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="b20a4-513">Permette inoltre il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-513">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="b20a4-514">Il numero complesso ottenuto produce un valore di <xref:System.Numerics.Complex> 0 (zero) quando viene aggiunto per il numero complesso originale.</span><span class="sxs-lookup"><span data-stu-id="b20a4-514">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="b20a4-515">Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.Complex.Negate%2A> metodo invece.</span><span class="sxs-lookup"><span data-stu-id="b20a4-515">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="b20a4-516">Il metodo equivalente per l'operatore è <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b20a4-516">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-517">Ottiene la fase di un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-517">Gets the phase of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b20a4-518">Fase di un numero complesso, in radianti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-518">The phase of a complex number, in radians.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-519">Per un numero complesso un + bi, la fase viene calcolata come <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, una).</span><span class="sxs-lookup"><span data-stu-id="b20a4-519">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="b20a4-520">È possibile identificare un numero complesso dalle coordinate Cartesiane sul piano complesso oppure dalle relative coordinate polari.</span><span class="sxs-lookup"><span data-stu-id="b20a4-520">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="b20a4-521">La fase (argomenti) di un numero complesso è l'angolo dell'asse reale di una linea disegnata dal punto di origine (l'intersezione dell'asse x e y) per il punto rappresentato dal numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-521">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="b20a4-522">La grandezza (rappresentato dal <xref:System.Numerics.Complex.Magnitude%2A> proprietà) è la distanza tra il punto di origine e il punto rappresentato dal numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-522">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="b20a4-523">È possibile creare un'istanza di un numero complesso basato su coordinate polari anziché le coordinate Cartesiane chiamando il <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-523">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="b20a4-524">Per convertire la fase da radianti in gradi, moltiplicarlo per 180 /<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-524">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-525">Nell'esempio seguente viene utilizzata la <xref:System.Numerics.Complex.FromPolarCoordinates%2A> metodo per creare un'istanza di un numero complesso in base alle coordinate polari e quindi Visualizza il valore della relativa <xref:System.Numerics.Complex.Magnitude%2A> e <xref:System.Numerics.Complex.Phase%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="b20a4-525">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-526">Restituisce il numero complesso specificato elevato a una potenza specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-526">Returns a specified complex number raised to a specified power.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-527">Numero complesso da elevare a una potenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-527">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="b20a4-528">Numero a virgola mobile a precisione doppia che specifica una potenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-528">A double-precision floating-point number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-529">Restituisce un numero complesso specificato elevato a una potenza specificata da un numero a virgola mobile a precisione doppia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-529">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-530">Numero complesso <paramref name="value" /> elevato alla potenza <paramref name="power" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-530">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-531">Se `value` è <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, il metodo restituisce <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-531">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b20a4-532">Per altri valori, se `power` è 0, il metodo restituisce <xref:System.Numerics.Complex.One?displayProperty=nameWithType>e se `power` è 1, restituirà `value`.</span><span class="sxs-lookup"><span data-stu-id="b20a4-532">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="b20a4-533">Questo metodo corrisponde al <xref:System.Math.Pow%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-533">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-534">L'esempio seguente illustra l'utilizzo di un numero complesso e un esponente elevamento a potenza il cui valore è compreso tra -1 a 10.</span><span class="sxs-lookup"><span data-stu-id="b20a4-534">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-535">Numero complesso da elevare a una potenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-535">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="b20a4-536">Numero complesso che specifica una potenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-536">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-537">Restituisce un numero complesso specificato elevato a una potenza specificata da un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-537">Returns a specified complex number raised to a power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-538">Numero complesso <paramref name="value" /> elevato alla potenza <paramref name="power" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-538">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-539">Ottiene il componente reale dell'oggetto <see cref="T:System.Numerics.Complex" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-539">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b20a4-540">Componente reale di un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-540">The real component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-541">Dato un numero complesso a + bi, <xref:System.Numerics.Complex.Real%2A> proprietà restituisce il valore di una.</span><span class="sxs-lookup"><span data-stu-id="b20a4-541">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-542">Nell'esempio seguente viene creata un'istanza di una matrice di <xref:System.Numerics.Complex> oggetti e visualizza i componenti reali e immaginari di ciascuno di essi in forma a + bi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-542">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-543">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-543">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-544">Restituisce il reciproco moltiplicativo di un numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-544">Returns the multiplicative inverse of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-545">Reciproco di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-545">The reciprocal of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-546">Il reciproco o inverso moltiplicativo, di un numero *x* è un numero *y* in cui *x* moltiplicato per *y* restituisce 1.</span><span class="sxs-lookup"><span data-stu-id="b20a4-546">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="b20a4-547">Reciproco di un numero complesso è il numero complesso che produce <xref:System.Numerics.Complex.One?displayProperty=nameWithType> quando vengono moltiplicati due numeri.</span><span class="sxs-lookup"><span data-stu-id="b20a4-547">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="b20a4-548">Se un numero complesso vengono rappresentato come + bi, il suo reciproco è rappresentato dall'espressione un / (un<sup>2</sup>+ b<sup>2</sup>) + -b / (un<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="b20a4-548">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="b20a4-549">Se il valore è <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, il metodo restituisce <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-549">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b20a4-550">In caso contrario, restituisce il risultato dell'espressione <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.</span><span class="sxs-lookup"><span data-stu-id="b20a4-550">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-551">L'esempio seguente usa il <xref:System.Numerics.Complex.Reciprocal%2A> metodo per calcolare i valori reciproci di diversi numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-551">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="b20a4-552">Viene inoltre illustrato che il risultato della moltiplicazione tra un numero complesso e il suo reciproco è <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-552">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-553">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-553">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-554">Restituisce il seno del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-554">Returns the sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-555">Seno di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-555">The sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-556">Il <xref:System.Numerics.Complex.Sin%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Sin%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-556">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b20a4-557">Il <xref:System.Numerics.Complex.Sin%2A> metodo utilizza la formula seguente per calcolare il seno del numero complesso a + bi:</span><span class="sxs-lookup"><span data-stu-id="b20a4-557">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="b20a4-558">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="b20a4-558">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-559">Nell'esempio seguente viene illustrato il <xref:System.Numerics.Complex.Sin%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-559">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="b20a4-560">Viene illustrato il valore restituito da tale passaggio il <xref:System.Numerics.Complex.Asin%2A> metodo per il <xref:System.Numerics.Complex.Sin%2A> metodo viene restituito originale <xref:System.Numerics.Complex> valore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-560">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-561">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-561">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-562">Restituisce il seno iperbolico del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-562">Returns the hyperbolic sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-563">Seno iperbolico di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-563">The hyperbolic sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-564">Il <xref:System.Numerics.Complex.Sinh%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Sinh%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-564">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b20a4-565">Il <xref:System.Numerics.Complex.Sinh%2A> metodo utilizza la formula seguente per calcolare il seno iperbolico del numero complesso a + bi:</span><span class="sxs-lookup"><span data-stu-id="b20a4-565">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="b20a4-566">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="b20a4-566">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-567">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-567">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-568">Restituisce la radice quadrata del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-568">Returns the square root of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-569">Radice quadrata di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-569">The square root of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-570">La radice quadrata del numero complesso `value` viene calcolato usando la formula seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-570">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="b20a4-571"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A> / 2.0)</span><span class="sxs-lookup"><span data-stu-id="b20a4-571"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="b20a4-572">Il <xref:System.Numerics.Complex.Sqrt%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-572">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="b20a4-573">Valore da cui sottrarre (minuendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-573">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="b20a4-574">Valore da sottrarre (sottraendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-574">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-575">Sottrae un numero complesso da un altro e restituisce il risultato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-575">Subtracts one complex number from another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-576">Risultato della sottrazione di <paramref name="right" /> da <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-576">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-577">La sottrazione di un numero complesso, c + di, da un altro numero complesso, un + bi, assume il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="b20a4-577">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="b20a4-578">(a - c) + (b - 1!d) è possibile</span><span class="sxs-lookup"><span data-stu-id="b20a4-578">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="b20a4-579">Se il chiamata al metodo restituisce un overflow il componente immaginario o reale, il valore di tale componente può essere <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-579">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b20a4-580">I linguaggi che non supportano gli operatori personalizzati possono utilizzare il <xref:System.Numerics.Complex.Subtract%2A> metodo per eseguire la sottrazione utilizzando numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-580">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-581">Nell'esempio seguente sottrae ogni numero complesso in una matrice da un numero complesso.</span><span class="sxs-lookup"><span data-stu-id="b20a4-581">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-582">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-582">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-583">Restituisce la tangente del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-583">Returns the tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-584">Tangente di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-584">The tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-585">Il <xref:System.Numerics.Complex.Tan%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Tan%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-585">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b20a4-586">Il <xref:System.Numerics.Complex.Tan%2A> metodo utilizza la formula seguente per calcolare la tangente del numero complesso `value`:</span><span class="sxs-lookup"><span data-stu-id="b20a4-586">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="b20a4-587"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="b20a4-587"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-588">Nell'esempio seguente viene illustrato il <xref:System.Numerics.Complex.Tan%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b20a4-588">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="b20a4-589">Viene illustrato il valore restituito da tale passaggio il <xref:System.Numerics.Complex.Atan%2A> metodo per il <xref:System.Numerics.Complex.Tan%2A> metodo viene restituito originale <xref:System.Numerics.Complex> valore.</span><span class="sxs-lookup"><span data-stu-id="b20a4-589">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b20a4-590">Numero complesso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-590">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-591">Restituisce la tangente iperbolica del numero complesso specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-591">Returns the hyperbolic tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-592">Tangente iperbolica di <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-592">The hyperbolic tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-593">Il <xref:System.Numerics.Complex.Tanh%2A> metodo per i numeri complessi corrisponde alla <xref:System.Math.Tanh%2A?displayProperty=nameWithType> metodo per i numeri reali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-593">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b20a4-594">Il <xref:System.Numerics.Complex.Tanh%2A> metodo utilizza la formula seguente per calcolare la tangente iperbolica del numero complesso `value`:</span><span class="sxs-lookup"><span data-stu-id="b20a4-594">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="b20a4-595"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="b20a4-595"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-596">Converte il valore di un numero complesso nella relativa rappresentazione di stringa equivalente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-596">Converts the value of a complex number to its equivalent string representation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-597">Converte il valore del numero complesso corrente nella relativa rappresentazione di stringa equivalente in formato cartesiano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-597">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-598">Rappresentazione di stringa dell'istanza corrente in formato cartesiano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-598">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-599">La rappresentazione di stringa del valore predefinito di un numero complesso visualizza il numero usando le coordinate Cartesiane nel formato `(` *un* `,` *b*`)`, dove *un* è la parte reale del numero complesso, e *b* è la parte immaginaria.</span><span class="sxs-lookup"><span data-stu-id="b20a4-599">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="b20a4-600">Entrambi *un* e *b* devono essere formattati utilizzando l'identificatore di formato generale ("G") e le convenzioni delle impostazioni cultura correnti del sistema.</span><span class="sxs-lookup"><span data-stu-id="b20a4-600">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-601">Nell'esempio seguente mostra la rappresentazione di stringa di diversi numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-601">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="b20a4-602">L'output utilizza le convenzioni di formattazione delle impostazioni cultura inglese - Stati Uniti ("en-US") lingua, ovvero, in questo caso, le impostazioni cultura correnti del sistema.</span><span class="sxs-lookup"><span data-stu-id="b20a4-602">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="b20a4-603">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-603">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-604">Converte il valore del numero complesso corrente nella relativa rappresentazione di stringa equivalente in formato cartesiano usando le informazioni di formattazione relative alle impostazioni cultura specificate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-604">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-605">Rappresentazione di stringa dell'istanza corrente in formato cartesiano, come specificato da <paramref name="provider" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-605">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-606">La rappresentazione di stringa del numero complesso restituito da questo metodo visualizza il numero usando le coordinate Cartesiane nel formato `(` *un* `,` *b*`)`, in cui *un* è la parte reale del numero complesso, e *b* è la parte immaginaria.</span><span class="sxs-lookup"><span data-stu-id="b20a4-606">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="b20a4-607">Entrambi *un* e *b* devono essere formattati utilizzando l'identificatore di formato generale ("G") e le convenzioni delle impostazioni cultura definite da `provider`.</span><span class="sxs-lookup"><span data-stu-id="b20a4-607">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="b20a4-608">Il `provider` parametro è un <xref:System.IFormatProvider> implementazione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-608">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="b20a4-609">Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura sul formato dei numeri reali e immaginari nella stringa restituita.</span><span class="sxs-lookup"><span data-stu-id="b20a4-609">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="b20a4-610">Se `provider` viene `null`, la stringa restituita viene formattata utilizzando il <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="b20a4-610">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="b20a4-611">Il `provider` parametro può essere uno dei seguenti:</span><span class="sxs-lookup"><span data-stu-id="b20a4-611">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="b20a4-612">Oggetto <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che fornisce informazioni di formattazione</span><span class="sxs-lookup"><span data-stu-id="b20a4-612">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="b20a4-613">Il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-613">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="b20a4-614">Un oggetto personalizzato che implementa il <xref:System.IFormatProvider> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b20a4-614">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="b20a4-615">Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-615">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-616">Nell'esempio seguente mostra la rappresentazione di stringa di diversi numeri complessi.</span><span class="sxs-lookup"><span data-stu-id="b20a4-616">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="b20a4-617">Il risultato utilizza convenzioni di formattazione per l'inglese - Stati Uniti ("en-US") e il francese - impostazioni cultura Francia ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="b20a4-617">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="b20a4-618">Stringa di formato numerico standard o personalizzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-618">A standard or custom numeric format string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-619">Converte il valore del numero complesso corrente nella relativa rappresentazione di stringa equivalente in formato cartesiano usando il formato specificato per le parti reale e immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-619">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-620">Rappresentazione di stringa dell'istanza corrente in formato cartesiano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-620">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-621">La rappresentazione di stringa del numero complesso restituito da questo metodo visualizza il numero usando le coordinate Cartesiane nel formato `(` *un* `,` *b*`)`, in cui *un* è la parte reale del numero complesso, e *b* è la parte immaginaria.</span><span class="sxs-lookup"><span data-stu-id="b20a4-621">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="b20a4-622">Entrambi *un* e *b* vengono formattati con la stringa di formato specificata dal `format`.</span><span class="sxs-lookup"><span data-stu-id="b20a4-622">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="b20a4-623">Il `format` parametro può essere qualsiasi identificatore di formato numerico standard valido, o qualsiasi combinazione di identificatori di formato numerico personalizzate.</span><span class="sxs-lookup"><span data-stu-id="b20a4-623">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="b20a4-624">Se `format` è uguale a <xref:System.String.Empty?displayProperty=nameWithType> o `null`, le parti reale e immaginarie del numero complesso vengono formattate con l'identificatore di formato generale ("G").</span><span class="sxs-lookup"><span data-stu-id="b20a4-624">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="b20a4-625">Se `format` è qualsiasi altro valore, il metodo genera un <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-625">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="b20a4-626">.NET Framework fornisce supporto di formattazione completo, come descritto in maggior dettaglio negli argomenti seguenti:</span><span class="sxs-lookup"><span data-stu-id="b20a4-626">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="b20a4-627">Per ulteriori informazioni sulle stringhe di formato numerico, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="b20a4-627">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="b20a4-628">Per ulteriori informazioni sulla formattazione in .NET Framework, vedere [formattazione dei tipi](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="b20a4-628">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="b20a4-629">Il formato della stringa restituita è determinato dal <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="b20a4-629">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="b20a4-630">A seconda di `format` parametro, questo oggetto controlla i simboli, ad esempio il segno negativo, il separatore di gruppo e il simbolo di separatore decimale nella stringa di output.</span><span class="sxs-lookup"><span data-stu-id="b20a4-630">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="b20a4-631">Per fornire informazioni di formattazione per le impostazioni cultura diverse da quelle correnti, chiamare il <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> rapporto di overload.</span><span class="sxs-lookup"><span data-stu-id="b20a4-631">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-632">Nell'esempio seguente consente di inizializzare un numero complesso e viene visualizzata mediante diverse stringhe di formato standard.</span><span class="sxs-lookup"><span data-stu-id="b20a4-632">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="b20a4-633">
            <paramref name="format" /> non è una stringa di formato valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-633">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="b20a4-634">Stringa di formato numerico standard o personalizzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-634">A standard or custom numeric format string.</span>
          </span>
        </param>
        <param name="provider">
          <span data-ttu-id="b20a4-635">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-635">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b20a4-636">Converte il valore del numero complesso corrente nella relativa rappresentazione di stringa equivalente in formato cartesiano usando il formato specificato e le informazioni sul formato relative alle impostazioni cultura per le parti reale e immaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-636">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b20a4-637">Rappresentazione di stringa dell'istanza corrente in formato cartesiano, come specificato da <paramref name="format" /> e da <paramref name="provider" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-637">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-638">La rappresentazione di stringa del numero complesso restituito da questo metodo visualizza il numero usando le coordinate Cartesiane nel formato `(` *un* `,` *b*`)`, in cui *un* è la parte reale del numero complesso, e *b* è la parte immaginaria.</span><span class="sxs-lookup"><span data-stu-id="b20a4-638">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="b20a4-639">Entrambi *un* e *b* vengono formattati con la stringa di formato specificata dal `format`.</span><span class="sxs-lookup"><span data-stu-id="b20a4-639">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="b20a4-640">Il `format` parametro può essere qualsiasi identificatore di formato numerico standard valido, o qualsiasi combinazione di identificatori di formato numerico personalizzate.</span><span class="sxs-lookup"><span data-stu-id="b20a4-640">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="b20a4-641">Se `format` è uguale a <xref:System.String.Empty?displayProperty=nameWithType> o `null`, le parti reale e immaginarie del numero complesso vengono formattate con l'identificatore di formato generale ("G").</span><span class="sxs-lookup"><span data-stu-id="b20a4-641">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="b20a4-642">Se `format` è qualsiasi altro valore, il metodo genera un <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="b20a4-642">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="b20a4-643">.NET Framework fornisce supporto di formattazione completo, come descritto in maggior dettaglio negli argomenti seguenti:</span><span class="sxs-lookup"><span data-stu-id="b20a4-643">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="b20a4-644">Per ulteriori informazioni sulle stringhe di formato numerico, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="b20a4-644">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="b20a4-645">Per ulteriori informazioni sulla formattazione in .NET Framework, vedere [formattazione dei tipi](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="b20a4-645">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="b20a4-646">Il `provider` parametro è un <xref:System.IFormatProvider> implementazione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-646">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="b20a4-647">Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura sul formato dei numeri reali e immaginari nella stringa restituita.</span><span class="sxs-lookup"><span data-stu-id="b20a4-647">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="b20a4-648">A seconda di `format` parametro, questo oggetto controlla i simboli, ad esempio il segno negativo, il separatore di gruppo e il simbolo di separatore decimale nella stringa di output.</span><span class="sxs-lookup"><span data-stu-id="b20a4-648">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="b20a4-649">Se `provider` viene `null`, la stringa restituita viene formattata utilizzando il <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="b20a4-649">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="b20a4-650">Il `provider` parametro può essere uno dei seguenti:</span><span class="sxs-lookup"><span data-stu-id="b20a4-650">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="b20a4-651">Oggetto <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che fornisce informazioni di formattazione</span><span class="sxs-lookup"><span data-stu-id="b20a4-651">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="b20a4-652">Il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-652">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="b20a4-653">Un oggetto personalizzato che implementa il <xref:System.IFormatProvider> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b20a4-653">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="b20a4-654">Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.</span><span class="sxs-lookup"><span data-stu-id="b20a4-654">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-655">Nell'esempio seguente crea una matrice di numeri complessi e consente di visualizzare ognuno dei quali utilizza diverse stringhe di formato standard, nonché <xref:System.Globalization.CultureInfo> gli oggetti che rappresentano le impostazioni cultura inglese - Stati Uniti ("en-US") e il francese - Francia ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="b20a4-655">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="b20a4-656">
            <paramref name="format" /> non è una stringa di formato valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-656">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b20a4-657">Restituisce una nuova istanza di <see cref="T:System.Numerics.Complex" /> con un numero reale uguale a zero e un numero immaginario uguale a zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b20a4-657">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b20a4-658">Il <xref:System.Numerics.Complex.Zero> proprietà viene utilizzata più di frequente per confrontare un <xref:System.Numerics.Complex> valore su zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-658">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b20a4-659">Nell'esempio seguente crea un <xref:System.Numerics.Complex> valore utilizzando il <xref:System.Numerics.Complex.Zero> proprietà.</span><span class="sxs-lookup"><span data-stu-id="b20a4-659">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="b20a4-660">Consente quindi di confrontare questo valore su un altro valore che viene creata un'istanza chiamando il <xref:System.Numerics.Complex> costruttore con una parte reale uguale a zero e una parte immaginaria uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="b20a4-660">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="b20a4-661">Come illustrato nell'output dell'esempio, i due valori sono uguali.</span><span class="sxs-lookup"><span data-stu-id="b20a4-661">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>