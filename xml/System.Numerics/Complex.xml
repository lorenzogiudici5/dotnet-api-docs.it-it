<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Complex.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac51adbe02d035bfc5cd2896e8b0e40079375718a5e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1adbe02d035bfc5cd2896e8b0e40079375718a5e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Numerics.Complex">
          <source>Represents a complex number.</source>
          <target state="translated">Rappresenta un numero complesso.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>A complex number is a number that comprises a real number part and an imaginary number part.</source>
          <target state="translated">Un numero complesso è un numero che comprende una parte numerica reale e una parte numerica immaginaria.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>A complex number z is usually written in the form z = x + yi, where <bpt id="p1">*</bpt>x<ept id="p1">*</ept> and <bpt id="p2">*</bpt>y<ept id="p2">*</ept> are real numbers, and <bpt id="p3">*</bpt>i<ept id="p3">*</ept> is the imaginary unit that has the property <bpt id="p4">*</bpt>i<ept id="p4">*</ept><bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept> = -1.</source>
          <target state="translated">Numero complesso z vengono in genere scritti nel formato z = x + yi, in cui <bpt id="p1">*</bpt>x<ept id="p1">*</ept> e <bpt id="p2">*</bpt>y<ept id="p2">*</ept> sono numeri reali, e <bpt id="p3">*</bpt>si<ept id="p3">*</ept> è l'unità immaginaria che dispone della proprietà <bpt id="p4">*</bpt>i<ept id="p4">*</ept> <bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept> = -1.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The real part of the complex number is represented by <bpt id="p1">*</bpt>x<ept id="p1">*</ept>, and the imaginary part of the complex number is represented by <bpt id="p2">*</bpt>y<ept id="p2">*</ept>.</source>
          <target state="translated">La parte reale del numero complesso è rappresentata da <bpt id="p1">*</bpt>x<ept id="p1">*</ept>, e la parte immaginaria del numero complesso è rappresentata da <bpt id="p2">*</bpt>y<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> tipo utilizza il sistema di coordinate cartesiano (reale, immaginario) durante la creazione e modifica di numeri complessi.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</source>
          <target state="translated">Un numero complesso può essere rappresentato come un punto in un sistema di coordinate bidimensionale, è detto piano complesso.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</source>
          <target state="translated">La parte reale del numero complesso è posizionata sull'asse x (l'asse orizzontale) e la parte immaginaria è posizionata sull'asse y (l'asse verticale).</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</source>
          <target state="translated">Qualsiasi punto del piano complesso può essere espresse anche in base al valore assoluto, utilizzando il grafico polare sistema di coordinate, In coordinate polari, un punto di distribuzione è caratterizzato da due numeri:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</source>
          <target state="translated">La grandezza che è la distanza tra il punto dall'origine (ovvero, 0,0, o il punto in cui l'asse x e y si intersecano).</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</source>
          <target state="translated">La fase, ovvero l'angolo tra l'asse reale e la riga disegnata dall'origine al punto.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Instantiating a Complex Number</source>
          <target state="translated">Creazione di un numero complesso</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>You can assign a value to a complex number in one of the following ways:</source>
          <target state="translated">È possibile assegnare un valore in un numero complesso in uno dei modi seguenti:</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>By passing two <ph id="ph1">&lt;xref:System.Double&gt;</ph> values to its constructor.</source>
          <target state="translated">Passando due <ph id="ph1">&lt;xref:System.Double&gt;</ph> valori al costruttore.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The first value represents the real part of the complex number, and the second value represents its imaginary part.</source>
          <target state="translated">Il primo valore rappresenta la parte reale del numero complesso e il secondo valore rappresenta la parte immaginaria.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</source>
          <target state="translated">Questi valori rappresentano la posizione del numero complesso nel sistema di coordinate cartesiano bidimensionale.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>By calling the static (<ph id="ph1">`Shared`</ph> in Visual Basic) <ph id="ph2">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType&gt;</ph> method to create a complex number from its polar coordinates.</source>
          <target state="translated">Chiamando il metodo statico (<ph id="ph1">`Shared`</ph> in Visual Basic) <ph id="ph2">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType&gt;</ph> metodo per creare un numero complesso dalle coordinate polari.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>By assigning a <ph id="ph1">&lt;xref:System.Byte&gt;</ph>, <ph id="ph2">&lt;xref:System.SByte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph5">&lt;xref:System.Int32&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph7">&lt;xref:System.Int64&gt;</ph>, <ph id="ph8">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph9">&lt;xref:System.Single&gt;</ph>, or <ph id="ph10">&lt;xref:System.Double&gt;</ph> value to a <ph id="ph11">&lt;xref:System.Numerics.Complex&gt;</ph> object.</source>
          <target state="translated">Assegnando un <ph id="ph1">&lt;xref:System.Byte&gt;</ph>, <ph id="ph2">&lt;xref:System.SByte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph5">&lt;xref:System.Int32&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph7">&lt;xref:System.Int64&gt;</ph>, <ph id="ph8">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph9">&lt;xref:System.Single&gt;</ph>, o <ph id="ph10">&lt;xref:System.Double&gt;</ph> valore un <ph id="ph11">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The value becomes the real part of the complex number, and its imaginary part equals 0.</source>
          <target state="translated">Il valore diventa la parte reale del numero complesso e la parte immaginaria è uguale a 0.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>By casting (in C#) or converting (in Visual Basic) a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> or <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> object.</source>
          <target state="translated">Cast (in c#) o convertendo (in Visual Basic) un <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valore un <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The value becomes the real part of the complex number, and its imaginary part equals 0.</source>
          <target state="translated">Il valore diventa la parte reale del numero complesso e la parte immaginaria è uguale a 0.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>By assigning the complex number that is returned by a method or operator to a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> object.</source>
          <target state="translated">Assegnando il numero complesso che viene restituito da un metodo o un operatore per un <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>For example, <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType&gt;</ph> is a static method that returns a complex number that is the sum of two complex numbers, and the <ph id="ph2">&lt;xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType&gt;</ph> operator adds two complex numbers and returns the result.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType&gt;</ph> è un metodo statico che restituisce un numero complesso che è la somma di due numeri complessi, e <ph id="ph2">&lt;xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType&gt;</ph> operatore aggiunge due numeri complessi e restituisce il risultato.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The following example demonstrates each of these five ways of assigning a value to a complex number.</source>
          <target state="translated">L'esempio seguente illustra ognuno di questi cinque modalità di assegnazione di un valore in un numero complesso.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Operations with Complex Numbers</source>
          <target state="translated">Operazioni con numeri complessi</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> structure in the .NET Framework includes members that provide the following functionality:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> struttura in .NET Framework include i membri che forniscono le funzionalità seguenti:</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Methods to compare two complex numbers to determine whether they are equal.</source>
          <target state="translated">Metodi per confrontare due numeri complessi per determinare se sono uguali.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Operators to perform arithmetic operations on complex numbers.</source>
          <target state="translated">Operatori per eseguire operazioni aritmetiche su numeri complessi.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> gli operatori consentono di eseguire l'addizione, sottrazione, moltiplicazione, divisione e negazione unaria con numeri complessi.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Methods to perform other numerical operations on complex numbers.</source>
          <target state="translated">Metodi per eseguire altre operazioni numeriche su numeri complessi.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</source>
          <target state="translated">Oltre le quattro operazioni aritmetiche di base, è possibile generare un numero complesso a una potenza specificata, trovare la radice quadrata di un numero complesso e ottenere il valore assoluto di un numero complesso.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Methods to perform trigonometric operations on complex numbers.</source>
          <target state="translated">Metodi per eseguire operazioni trigonometriche su numeri complessi.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>For example, you can calculate the tangent of an angle represented by a complex number.</source>
          <target state="translated">Ad esempio, è possibile calcolare la tangente di un angolo rappresentato da un numero complesso.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Note that, because the <ph id="ph1">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> and  <ph id="ph2">&lt;xref:System.Numerics.Complex.Imaginary%2A&gt;</ph> properties are read-only, you cannot modify the value of an existing <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> object.</source>
          <target state="translated">Si noti che, in quanto il <ph id="ph1">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Numerics.Complex.Imaginary%2A&gt;</ph> le proprietà sono di sola lettura, non è possibile modificare il valore di un oggetto esistente <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>All methods that perform an operation on a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> number, if their return value is of type <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph>, return a new <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> number.</source>
          <target state="translated">Tutti i metodi che eseguono un'operazione su un <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> numero, se il valore restituito è di tipo <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph>, restituire un nuovo <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> numero.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Precision and Complex Numbers</source>
          <target state="translated">Precisione e numeri complessi</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</source>
          <target state="translated">Le parti reali e immaginarie di un numero complesso sono rappresentate da due valori a virgola mobile a precisione doppia.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>This means that <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</source>
          <target state="translated">Ciò significa che <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> valori, come i valori a virgola mobile a precisione doppia, possano perdita di precisione in seguito a operazioni numeriche.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>This means that strict comparisons for equality of two <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> values may fail, even if the difference between the two values is due to a loss of precision.</source>
          <target state="translated">Ciò significa che strict confronti di uguaglianza di due <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> valori potrebbero non riuscire, anche se è la differenza tra i due valori a causa di una perdita di precisione.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Double&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;xref:System.Double&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>For example, performing exponentiation on the logarithm of a number should return the original number.</source>
          <target state="translated">L'esecuzione di elevamento a potenza sul logaritmo di un numero, ad esempio, deve restituire il numero originale.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</source>
          <target state="translated">In alcuni casi, tuttavia, la perdita di precisione dei valori a virgola mobile può causare lievi differenze tra i due valori, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Similarly, the following example, which calculates the square root of a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</source>
          <target state="translated">Analogamente, nell'esempio seguente, che calcola la radice quadrata di un <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> numero, produce risultati leggermente diversi sulle 32 bit e IA64 versioni di .NET Framework.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Complex Numbers, Infinity, and NaN</source>
          <target state="translated">Numeri complessi, valori infiniti e NaN</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The real and imaginary parts of a complex number are represented by <ph id="ph1">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated">Le parti reali e immaginarie di un numero complesso vengono rappresentate da <ph id="ph1">&lt;xref:System.Double&gt;</ph> valori.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>In addition to ranging from <ph id="ph1">&lt;xref:System.Double.MinValue?displayProperty=nameWithType&gt;</ph> to <ph id="ph2">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>, the real or imaginary part of a complex number can have a value of <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, or <ph id="ph5">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Oltre a compreso <ph id="ph1">&lt;xref:System.Double.MinValue?displayProperty=nameWithType&gt;</ph> a <ph id="ph2">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>, la parte reale o immaginaria di un numero complesso può avere un valore di <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, o <ph id="ph5">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source><ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> all propagate in any arithmetic or trigonometric operation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> si propagano in qualsiasi operazione aritmetica o eseguire funzioni trigonometriche tutte.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>In the following example, division by <ph id="ph1">&lt;xref:System.Numerics.Complex.Zero&gt;</ph> produces a complex number whose real and imaginary parts are both <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente, la divisione per <ph id="ph1">&lt;xref:System.Numerics.Complex.Zero&gt;</ph> produce un numero complesso le cui parti reale e immaginarie vengono entrambi <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Di conseguenza, l'esecuzione di moltiplicazione con questo valore genera inoltre un numero complesso le cui parti reale e immaginarie vengono <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Similarly, performing a multiplication that overflows the range of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> type produces a complex number whose real part is <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> and whose imaginary part is <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Analogamente, esecuzione di una moltiplicazione che supera l'intervallo del <ph id="ph1">&lt;xref:System.Double&gt;</ph> tipo produce un numero complesso la parte reale è <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> e la parte immaginaria è <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Subsequently performing division with this complex number returns a complex number whose real part is <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> and whose imaginary part is <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Successivamente si esegue una divisione con questo numero complesso restituisce un numero complesso la parte reale è <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> e la parte immaginaria è <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Mathematical operations with complex numbers that are invalid or that overflow the range of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type do not throw an exception.</source>
          <target state="translated">Operazioni matematiche con numeri complessi che non sono valide o che superano l'intervallo del <ph id="ph1">&lt;xref:System.Double&gt;</ph> tipo di dati non generano un'eccezione.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Instead, they return a <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> under the following conditions:</source>
          <target state="translated">Invece, restituiscono un <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> nelle condizioni seguenti:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The division of a positive number by zero returns <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La divisione di un numero positivo per zero restituisce <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Any operation that overflows the upper bound of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type returns <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Qualsiasi operazione che supera il limite superiore di <ph id="ph1">&lt;xref:System.Double&gt;</ph> del tipo di dati restituisce <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The division of a negative number by zero returns <ph id="ph1">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La divisione di un numero negativo per zero restituisce <ph id="ph1">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Any operation that overflows the lower bound of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type returns <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Qualsiasi operazione che supera il limite inferiore del <ph id="ph1">&lt;xref:System.Double&gt;</ph> del tipo di dati restituisce <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The division of a zero by zero returns <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La divisione di zero per zero restituisce <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Any operation that is performed on operands whose values are <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> returns <ph id="ph4">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, or <ph id="ph6">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>, depending on the specific operation.</source>
          <target state="translated">Qualsiasi operazione che viene eseguita su operandi i cui valori sono <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> restituisce <ph id="ph4">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, o <ph id="ph6">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>, a seconda dell'operazione specifica.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Note that this applies to any intermediate calculations performed by a method.</source>
          <target state="translated">Si noti che questo si applica a tutti i calcoli intermedi eseguiti da un metodo.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>For example, the multiplication of <ph id="ph1">`new Complex(9e308, 9e308) and new Complex(2.5, 3.5)`</ph> uses the formula (ac - bd) + (ad + bc)i.</source>
          <target state="translated">Ad esempio, la moltiplicazione di <ph id="ph1">`new Complex(9e308, 9e308) and new Complex(2.5, 3.5)`</ph> viene utilizzata la formula (ac - bd) + (ad + bc) i.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The calculation of the real component that results from the multiplication evaluates the expression 9e308 * 2.5 - 9e308 * 3.5.</source>
          <target state="translated">Il calcolo del componente reale risultante dalla moltiplicazione valuta l'espressione 9e308 * 2.5 - 9e308 * 3.5.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Each intermediate multiplication in this expression returns <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, and the attempt to subtract <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> from <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> returns <ph id="ph4">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ogni moltiplicazione intermedia in questa espressione restituisce <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>e il tentativo di sottrarre <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> da <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> restituisce <ph id="ph4">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Formatting a Complex Number</source>
          <target state="translated">Formattazione di un numero complesso</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>By default, the string representation of a complex number takes the form <ph id="ph1">`(`</ph><bpt id="p1">*</bpt>real<ept id="p1">*</ept><ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>imaginary<ept id="p2">*</ept><ph id="ph3">`)`</ph>, where <bpt id="p3">*</bpt>real<ept id="p3">*</ept> and <bpt id="p4">*</bpt>imaginary<ept id="p4">*</ept> are the string representations of the <ph id="ph4">&lt;xref:System.Double&gt;</ph> values that form the complex number's real and imaginary components.</source>
          <target state="translated">Per impostazione predefinita, la rappresentazione di stringa di un numero complesso assume il formato <ph id="ph1">`(`</ph> <bpt id="p1">*</bpt>reale<ept id="p1">*</ept> <ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>immaginaria<ept id="p2">*</ept><ph id="ph3">`)`</ph>, dove <bpt id="p3">*</bpt>reale<ept id="p3">*</ept> e <bpt id="p4">*</bpt>immaginaria<ept id="p4">*</ept> sono rappresentazioni di stringa del <ph id="ph4">&lt;xref:System.Double&gt;</ph> valori che formano i componenti di reale e immaginaria del numero complesso.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>Some overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.ToString%2A&gt;</ph> method allow customization of the string representations of these <ph id="ph2">&lt;xref:System.Double&gt;</ph> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</source>
          <target state="translated">Alcuni overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.ToString%2A&gt;</ph> metodo consentono la personalizzazione di rappresentazioni di stringa di questi <ph id="ph2">&lt;xref:System.Double&gt;</ph> valori riflettono le convenzioni di formattazione di una lingua specifica oppure vengono visualizzati in un determinato formato definito da un valore numerico standard o personalizzato stringa di formato.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>(For more information, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.)</source>
          <target state="translated">(Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>stringhe di formato numerico Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> e <bpt id="p2">[</bpt>stringhe di formato numerico personalizzato<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</source>
          <target state="translated">Uno dei modi più comuni di esprimere la rappresentazione di stringa di un numero complesso assume il formato a + bi, in cui un componente reale del numero complesso e b è componente immaginario del numero complesso.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>In electrical engineering, a complex number is most commonly expressed as a + bj.</source>
          <target state="translated">In elettrotecnica, un numero complesso è in genere espresso come un + bj.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>You can return the string representation of a complex number in either of these two forms.</source>
          <target state="translated">È possibile restituire la rappresentazione di stringa di un numero complesso in uno di questi due formati.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>To do this, define a custom format provider by implementing the <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> and <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interfaces, and then call the <ph id="ph3">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">A tale scopo, definire un provider di formato personalizzato implementando il <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> e <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interfacce e quindi chiamare il <ph id="ph3">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The following example defines a <ph id="ph1">`ComplexFormatter`</ph> class that represents a complex number as a string in the form of either a + bi or a + bj.</source>
          <target state="translated">L'esempio seguente definisce un <ph id="ph1">`ComplexFormatter`</ph> classe che rappresenta un numero complesso come una stringa in forma di + bi o + bj.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.Complex">
          <source>The following example then uses this custom formatter to display the string representation of a complex number.</source>
          <target state="translated">L'esempio seguente usa quindi il formattatore personalizzato per visualizzare la rappresentazione di stringa di un numero complesso.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.#ctor(System.Double,System.Double)">
          <source>The real part of the complex number.</source>
          <target state="translated">Parte reale del numero complesso.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.#ctor(System.Double,System.Double)">
          <source>The imaginary part of the complex number.</source>
          <target state="translated">Parte immaginaria del numero complesso.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.#ctor(System.Double,System.Double)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> structure using the specified real and imaginary values.</source>
          <target state="translated">Inizializza una nuova istanza della struttura <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> usando i valori reali e immaginari specificati.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.#ctor(System.Double,System.Double)">
          <source>The <ph id="ph1">`real`</ph> or <ph id="ph2">`imaginary`</ph> arguments may lose precision if they are data types that require an explicit cast to <ph id="ph3">&lt;xref:System.Double&gt;</ph>.</source>
          <target state="translated">Il <ph id="ph1">`real`</ph> o <ph id="ph2">`imaginary`</ph> argomenti possono perdita di precisione se sono tipi di dati che richiedono un cast esplicito a <ph id="ph3">&lt;xref:System.Double&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.#ctor(System.Double,System.Double)">
          <source>The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</source>
          <target state="translated">Nell'esempio seguente viene creata un'istanza di due numeri complessi e quindi utilizzati in operazioni di addizione, sottrazione, moltiplicazione e divisione.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>Gets the absolute value (or magnitude) of a complex number.</source>
          <target state="translated">Ottiene il valore assoluto (o grandezza) di un numero complesso.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>The absolute value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Valore assoluto di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>The absolute value of a complex number is equivalent to its <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> property.</source>
          <target state="translated">Il valore assoluto di un numero complesso è equivalente al relativo <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>The absolute value of a real number a + bi is calculated as follows:</source>
          <target state="translated">Il valore assoluto di un numero reale un + bi viene calcolata come segue:</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>If b = 0, the result is 0.</source>
          <target state="translated">Se b = 0, il risultato è 0.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>If a &gt; b, the result is a *<ph id="ph1">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph>(1 + b<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept>/a<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>).</source>
          <target state="translated">Se un &gt; b, il risultato è un *<ph id="ph1">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph>(1 + b<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept>/a<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>).</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>If b &gt; a, the result is b * <ph id="ph1">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph>(1 + a<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept>/b<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>).</source>
          <target state="translated">Se b &gt;, il risultato è b * <ph id="ph1">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph>(1 +<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept>/b<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>If the calculation of the absolute value results in an overflow, the method returns either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il calcolo del valore assoluto produce un overflow, il metodo restituisce <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>If either the <ph id="ph1">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Numerics.Complex.Imaginary%2A&gt;</ph> property is <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> and the other property is neither <ph id="ph4">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> nor <ph id="ph5">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, the method returns <ph id="ph6">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Numerics.Complex.Imaginary%2A&gt;</ph> proprietà <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph> e l'altra proprietà non è né <ph id="ph4">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> né <ph id="ph5">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, il metodo restituisce <ph id="ph6">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Abs(System.Numerics.Complex)">
          <source>The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> property.</source>
          <target state="translated">Nell'esempio seguente calcola il valore assoluto di un numero complesso e viene illustrato che è equivalente al valore del <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Acos(System.Numerics.Complex)">
          <source>A complex number that represents a cosine.</source>
          <target state="translated">Numero complesso che rappresenta un coseno.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Acos(System.Numerics.Complex)">
          <source>Returns the angle that is the arc cosine of the specified complex number.</source>
          <target state="translated">Restituisce l'angolo che costituisce l'arcocoseno del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Acos(System.Numerics.Complex)">
          <source>The angle, measured in radians, which is the arc cosine of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Angolo espresso in radianti che costituisce l'arcocoseno di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Acos(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Acos%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Acos%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Acos(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> method uses the following formula:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> metodo utilizza la formula seguente:</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Acos(System.Numerics.Complex)">
          <source>(-<ph id="ph1">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph>) * <ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph><ph id="ph6">*</ph><ph id="ph7">&lt;xref:System.Numerics.Complex.Sqrt%2A&gt;</ph>(<ph id="ph8">&lt;xref:System.Numerics.Complex.One&gt;</ph><ph id="ph9"> - </ph><ph id="ph10">`value`</ph><ph id="ph11"> * </ph><ph id="ph12">`value`</ph>)))</source>
          <target state="translated">(-<ph id="ph1">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph>) * <ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph><ph id="ph6">*</ph><ph id="ph7">&lt;xref:System.Numerics.Complex.Sqrt%2A&gt;</ph>(<ph id="ph8">&lt;xref:System.Numerics.Complex.One&gt;</ph><ph id="ph9"> - </ph><ph id="ph10">`value`</ph><ph id="ph11"> * </ph><ph id="ph12">`value`</ph>)))</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Acos(System.Numerics.Complex)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Acos(System.Numerics.Complex)">
          <source>It shows that passing the value returned by the <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> method to the <ph id="ph2">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph> method returns the original <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> value.</source>
          <target state="translated">Viene illustrato che il valore restituito dal passaggio il <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> metodo il <ph id="ph2">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph> restituisce originale <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The first complex number to add.</source>
          <target state="translated">Primo numero complesso da sommare.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The second complex number to add.</source>
          <target state="translated">Secondo numero complesso da sommare.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Adds two complex numbers and returns the result.</source>
          <target state="translated">Somma due numeri complessi e restituisce il risultato.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The sum of <ph id="ph1">&lt;paramref name="left" /&gt;</ph> and <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated">Somma di <ph id="ph1">&lt;paramref name="left" /&gt;</ph> e <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</source>
          <target state="translated">L'aggiunta di un oggetto complesso numero, +, bi e un secondo numero complesso, c + di, assume il formato seguente:</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)">
          <source>(a + c) + (b + d)i.</source>
          <target state="translated">(a + c) + (b + d)i.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)">
          <source>If the method call results in an overflow in either the real or imaginary component, the value of the component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il chiamata al metodo restituisce un overflow il componente reale o immaginario, il valore del componente può essere <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Languages that do not support custom operators can use the <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%2A&gt;</ph> method to perform addition with complex numbers.</source>
          <target state="translated">I linguaggi che non supportano gli operatori personalizzati possono utilizzare il <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%2A&gt;</ph> metodo per eseguire l'addizione di numeri complessi.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The following example illustrates addition with complex numbers.</source>
          <target state="translated">L'esempio seguente illustra l'addizione di numeri complessi.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Asin(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Asin(System.Numerics.Complex)">
          <source>Returns the angle that is the arc sine of the specified complex number.</source>
          <target state="translated">Restituisce l'angolo che costituisce l'arcoseno del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Asin(System.Numerics.Complex)">
          <source>The angle which is the arc sine of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Angolo che costituisce l'arcoseno di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Asin(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Asin%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Asin%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Asin(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> method uses the following formula:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> metodo utilizza la formula seguente:</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Asin(System.Numerics.Complex)">
          <source><ph id="ph1">-</ph><ph id="ph2">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph><ph id="ph3"> * </ph><ph id="ph4">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph5">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> * value + <ph id="ph6">&lt;xref:System.Numerics.Complex.Sqrt%2A&gt;</ph>(<ph id="ph7">&lt;xref:System.Numerics.Complex.One&gt;</ph> - value * value))</source>
          <target state="translated"><ph id="ph1">-</ph><ph id="ph2">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph><ph id="ph3"> * </ph><ph id="ph4">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph5">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> * valore + <ph id="ph6">&lt;xref:System.Numerics.Complex.Sqrt%2A&gt;</ph>(<ph id="ph7">&lt;xref:System.Numerics.Complex.One&gt;</ph> -valore * valore))</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Asin(System.Numerics.Complex)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Asin(System.Numerics.Complex)">
          <source>It shows that passing the value returned by the <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> method to the <ph id="ph2">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> method returns the original <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> value.</source>
          <target state="translated">Viene illustrato che il valore restituito dal passaggio il <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> metodo il <ph id="ph2">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> restituisce originale <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Atan(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Atan(System.Numerics.Complex)">
          <source>Returns the angle that is the arc tangent of the specified complex number.</source>
          <target state="translated">Restituisce l'angolo che costituisce l'arcotangente del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Atan(System.Numerics.Complex)">
          <source>The angle that is the arc tangent of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Angolo che costituisce l'arcotangente di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Atan(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Atan%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Atan%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Atan(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> method uses the following formula:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> metodo utilizza la formula seguente:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Atan(System.Numerics.Complex)">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> / new Complex(2.0, 0.0)) * (<ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph3">&lt;xref:System.Numerics.Complex.One&gt;</ph><ph id="ph4"> - </ph><ph id="ph5">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> * value) - <ph id="ph6">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph7">&lt;xref:System.Numerics.Complex.One&gt;</ph> + ImaginaryOne * value)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> / nuovo complesso (2.0, 0,0)) * (<ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph3">&lt;xref:System.Numerics.Complex.One&gt;</ph> <ph id="ph4"> - </ph> <ph id="ph5">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> * valore)- <ph id="ph6">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph7">&lt;xref:System.Numerics.Complex.One&gt;</ph> + ImaginaryOne * valore)</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Atan(System.Numerics.Complex)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Atan(System.Numerics.Complex)">
          <source>It shows that passing the value returned by the <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> method to the <ph id="ph2">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> method returns the original <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> value.</source>
          <target state="translated">Viene illustrato che il valore restituito dal passaggio il <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> metodo il <ph id="ph2">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> restituisce originale <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)">
          <source>Computes the conjugate of a complex number and returns the result.</source>
          <target state="translated">Calcola il coniugato di un numero complesso e restituisce il risultato.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)">
          <source>The conjugate of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Coniugato di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)">
          <source>The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</source>
          <target state="translated">Il coniugato di un numero complesso inverte il segno del componente immaginario; si applica, ovvero la negazione unaria il componente immaginario.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)">
          <source>If a + bi is a complex number, its conjugate is a - bi.</source>
          <target state="translated">Se un + bi è un numero complesso, il relativo coniugato-bi.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)">
          <source>The following example displays the conjugate of two complex numbers.</source>
          <target state="translated">Nell'esempio seguente viene visualizzato il coniugato di due numeri complessi.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Cos(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Cos(System.Numerics.Complex)">
          <source>Returns the cosine of the specified complex number.</source>
          <target state="translated">Restituisce il coseno del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Cos(System.Numerics.Complex)">
          <source>The cosine of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Coseno di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Cos(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Cos%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Cos%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Cos(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph> method uses the following formula to calculate the cosine of the complex number a + bi:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph> metodo utilizza la formula seguente per calcolare il coseno del numero complesso a + bi:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Cos(System.Numerics.Complex)">
          <source>(<ph id="ph1">&lt;xref:System.Math.Cos%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cosh%2A&gt;</ph>(b), -(<ph id="ph3">&lt;xref:System.Math.Sin%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sinh%2A&gt;</ph>(b)))</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Math.Cos%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cosh%2A&gt;</ph>(b), -(<ph id="ph3">&lt;xref:System.Math.Sin%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sinh%2A&gt;</ph>(b)))</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Cos(System.Numerics.Complex)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Cos(System.Numerics.Complex)">
          <source>It shows that passing the value returned by the <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> method to the <ph id="ph2">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph> method returns the original <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> value.</source>
          <target state="translated">Viene illustrato che il valore restituito dal passaggio il <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> metodo il <ph id="ph2">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph> restituisce originale <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)">
          <source>Returns the hyperbolic cosine of the specified complex number.</source>
          <target state="translated">Restituisce il coseno iperbolico del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)">
          <source>The hyperbolic cosine of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Coseno iperbolico di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Cosh%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Cosh%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Cosh%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Cosh%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Cosh%2A&gt;</ph> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Cosh%2A&gt;</ph> metodo utilizza la formula seguente per calcolare il coseno iperbolico del numero complesso a + bi:</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)">
          <source>(<ph id="ph1">&lt;xref:System.Math.Cosh%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cos%2A&gt;</ph>(b), <ph id="ph3">&lt;xref:System.Math.Sinh%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sin%2A&gt;</ph>(b))</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Math.Cosh%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cos%2A&gt;</ph>(b), <ph id="ph3">&lt;xref:System.Math.Sinh%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sin%2A&gt;</ph>(b))</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The complex number to be divided.</source>
          <target state="translated">Numero complesso da dividere.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The complex number to divide by.</source>
          <target state="translated">Numero complesso per cui dividere.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Divides one complex number by another and returns the result.</source>
          <target state="translated">Divide un numero complesso per un altro e restituisce il risultato.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The quotient of the division.</source>
          <target state="translated">Quoziente della divisione.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</source>
          <target state="translated">La divisione di un numero complesso, un + bi, da un secondo numero complesso, numero, c + di, assume il formato seguente:</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)">
          <source>((ac + bd) / (c<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> + d<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>)) + ((bc - ad) / (c<bpt id="p3">&lt;sup&gt;</bpt>2<ept id="p3">&lt;/sup&gt;</ept> + d<bpt id="p4">&lt;sup&gt;</bpt>2<ept id="p4">&lt;/sup&gt;</ept>)i</source>
          <target state="translated">((AC + BD) / (c<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> + d<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>)) + ((bc-ad) / (c<bpt id="p3">&lt;sup&gt;</bpt>2<ept id="p3">&lt;/sup&gt;</ept> + d<bpt id="p4">&lt;sup&gt;</bpt>2<ept id="p4">&lt;/sup&gt;</ept>) è</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)">
          <source>If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il calcolo del quoziente restituisce il componente reale o immaginario un overflow, il valore di tale componente è <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Divide%2A&gt;</ph> method can be used by languages that do not support custom operators.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Divide%2A&gt;</ph> metodo può essere utilizzato dai linguaggi che non supportano gli operatori personalizzati.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Its behavior is identical to division using the division operator.</source>
          <target state="translated">Il comportamento è identico alla divisione utilizzando l'operatore di divisione.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The following example divides a complex number by each element in an array of complex numbers.</source>
          <target state="translated">Nell'esempio seguente divide un numero complesso da ogni elemento in una matrice di numeri complessi.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="T:System.Numerics.Complex">
          <source>Returns a value that indicates whether two complex numbers are equal.</source>
          <target state="translated">Restituisce un valore che indica se due numeri complessi sono uguali.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>The complex number to compare.</source>
          <target state="translated">Numero complesso da confrontare.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>Returns a value that indicates whether the current instance and a specified complex number have the same value.</source>
          <target state="translated">Restituisce un valore che indica se l'istanza corrente e un numero complesso specificato hanno lo stesso valore.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this complex number and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> have the same value; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se questo numero complesso e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> presentano lo stesso valore. In caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method provides the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> implementation for the <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> structure.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> metodo fornisce il <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> implementazione per il <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> struttura.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>It performs slightly better than <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Object%29&gt;</ph> method because it does not have to convert its parameter to a complex number.</source>
          <target state="translated">Offre prestazioni leggermente migliori rispetto <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Object%29&gt;</ph> metodo perché non è necessario convertire il parametro in un numero complesso.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</source>
          <target state="translated">Due numeri complessi sono uguali se sono uguali le parti reali e quelle immaginarie sono uguali.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method is equivalent to the following expression:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> metodo è equivalente all'espressione seguente:</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>Use the <ph id="ph1">&lt;see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /&gt;</ph> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /&gt;</ph> metodo con cautela, poiché i due valori che sono apparentemente equivalenti possono essere considerati diversi a causa della diversa precisione dei relativi componenti reali e immaginarie.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>The following example reports that <bpt id="p1">&lt;c&gt;</bpt>(3.33333, 0.142857)<ept id="p1">&lt;/c&gt;</ept> and <bpt id="p2">&lt;c&gt;</bpt>(10/3, 1/7)<ept id="p2">&lt;/c&gt;</ept> are not equal.</source>
          <target state="translated">L'esempio seguente segnala che <bpt id="p1">&lt;c&gt;</bpt>(3.33333, 0.142857)<ept id="p1">&lt;/c&gt;</ept> e <bpt id="p2">&lt;c&gt;</bpt>(10/3, 1/7)<ept id="p2">&lt;/c&gt;</ept> non sono uguali.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</source>
          <target state="translated">Una tecnica consigliata è definire un margine accettabile di differenza tra i due valori (ad esempio. 01% di uno dei componenti di reali e immaginarie valori dei) anziché il confronto dei valori per verificarne l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</source>
          <target state="translated">Se il valore assoluto della differenza tra i due valori è minore o uguale a margine, la differenza è probabilmente a causa delle differenze di precisione e, di conseguenza, i valori possono essere uguali.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</source>
          <target state="translated">Nell'esempio seguente viene utilizzata questa tecnica per confrontare i due valori complessi che l'esempio di codice precedente risulta per essere uguali.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Numerics.Complex)">
          <source>It finds the two complex numbers to be equal.</source>
          <target state="translated">Trova i due numeri complessi siano uguali.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>The object to compare.</source>
          <target state="translated">Oggetto da confrontare.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>Returns a value that indicates whether the current instance and a specified object have the same value.</source>
          <target state="translated">Restituisce un valore che indica se l'istanza corrente e un oggetto specificato hanno lo stesso valore.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> parameter is a <ph id="ph3">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> object or a type capable of implicit conversion to a <ph id="ph4">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> object, and its value is equal to the current <ph id="ph5">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> object; otherwise, <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> è un oggetto <ph id="ph3">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> o un tipo in grado di eseguire la conversione implicita in un oggetto <ph id="ph4">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> e il relativo valore è uguale all'oggetto <ph id="ph5">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> corrente. In caso contrario, <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</source>
          <target state="translated">Due numeri complessi sono uguali se sono uguali le parti reali e quelle immaginarie sono uguali.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Object%29&gt;</ph> method is equivalent to the following expression:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Object%29&gt;</ph> metodo è equivalente all'espressione seguente:</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>If the <ph id="ph1">`obj`</ph> parameter is not a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object, but it is a data type for which an implicit conversion is defined, the <ph id="ph3">&lt;xref:System.Numerics.Complex.Equals%28System.Object%29&gt;</ph> method converts <ph id="ph4">`obj`</ph> to a <ph id="ph5">&lt;xref:System.Numerics.Complex&gt;</ph> object whose real part is equal to the value of <ph id="ph6">`obj`</ph> and whose imaginary part is equal to zero before it performs the comparison.</source>
          <target state="translated">Se il <ph id="ph1">`obj`</ph> parametro non è un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto, ma è un tipo di dati per cui è definita una conversione implicita, il <ph id="ph3">&lt;xref:System.Numerics.Complex.Equals%28System.Object%29&gt;</ph> metodo converte <ph id="ph4">`obj`</ph> per un <ph id="ph5">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto la cui parte reale è uguale al valore di <ph id="ph6">`obj`</ph>e la parte immaginaria è uguale a zero prima di eseguire il confronto.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</source>
          <target state="translated">Nell'esempio seguente viene illustrato questo mediante la ricerca di un numero complesso e un valore a virgola mobile a precisione doppia sono uguali.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>Use the <ph id="ph1">&lt;see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /&gt;</ph> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /&gt;</ph> metodo con cautela, poiché i due valori che sono apparentemente equivalenti possono essere considerati diversi a causa della diversa precisione dei relativi componenti reali e immaginarie.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>The problem can be accentuated if <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> must be converted to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> before performing the comparison.</source>
          <target state="translated">Il problema può essere accentuato se <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> deve essere convertito in un <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> prima di eseguire il confronto.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>The following example compares a complex number whose real component appears to be equal to a <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> value with that <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> value.</source>
          <target state="translated">L'esempio seguente confronta un numero complesso viene visualizzato il cui componente reale uguale a un <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> valore con cui <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>As the output shows, the comparison for equality returns <ph id="ph1">&lt;see langword="False" /&gt;</ph>.</source>
          <target state="translated">Come illustrato nell'output, il confronto di uguaglianza restituisce <ph id="ph1">&lt;see langword="False" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</source>
          <target state="translated">Una tecnica consigliata è definire un margine accettabile di differenza tra i due valori (ad esempio. 01% di uno dei componenti di reali e immaginarie valori dei) anziché il confronto dei valori per verificarne l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</source>
          <target state="translated">Se il valore assoluto della differenza tra i due valori è minore o uguale a margine, la differenza è probabilmente a causa delle differenze di precisione e, di conseguenza, i valori possono essere uguali.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>The following example uses this technique to compare the two values that the previous code example found to be unequal.</source>
          <target state="translated">Nell'esempio seguente usa questa tecnica per confrontare due valori di esempio di codice precedente risulta per essere uguali.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Equals(System.Object)">
          <source>It now finds them to be equal.</source>
          <target state="translated">Li trova ora siano uguali.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Exp(System.Numerics.Complex)">
          <source>A complex number that specifies a power.</source>
          <target state="translated">Numero complesso che specifica una potenza.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Exp(System.Numerics.Complex)">
          <source>Returns <ph id="ph1">&lt;see langword="e" /&gt;</ph> raised to the power specified by a complex number.</source>
          <target state="translated">Restituisce <ph id="ph1">&lt;see langword="e" /&gt;</ph> elevato alla potenza specificata da un numero complesso.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Exp(System.Numerics.Complex)">
          <source>The number <ph id="ph1">&lt;see langword="e" /&gt;</ph> raised to the power <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Numero <ph id="ph1">&lt;see langword="e" /&gt;</ph> elevato alla potenza <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Exp(System.Numerics.Complex)">
          <source>Use the <ph id="ph1">&lt;xref:System.Numerics.Complex.Pow%2A&gt;</ph> method to calculate the powers of other bases.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Numerics.Complex.Pow%2A&gt;</ph> metodo per calcolare le potenze di altre basi.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Exp(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Exp%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Exp%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Exp(System.Numerics.Complex)">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> is the inverse of <ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> è l'inverso del <ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Exp(System.Numerics.Complex)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Exp(System.Numerics.Complex)">
          <source>It shows that, with some allowance for the lack of precision of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type, passing the value returned by the <ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph> method to the <ph id="ph3">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> method returns the original <ph id="ph4">&lt;xref:System.Numerics.Complex&gt;</ph> value.</source>
          <target state="translated">Mostra che, con alcune concesso per la mancanza di precisione del <ph id="ph1">&lt;xref:System.Double&gt;</ph> tipo di dati, passando il valore restituito dal <ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph> metodo il <ph id="ph3">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> restituisce originale <ph id="ph4">&lt;xref:System.Numerics.Complex&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)">
          <source>The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</source>
          <target state="translated">La grandezza che è la distanza dall'origine (l'intersezione dell'asse x con l'asse y) al numero.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)">
          <source>The phase, which is the angle from the line to the horizontal axis, measured in radians.</source>
          <target state="translated">La fase che è l'angolo dalla riga all'asse orizzontale, espresso nei radianti.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)">
          <source>Creates a complex number from a point's polar coordinates.</source>
          <target state="translated">Crea un numero complesso dalle coordinate polari di un punto.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> method instantiates a complex number based on its polar coordinates.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> metodo crea un'istanza di un numero complesso in base alle coordinate polari.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)">
          <source>Because there are multiple representations of a point on a complex plane, the return value of the <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> method is normalized.</source>
          <target state="translated">Poiché esistono più rappresentazioni di un punto su un piano complesso, il valore restituito del <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> (metodo) è normalizzato.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)">
          <source>The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<ph id="ph1">&lt;xref:System.Math.PI&gt;</ph> to <ph id="ph2">&lt;xref:System.Math.PI&gt;</ph>.</source>
          <target state="translated">La grandezza viene normalizzata su un numero positivo e la fase viene normalizzata a un valore nell'intervallo compreso tra -<ph id="ph1">&lt;xref:System.Math.PI&gt;</ph> a <ph id="ph2">&lt;xref:System.Math.PI&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)">
          <source>As a result, the values of the <ph id="ph1">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> properties of the resulting complex number may not equal the original values of the <ph id="ph3">`magnitude`</ph> and <ph id="ph4">`phase`</ph> parameters.</source>
          <target state="translated">Di conseguenza, i valori del <ph id="ph1">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> le proprietà del numero complesso risulta potrebbero non essere uguali ai valori originali del <ph id="ph3">`magnitude`</ph> e <ph id="ph4">`phase`</ph> parametri.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)">
          <source>To convert a value from degrees to radians for the <ph id="ph1">`phase`</ph> parameter, multiply it by <ph id="ph2">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180.</source>
          <target state="translated">Per convertire un valore gradi in radianti per il <ph id="ph1">`phase`</ph> parametro, moltiplicarlo per  <ph id="ph2">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph> /180.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> method to instantiate a complex number based on its polar coordinates and then displays the value of its <ph id="ph2">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph> properties.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> metodo per creare un'istanza di un numero complesso in base alle coordinate polari e quindi Visualizza il valore della relativa <ph id="ph2">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.GetHashCode">
          <source>Returns the hash code for the current <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> object.</source>
          <target state="translated">Restituisce il codice hash per l'oggetto <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Codice hash di un intero con segno a 32 bit.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="P:System.Numerics.Complex.Imaginary">
          <source>Gets the imaginary component of the current <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> object.</source>
          <target state="translated">Ottiene il componente immaginario dell'oggetto <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Imaginary">
          <source>The imaginary component of a complex number.</source>
          <target state="translated">Componente immaginario di un numero complesso.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Imaginary">
          <source>Given a complex number a + bi, the <ph id="ph1">&lt;xref:System.Numerics.Complex.Imaginary%2A&gt;</ph> property returns the value of b.</source>
          <target state="translated">Dato un numero complesso a + bi, <ph id="ph1">&lt;xref:System.Numerics.Complex.Imaginary%2A&gt;</ph> proprietà restituisce il valore di b.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Imaginary">
          <source>The following example instantiates an array of <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> objects and displays the real and imaginary components of each in the form a + bi.</source>
          <target state="translated">Nell'esempio seguente viene creata un'istanza di una matrice di <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> degli oggetti e visualizza i componenti reali e immaginari di ciascuno di essi in forma a + bi.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="F:System.Numerics.Complex.ImaginaryOne">
          <source>Returns a new <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> instance with a real number equal to zero and an imaginary number equal to one.</source>
          <target state="translated">Restituisce una nuova istanza di <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> con un numero reale uguale a zero e un numero immaginario uguale a uno.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Numerics.Complex.ImaginaryOne">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> value by using the <ph id="ph2">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> property.</source>
          <target state="translated">Nell'esempio seguente viene creata un'istanza di un <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> valore utilizzando il <ph id="ph2">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Numerics.Complex.ImaginaryOne">
          <source>It then compares this value to another value that is instantiated by calling the <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> constructor with a real part equal to zero and an imaginary part equal to one.</source>
          <target state="translated">Consente quindi di confrontare questo valore su un altro valore che viene creata un'istanza chiamando il <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> costruttore con una parte reale uguale a zero e una parte immaginaria uguale a uno.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Numerics.Complex.ImaginaryOne">
          <source>As the output from the example shows, the two values are equal.</source>
          <target state="translated">Come illustrato nell'output dell'esempio, i due valori sono uguali.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="T:System.Numerics.Complex">
          <source>Returns the logarithm of a complex number.</source>
          <target state="translated">Restituisce il logaritmo di un numero complesso.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex)">
          <source>Returns the natural (base <ph id="ph1">&lt;see langword="e" /&gt;</ph>) logarithm of a specified complex number.</source>
          <target state="translated">Restituisce <ph id="ph1">&lt;see langword="e" /&gt;</ph>, la base del logaritmo naturale del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex)">
          <source>The natural (base <ph id="ph1">&lt;see langword="e" /&gt;</ph>) logarithm of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Logaritmo naturale (base <ph id="ph1">&lt;see langword="e" /&gt;</ph>) di <ph id="ph2">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex)">
          <source>It shows that, with some allowance for the lack of precision of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type, passing the value returned by the <ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph> method to the <ph id="ph3">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> method returns the original <ph id="ph4">&lt;xref:System.Numerics.Complex&gt;</ph> value.</source>
          <target state="translated">Mostra che, con alcune concesso per la mancanza di precisione del <ph id="ph1">&lt;xref:System.Double&gt;</ph> tipo di dati, passando il valore restituito dal <ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph> metodo il <ph id="ph3">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> restituisce originale <ph id="ph4">&lt;xref:System.Numerics.Complex&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)">
          <source>The base of the logarithm.</source>
          <target state="translated">Base del logaritmo.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)">
          <source>Returns the logarithm of a specified complex number in a specified base.</source>
          <target state="translated">Restituisce il logaritmo del numero complesso specificato nella base specificata.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)">
          <source>The logarithm of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in base <ph id="ph2">&lt;paramref name="baseValue" /&gt;</ph>.</source>
          <target state="translated">Logaritmo di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in base <ph id="ph2">&lt;paramref name="baseValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Log10(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Log10(System.Numerics.Complex)">
          <source>Returns the base-10 logarithm of a specified complex number.</source>
          <target state="translated">Restituisce il logaritmo in base 10 del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Log10(System.Numerics.Complex)">
          <source>The base-10 logarithm of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Logaritmo in base 10 di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Log10(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Log10%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Log10%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Log10%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Log10%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="P:System.Numerics.Complex.Magnitude">
          <source>Gets the magnitude (or absolute value) of a complex number.</source>
          <target state="translated">Ottiene la grandezza (o valore assoluto) di un numero complesso.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Magnitude">
          <source>The magnitude of the current instance.</source>
          <target state="translated">Grandezza dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Magnitude">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> property is equivalent to the absolute value of a complex number.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> proprietà è equivalente al valore assoluto di un numero complesso.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Magnitude">
          <source>It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</source>
          <target state="translated">Specifica la distanza dall'origine (l'intersezione dell'asse x e y nel sistema di coordinate cartesiano) al punto bidimensionale rappresentato da un numero complesso.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Magnitude">
          <source>The absolute value is calculated as follows:</source>
          <target state="translated">Il valore assoluto viene calcolato come segue:</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Magnitude">
          <source>&amp;#124; a + bi &amp;#124; = <ph id="ph1">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph>(a * a + b * b)</source>
          <target state="translated">&amp;#124; a + bi &amp;#124; = <ph id="ph1">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph>(a * a + b * b)</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Magnitude">
          <source>If the calculation of the absolute value results in an overflow, this property returns either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il calcolo del valore assoluto restituisce un overflow, questa proprietà restituisce <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Magnitude">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> and the <ph id="ph2">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph> properties define the position of a point that represents a complex number in the polar coordinate system.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph> definiscono la posizione di un punto che rappresenta un numero complesso nel sistema di coordinate polari.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Magnitude">
          <source>You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> method.</source>
          <target state="translated">È possibile creare un'istanza di un numero complesso in base alle coordinate polari anziché le coordinate Cartesiane chiamando il <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Magnitude">
          <source>The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> property.</source>
          <target state="translated">Nell'esempio seguente calcola il valore assoluto di un numero complesso e viene illustrato che è equivalente al valore del <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The first complex number to multiply.</source>
          <target state="translated">Primo numero complesso da moltiplicare.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The second complex number to multiply.</source>
          <target state="translated">Secondo numero complesso da moltiplicare.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Returns the product of two complex numbers.</source>
          <target state="translated">Restituisce il prodotto di due numeri complessi.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The product of the <ph id="ph1">&lt;paramref name="left" /&gt;</ph> and <ph id="ph2">&lt;paramref name="right" /&gt;</ph> parameters.</source>
          <target state="translated">Prodotto dei parametri <ph id="ph1">&lt;paramref name="left" /&gt;</ph> e <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</source>
          <target state="translated">La moltiplicazione di un oggetto complesso numero, +, bi e un secondo numero complesso, c + di, assume il formato seguente:</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>(ac - bd) + (ad + bc)i</source>
          <target state="translated">(ac - bd) + (ad + bc)i</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se la moltiplicazione produce un overflow nel componente reale o immaginario, il valore di tale componente è <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Multiply%2A&gt;</ph> method is implemented for languages that do not support custom operators.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Multiply%2A&gt;</ph> metodo viene implementato per lingue che non supportano gli operatori personalizzati.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Its behavior is identical to multiplication using the multiplication operator.</source>
          <target state="translated">Il comportamento è identico alla moltiplicazione utilizzando l'operatore di moltiplicazione.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The following example multiples a complex number by each element in an array of complex numbers.</source>
          <target state="translated">Nell'esempio seguente viene moltiplicato un numero complesso da ogni elemento in una matrice di numeri complessi.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Negate(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Negate(System.Numerics.Complex)">
          <source>Returns the additive inverse of a specified complex number.</source>
          <target state="translated">Restituisce l'inverso additivo di un numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Negate(System.Numerics.Complex)">
          <source>The result of the <ph id="ph1">&lt;see cref="P:System.Numerics.Complex.Real" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.Numerics.Complex.Imaginary" /&gt;</ph> components of the <ph id="ph3">&lt;paramref name="value" /&gt;</ph> parameter multiplied by -1.</source>
          <target state="translated">Risultato dei componenti <ph id="ph1">&lt;see cref="P:System.Numerics.Complex.Real" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.Numerics.Complex.Imaginary" /&gt;</ph> del parametro <ph id="ph3">&lt;paramref name="value" /&gt;</ph> moltiplicato per -1.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Negate(System.Numerics.Complex)">
          <source>The additive inverse of a complex number is a complex number that produces a value of <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> when it is added to the original complex number.</source>
          <target state="translated">L'inverso additivo di un numero complesso è un numero complesso che produce un valore di <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> quando questo viene aggiunto al numero complesso originale.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Negate(System.Numerics.Complex)">
          <source>This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</source>
          <target state="translated">Questo metodo restituisce un numero complesso in cui i componenti reali e immaginari del numero complesso originale vengono moltiplicati per -1.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Negate(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Negate%2A&gt;</ph> method is implemented for languages that do not support custom operators.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Negate%2A&gt;</ph> metodo viene implementato per lingue che non supportano gli operatori personalizzati.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Negate(System.Numerics.Complex)">
          <source>Its behavior is identical to negation using the unary negation operator, <ph id="ph1">&lt;xref:System.Numerics.Complex.op_UnaryNegation%2A&gt;</ph>.</source>
          <target state="translated">Il comportamento è identico alla negazione utilizzando l'operatore di negazione unario, <ph id="ph1">&lt;xref:System.Numerics.Complex.op_UnaryNegation%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Negate(System.Numerics.Complex)">
          <source>The following example obtains the additive inverse of each element in an array of complex numbers.</source>
          <target state="translated">Nell'esempio seguente si ottiene l'inverso additivo di ogni elemento in una matrice di numeri complessi.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="F:System.Numerics.Complex.One">
          <source>Returns a new <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> instance with a real number equal to one and an imaginary number equal to zero.</source>
          <target state="translated">Restituisce una nuova istanza di <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> con un numero reale uguale a uno e un numero immaginario uguale a zero.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Numerics.Complex.One">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> value by using the <ph id="ph2">&lt;xref:System.Numerics.Complex.One&gt;</ph> property.</source>
          <target state="translated">Nell'esempio seguente viene creata un'istanza di un <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> valore utilizzando il <ph id="ph2">&lt;xref:System.Numerics.Complex.One&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Numerics.Complex.One">
          <source>It then compares this value to another value that is instantiated by calling the <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> constructor with a real part equal to one and an imaginary part equal to zero.</source>
          <target state="translated">Consente quindi di confrontare questo valore su un altro valore che viene creata un'istanza chiamando il <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> costruttore con una parte reale uguale a uno e una parte immaginaria uguale a zero.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Numerics.Complex.One">
          <source>As the output from the example shows, the two values are equal.</source>
          <target state="translated">Come illustrato nell'output dell'esempio, i due valori sono uguali.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The first value to add.</source>
          <target state="translated">Primo valore da sommare.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The second value to add.</source>
          <target state="translated">Secondo valore da sommare.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Adds two complex numbers.</source>
          <target state="translated">Somma due numeri complessi.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The sum of <ph id="ph1">&lt;paramref name="left" /&gt;</ph> and <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated">Somma di <ph id="ph1">&lt;paramref name="left" /&gt;</ph> e <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Addition%2A&gt;</ph> method defines the addition operation for complex numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Addition%2A&gt;</ph> metodo definisce l'operazione di addizione per i numeri complessi.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>It enables code such as the following:</source>
          <target state="translated">Consente il codice seguente:</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</source>
          <target state="translated">L'aggiunta di un oggetto complesso numero, +, bi e un secondo numero complesso, c + di, assume il formato seguente:</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>(a + c) + (b + d)i</source>
          <target state="translated">(a + c) + (b + d)i</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>If the method call results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il chiamata al metodo restituisce un overflow il componente reale o immaginario, il valore di tale componente può essere <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%2A&gt;</ph> method instead.</source>
          <target state="translated">I linguaggi che non supportano gli operatori personalizzati possono chiamare il <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%2A&gt;</ph> metodo invece.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Il metodo equivalente per l'operatore è <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The following example illustrates addition with complex numbers.</source>
          <target state="translated">L'esempio seguente illustra l'addizione di numeri complessi.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The value to be divided.</source>
          <target state="translated">Valore da dividere.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The value to divide by.</source>
          <target state="translated">Valore per cui dividere.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Divides a specified complex number by another specified complex number.</source>
          <target state="translated">Divide un numero complesso specificato per un altro numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The result of dividing <ph id="ph1">&lt;paramref name="left" /&gt;</ph> by <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated">Risultato della divisione di <ph id="ph1">&lt;paramref name="left" /&gt;</ph> in base a <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Division%2A&gt;</ph> method defines the division operation for complex numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Division%2A&gt;</ph> metodo definisce l'operazione di divisione di numeri complessi.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>It enables code such as the following:</source>
          <target state="translated">Consente il codice seguente:</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</source>
          <target state="translated">La divisione di un oggetto complesso numero, +, bi e un secondo numero complesso, c + di, assume il formato seguente:</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>((ac + bd) / (c<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> + d<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>)) + ((bc - ad) / (c<bpt id="p3">&lt;sup&gt;</bpt>2<ept id="p3">&lt;/sup&gt;</ept> + d<bpt id="p4">&lt;sup&gt;</bpt>2<ept id="p4">&lt;/sup&gt;</ept>)i</source>
          <target state="translated">((AC + BD) / (c<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> + d<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>)) + ((bc-ad) / (c<bpt id="p3">&lt;sup&gt;</bpt>2<ept id="p3">&lt;/sup&gt;</ept> + d<bpt id="p4">&lt;sup&gt;</bpt>2<ept id="p4">&lt;/sup&gt;</ept>) è</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>If the division results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se la divisione produce un overflow nel componente reale o immaginario, il valore di tale componente è <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Languages that do not support custom operators and operator overloading can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Divide%2A&gt;</ph> method instead.</source>
          <target state="translated">Le lingue che non supportano gli operatori personalizzati e l'overload degli operatori è possono chiamare il <ph id="ph1">&lt;xref:System.Numerics.Complex.Divide%2A&gt;</ph> metodo invece.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Il metodo equivalente per l'operatore è <ph id="ph1">&lt;xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The first complex number to compare.</source>
          <target state="translated">Primo numero complesso da confrontare.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The second complex number to compare.</source>
          <target state="translated">Secondo numero complesso da confrontare.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Returns a value that indicates whether two complex numbers are equal.</source>
          <target state="translated">Restituisce un valore che indica se due numeri complessi sono uguali.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> parameters have the same value; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se i parametri <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> presentano lo stesso valore; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Equality%2A&gt;</ph> method defines the operation of the equality operator for <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> values.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Equality%2A&gt;</ph> metodo definisce il funzionamento dell'operatore di uguaglianza per <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> valori.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>It enables code such as the following:</source>
          <target state="translated">Consente il codice seguente:</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method instead.</source>
          <target state="translated">I linguaggi che non supportano gli operatori personalizzati possono chiamare il <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> metodo invece.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</source>
          <target state="translated">Due numeri complessi sono uguali se sono uguali le parti reali e quelle immaginarie sono uguali.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Equality%2A&gt;</ph> method is equivalent to the following expression:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Equality%2A&gt;</ph> metodo è equivalente all'espressione seguente:</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</source>
          <target state="translated">Si noti che, a causa delle differenze nella precisione, due numeri complessi che apparentemente equivalenti possono essere considerati non uguali.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>For more information and a possible workaround, see the <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method.</source>
          <target state="translated">Per ulteriori informazioni e una possibile soluzione alternativa, vedere il <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Il metodo equivalente per l'operatore è <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="T:System.Numerics.Complex">
          <source>Defines an explicit conversion between a <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> object and another type.</source>
          <target state="translated">Definisce una conversione esplicita tra un oggetto <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> e un altro tipo.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> value to a complex number.</source>
          <target state="translated">Definisce una conversione esplicita di un valore <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> in un numero complesso.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex">
          <source>A complex number that has a real component equal to <ph id="ph1">&lt;paramref name="value" /&gt;</ph> and an imaginary component equal to zero.</source>
          <target state="translated">Numero complesso contenente un componente reale uguale a <ph id="ph1">&lt;paramref name="value" /&gt;</ph> e un componente immaginario uguale a zero.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex">
          <source>Explicit conversion operators define types that can be converted to a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> object.</source>
          <target state="translated">Operatori di conversione espliciti definiscono i tipi che possono essere convertiti in un <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> in Visual Basic) is used.</source>
          <target state="translated">Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio <ph id="ph1">`CType`</ph> in Visual Basic) viene utilizzato.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">In caso contrario, visualizzano un errore del compilatore.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex">
          <source>The conversion of a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> value to the real part of a complex number can result in a loss of precision because a <ph id="ph2">&lt;xref:System.Double&gt;</ph>, which is the type of the complex number's <ph id="ph3">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> property, has fewer significant digits than a <ph id="ph4">&lt;xref:System.Decimal&gt;</ph>.</source>
          <target state="translated">La conversione di un <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valore per la parte reale di un numero complesso può comportare una perdita di precisione perché un <ph id="ph2">&lt;xref:System.Double&gt;</ph>, che è il tipo del valore del numero complesso <ph id="ph3">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> ha meno cifre significative rispetto a un <ph id="ph4">&lt;xref:System.Decimal&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex">
          <source>The following example illustrates the explicit conversion of <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> values to <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> values.</source>
          <target state="translated">Nell'esempio seguente viene illustrata la conversione esplicita di <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valori <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> valori.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value to a complex number.</source>
          <target state="translated">Definisce una conversione esplicita di un valore <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> in un numero complesso.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>A complex number that has a real component equal to <ph id="ph1">&lt;paramref name="value" /&gt;</ph> and an imaginary component equal to zero.</source>
          <target state="translated">Numero complesso contenente un componente reale uguale a <ph id="ph1">&lt;paramref name="value" /&gt;</ph> e un componente immaginario uguale a zero.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>Explicit conversion operators define types that can be converted to a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> object.</source>
          <target state="translated">Operatori di conversione espliciti definiscono i tipi che possono essere convertiti in un <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> in Visual Basic) is used.</source>
          <target state="translated">Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio <ph id="ph1">`CType`</ph> in Visual Basic) viene utilizzato.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">In caso contrario, visualizzano un errore del compilatore.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>The conversion of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value to the real part of a complex number can result in a loss of precision because a <ph id="ph2">&lt;xref:System.Double&gt;</ph>, which is the type of the complex number's <ph id="ph3">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> property, has fewer significant digits than a <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">La conversione di un <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valore per la parte reale di un numero complesso può comportare una perdita di precisione perché un <ph id="ph2">&lt;xref:System.Double&gt;</ph>, che è il tipo del valore del numero complesso <ph id="ph3">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> ha meno cifre significative rispetto a un <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>If the conversion is unsuccessful because the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is out of the range of the <ph id="ph2">&lt;xref:System.Double&gt;</ph> type, the operation does not throw an <ph id="ph3">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Se la conversione ha esito negativo perché la <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valore è compreso nell'intervallo del <ph id="ph2">&lt;xref:System.Double&gt;</ph> tipo, l'operazione non genera un <ph id="ph3">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>Instead, if <ph id="ph1">`value`</ph> is less than <ph id="ph2">&lt;xref:System.Double.MinValue&gt;</ph>, the result is a complex number that has a <ph id="ph3">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> property value equal to <ph id="ph4">&lt;xref:System.Double.NegativeInfinity&gt;</ph>.</source>
          <target state="translated">In alternativa, se <ph id="ph1">`value`</ph> è minore di <ph id="ph2">&lt;xref:System.Double.MinValue&gt;</ph>, il risultato è un numero complesso che ha un <ph id="ph3">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> uguale al valore della proprietà <ph id="ph4">&lt;xref:System.Double.NegativeInfinity&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>If <ph id="ph1">`value`</ph> is greater than <ph id="ph2">&lt;xref:System.Double.MaxValue&gt;</ph>, the result is a complex number that has a <ph id="ph3">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> property value equal to <ph id="ph4">&lt;xref:System.Double.PositiveInfinity&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è maggiore di <ph id="ph2">&lt;xref:System.Double.MaxValue&gt;</ph>, il risultato è un numero complesso che ha un <ph id="ph3">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> uguale al valore della proprietà <ph id="ph4">&lt;xref:System.Double.PositiveInfinity&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex">
          <source>The following example illustrates the explicit conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values to <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> values.</source>
          <target state="translated">Nell'esempio seguente viene illustrata la conversione esplicita di <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valori <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> valori.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="T:System.Numerics.Complex">
          <source>Defines an implicit conversion between a <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> object and another type.</source>
          <target state="translated">Definisce una conversione implicita tra un oggetto <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> e un altro tipo.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex">
          <source>Defines an implicit conversion of an unsigned byte to a complex number.</source>
          <target state="translated">Definisce una conversione implicita di un byte senza segno in un numero complesso.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter as its real part and zero as its imaginary part.</source>
          <target state="translated">Oggetto contenente il valore del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> come parte reale e zero come parte immaginaria.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operator define the types from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operatore definiscono i tipi da cui un compilatore può convertire automaticamente un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Essi sono di ampliamento che comporta la perdita di dati e non generano un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.Byte&gt;</ph> value to a complex number, as the following example shows.</source>
          <target state="translated">Questo overload consente al compilatore di gestire le conversioni da un <ph id="ph1">&lt;xref:System.Byte&gt;</ph> valore in un numero complesso, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex">
          <source>Note that the result of the conversion is a complex number whose real part is equal to the <ph id="ph1">&lt;xref:System.Byte&gt;</ph> value and whose imaginary part is equal to zero.</source>
          <target state="translated">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale al <ph id="ph1">&lt;xref:System.Byte&gt;</ph> valore e la parte immaginaria è uguale a zero.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex">
          <source>Defines an implicit conversion of a double-precision floating-point number to a complex number.</source>
          <target state="translated">Definisce una conversione implicita di un numero a virgola mobile a precisione doppia in un numero complesso.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter as its real part and zero as its imaginary part.</source>
          <target state="translated">Oggetto contenente il valore del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> come parte reale e zero come parte immaginaria.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operator define the types from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operatore definiscono i tipi da cui un compilatore può convertire automaticamente un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Essi sono di ampliamento che comporta la perdita di dati e non generano un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value to a complex number, as the following example shows.</source>
          <target state="translated">Questo overload consente al compilatore di gestire le conversioni da un <ph id="ph1">&lt;xref:System.Double&gt;</ph> valore in un numero complesso, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex">
          <source>Note that the result of the conversion is a complex number whose real part is equal to the <ph id="ph1">&lt;xref:System.Double&gt;</ph> value and whose imaginary part is equal to zero.</source>
          <target state="translated">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale al <ph id="ph1">&lt;xref:System.Double&gt;</ph> valore e la parte immaginaria è uguale a zero.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex">
          <source>Defines an implicit conversion of a 16-bit signed integer to a complex number.</source>
          <target state="translated">Definisce una conversione implicita di un intero con segno a 16 bit in un numero complesso.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter as its real part and zero as its imaginary part.</source>
          <target state="translated">Oggetto contenente il valore del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> come parte reale e zero come parte immaginaria.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operator define the types from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operatore definiscono i tipi da cui un compilatore può convertire automaticamente un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Essi sono di ampliamento che comporta la perdita di dati e non generano un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex">
          <source>This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</source>
          <target state="translated">Questo overload consente al compilatore di gestire le conversioni da un intero con segno a 16 bit in un numero complesso, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex">
          <source>Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</source>
          <target state="translated">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale a signed integer a 16 bit e la parte immaginaria è uguale a zero.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex">
          <source>Defines an implicit conversion of a 32-bit signed integer to a complex number.</source>
          <target state="translated">Definisce una conversione implicita di un Intero con segno a 32 bit in un numero complesso.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter as its real part and zero as its imaginary part.</source>
          <target state="translated">Oggetto contenente il valore del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> come parte reale e zero come parte immaginaria.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operator define the types from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operatore definiscono i tipi da cui un compilatore può convertire automaticamente un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Essi sono di ampliamento che comporta la perdita di dati e non generano un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex">
          <source>This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</source>
          <target state="translated">Questo overload consente al compilatore di gestire le conversioni da un intero con segno a 32 bit in un numero complesso, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex">
          <source>Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</source>
          <target state="translated">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale a signed integer a 32 bit e la parte immaginaria è uguale a zero.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex">
          <source>Defines an implicit conversion of a 64-bit signed integer to a complex number.</source>
          <target state="translated">Definisce una conversione implicita di un Intero con segno a 64 bit in un numero complesso.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter as its real part and zero as its imaginary part.</source>
          <target state="translated">Oggetto contenente il valore del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> come parte reale e zero come parte immaginaria.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operator define the types from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operatore definiscono i tipi da cui un compilatore può convertire automaticamente un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Essi sono di ampliamento che comporta la perdita di dati e non generano un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex">
          <source>This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</source>
          <target state="translated">Questo overload consente al compilatore di gestire le conversioni da un intero con segno a 64 bit in un numero complesso, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex">
          <source>Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</source>
          <target state="translated">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale a signed integer a 64 bit e la parte immaginaria è uguale a zero.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex">
          <source>Defines an implicit conversion of a signed byte to a complex number.</source>
          <target state="translated">Definisce una conversione implicita di un byte con segno in un numero complesso.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Questa API non è conforme a CLS.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter as its real part and zero as its imaginary part.</source>
          <target state="translated">Oggetto contenente il valore del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> come parte reale e zero come parte immaginaria.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operator define the types from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operatore definiscono i tipi da cui un compilatore può convertire automaticamente un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Essi sono di ampliamento che comporta la perdita di dati e non generano un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex">
          <source>This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</source>
          <target state="translated">Questo overload consente al compilatore di gestire le conversioni da un byte con segno a un numero complesso, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex">
          <source>Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</source>
          <target state="translated">Si noti che il risultato della conversione è un numero complesso è uguale al byte con segno la cui parte reale e immaginaria è uguale a zero.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex">
          <source>Defines an implicit conversion of a single-precision floating-point number to a complex number.</source>
          <target state="translated">Definisce una conversione implicita di un numero a virgola mobile a precisione singola in un numero complesso.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter as its real part and zero as its imaginary part.</source>
          <target state="translated">Oggetto contenente il valore del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> come parte reale e zero come parte immaginaria.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operator define the types from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operatore definiscono i tipi da cui un compilatore può convertire automaticamente un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Essi sono di ampliamento che comporta la perdita di dati e non generano un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value to a complex number, as the following example shows.</source>
          <target state="translated">Questo overload consente al compilatore di gestire le conversioni da un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valore in un numero complesso, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex">
          <source>Note that the result of the conversion is a complex number whose real part is equal to the <ph id="ph1">&lt;xref:System.Single&gt;</ph> value and whose imaginary part is equal to zero.</source>
          <target state="translated">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale al <ph id="ph1">&lt;xref:System.Single&gt;</ph> valore e la parte immaginaria è uguale a zero.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex">
          <source>Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</source>
          <target state="translated">Definisce una conversione implicita di un intero senza segno a 16 bit in un numero complesso.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Questa API non è conforme a CLS.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter as its real part and zero as its imaginary part.</source>
          <target state="translated">Oggetto contenente il valore del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> come parte reale e zero come parte immaginaria.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operator define the types from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operatore definiscono i tipi da cui un compilatore può convertire automaticamente un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Essi sono di ampliamento che comporta la perdita di dati e non generano un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex">
          <source>This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</source>
          <target state="translated">Questo overload consente al compilatore di gestire le conversioni da un intero senza segno a 16 bit in un numero complesso, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex">
          <source>Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</source>
          <target state="translated">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale a unsigned integer a 16 bit e la parte immaginaria è uguale a zero.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex">
          <source>Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</source>
          <target state="translated">Definisce una conversione implicita di un intero senza segno a 32 bit in un numero complesso.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Questa API non è conforme a CLS.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter as its real part and zero as its imaginary part.</source>
          <target state="translated">Oggetto contenente il valore del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> come parte reale e zero come parte immaginaria.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operator define the types from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operatore definiscono i tipi da cui un compilatore può convertire automaticamente un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Essi sono di ampliamento che comporta la perdita di dati e non generano un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex">
          <source>This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</source>
          <target state="translated">Questo overload consente al compilatore di gestire le conversioni da un intero senza segno a 32 bit in un numero complesso, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex">
          <source>Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</source>
          <target state="translated">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale a unsigned integer a 32 bit e la parte immaginaria è uguale a zero.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex">
          <source>The value to convert to a complex number.</source>
          <target state="translated">Valore da convertire in un numero complesso.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex">
          <source>Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</source>
          <target state="translated">Definisce una conversione implicita di un intero senza segno a 64 bit in un numero complesso.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Questa API non è conforme a CLS.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter as its real part and zero as its imaginary part.</source>
          <target state="translated">Oggetto contenente il valore del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> come parte reale e zero come parte immaginaria.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operator define the types from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">Gli overload di <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Implicit%2A&gt;</ph> operatore definiscono i tipi da cui un compilatore può convertire automaticamente un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> oggetto senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Essi sono di ampliamento che comporta la perdita di dati e non generano un <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex">
          <source>This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</source>
          <target state="translated">Questo overload consente al compilatore di gestire le conversioni da un intero senza segno a 64 bit in un numero complesso, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex">
          <source>Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</source>
          <target state="translated">Si noti che il risultato della conversione è un numero complesso la parte reale è uguale a unsigned integer a 64 bit e la parte immaginaria è uguale a zero.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The first value to compare.</source>
          <target state="translated">Primo valore da confrontare.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The second value to compare.</source>
          <target state="translated">Secondo valore da confrontare.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Returns a value that indicates whether two complex numbers are not equal.</source>
          <target state="translated">Restituisce un valore che indica se due numeri complessi non sono uguali.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are not equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> non sono uguali; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Equality%2A&gt;</ph> method defines the operation of the inequality operator for complex numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Equality%2A&gt;</ph> metodo definisce il funzionamento dell'operatore di disuguaglianza per i numeri complessi.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>It enables code such as the following:</source>
          <target state="translated">Consente il codice seguente:</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Languages that do not support custom operators can test for inequality by calling the <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method and reversing its value.</source>
          <target state="translated">I linguaggi che non supportano gli operatori personalizzati possono verificare la disuguaglianza chiamando il <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> (metodo) e l'inversione del relativo valore.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</source>
          <target state="translated">Si noti che, a causa delle differenze nella precisione, due numeri complessi che apparentemente equivalenti possono essere considerati non uguali.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>One possible workaround is to implement a comparison method that returns <ph id="ph1">`true`</ph> only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</source>
          <target state="translated">Una possibile soluzione alternativa consiste nell'implementare un metodo di confronto che restituisce <ph id="ph1">`true`</ph> solo se la differenza tra le due parti reali e immaginarie di numeri complessi supera una determinata soglia (ad esempio. 01% del valore del componente reale o immaginario di uno dei numeri complessi).</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method.</source>
          <target state="translated">Per altre informazioni, vedere il metodo <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The first value to multiply.</source>
          <target state="translated">Primo valore da moltiplicare.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The second value to multiply.</source>
          <target state="translated">Secondo valore da moltiplicare.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Multiplies two specified complex numbers.</source>
          <target state="translated">Moltiplica due numeri complessi specificati.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The product of <ph id="ph1">&lt;paramref name="left" /&gt;</ph> and <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated">Prodotto di <ph id="ph1">&lt;paramref name="left" /&gt;</ph> e <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Multiply%2A&gt;</ph> method defines the operation of the multiplication operator for complex numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Multiply%2A&gt;</ph> metodo definisce il funzionamento dell'operatore di moltiplicazione per i numeri complessi.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>It enables code such as the following:</source>
          <target state="translated">Consente il codice seguente:</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</source>
          <target state="translated">La moltiplicazione di un oggetto complesso numero, +, bi e un secondo numero complesso, c + di, assume il formato seguente:</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>(ac - bd) + (ad + bc)i</source>
          <target state="translated">(ac - bd) + (ad + bc)i</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se la moltiplicazione produce un overflow nel componente reale o immaginario, il valore di tale componente è <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Multiply%2A&gt;</ph> method instead.</source>
          <target state="translated">I linguaggi che non supportano gli operatori personalizzati possono chiamare il <ph id="ph1">&lt;xref:System.Numerics.Complex.Multiply%2A&gt;</ph> metodo invece.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Il metodo equivalente per l'operatore è <ph id="ph1">&lt;xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The value to subtract from (the minuend).</source>
          <target state="translated">Valore da cui sottrarre (minuendo).</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The value to subtract (the subtrahend).</source>
          <target state="translated">Valore da sottrarre (sottraendo).</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Subtracts a complex number from another complex number.</source>
          <target state="translated">Sottrae un numero complesso da un altro numero complesso.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The result of subtracting <ph id="ph1">&lt;paramref name="right" /&gt;</ph> from <ph id="ph2">&lt;paramref name="left" /&gt;</ph>.</source>
          <target state="translated">Risultato della sottrazione di <ph id="ph1">&lt;paramref name="right" /&gt;</ph> da <ph id="ph2">&lt;paramref name="left" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Subtraction%2A&gt;</ph> method defines the operation of the subtraction operator for complex numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Subtraction%2A&gt;</ph> metodo definisce il funzionamento dell'operatore di sottrazione di numeri complessi.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>It enables code such as the following:</source>
          <target state="translated">Consente il codice seguente:</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>If the method call results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il chiamata al metodo restituisce un overflow il componente reale o immaginario, il valore di tale componente può essere <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</source>
          <target state="translated">La sottrazione di un numero complesso, c + di, da un altro numero complesso, un + bi, assume il formato seguente:</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>(a - c) + (b - d)i</source>
          <target state="translated">(a - c) + (b - d)i</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Subtract%2A&gt;</ph> method instead.</source>
          <target state="translated">I linguaggi che non supportano gli operatori personalizzati possono chiamare il <ph id="ph1">&lt;xref:System.Numerics.Complex.Subtract%2A&gt;</ph> metodo invece.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Il metodo equivalente per l'operatore è <ph id="ph1">&lt;xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)">
          <source>The value to negate.</source>
          <target state="translated">Valore da negare.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)">
          <source>Returns the additive inverse of a specified complex number.</source>
          <target state="translated">Restituisce l'inverso additivo di un numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)">
          <source>The result of the <ph id="ph1">&lt;see cref="P:System.Numerics.Complex.Real" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.Numerics.Complex.Imaginary" /&gt;</ph> components of the <ph id="ph3">&lt;paramref name="value" /&gt;</ph> parameter multiplied by -1.</source>
          <target state="translated">Risultato dei componenti <ph id="ph1">&lt;see cref="P:System.Numerics.Complex.Real" /&gt;</ph> e <ph id="ph2">&lt;see cref="P:System.Numerics.Complex.Imaginary" /&gt;</ph> del parametro <ph id="ph3">&lt;paramref name="value" /&gt;</ph> moltiplicato per -1.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_UnaryNegation%2A&gt;</ph> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.op_UnaryNegation%2A&gt;</ph> metodo consente di definire il funzionamento dell'operatore di negazione (inverso additivo) unario per numeri complessi.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)">
          <source>It enables code such as the following:</source>
          <target state="translated">Consente il codice seguente:</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)">
          <source>The resulting complex number produces a value of <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> 0 (zero) when it is added to the original complex number.</source>
          <target state="translated">Numero complesso risultante produce un valore di <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> 0 (zero) quando viene aggiunto al numero complesso originale.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Negate%2A&gt;</ph> method instead.</source>
          <target state="translated">I linguaggi che non supportano gli operatori personalizzati possono chiamare il <ph id="ph1">&lt;xref:System.Numerics.Complex.Negate%2A&gt;</ph> metodo invece.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Il metodo equivalente per l'operatore è <ph id="ph1">&lt;xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="P:System.Numerics.Complex.Phase">
          <source>Gets the phase of a complex number.</source>
          <target state="translated">Ottiene la fase di un numero complesso.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Phase">
          <source>The phase of a complex number, in radians.</source>
          <target state="translated">Fase di un numero complesso, in radianti.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Phase">
          <source>For a complex number a + bi, the phase is computed as <ph id="ph1">&lt;xref:System.Math.Atan2%2A?displayProperty=nameWithType&gt;</ph>(b, a).</source>
          <target state="translated">Per un numero complesso un + bi, la fase viene calcolata come <ph id="ph1">&lt;xref:System.Math.Atan2%2A?displayProperty=nameWithType&gt;</ph>(b, una).</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Phase">
          <source>You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</source>
          <target state="translated">È possibile identificare un numero complesso dalle coordinate Cartesiane sul piano complesso o dalle relative coordinate polari.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Phase">
          <source>The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</source>
          <target state="translated">La fase (argomenti) di un numero complesso è l'angolo dell'asse reale di una linea disegnata dal punto di origine (l'intersezione dell'asse x e y) per il punto rappresentato dal numero complesso.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Phase">
          <source>The magnitude (represented by the <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> property) is the distance from the point of origin to the point that is represented by the complex number.</source>
          <target state="translated">La grandezza (rappresentato dal <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> proprietà) è la distanza tra il punto di origine e il punto rappresentato dal numero complesso.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Phase">
          <source>You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> method.</source>
          <target state="translated">È possibile creare un'istanza di un numero complesso in base alle coordinate polari anziché le coordinate Cartesiane chiamando il <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Phase">
          <source>To convert the phase from radians to degrees, multiply it by 180/<ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per convertire la fase da radianti in gradi, moltiplicarlo per 180 /<ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Phase">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <ph id="ph2">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph> properties.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> metodo per creare un'istanza di un numero complesso in base alle coordinate polari e quindi Visualizza il valore della relativa <ph id="ph2">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="T:System.Numerics.Complex">
          <source>Returns a specified complex number raised to a specified power.</source>
          <target state="translated">Restituisce il numero complesso specificato elevato a una potenza specificata.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)">
          <source>A complex number to be raised to a power.</source>
          <target state="translated">Numero complesso da elevare a una potenza.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)">
          <source>A double-precision floating-point number that specifies a power.</source>
          <target state="translated">Numero a virgola mobile a precisione doppia che specifica una potenza.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)">
          <source>Returns a specified complex number raised to a power specified by a double-precision floating-point number.</source>
          <target state="translated">Restituisce un numero complesso specificato elevato a una potenza specificata da un numero a virgola mobile a precisione doppia.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)">
          <source>The complex number <ph id="ph1">&lt;paramref name="value" /&gt;</ph> raised to the power <ph id="ph2">&lt;paramref name="power" /&gt;</ph>.</source>
          <target state="translated">Numero complesso <ph id="ph1">&lt;paramref name="value" /&gt;</ph> elevato alla potenza <ph id="ph2">&lt;paramref name="power" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)">
          <source>If <ph id="ph1">`value`</ph> is <ph id="ph2">&lt;xref:System.Numerics.Complex.Zero?displayProperty=nameWithType&gt;</ph>, the method returns <ph id="ph3">&lt;xref:System.Numerics.Complex.Zero?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> è <ph id="ph2">&lt;xref:System.Numerics.Complex.Zero?displayProperty=nameWithType&gt;</ph>, il metodo restituisce <ph id="ph3">&lt;xref:System.Numerics.Complex.Zero?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)">
          <source>For other values, if <ph id="ph1">`power`</ph> is 0, the method returns <ph id="ph2">&lt;xref:System.Numerics.Complex.One?displayProperty=nameWithType&gt;</ph>, and if <ph id="ph3">`power`</ph> is 1, it returns <ph id="ph4">`value`</ph>.</source>
          <target state="translated">Per altri valori, se <ph id="ph1">`power`</ph> è 0, il metodo restituisce <ph id="ph2">&lt;xref:System.Numerics.Complex.One?displayProperty=nameWithType&gt;</ph>e se <ph id="ph3">`power`</ph> è 1, restituisce <ph id="ph4">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Pow%2A?displayProperty=nameWithType&gt;</ph> method for primitive numeric types.</source>
          <target state="translated">Questo metodo corrisponde al <ph id="ph1">&lt;xref:System.Math.Pow%2A?displayProperty=nameWithType&gt;</ph> metodo per i tipi numerici primitivi.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)">
          <source>The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'elevamento a potenza utilizzando un numero complesso e un esponente il cui valore è compreso tra -1 a 10.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)">
          <source>A complex number to be raised to a power.</source>
          <target state="translated">Numero complesso da elevare a una potenza.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)">
          <source>A complex number that specifies a power.</source>
          <target state="translated">Numero complesso che specifica una potenza.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Returns a specified complex number raised to a power specified by a complex number.</source>
          <target state="translated">Restituisce un numero complesso specificato elevato a una potenza specificata da un numero complesso.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The complex number <ph id="ph1">&lt;paramref name="value" /&gt;</ph> raised to the power <ph id="ph2">&lt;paramref name="power" /&gt;</ph>.</source>
          <target state="translated">Numero complesso <ph id="ph1">&lt;paramref name="value" /&gt;</ph> elevato alla potenza <ph id="ph2">&lt;paramref name="power" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="P:System.Numerics.Complex.Real">
          <source>Gets the real component of the current <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> object.</source>
          <target state="translated">Ottiene il componente reale dell'oggetto <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Real">
          <source>The real component of a complex number.</source>
          <target state="translated">Componente reale di un numero complesso.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Real">
          <source>Given a complex number a + bi, the <ph id="ph1">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> property returns the value of a.</source>
          <target state="translated">Dato un numero complesso a + bi, <ph id="ph1">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> proprietà restituisce il valore di una.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.Complex.Real">
          <source>The following example instantiates an array of <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> objects and displays the real and imaginary components of each in the form a + bi.</source>
          <target state="translated">Nell'esempio seguente viene creata un'istanza di una matrice di <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> degli oggetti e visualizza i componenti reali e immaginari di ciascuno di essi in forma a + bi.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)">
          <source>Returns the multiplicative inverse of a complex number.</source>
          <target state="translated">Restituisce il reciproco moltiplicativo di un numero complesso.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)">
          <source>The reciprocal of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Reciproco di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)">
          <source>The reciprocal, or multiplicative inverse, of a number <bpt id="p1">*</bpt>x<ept id="p1">*</ept> is a number <bpt id="p2">*</bpt>y<ept id="p2">*</ept> where <bpt id="p3">*</bpt>x<ept id="p3">*</ept> multiplied by <bpt id="p4">*</bpt>y<ept id="p4">*</ept> yields 1.</source>
          <target state="translated">Il reciproco o inverso moltiplicativo, di un numero <bpt id="p1">*</bpt>x<ept id="p1">*</ept> è un numero <bpt id="p2">*</bpt>y<ept id="p2">*</ept> in <bpt id="p3">*</bpt>x<ept id="p3">*</ept> moltiplicato per <bpt id="p4">*</bpt>y<ept id="p4">*</ept> restituisce 1.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)">
          <source>The reciprocal of a complex number is the complex number that produces <ph id="ph1">&lt;xref:System.Numerics.Complex.One?displayProperty=nameWithType&gt;</ph> when the two numbers are multiplied.</source>
          <target state="translated">Il reciproco di un numero complesso è il numero complesso che produce <ph id="ph1">&lt;xref:System.Numerics.Complex.One?displayProperty=nameWithType&gt;</ph> quando vengono moltiplicati i due numeri.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)">
          <source>If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept>+b<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>) + -b/(a<bpt id="p3">&lt;sup&gt;</bpt>2<ept id="p3">&lt;/sup&gt;</ept> + b<bpt id="p4">&lt;sup&gt;</bpt>2<ept id="p4">&lt;/sup&gt;</ept>).</source>
          <target state="translated">Se un numero complesso è rappresentato da una a + bi, il suo reciproco è rappresentato dall'espressione un / (un<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept>+ b<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>) + b-/ (un<bpt id="p3">&lt;sup&gt;</bpt>2<ept id="p3">&lt;/sup&gt;</ept> + b<bpt id="p4">&lt;sup&gt;</bpt>2<ept id="p4">&lt;/sup&gt;</ept>).</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)">
          <source>If value is <ph id="ph1">&lt;xref:System.Numerics.Complex.Zero?displayProperty=nameWithType&gt;</ph>, the method returns <ph id="ph2">&lt;xref:System.Numerics.Complex.Zero?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il valore è <ph id="ph1">&lt;xref:System.Numerics.Complex.Zero?displayProperty=nameWithType&gt;</ph>, il metodo restituisce <ph id="ph2">&lt;xref:System.Numerics.Complex.Zero?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)">
          <source>Otherwise, it returns the result of the expression <ph id="ph1">&lt;xref:System.Numerics.Complex.One?displayProperty=nameWithType&gt;</ph><ph id="ph2">/</ph><ph id="ph3">`value`</ph>.</source>
          <target state="translated">In caso contrario, restituisce il risultato dell'espressione <ph id="ph1">&lt;xref:System.Numerics.Complex.One?displayProperty=nameWithType&gt;</ph> <ph id="ph2">/</ph> <ph id="ph3">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Numerics.Complex.Reciprocal%2A&gt;</ph> method to calculate the reciprocal values of several complex numbers.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Numerics.Complex.Reciprocal%2A&gt;</ph> metodo per calcolare i valori reciproci di diversi numeri complessi.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)">
          <source>It also demonstrates that the result of multiplying a complex number by its reciprocal is <ph id="ph1">&lt;xref:System.Numerics.Complex.One?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Viene inoltre illustrato che è il risultato della moltiplicazione tra un numero complesso e il suo reciproco <ph id="ph1">&lt;xref:System.Numerics.Complex.One?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Sin(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Sin(System.Numerics.Complex)">
          <source>Returns the sine of the specified complex number.</source>
          <target state="translated">Restituisce il seno del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Sin(System.Numerics.Complex)">
          <source>The sine of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Seno di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sin(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Sin%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Sin%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sin(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> method uses the following formula to calculate the sine of the complex number a + bi:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> metodo utilizza la formula seguente per calcolare il seno del numero complesso a + bi:</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sin(System.Numerics.Complex)">
          <source>(<ph id="ph1">&lt;xref:System.Math.Sin%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cosh%2A&gt;</ph>(b), <ph id="ph3">&lt;xref:System.Math.Cos%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sinh%2A&gt;</ph>(b))</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Math.Sin%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cosh%2A&gt;</ph>(b), <ph id="ph3">&lt;xref:System.Math.Cos%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sinh%2A&gt;</ph>(b))</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sin(System.Numerics.Complex)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sin(System.Numerics.Complex)">
          <source>It shows that passing the value returned by the <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> method to the <ph id="ph2">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> method returns the original <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> value.</source>
          <target state="translated">Viene illustrato che il valore restituito dal passaggio il <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> metodo il <ph id="ph2">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> restituisce originale <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)">
          <source>Returns the hyperbolic sine of the specified complex number.</source>
          <target state="translated">Restituisce il seno iperbolico del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)">
          <source>The hyperbolic sine of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Seno iperbolico di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Sinh%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Sinh%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Sinh%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Sinh%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Sinh%2A&gt;</ph> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Sinh%2A&gt;</ph> metodo utilizza la formula seguente per calcolare il seno iperbolico del numero complesso a + bi:</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)">
          <source>(<ph id="ph1">&lt;xref:System.Math.Sinh%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cos%2A&gt;</ph>(b), <ph id="ph3">&lt;xref:System.Math.Cosh%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sin%2A&gt;</ph>(b))</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Math.Sinh%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cos%2A&gt;</ph>(b), <ph id="ph3">&lt;xref:System.Math.Cosh%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sin%2A&gt;</ph>(b))</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)">
          <source>Returns the square root of a specified complex number.</source>
          <target state="translated">Restituisce la radice quadrata del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)">
          <source>The square root of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Radice quadrata di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)">
          <source>The square root of the complex number <ph id="ph1">`value`</ph> is calculated by using the following formula:</source>
          <target state="translated">La radice quadrata del numero complesso <ph id="ph1">`value`</ph> viene calcolato utilizzando la formula seguente:</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType&gt;</ph>(<ph id="ph2">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph>(<ph id="ph3">`value`</ph>.<ph id="ph4">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph>), <ph id="ph5">`value`</ph>.<ph id="ph6">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph>/2.0)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType&gt;</ph>(<ph id="ph2">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph>(<ph id="ph3">`value`</ph>.<ph id="ph4">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph>), <ph id="ph5">`value`</ph>.<ph id="ph6">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph>/2.0)</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Sqrt%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Sqrt%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Sqrt%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The value to subtract from (the minuend).</source>
          <target state="translated">Valore da cui sottrarre (minuendo).</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The value to subtract (the subtrahend).</source>
          <target state="translated">Valore da sottrarre (sottraendo).</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Subtracts one complex number from another and returns the result.</source>
          <target state="translated">Sottrae un numero complesso da un altro e restituisce il risultato.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The result of subtracting <ph id="ph1">&lt;paramref name="right" /&gt;</ph> from <ph id="ph2">&lt;paramref name="left" /&gt;</ph>.</source>
          <target state="translated">Risultato della sottrazione di <ph id="ph1">&lt;paramref name="right" /&gt;</ph> da <ph id="ph2">&lt;paramref name="left" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</source>
          <target state="translated">La sottrazione di un numero complesso, c + di, da un altro numero complesso, un + bi, assume il formato seguente:</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)">
          <source>(a - c) + (b - d)i</source>
          <target state="translated">(a - c) + (b - d)i</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)">
          <source>If the method call results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il chiamata al metodo restituisce un overflow il componente reale o immaginario, il valore di tale componente può essere <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)">
          <source>Languages that do not support custom operators can use the <ph id="ph1">&lt;xref:System.Numerics.Complex.Subtract%2A&gt;</ph> method to perform subtraction using complex numbers.</source>
          <target state="translated">I linguaggi che non supportano gli operatori personalizzati possono utilizzare il <ph id="ph1">&lt;xref:System.Numerics.Complex.Subtract%2A&gt;</ph> metodo per eseguire sottrazioni utilizzando numeri complessi.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)">
          <source>The following example subtracts each complex number in an array from a complex number.</source>
          <target state="translated">Nell'esempio seguente viene sottratto ogni numero complesso in una matrice da un numero complesso.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Tan(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Tan(System.Numerics.Complex)">
          <source>Returns the tangent of the specified complex number.</source>
          <target state="translated">Restituisce la tangente del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Tan(System.Numerics.Complex)">
          <source>The tangent of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Tangente di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Tan(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Tan%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Tan%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Tan(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> method uses the following formula to calculate the tangent of the complex number <ph id="ph2">`value`</ph>:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> metodo utilizza la formula seguente per calcolare la tangente del numero complesso <ph id="ph2">`value`</ph>:</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Tan(System.Numerics.Complex)">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph>(<ph id="ph2">`value`</ph>) / <ph id="ph3">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph>(<ph id="ph4">`value`</ph>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph>(<ph id="ph2">`value`</ph>) / <ph id="ph3">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph>(<ph id="ph4">`value`</ph>)</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Tan(System.Numerics.Complex)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> method.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Tan(System.Numerics.Complex)">
          <source>It shows that passing the value returned by the <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> method to the <ph id="ph2">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> method returns the original <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> value.</source>
          <target state="translated">Viene illustrato che il valore restituito dal passaggio il <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> metodo il <ph id="ph2">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> restituisce originale <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)">
          <source>A complex number.</source>
          <target state="translated">Numero complesso.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)">
          <source>Returns the hyperbolic tangent of the specified complex number.</source>
          <target state="translated">Restituisce la tangente iperbolica del numero complesso specificato.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)">
          <source>The hyperbolic tangent of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Tangente iperbolica di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Tanh%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Tanh%2A?displayProperty=nameWithType&gt;</ph> method for real numbers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Tanh%2A&gt;</ph> metodo per i numeri complessi corrisponde alla <ph id="ph2">&lt;xref:System.Math.Tanh%2A?displayProperty=nameWithType&gt;</ph> metodo per i numeri reali.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Tanh%2A&gt;</ph> method uses the following formula to calculate the hyperbolic tangent of the complex number <ph id="ph2">`value`</ph>:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Tanh%2A&gt;</ph> metodo utilizza la formula seguente per calcolare la tangente iperbolica del numero complesso <ph id="ph2">`value`</ph>:</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex.Sinh%2A&gt;</ph>(<ph id="ph2">`value`</ph>) / <ph id="ph3">&lt;xref:System.Numerics.Complex.Cosh%2A&gt;</ph>(<ph id="ph4">`value`</ph>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.Complex.Sinh%2A&gt;</ph>(<ph id="ph2">`value`</ph>) / <ph id="ph3">&lt;xref:System.Numerics.Complex.Cosh%2A&gt;</ph>(<ph id="ph4">`value`</ph>)</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="T:System.Numerics.Complex">
          <source>Converts the value of a complex number to its equivalent string representation.</source>
          <target state="translated">Converte il valore di un numero complesso nella relativa rappresentazione di stringa equivalente.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString">
          <source>Converts the value of the current complex number to its equivalent string representation in Cartesian form.</source>
          <target state="translated">Converte il valore del numero complesso corrente nella relativa rappresentazione di stringa equivalente in formato cartesiano.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString">
          <source>The string representation of the current instance in Cartesian form.</source>
          <target state="translated">Rappresentazione di stringa dell'istanza corrente in formato cartesiano.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString">
          <source>The default string representation of a complex number displays the number using its Cartesian coordinates in the form <ph id="ph1">`(`</ph><bpt id="p1">*</bpt>a<ept id="p1">*</ept><ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, where <bpt id="p3">*</bpt>a<ept id="p3">*</ept> is the real part of the complex number, and <bpt id="p4">*</bpt>b<ept id="p4">*</ept> is its imaginary part.</source>
          <target state="translated">La rappresentazione di stringa del valore predefinito di un numero complesso visualizza il numero usando le coordinate Cartesiane nel formato <ph id="ph1">`(`</ph> <bpt id="p1">*</bpt>un<ept id="p1">*</ept> <ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, dove <bpt id="p3">*</bpt>un<ept id="p3">*</ept> è la parte reale del numero complesso, e <bpt id="p4">*</bpt>b<ept id="p4">*</ept> è la parte immaginaria.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString">
          <source>Both <bpt id="p1">*</bpt>a<ept id="p1">*</ept> and <bpt id="p2">*</bpt>b<ept id="p2">*</ept> are formatted using the general format specifier ("G") and the conventions of the current system culture.</source>
          <target state="translated">Entrambi <bpt id="p1">*</bpt>un<ept id="p1">*</ept> e <bpt id="p2">*</bpt>b<ept id="p2">*</ept> vengono formattati utilizzando l'identificatore di formato generale ("G") e le convenzioni delle impostazioni cultura correnti del sistema.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString">
          <source>The following example displays the string representation of several complex numbers.</source>
          <target state="translated">L'esempio seguente mostra la rappresentazione di stringa di diversi numeri complessi.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString">
          <source>The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</source>
          <target state="translated">L'output utilizza le convenzioni di formattazione delle impostazioni cultura inglese - impostazioni cultura di Stati Uniti ("en-US"), ovvero, in questo caso, la lingua corrente.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</source>
          <target state="translated">Converte il valore del numero complesso corrente nella relativa rappresentazione di stringa equivalente in formato cartesiano usando le informazioni di formattazione relative alle impostazioni cultura specificate.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>The string representation of the current instance in Cartesian form, as specified by <ph id="ph1">&lt;paramref name="provider" /&gt;</ph>.</source>
          <target state="translated">Rappresentazione di stringa dell'istanza corrente in formato cartesiano, come specificato da <ph id="ph1">&lt;paramref name="provider" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form <ph id="ph1">`(`</ph><bpt id="p1">*</bpt>a<ept id="p1">*</ept><ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, where <bpt id="p3">*</bpt>a<ept id="p3">*</ept> is the real part of the complex number, and <bpt id="p4">*</bpt>b<ept id="p4">*</ept> is its imaginary part.</source>
          <target state="translated">La rappresentazione di stringa del numero complesso restituito da questo metodo visualizza il numero usando le coordinate Cartesiane nel formato <ph id="ph1">`(`</ph> <bpt id="p1">*</bpt>un<ept id="p1">*</ept> <ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, dove <bpt id="p3">*</bpt>un<ept id="p3">*</ept> è la parte reale del numero complesso, e <bpt id="p4">*</bpt>b<ept id="p4">*</ept> è la parte immaginaria.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>Both <bpt id="p1">*</bpt>a<ept id="p1">*</ept> and <bpt id="p2">*</bpt>b<ept id="p2">*</ept> are formatted using the general format specifier ("G") and the conventions of the culture defined by <ph id="ph1">`provider`</ph>.</source>
          <target state="translated">Entrambi <bpt id="p1">*</bpt>un<ept id="p1">*</ept> e <bpt id="p2">*</bpt>b<ept id="p2">*</ept> vengono formattati utilizzando l'identificatore di formato generale ("G") e le convenzioni delle impostazioni cultura definite da <ph id="ph1">`provider`</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
          <target state="translated">Il <ph id="ph1">`provider`</ph> parametro è un <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementazione.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</source>
          <target state="translated">Il relativo <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> metodo restituisce un <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> oggetto che fornisce informazioni specifiche delle impostazioni cultura sul formato di numeri reali e immaginari nella stringa restituita.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the returned string is formatted using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
          <target state="translated">Se <ph id="ph1">`provider`</ph> è <ph id="ph2">`null`</ph>, la stringa restituita viene formattata utilizzando il <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> oggetto delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter can be one of the following:</source>
          <target state="translated">Il <ph id="ph1">`provider`</ph> parametro può essere uno dei seguenti:</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> oggetto che rappresenta le impostazioni cultura che fornisce informazioni di formattazione</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> oggetto che fornisce informazioni di formattazione.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>A custom object that implements the <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interface.</source>
          <target state="translated">Un oggetto personalizzato che implementa il <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
          <target state="translated">Il relativo <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> metodo restituisce il <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> oggetto che fornisce informazioni di formattazione.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>The following example displays the string representation of several complex numbers.</source>
          <target state="translated">L'esempio seguente mostra la rappresentazione di stringa di diversi numeri complessi.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.IFormatProvider)">
          <source>The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</source>
          <target state="translated">Il risultato utilizza convenzioni di formattazione per l'inglese - Stati Uniti ("en-US") e il francese - impostazioni cultura Francia ("fr-FR").</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>A standard or custom numeric format string.</source>
          <target state="translated">Stringa di formato numerico standard o personalizzato.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</source>
          <target state="translated">Converte il valore del numero complesso corrente nella relativa rappresentazione di stringa equivalente in formato cartesiano usando il formato specificato per le parti reale e immaginaria.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>The string representation of the current instance in Cartesian form.</source>
          <target state="translated">Rappresentazione di stringa dell'istanza corrente in formato cartesiano.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form <ph id="ph1">`(`</ph><bpt id="p1">*</bpt>a<ept id="p1">*</ept><ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, where <bpt id="p3">*</bpt>a<ept id="p3">*</ept> is the real part of the complex number, and <bpt id="p4">*</bpt>b<ept id="p4">*</ept> is its imaginary part.</source>
          <target state="translated">La rappresentazione di stringa del numero complesso restituito da questo metodo visualizza il numero usando le coordinate Cartesiane nel formato <ph id="ph1">`(`</ph> <bpt id="p1">*</bpt>un<ept id="p1">*</ept> <ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, dove <bpt id="p3">*</bpt>un<ept id="p3">*</ept> è la parte reale del numero complesso, e <bpt id="p4">*</bpt>b<ept id="p4">*</ept> è la parte immaginaria.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>Both <bpt id="p1">*</bpt>a<ept id="p1">*</ept> and <bpt id="p2">*</bpt>b<ept id="p2">*</ept> are formatted using the format string specified by <ph id="ph1">`format`</ph>.</source>
          <target state="translated">Entrambi <bpt id="p1">*</bpt>un<ept id="p1">*</ept> e <bpt id="p2">*</bpt>b<ept id="p2">*</ept> vengono formattati usando la stringa di formato specificata da <ph id="ph1">`format`</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</source>
          <target state="translated">Il <ph id="ph1">`format`</ph> parametro può essere qualsiasi identificatore di formato numerico standard valido, o qualsiasi combinazione di identificatori di formato numerico personalizzate.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>If <ph id="ph1">`format`</ph> is equal to <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> or is <ph id="ph3">`null`</ph>, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</source>
          <target state="translated">Se <ph id="ph1">`format`</ph> è uguale a <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">`null`</ph>, le parti reale e immaginarie del numero complesso vengono formattate con l'identificatore di formato generale ("G").</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>If <ph id="ph1">`format`</ph> is any other value, the method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`format`</ph> è qualsiasi altro valore, il metodo genera un <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</source>
          <target state="translated">.NET Framework fornisce supporto di formattazione completo, come descritto in maggior dettaglio negli argomenti seguenti:</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>For more information about numeric format strings, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulle stringhe di formato numerico, vedere <bpt id="p1">[</bpt>stringhe di formato numerico Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> e <bpt id="p2">[</bpt>stringhe di formato numerico personalizzato<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>For more information about formatting in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla formattazione in .NET Framework, vedere <bpt id="p1">[</bpt>formattazione dei tipi di<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>The format of the returned string is determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
          <target state="translated">Il formato della stringa restituita è determinato dal <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> oggetto per le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>Depending on the <ph id="ph1">`format`</ph> parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</source>
          <target state="translated">A seconda di <ph id="ph1">`format`</ph> parametro, questo oggetto controlla i simboli, ad esempio il segno negativo, il separatore di gruppo e il simbolo di separatore decimale nella stringa di output.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>To provide formatting information for cultures other than the current culture, call the <ph id="ph1">&lt;xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> overload.</source>
          <target state="translated">Per fornire informazioni di formattazione per le impostazioni cultura diverse da quelle correnti, chiamare il <ph id="ph1">&lt;xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> rapporto di overload.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source>The following example initializes a complex number and displays it using several standard format strings.</source>
          <target state="translated">Nell'esempio seguente consente di inizializzare un numero complesso e viene visualizzata mediante diverse stringhe di formato standard.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.String)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is not a valid format string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> non è una stringa di formato valida.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>A standard or custom numeric format string.</source>
          <target state="translated">Stringa di formato numerico standard o personalizzato.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</source>
          <target state="translated">Converte il valore del numero complesso corrente nella relativa rappresentazione di stringa equivalente in formato cartesiano usando il formato specificato e le informazioni sul formato relative alle impostazioni cultura per le parti reale e immaginaria.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>The string representation of the current instance in Cartesian form, as specified by <ph id="ph1">&lt;paramref name="format" /&gt;</ph> and <ph id="ph2">&lt;paramref name="provider" /&gt;</ph>.</source>
          <target state="translated">Rappresentazione di stringa dell'istanza corrente in formato cartesiano, come specificato da <ph id="ph1">&lt;paramref name="format" /&gt;</ph> e da <ph id="ph2">&lt;paramref name="provider" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form <ph id="ph1">`(`</ph><bpt id="p1">*</bpt>a<ept id="p1">*</ept><ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, where <bpt id="p3">*</bpt>a<ept id="p3">*</ept> is the real part of the complex number, and <bpt id="p4">*</bpt>b<ept id="p4">*</ept> is its imaginary part.</source>
          <target state="translated">La rappresentazione di stringa del numero complesso restituito da questo metodo visualizza il numero usando le coordinate Cartesiane nel formato <ph id="ph1">`(`</ph> <bpt id="p1">*</bpt>un<ept id="p1">*</ept> <ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, dove <bpt id="p3">*</bpt>un<ept id="p3">*</ept> è la parte reale del numero complesso, e <bpt id="p4">*</bpt>b<ept id="p4">*</ept> è la parte immaginaria.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>Both <bpt id="p1">*</bpt>a<ept id="p1">*</ept> and <bpt id="p2">*</bpt>b<ept id="p2">*</ept> are formatted using the format string specified by <ph id="ph1">`format`</ph>.</source>
          <target state="translated">Entrambi <bpt id="p1">*</bpt>un<ept id="p1">*</ept> e <bpt id="p2">*</bpt>b<ept id="p2">*</ept> vengono formattati usando la stringa di formato specificata da <ph id="ph1">`format`</ph>.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</source>
          <target state="translated">Il <ph id="ph1">`format`</ph> parametro può essere qualsiasi identificatore di formato numerico standard valido, o qualsiasi combinazione di identificatori di formato numerico personalizzate.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>If <ph id="ph1">`format`</ph> is equal to <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> or is <ph id="ph3">`null`</ph>, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</source>
          <target state="translated">Se <ph id="ph1">`format`</ph> è uguale a <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">`null`</ph>, le parti reale e immaginarie del numero complesso vengono formattate con l'identificatore di formato generale ("G").</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>If <ph id="ph1">`format`</ph> is any other value, the method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`format`</ph> è qualsiasi altro valore, il metodo genera un <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</source>
          <target state="translated">.NET Framework fornisce supporto di formattazione completo, come descritto in maggior dettaglio negli argomenti seguenti:</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>For more information about numeric format strings, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulle stringhe di formato numerico, vedere <bpt id="p1">[</bpt>stringhe di formato numerico Standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> e <bpt id="p2">[</bpt>stringhe di formato numerico personalizzato<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>For more information about formatting in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla formattazione in .NET Framework, vedere <bpt id="p1">[</bpt>formattazione dei tipi di<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
          <target state="translated">Il <ph id="ph1">`provider`</ph> parametro è un <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementazione.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</source>
          <target state="translated">Il relativo <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> metodo restituisce un <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> oggetto che fornisce informazioni specifiche delle impostazioni cultura sul formato di numeri reali e immaginari nella stringa restituita.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>Depending on the <ph id="ph1">`format`</ph> parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</source>
          <target state="translated">A seconda di <ph id="ph1">`format`</ph> parametro, questo oggetto controlla i simboli, ad esempio il segno negativo, il separatore di gruppo e il simbolo di separatore decimale nella stringa di output.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the returned string is formatted using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
          <target state="translated">Se <ph id="ph1">`provider`</ph> è <ph id="ph2">`null`</ph>, la stringa restituita viene formattata utilizzando il <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> oggetto delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter can be one of the following:</source>
          <target state="translated">Il <ph id="ph1">`provider`</ph> parametro può essere uno dei seguenti:</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> oggetto che rappresenta le impostazioni cultura che fornisce informazioni di formattazione</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> oggetto che fornisce informazioni di formattazione.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>A custom object that implements the <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interface.</source>
          <target state="translated">Un oggetto personalizzato che implementa il <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
          <target state="translated">Il relativo <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> metodo restituisce il <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> oggetto che fornisce informazioni di formattazione.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source>The following example creates an array of complex numbers, and displays each using several standard format strings as well as <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</source>
          <target state="translated">Nell'esempio seguente crea una matrice di numeri complessi e vengono visualizzati utilizzando diverse stringhe di formato standard nonché <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> gli oggetti che rappresentano le impostazioni cultura inglese - Stati Uniti ("en-US") e il francese - Francia ("fr-FR").</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is not a valid format string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> non è una stringa di formato valida.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="F:System.Numerics.Complex.Zero">
          <source>Returns a new <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> instance with a real number equal to zero and an imaginary number equal to zero.</source>
          <target state="translated">Restituisce una nuova istanza di <ph id="ph1">&lt;see cref="T:System.Numerics.Complex" /&gt;</ph> con un numero reale uguale a zero e un numero immaginario uguale a zero.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Numerics.Complex.Zero">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Zero&gt;</ph> property is most frequently used to compare a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> value to zero.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Numerics.Complex.Zero&gt;</ph> proprietà viene utilizzata più di frequente per confrontare un <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> valore su zero.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Numerics.Complex.Zero">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> value by using the <ph id="ph2">&lt;xref:System.Numerics.Complex.Zero&gt;</ph> property.</source>
          <target state="translated">Nell'esempio seguente viene creata un'istanza di un <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> valore utilizzando il <ph id="ph2">&lt;xref:System.Numerics.Complex.Zero&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Numerics.Complex.Zero">
          <source>It then compares this value to another value that is instantiated by calling the <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> constructor with a real part equal to zero and an imaginary part equal to zero.</source>
          <target state="translated">Consente quindi di confrontare questo valore su un altro valore che viene creata un'istanza chiamando il <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> costruttore con una parte reale uguale a zero e una parte immaginaria uguale a zero.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Numerics.Complex.Zero">
          <source>As the output from the example shows, the two values are equal.</source>
          <target state="translated">Come illustrato nell'output dell'esempio, i due valori sono uguali.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>