<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="efd418e89cc117ce9591fb47a62b60bea717ad41" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36549255" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Rappresenta un intero con segno arbitrariamente grande.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger> è un tipo immutabile che rappresenta un integer arbitrariamente grande il cui valore in teoria non dispone di alcun inferiori o superiori. I membri del <xref:System.Numerics.BigInteger> tipo sono strettamente paralleli a quelli di altri tipi integrali (la <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, e <xref:System.UInt64> tipi). Questo tipo è diverso da altri tipi integrali nel [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], che dispone di un intervallo indicato da loro `MinValue` e `MaxValue` proprietà.  
  
> [!NOTE]
>  Poiché il <xref:System.Numerics.BigInteger> tipo non è modificabile (vedere [modificabilità e la struttura BigInteger](#mutability)) e non prevede alcun limite superiore o inferiore, un <xref:System.OutOfMemoryException> possono essere generate per qualsiasi operazione che causa un <xref:System.Numerics.BigInteger> valore aumento delle dimensioni troppo grande.  
  
## <a name="instantiating-a-biginteger-object"></a>Creazione di un oggetto BigInteger  
 È possibile creare un'istanza di un <xref:System.Numerics.BigInteger> oggetto in diversi modi:  
  
-   È possibile usare il `new` (parola chiave) e indicare qualsiasi valore integrale o a virgola mobile come parametro per il <xref:System.Numerics.BigInteger> costruttore. (Valori a virgola mobile vengono troncati prima che vengano assegnati per il <xref:System.Numerics.BigInteger>.) Nell'esempio seguente viene illustrato come utilizzare il `new` (parola chiave) per creare un'istanza <xref:System.Numerics.BigInteger> valori.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   È possibile dichiarare un <xref:System.Numerics.BigInteger> variabile e assegnare un valore come avverrebbe qualsiasi tipo numerico, a condizione che tale valore è un tipo integrale. Nell'esempio seguente usa l'assegnazione per creare una <xref:System.Numerics.BigInteger> valore da un <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   È possibile assegnare un valore decimale o a virgola mobile a un <xref:System.Numerics.BigInteger> se il cast del valore o convertirlo innanzitutto dell'oggetto. Nell'esempio seguente esegue il cast (in c#) o la conversione (in Visual Basic) in modo esplicito un <xref:System.Double> e un <xref:System.Decimal> valore a un <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Questi metodi consentono di creare un'istanza di un <xref:System.Numerics.BigInteger> oggetto il cui valore è compreso nell'intervallo di uno dei numerici esistenti solo con tipi. È possibile creare un'istanza di un <xref:System.Numerics.BigInteger> oggetto il cui valore può essere superiore all'intervallo dei tipi numerici esistenti in uno dei tre modi:  
  
-   È possibile usare il `new` (parola chiave) e fornire una matrice di byte di qualsiasi dimensione per la <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> costruttore. Ad esempio:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   È possibile chiamare il <xref:System.Numerics.BigInteger.Parse%2A> oppure <xref:System.Numerics.BigInteger.TryParse%2A> metodi per convertire la rappresentazione di stringa di un numero un <xref:System.Numerics.BigInteger>. Ad esempio:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   È possibile chiamare una `static` (`Shared` in Visual Basic) <xref:System.Numerics.BigInteger> metodo che esegue alcune operazioni su un'espressione numerica e restituisce un calcolato <xref:System.Numerics.BigInteger> risultato. Nell'esempio seguente esegue questa operazione si <xref:System.UInt64.MaxValue?displayProperty=nameWithType> e l'assegnazione del risultato a un <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 Il valore inizializzato di un <xref:System.Numerics.BigInteger> è <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Esecuzione di operazioni sui valori BigInteger  
 È possibile utilizzare un <xref:System.Numerics.BigInteger> istanza si utilizza qualsiasi altro tipo integrale. <xref:System.Numerics.BigInteger> esegue l'overload degli operatori numerici standard per consentire di eseguire operazioni matematiche di base, ad esempio addizione, sottrazione, divisione, moltiplicazione, sottrazione, negazione e negazione unaria. È inoltre possibile utilizzare gli operatori numerici standard per confrontare due <xref:System.Numerics.BigInteger> valori tra loro. Come altri tipi integrali <xref:System.Numerics.BigInteger> supporta anche il bit per bit `And`, `Or`, `XOr`, left shift e right shift (operatori). Per le lingue che non supportano gli operatori personalizzati, il <xref:System.Numerics.BigInteger> struttura fornisce inoltre metodi equivalenti per l'esecuzione di operazioni matematiche. Tra cui <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>e molti altri.  
  
 Numero di membri del <xref:System.Numerics.BigInteger> struttura corrispondono direttamente ai membri di altri tipi integrali. Inoltre, <xref:System.Numerics.BigInteger> aggiunge membri come illustrato di seguito:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, che restituisce un valore che indica il segno di un <xref:System.Numerics.BigInteger> valore.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, che restituisce il valore assoluto di un <xref:System.Numerics.BigInteger> valore.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, che restituisce il quoziente e resto di un'operazione di divisione.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, che restituisce il massimo comune divisore di due <xref:System.Numerics.BigInteger> valori.  
  
 Molti di questi membri aggiuntivi corrispondono ai membri del <xref:System.Math> (classe), che fornisce la funzionalità per funzionare con i tipi numerici primitivi.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Modificabilità e BigInteger (struttura)  
 Nell'esempio seguente crea un <xref:System.Numerics.BigInteger> dell'oggetto e quindi incrementa il valore di uno.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Sebbene in questo esempio viene visualizzato per modificare il valore dell'oggetto esistente, non il case. <xref:System.Numerics.BigInteger> gli oggetti non sono modificabili, vale a dire che internamente, common language runtime crea effettivamente una nuova <xref:System.Numerics.BigInteger> dell'oggetto e le assegna un valore più grande rispetto al suo valore precedente. Questo nuovo oggetto viene quindi restituito al chiamante.  
  
> [!NOTE]
>  Gli altri tipi numerici in .NET Framework sono inoltre non modificabili. Tuttavia, poiché il <xref:System.Numerics.BigInteger> tipo non dispone di alcun limiti inferiori o superiori, i relativi valori possono raggiungere dimensioni estremamente elevati e ha un impatto apprezzabile sulle prestazioni.  
  
 Anche se questo processo non è visibile al chiamante, comportano una riduzione delle prestazioni. In alcuni casi, in particolare quando vengono eseguite operazioni ripetute in un ciclo su grandi <xref:System.Numerics.BigInteger> valori, la riduzione delle prestazioni può essere significativo. Nell'esempio seguente, ad esempio, un'operazione viene eseguita ripetutamente fino a un milione di volte e una <xref:System.Numerics.BigInteger> valore viene incrementato di uno ogni volta che l'operazione ha esito positivo.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 In tal caso, è possibile migliorare le prestazioni mediante l'esecuzione di tutte le assegnazioni intermediate a un <xref:System.Int32> variabile. Il valore finale della variabile può quindi essere assegnato al <xref:System.Numerics.BigInteger> dell'oggetto quando l'uscita dal ciclo. Nell'esempio seguente viene illustrato questo concetto.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Utilizzo di matrici di Byte e stringhe esadecimali  
 Se si converte <xref:System.Numerics.BigInteger> valori per le matrici di byte, o se si convertono le matrici di byte a <xref:System.Numerics.BigInteger> valori, è necessario considerare l'ordine dei byte. Il <xref:System.Numerics.BigInteger> struttura si aspetta che i singoli byte in una matrice di byte vengano visualizzati in ordine little-endian (vale a dire, i byte meno significativi del valore precedono i byte di ordine più elevato). È possibile round trip un <xref:System.Numerics.BigInteger> valore chiamando il <xref:System.Numerics.BigInteger.ToByteArray%2A> e quindi passando il byte risulta della matrice per la <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Per creare un'istanza di un <xref:System.Numerics.BigInteger> valore da una matrice di byte che rappresenta un valore di un altro tipo integrale, è possibile passare il valore integrale per il <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> (metodo) e quindi passare la matrice di byte risultante al <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore. Nell'esempio seguente crea un <xref:System.Numerics.BigInteger> valore da una matrice di byte che rappresenta un <xref:System.Int16> valore.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 Il <xref:System.Numerics.BigInteger> struttura si presuppone che i valori negativi vengono archiviati utilizzando la rappresentazione in complemento a due. Poiché il <xref:System.Numerics.BigInteger> struttura rappresenta un valore numerico senza lunghezza fissa, il <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore interpreta sempre il bit più significativo dell'ultimo byte della matrice come bit di segno. Per impedire il <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore da confondere il due rappresentazione di complemento di un valore negativo con la rappresentazione di segno e grandezza di un valore positivo, positivo valori in cui più significativa dell'ultimo byte nella matrice di byte solitamente sarebbe set deve includere un byte aggiuntiva il cui valore è 0. Ad esempio, 0xC0 0xBD 0xF0 0xFF è la rappresentazione esadecimale little-endian di 1.000.000 o 4.293.967.296. Poiché il bit più significativo dell'ultimo byte in questa matrice è attivato, il valore della matrice di byte verrebbe interpretato dal <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore come-1,000,000. Per creare un'istanza di un <xref:System.Numerics.BigInteger> il cui valore è positivo, una matrice di byte cui elementi sono 0xC0 0xBD 0xF0 0xFF 0x00 deve essere passato al costruttore. Questa condizione è illustrata nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Le matrici di byte create di <xref:System.Numerics.BigInteger.ToByteArray%2A> metodo da valori positivi includono questo byte di valore zero aggiuntivo. Pertanto, il <xref:System.Numerics.BigInteger> struttura può correttamente il round trip dei valori assegnandoli a e quindi ripristinarli da matrici di byte, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Tuttavia, si potrebbe essere necessario aggiungere questo byte zero-valore aggiuntivo per le matrici di byte che vengono creati dinamicamente dallo sviluppatore o che vengono restituiti dai metodi che convertono interi senza segno a matrici di byte (ad esempio <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, e <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Durante l'analisi di una stringa esadecimale, il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> e <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodi presuppongono che se è impostato il bit più significativo del primo byte nella stringa o se la prima cifra della stringa esadecimale rappresenta i quattro bit più bassi di un valore byte, il valore è rappresentati tramite la rappresentazione in complemento a due. Ad esempio, "FF01" sia "F01" rappresentano il valore decimale -255. Per differenziare positivi da valori negativi, i valori positivi devono includere uno zero iniziale. Gli overload pertinenti del <xref:System.Numerics.BigInteger.ToString%2A> (metodo), quando vengono passati la stringa di formato "X", aggiungere uno zero iniziale per la stringa esadecimale restituita per i valori positivi. Questo rende possibile per il round trip <xref:System.Numerics.BigInteger> valori utilizzando il <xref:System.Numerics.BigInteger.ToString%2A> e <xref:System.Numerics.BigInteger.Parse%2A> metodi, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Tuttavia, le stringhe esadecimali create chiamando il `ToString` i metodi di altri tipi integrali o gli overload del <xref:System.Convert.ToString%2A> metodo che includono un `toBase` parametro non viene indicato il segno del valore o il tipo di dati di origine da cui è stata derivata la stringa esadecimale. Creare un'istanza di correttamente un <xref:System.Numerics.BigInteger> valore da una stringa di questo tipo richiede una logica aggiuntiva. Nell'esempio seguente è illustrata una possibile implementazione.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Matrice di valori byte in ordine little-endian.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando i valori di una matrice di byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I singoli byte il `value` la matrice deve essere in ordine little-endian, dal livello più basso byte di ordine più elevato. Ad esempio, il valore numerico 1.000.000.000.000 è rappresentato come illustrato nella tabella seguente:  
  
|||  
|-|-|  
|Stringa esadecimale|E8D4A51000|  
|Matrice di byte (indice minimo prima)|00 10 A5 D4 E8 00|  
  
 La maggior parte dei metodi che convertono i valori numerici in matrici di byte, ad esempio <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> e <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, restituiscono matrici di byte in ordine little-endian.  
  
 Il costruttore si aspetta valori positivi nella matrice di byte da usare la rappresentazione di segno e grandezza e i valori negativi da usare la rappresentazione in complemento a due. In altre parole, se l'ordine più elevato di bit del byte più significativo `value` è impostata, il valore risultante <xref:System.Numerics.BigInteger> valore è negativo. A seconda dell'origine della matrice di byte, è possibile che un valore positivo siano interpretati erroneamente come un valore negativo. Le matrici di byte in genere vengono generate nei modi seguenti:  
  
-   Chiamando il <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> metodo. Poiché questo metodo restituisce una matrice di byte con il bit più significativo del byte più significativo nel set di matrice a zero per i valori positivi, non c'è alcuna possibilità di interpretare un valore positivo come negativo. Non modificato di matrici di byte create il <xref:System.Numerics.BigInteger.ToByteArray%2A> sempre correttamente il round trip se vengono passati al metodo il <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore.  
  
-   Chiamando il <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> (metodo) e passare un intero con segno come un parametro. Poiché interi con segno a gestiscono la rappresentazione di segno e grandezza sia la rappresentazione in complemento a due, non è Nessuna possibilità di interpretare un valore positivo come negativo.  
  
-   Chiamando il <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metodo e passando un unsigned integer come parametro. Poiché interi senza segno vengono rappresentati solo dalla grandezza, i valori positivi possono essere erroneamente interpretati come valori negativi. Per evitare questo problema, è possibile aggiungere un valore zero byte alla fine della matrice. Nell'esempio nella sezione successiva viene illustrato questo concetto.  
  
-   Tramite la creazione di una matrice di byte sia staticamente o dinamicamente senza necessariamente chiamare uno dei metodi precedenti, o modificando una matrice di byte esistente. Per impedire che i valori positivi vengano erroneamente interpretati come valori negativi, è possibile aggiungere un valore zero byte alla fine della matrice.  
  
 Se `value` è un oggetto vuoto <xref:System.Byte> matrice, il nuovo <xref:System.Numerics.BigInteger> oggetto viene inizializzato su un valore di <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Se `value` viene `null`, il costruttore genera un <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 Nell'esempio seguente crea un <xref:System.Numerics.BigInteger> oggetto da una matrice di byte a 5 elementi il cui valore è {5, 4, 3, 2, 1}. Viene quindi visualizzato il <xref:System.Numerics.BigInteger> valore, rappresentati come numeri decimali ed esadecimali, nella console. Un confronto della matrice di input con l'output di testo consente di cancellare i motivi per cui questo overload del <xref:System.Numerics.BigInteger> costruttore di classe crea un <xref:System.Numerics.BigInteger> oggetto il cui valore è 4328719365 (o 0x102030405). Il primo elemento della matrice di byte, il cui valore è 5, definisce il valore del byte di ordine più basso il <xref:System.Numerics.BigInteger> oggetto, ovvero 0x05. Il secondo elemento della matrice di byte, il cui valore è 4, definisce il valore del secondo byte del <xref:System.Numerics.BigInteger> oggetto, ovvero 0x04 e così via.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 Nell'esempio seguente crea un'istanza di un numero positivo e negativo <xref:System.Numerics.BigInteger> valore, vengono passati per il <xref:System.Numerics.BigInteger.ToByteArray%2A> (metodo) e quindi Ripristina originale <xref:System.Numerics.BigInteger> valori dalla matrice di byte risultante. Si noti che i due valori sono rappresentati da matrici di byte identici. L'unica differenza tra di essi è in bit più significativo dell'ultimo elemento nella matrice di byte. Questo bit viene impostato (il valore del byte è 0xFF), se la matrice viene creata da un valore negativo <xref:System.Numerics.BigInteger> valore. Il bit non è impostato (il valore del byte è zero), se l'array viene creato da un numero positivo <xref:System.Numerics.BigInteger> valore.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 Nell'esempio seguente viene illustrato come assicurarsi che un valore positivo non è in modo non corretto creata un'istanza come un valore negativo mediante l'aggiunta di un byte il cui valore è uguale a zero alla fine della matrice.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Numero decimale.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando un valore <see cref="T:System.Decimal" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il risultato della chiamata di questo costruttore è identico all'assegnazione in modo esplicito un <xref:System.Decimal> valore per un <xref:System.Numerics.BigInteger> variabile.  
  
 La chiamata di questo costruttore può provocare la perdita di dati. qualsiasi parte frazionaria del `value` viene troncato quando si crea un <xref:System.Numerics.BigInteger> oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> costruttore per creare un'istanza di un <xref:System.Numerics.BigInteger> oggetto. Definisce una matrice di <xref:System.Decimal> valori e quindi passa ogni valore per il <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> costruttore. Si noti che il <xref:System.Decimal> valore viene troncato anziché arrotondata quando viene assegnato al <xref:System.Numerics.BigInteger> oggetto.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valore a virgola mobile e precisione doppia.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando un valore a virgola mobile con precisione doppia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria del `value` parametro viene troncato quando si crea un <xref:System.Numerics.BigInteger> oggetto.  
  
 A causa della mancanza di precisione del <xref:System.Double> tipo di dati, la chiamata di questo costruttore può causare la perdita di dati.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione in modo esplicito un <xref:System.Double> valore a un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> costruttore per creare un'istanza di un <xref:System.Numerics.BigInteger> oggetto. Illustra anche la perdita di precisione che può verificarsi quando si usa il <xref:System.Double> tipo di dati. Un <xref:System.Double> viene assegnato un valore di grandi dimensioni, che viene quindi assegnato a un <xref:System.Numerics.BigInteger> oggetto. Come illustrato nell'output, questa assegnazione comporta una perdita di precisione. Entrambi i valori vengono quindi incrementati di uno. L'output mostra che il <xref:System.Numerics.BigInteger> oggetto riflette il valore modificato, mentre il <xref:System.Double> non oggetto.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Double.NaN" />.  -oppure- Il valore di <paramref name="value" /> è <see cref="F:System.Double.NegativeInfinity" />.  -oppure- Il valore di <paramref name="value" /> è <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Intero con segno a 32 bit.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando un Signed Integer a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna perdita di precisione quando si crea un <xref:System.Numerics.BigInteger> oggetto utilizzando questo costruttore.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione di un <xref:System.Int32> valore a un <xref:System.Numerics.BigInteger>.  
  
 Il <xref:System.Numerics.BigInteger> struttura non include costruttori con un parametro di tipo <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, o <xref:System.UInt16>. Tuttavia, il <xref:System.Int32> tipo supporta la conversione implicita di interi con e senza segno a 8 bit e a 16 bit per interi con segno a 32 bit. Di conseguenza, questo costruttore viene chiamato se `value` è uno di questi quattro tipi integrali.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> costruttore per creare un'istanza <xref:System.Numerics.BigInteger> valori da una matrice di interi a 32 bit. Usa inoltre la conversione implicita per assegnare ogni valore intero a 32 bit a un <xref:System.Numerics.BigInteger> variabile. Quindi confronta i due valori per stabilire che il valore risultante <xref:System.Numerics.BigInteger> valori sono uguali.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Intero con segno a 64 bit.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> usando un valore intero con segno a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna perdita di precisione quando si crea un <xref:System.Numerics.BigInteger> oggetto utilizzando questo costruttore.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione di un <xref:System.Int64> valore a un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> costruttore per creare un'istanza <xref:System.Numerics.BigInteger> valori da una matrice di interi a 64 bit. Usa inoltre la conversione implicita per assegnare ogni valore integer a 64 bit a un <xref:System.Numerics.BigInteger> variabile. Quindi confronta i due valori per stabilire che il valore risultante <xref:System.Numerics.BigInteger> valori sono uguali.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valore a virgola mobile e precisione singola.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando un valore a virgola mobile con precisione singola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria del `value` parametro viene troncato quando si crea un <xref:System.Numerics.BigInteger> oggetto.  
  
 A causa della mancanza di precisione del <xref:System.Single> tipo di dati, la chiamata di questo costruttore può comportare la perdita di dati.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione in modo esplicito un <xref:System.Single> valore a un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> costruttore per creare un'istanza di un <xref:System.Numerics.BigInteger> oggetto. Illustra anche la perdita di precisione che può verificarsi quando si usa il <xref:System.Single> tipo di dati. Un <xref:System.Single> viene assegnato un valore negativo elevato, che viene quindi assegnato a un <xref:System.Numerics.BigInteger> oggetto. Come illustrato nell'output, questa assegnazione comporta una perdita di precisione. Entrambi i valori vengono quindi incrementati di uno. L'output mostra che il <xref:System.Numerics.BigInteger> oggetto riflette il valore modificato, mentre il <xref:System.Single> non oggetto.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Single.NaN" />.  -oppure- Il valore di <paramref name="value" /> è <see cref="F:System.Single.NegativeInfinity" />.  -oppure- Il valore di <paramref name="value" /> è <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valore intero senza segno a 32 bit.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando un valore Unsigned Integer a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna perdita di precisione quando si crea un <xref:System.Numerics.BigInteger> utilizza questo costruttore.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione di un <xref:System.UInt32> valore a un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> costruttore e un'istruzione di assegnazione per inizializzare <xref:System.Numerics.BigInteger> valori da una matrice di interi senza segno a 32 bit. Quindi confronta i due valori di dimostrare che i due metodi di inizializzazione di un <xref:System.Numerics.BigInteger> valore produce risultati identici.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Intero senza segno a 64 bit.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> con un valore Unsigned Integer a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna perdita di precisione quando si crea un <xref:System.Numerics.BigInteger> utilizza questo costruttore.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione di un <xref:System.UInt64> valore a un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> costruttore per creare un'istanza di un <xref:System.Numerics.BigInteger> il cui valore è uguale all'oggetto <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Numero.</param>
        <summary>Ottiene il valore assoluto di un oggetto <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Valore assoluto di <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore assoluto di un numero è il numero senza segno, come illustrato nella tabella seguente.  
  
|Parametro `value`.|Valore restituito|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 Il <xref:System.Numerics.BigInteger.Abs%2A> metodo è equivalente al <xref:System.Math.Abs%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la <xref:System.Numerics.BigInteger.Abs%2A> metodo per convertire un <xref:System.Numerics.BigInteger> valore compreso tra la rappresentazione in complemento a due e rappresentazione di segno e grandezza prima della serializzazione in un file. I dati nel file viene quindi deserializzati e assegnati a un nuovo <xref:System.Numerics.BigInteger> oggetto.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da sommare.</param>
        <param name="right">Secondo valore da sommare.</param>
        <summary>Somma due valori <see cref="T:System.Numerics.BigInteger" /> e restituisce il risultato.</summary>
        <returns>Somma di <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Linguaggi che non supportano l'overload degli operatori o gli operatori personalizzati possono utilizzare il <xref:System.Numerics.BigInteger.Add%2A> metodo per eseguire addizioni utilizzando <xref:System.Numerics.BigInteger> valori.  
  
 Il <xref:System.Numerics.BigInteger.Add%2A> metodo è un sostituto utile per l'operatore di addizione quando si crea un <xref:System.Numerics.BigInteger> variabile assegnandole una somma risultante dall'aggiunta, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Confronta due valori <see cref="T:System.Numerics.BigInteger" /> e restituisce un Integer che indica se il primo valore è minore, uguale o maggiore rispetto al secondo valore.</summary>
        <returns>Intero con segno che indica i valori relativi di <paramref name="left" /> e <paramref name="right" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="left" /> è minore di <paramref name="right" />.  </description></item><item><term> Zero  </term><description><paramref name="left" /> è uguale a <paramref name="right" />.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="left" /> è maggiore di <paramref name="right" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se il <xref:System.Numerics.BigInteger> tipo non dispone di alcun intervallo fisso, i confronti di <xref:System.Numerics.BigInteger> valori non sono caratterizzati dalla mancanza di precisione che caratterizza il confronto di numeri a virgola mobile. Nell'esempio seguente vengono confrontate due <xref:System.Numerics.BigInteger> valori che differiscono in base uno e ognuno hanno 1.896 cifre. Il <xref:System.Numerics.BigInteger.Compare%2A> metodo correttamente segnala che i due valori non sono uguali.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta il valore di questa istanza con un altro valore e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore dell'altro valore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Intero con segno a 64 bit da confrontare.</param>
        <summary>Confronta questa istanza con un intero con segno a 64 bit e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore del valore dell'intero con segno a 64 bit.</summary>
        <returns>Signed Integer che indica la relazione dell'istanza con <paramref name="other" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore restituito </term><description> Descrizione </description></listheader><item><term> Minore di zero </term><description> L'istanza corrente è minore di <paramref name="other" />.  </description></item><item><term> Zero </term><description> L'istanza corrente è uguale a <paramref name="other" />.  </description></item><item><term> Maggiore di zero </term><description> L'istanza corrente è maggiore di <paramref name="other" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `other` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metodo viene chiamato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il risultato della chiamata di <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metodo con i valori integrali.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Oggetto da confrontare.</param>
        <summary>Confronta questa istanza con un secondo <see cref="T:System.Numerics.BigInteger" /> e restituisce un Integer che indica se il valore di questa istanza è minore, uguale o maggiore rispetto al valore dell'oggetto specificato.</summary>
        <returns>Signed Integer che indica la relazione dell'istanza con <paramref name="other" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore restituito </term><description> Descrizione </description></listheader><item><term> Minore di zero </term><description> L'istanza corrente è minore di <paramref name="other" />.  </description></item><item><term> Zero </term><description> L'istanza corrente è uguale a <paramref name="other" />.  </description></item><item><term> Maggiore di zero </term><description> L'istanza corrente è maggiore di <paramref name="other" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del <xref:System.Numerics.BigInteger.CompareTo%2A> metodo implementa il <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> metodo. Utilizzato dagli oggetti di raccolte generiche per ordinare gli elementi nella raccolta.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> metodo per ordinare un elenco di `StarInfo` oggetti. Ogni `StarInfo` oggetto fornisce informazioni sul nome di una stella e della distanza dal terra in miglia. `StarInfo` implementa il <xref:System.IComparable%601> interfaccia, che consente `StarInfo` oggetti in base a classi di raccolte generiche. Il relativo <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementazione esegue semplicemente il wrapping di una chiamata a <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Il codice seguente crea quindi un'istanza quattro `StarInfo` oggetti e li archivia in un oggetto generico <xref:System.Collections.Generic.List%601> oggetto. Dopo il <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> viene chiamato, `StarInfo` gli oggetti vengono visualizzati in ordine di distanza dal terra.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare.</param>
        <summary>Confronta questa istanza con un oggetto specificato e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore rispetto al valore dell'oggetto specificato.</summary>
        <returns>Signed Integer che indica la relazione dell'istanza corrente con il parametro <paramref name="obj" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore restituito </term><description> Descrizione </description></listheader><item><term> Minore di zero </term><description> L'istanza corrente è minore di <paramref name="obj" />.  </description></item><item><term> Zero </term><description> L'istanza corrente è uguale a <paramref name="obj" />.  </description></item><item><term> Maggiore di zero </term><description> L'istanza corrente è maggiore di <paramref name="obj" /> o il parametro <paramref name="obj" /> è <see langword="null" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del <xref:System.Numerics.BigInteger.CompareTo%2A> metodo implementa il <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> metodo. Utilizzato dagli oggetti di raccolta non generica per ordinare gli elementi nella raccolta.  
  
 Il `obj` parametro deve essere uno dei seguenti:  
  
-   Oggetto il cui tipo di runtime è <xref:System.Numerics.BigInteger>.  
  
-   Un' <xref:System.Object> variabile il cui valore è `null`. Se il valore di `obj` parametro `null`, il metodo restituisce 1, che indica che l'istanza corrente è maggiore di `obj`.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metodo per confrontare un <xref:System.Numerics.BigInteger> valore con ogni elemento in una matrice di oggetti  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> non è un oggetto <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Intero senza segno a 64 bit da confrontare.</param>
        <summary>Confronta questa istanza con un intero senza segno a 64 bit e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore del valore dell'intero senza segno a 64 bit.</summary>
        <returns>Signed Integer che indica il valore relativo dell'istanza e <paramref name="other" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore restituito </term><description> Descrizione </description></listheader><item><term> Minore di zero </term><description> L'istanza corrente è minore di <paramref name="other" />.  </description></item><item><term> Zero </term><description> L'istanza corrente è uguale a <paramref name="other" />.  </description></item><item><term> Maggiore di zero </term><description> L'istanza corrente è maggiore di <paramref name="other" />. </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valore da dividere.</param>
        <param name="divisor">Valore per cui dividere.</param>
        <summary>Divide un valore <see cref="T:System.Numerics.BigInteger" /> per un altro e restituisce il risultato.</summary>
        <returns>Quoziente della divisione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.Divide%2A> metodo esegue una divisione di interi; le parti restanti risultante dalla divisione viene eliminata. Per eseguire la divisione di interi, mantenendo tuttavia il resto, chiamare il <xref:System.Numerics.BigInteger.DivRem%2A> metodo. Per recuperare solo il resto, chiamare il <xref:System.Numerics.BigInteger.Remainder%2A> metodo.  
  
 Il <xref:System.Numerics.BigInteger.Divide%2A> metodo può essere utilizzato dai linguaggi che non supportano l'overload degli operatori. Il comportamento è identico alla divisione utilizzando l'operatore di divisione.  
  
   
  
## Examples  
 L'esempio seguente crea una matrice di <xref:System.Numerics.BigInteger> valori. Ogni elemento viene quindi utilizzato come il quoziente in un'operazione di divisione che utilizza il <xref:System.Numerics.BigInteger.Divide%2A> metodo, l'operatore di divisione (/) e il <xref:System.Numerics.BigInteger.DivRem%2A> metodo.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> è 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Valore da dividere.</param>
        <param name="divisor">Valore per cui dividere.</param>
        <param name="remainder">Quando termina, questo metodo contiene un valore <see cref="T:System.Numerics.BigInteger" /> che rappresenta il resto dalla divisione. Questo parametro viene passato non inizializzato.</param>
        <summary>Divide un valore <see cref="T:System.Numerics.BigInteger" /> per un altro, restituisce il risultato e restituisce il resto in un parametro di output.</summary>
        <returns>Quoziente della divisione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo mantiene il quoziente e resto risultante dalla divisione di interi. Se non si è interessati al resto, usare il <xref:System.Numerics.BigInteger.Divide%2A> metodo o l'operatore di divisione; se si è solo interessati al resto, utilizzare il <xref:System.Numerics.BigInteger.Remainder%2A> metodo.  
  
 Il segno dell'oggetto restituito `remainder` valore è uguale al segno del `dividend` parametro.  
  
 Il comportamento del <xref:System.Numerics.BigInteger.DivRem%2A> metodo è identico a quello del <xref:System.Math.DivRem%2A?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 L'esempio seguente crea una matrice di <xref:System.Numerics.BigInteger> valori. Ogni elemento viene quindi utilizzato come il quoziente in un'operazione di divisione che utilizza il <xref:System.Numerics.BigInteger.Divide%2A> metodo, l'operatore di divisione (/) e il <xref:System.Numerics.BigInteger.DivRem%2A> metodo.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> è 0 (zero).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se due valori numerici sono uguali.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Valore intero con segno a 64 bit da confrontare.</param>
        <summary>Restituisce un valore che indica se l'istanza corrente e un intero con segno a 64 bit hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se il Signed Integer a 64 bit e l'istanza corrente hanno lo stesso valore; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `other` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene chiamato il metodo.  
  
 Per determinare la relazione tra i due oggetti anziché semplicemente il test di uguaglianza, chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente crea un <xref:System.Numerics.BigInteger> oggetto da ogni tipo integrale eccetto <xref:System.UInt64>. Chiama quindi il <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> metodo per confrontare le <xref:System.Numerics.BigInteger> valore con il valore integer originale che è stato passato al <xref:System.Numerics.BigInteger> costruttore. Come illustrato nell'output, i valori sono uguali in ogni caso.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Oggetto da confrontare.</param>
        <summary>Restituisce un valore che indica se l'istanza corrente e un oggetto <see cref="T:System.Numerics.BigInteger" /> specificato hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se questo oggetto <see cref="T:System.Numerics.BigInteger" /> e <paramref name="other" /> hanno lo stesso valore; <see langword="false" /> in caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il <xref:System.IEquatable%601> interfaccia ed esegue leggermente migliori rispetto <xref:System.Numerics.BigInteger.Equals%28System.Object%29> perché non è necessario convertire il `other` parametro per un <xref:System.Numerics.BigInteger> oggetto.  
  
 Per determinare la relazione tra i due <xref:System.Numerics.BigInteger> oggetti anziché solo eseguendo un test di uguaglianza, chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 L'esempio seguente confronta la distanza approssimativa di diverse stelle dalla terra con la distanza di Indi Epsilon da terra per determinare se sono uguali. Nell'esempio viene utilizzato ogni overload del <xref:System.Numerics.BigInteger.Equals%2A> metodo per verificare l'uguaglianza.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare.</param>
        <summary>Restituisce un valore che indica se l'istanza corrente e un oggetto specificato hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se l'argomento di <paramref name="obj" /> è un oggetto <see cref="T:System.Numerics.BigInteger" /> e se il valore è uguale a quello dell'istanza <see cref="T:System.Numerics.BigInteger" /> corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `obj` l'argomento non è un <xref:System.Numerics.BigInteger> valore, il metodo restituisce `false`. Il metodo restituisce `true` solo se `obj` è un <xref:System.Numerics.BigInteger> istanza il cui valore è uguale all'istanza corrente.  
  
 Per determinare la relazione tra i due oggetti anziché semplicemente il test di uguaglianza, chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metodo.  
  
   
  
## Examples  
 L'esempio seguente definisce parallelo <xref:System.Object> e <xref:System.Numerics.BigInteger> matrici. Ogni elemento di una matrice ha lo stesso valore impostato per l'elemento corrispondente della seconda matrice. Come illustrato nell'esempio, l'istanza nell'output il <xref:System.Numerics.BigInteger> matrice viene considerata uguale all'istanza nel <xref:System.Object> matrice solo se quest'ultimo è un <xref:System.Numerics.BigInteger> e i relativi valori sono uguali.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Intero senza segno a 64 bit da confrontare.</param>
        <summary>Restituisce un valore che indica se l'istanza corrente e un intero senza segno a 64 bit hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se l'Unsigned Integer a 64 bit e l'istanza corrente hanno lo stesso valore; <see langword="false" /> in caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per determinare la relazione tra i due oggetti anziché semplicemente il test di uguaglianza, chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 L'esempio seguente confronta la distanza approssimativa di diverse stelle dalla terra con la distanza di Indi Epsilon da terra per determinare se sono uguali. Nell'esempio viene utilizzato ogni overload del <xref:System.Numerics.BigInteger.Equals%2A> metodo per verificare l'uguaglianza.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore.</param>
        <param name="right">Secondo valore.</param>
        <summary>Trova il massimo comune divisore di due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Massimo comune divisore di <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il massimo comun divisore è il numero più grande in cui i due <xref:System.Numerics.BigInteger> valori possono essere divise senza restituire il resto.  
  
 Se il `left` e `right` i parametri sono numeri diversi da zero, il metodo restituisce sempre almeno un valore pari a 1 perché tutti i numeri possono essere divisi per 1. Se dei parametri è zero, il metodo restituisce il valore assoluto del parametro diverso da zero. Se entrambi i valori sono zero, il metodo restituisce zero.  
  
> [!NOTE]
>  Massimo comune divisore di valori molto grandi di calcolo `left` e `right` può essere un'operazione richiede molto tempo.  
  
 Il valore restituito dal <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metodo è sempre un valore positivo indipendentemente dal segno del `left` e `right` parametri.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata una chiamata per il <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metodo e la gestione delle eccezioni necessaria per fornire informazioni utili su un <xref:System.ArgumentOutOfRangeException>. Il risultato indica che il massimo comune divisore di questi due numeri è 1.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente è un numero pari.</summary>
        <value>
          <see langword="true" /> se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> è un numero pari; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è una comoda funzionalità che indica se un <xref:System.Numerics.BigInteger> valore è divisibile per due. È equivalente all'espressione seguente:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Se il valore dell'oggetto corrente <xref:System.Numerics.BigInteger> oggetto è <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, la proprietà restituisce `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente è <see cref="P:System.Numerics.BigInteger.One" />.</summary>
        <value>
          <see langword="true" /> se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> è <see cref="P:System.Numerics.BigInteger.One" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà offre un miglioramento significativo delle prestazioni degli altri confronti con uno, ad esempio `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente è una potenza di due.</summary>
        <value>
          <see langword="true" /> se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> è una potenza di due; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà determina se un <xref:System.Numerics.BigInteger> valore dispone di un singolo bit diverso da zero set. Ciò significa che restituirà `true` se il valore dell'oggetto corrente <xref:System.Numerics.BigInteger> oggetto è 1 (vale a dire, 2<sup>0</sup>) o qualsiasi maggiore potenza di due. Viene restituito `false` se il valore dell'oggetto corrente <xref:System.Numerics.BigInteger> oggetto è 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente è <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
        <value>
          <see langword="true" /> se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> è <see cref="P:System.Numerics.BigInteger.Zero" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà offre un miglioramento significativo delle prestazioni rispetto a `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il logaritmo del numero specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Numero di cui è necessario trovare il logaritmo.</param>
        <summary>Restituisce il logaritmo naturale (in base <see langword="e" />) di un numero specificato.</summary>
        <returns>Logaritmo naturale (di base <see langword="e" />) di <paramref name="value" />, come mostrato nella tabella della sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro è specificato come un numero di base 10.  
  
 Il preciso restituito varia in base al segno del valore di questo metodo `value`, come illustrato nella tabella seguente.  
  
|Eseguire l'accesso di `value` parametro|Valore restituito|  
|-------------------------------|------------------|  
|Positivo|Il logaritmo naturale `value`; vale a dire, ln `value`, o di log e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>.|  
|Negativo|<xref:System.Double.NaN>.|  
  
 Per calcolare il logaritmo in base 10 di un <xref:System.Numerics.BigInteger> valore, chiamare il <xref:System.Numerics.BigInteger.Log10%2A> metodo. Per calcolare il logaritmo di un numero in un'altra base, chiamare il <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> metodo.  
  
 È possibile trovare la radice quadrata di un numero chiamando il <xref:System.Numerics.BigInteger.Log%2A> metodo insieme al <xref:System.Math.Exp%2A?displayProperty=nameWithType> metodo. Si noti che il risultato è <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> se il risultato è maggiore di <xref:System.Double.MaxValue?displayProperty=nameWithType>. L'esempio seguente calcola la radice quadrata di ogni elemento nella matrice di <xref:System.Numerics.BigInteger> valori.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Questo metodo corrisponde al <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il logaritmo naturale di <paramref name="value" /> non è compreso nell'intervallo del tipo di dati <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Numero di cui trovare il logaritmo.</param>
        <param name="baseValue">Base del logaritmo.</param>
        <summary>Restituisce il logaritmo del numero specificato in una base specificata.</summary>
        <returns>Logaritmo di base <paramref name="baseValue" /> di <paramref name="value" />, come mostrato nella tabella della sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` e `baseValue` parametri vengono specificati come numeri di base 10.  
  
 Il preciso restituito varia in base al segno del valore del metodo `value` e l'accesso e al valore di `baseValue`, come illustrato nella tabella seguente.  
  
|Parametro `value`.|Parametro `baseValue`.|Valore restituito|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) - oppure -(`baseValue` > 1)|logbaseValue (`value`)|  
|`value` < 0|(qualsiasi valore)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(qualsiasi valore)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(qualsiasi valore)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(qualsiasi valore)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Per calcolare il logaritmo in base 10 di un <xref:System.Numerics.BigInteger> valore, chiamare il <xref:System.Numerics.BigInteger.Log10%2A> metodo. Per calcolare il logaritmo naturale di un numero, chiamare il <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> metodo.  
  
 Questo metodo corrisponde al <xref:System.Math.Log%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il logaritmo di <paramref name="value" /> non è compreso nell'intervallo del tipo di dati <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Numero di cui trovare il logaritmo.</param>
        <summary>Restituisce il logaritmo in base 10 del numero specificato.</summary>
        <returns>Logaritmo in base 10 di <paramref name="value" />, come mostrato nella tabella della sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro è specificato come un numero di base 10.  
  
 Il preciso restituito varia in base al segno del valore del metodo `value`, come illustrato nella tabella seguente.  
  
|Segno del parametro value|Valore restituito|  
|-----------------------------|------------------|  
|Positivo|La base 10 di log `value`; vale a dire, log10`value`.|  
|Zero|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|Negativo|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 Per calcolare il logaritmo naturale di un <xref:System.Numerics.BigInteger> valore, chiamare il <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodo. Per calcolare il logaritmo di un numero in un'altra base, chiamare il <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> metodo.  
  
 Questo metodo corrisponde al <xref:System.Math.Log10%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il logaritmo a base 10 di <paramref name="value" /> non è compreso nell'intervallo del tipo di dati <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce il maggiore di due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Parametro <paramref name="left" /> o <paramref name="right" />, qualunque sia il maggiore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo corrisponde al <xref:System.Math.Max%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la <xref:System.Numerics.BigInteger.Max%2A> metodo per selezionare il numero più grande in una matrice di <xref:System.Numerics.BigInteger> valori.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce il minore di due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Parametro <paramref name="left" /> o <paramref name="right" />, qualunque sia il minore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo corrisponde al <xref:System.Math.Min%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la <xref:System.Numerics.BigInteger.Min%2A> metodo per selezionare il numero più piccolo in una matrice di <xref:System.Numerics.BigInteger> valori.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che rappresenta il numero negativo uno (-1).</summary>
        <value>Intero il cui valore è il numero negativo uno (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.MinusOne%2A> proprietà viene utilizzata per confrontare un <xref:System.Numerics.BigInteger> il valore su -1 o -1 per assegnare un <xref:System.Numerics.BigInteger> oggetto.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Numero da elevare alla potenza di <c>exponent</c>.</param>
        <param name="exponent">Esponente per il quale elevare <c>value</c>.</param>
        <param name="modulus">Numero per il quale eseguire la divisione di <c>value</c> elevato alla potenza di <c>exponent</c>.</param>
        <summary>Esegue la divisione con modulo per un numero elevato alla potenza di un altro numero.</summary>
        <returns>Resto risultante dalla divisione di <paramref name="value" /><sup>exponent</sup> per <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.ModPow%2A> metodo valuta l'espressione seguente:  
  
 (baseValue ^ esponente) Modulo Mod  
  
 Eseguire l'elevamento a potenza sugli <xref:System.Numerics.BigInteger> valori senza divisione del modulo, usare il <xref:System.Numerics.BigInteger.Pow%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente fornisce una semplice chiamare la <xref:System.Numerics.BigInteger.ModPow%2A> metodo.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="modulus" /> è zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exponent" /> è negativo.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo numero da moltiplicare.</param>
        <param name="right">Secondo numero da moltiplicare.</param>
        <summary>Restituisce il prodotto di due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Prodotto dei parametri <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.Multiply%2A> metodo viene implementato per lingue che non supportano l'overload degli operatori. Il comportamento è identico alla moltiplicazione utilizzando l'operatore di moltiplicazione. Inoltre, il <xref:System.Numerics.BigInteger.Multiply%2A> metodo è un sostituto utile per l'operatore di moltiplicazione quando si crea un <xref:System.Numerics.BigInteger> variabile mediante l'assegnazione di un prodotto risultante dalla moltiplicazione, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Se necessario, questo metodo esegue automaticamente la conversione implicita di altri tipi integrali a <xref:System.Numerics.BigInteger> oggetti. Come illustrato nell'esempio nella sezione successiva, in cui il <xref:System.Numerics.BigInteger.Multiply%2A> viene passato due <xref:System.Int64> valori.  
  
   
  
## Examples  
 Nell'esempio seguente tenta di eseguire la moltiplicazione con due valori long integer. Poiché il risultato supera l'intervallo di un valore long integer, un <xref:System.OverflowException> viene generata e <xref:System.Numerics.BigInteger.Multiply%2A> metodo viene chiamato per gestire la moltiplicazione. Si noti che in c# è necessario utilizzare uno di `checked` (parola chiave) (come in questo esempio) o `/checked+` l'opzione del compilatore per assicurarsi che viene generata un'eccezione in una condizione di overflow numerico.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da negare.</param>
        <summary>Nega un valore <see cref="T:System.Numerics.BigInteger" /> specificato.</summary>
        <returns>Risultato del parametro <paramref name="value" /> moltiplicato per il valore uno negativo (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La negazione ottiene l'inverso additivo di un numero. L'inverso additivo di un numero è un numero che produce un valore pari a zero quando viene aggiunto al numero originale.  
  
 Il <xref:System.Numerics.BigInteger.Negate%2A> metodo viene implementato per lingue che non supportano gli operatori personalizzati. Il comportamento è identico alla negazione utilizzando l'operatore di negazione unario. Inoltre, il <xref:System.Numerics.BigInteger.Negate%2A> metodo è un sostituto utile per l'operatore di negazione quando si crea un <xref:System.Numerics.BigInteger> variabile, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 Nell'esempio seguente vengono illustrati tre modi per negare il valore di un <xref:System.Numerics.BigInteger> oggetto.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che rappresenta il numero uno (1).</summary>
        <value>Oggetto il cui valore è il numero uno (1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.One%2A> proprietà viene in genere utilizzata per confrontare un <xref:System.Numerics.BigInteger> il valore su 1 o 1 per assegnare un <xref:System.Numerics.BigInteger> oggetto.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da sommare.</param>
        <param name="right">Secondo valore da sommare.</param>
        <summary>Somma i valori di due oggetti <see cref="T:System.Numerics.BigInteger" /> specificati.</summary>
        <returns>Somma di <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Addition%2A> metodo consente di definire l'operazione di addizione per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Add%2A> metodo invece.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore.</param>
        <param name="right">Secondo valore.</param>
        <summary>Esegue un'operazione <see langword="And" /> bit per bit su due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Risultato dell'operazione <see langword="And" /> bit per bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> metodo consente di definire il bit per bit `And` operazione per <xref:System.Numerics.BigInteger> valori. Bit per bit `And` operazione consente di impostare un risultato bit solo se i bit corrispondenti `left` e `right` impostati anche, come illustrato nella tabella seguente.  
  
|Bit in `left`|Bit in `right`|Bit nel risultato|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 Il <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> metodo consente al codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 Il <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> metodo esegue il bit per bit `And` operazione su due <xref:System.Numerics.BigInteger> valori come se fossero entrambi nella rappresentazione in complemento a due con l'estensione del segno virtuale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore.</param>
        <param name="right">Secondo valore.</param>
        <summary>Esegue un'operazione <see langword="Or" /> bit per bit su due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Risultato dell'operazione <see langword="Or" /> bit per bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> metodo consente di definire il bit per bit `Or` operazione per <xref:System.Numerics.BigInteger> valori. Bit per bit `Or` operazione consente di impostare un risultato bit solo se uno o entrambi i bit corrispondenti nella `left` e `right` sono impostate, come illustrato nella tabella seguente.  
  
|Bit in `left`|Bit in `right`|Bit nel risultato|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 Il <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> metodo consente al codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 Il <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> metodo esegue il bit per bit `Or` operazione su due <xref:System.Numerics.BigInteger> valori come se fossero entrambi nella rappresentazione in complemento a due con l'estensione del segno virtuale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da decrementare.</param>
        <summary>Decrementa un valore <see cref="T:System.Numerics.BigInteger" /> di 1.</summary>
        <returns>Valore del parametro <paramref name="value" /> decrementato di 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Decrement%2A> metodo consente di definire l'operazione di decremento per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Subtract%2A> metodo invece. Ad esempio:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Perché <xref:System.Numerics.BigInteger> oggetti non sono modificabili, la <xref:System.Numerics.BigInteger.op_Decrement%2A> operatore crea un nuovo <xref:System.Numerics.BigInteger> oggetto il cui valore è inferiore a quello della <xref:System.Numerics.BigInteger> oggetto rappresentato dal `value`. Ciò significa che le chiamate ripetute a <xref:System.Numerics.BigInteger.op_Decrement%2A> potrebbe essere conveniente.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valore da dividere.</param>
        <param name="divisor">Valore per cui dividere.</param>
        <summary>Divide un valore <see cref="T:System.Numerics.BigInteger" /> specificato per un altro valore <see cref="T:System.Numerics.BigInteger" /> specificato tramite una divisione intera.</summary>
        <returns>Risultato integrale della divisione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Division%2A> metodo consente di definire l'operazione di divisione per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Linguaggi che non supportano gli operatori personalizzati e l'overload degli operatori possono chiamare il <xref:System.Numerics.BigInteger.Divide%2A> metodo invece.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 L'esempio seguente crea una matrice di <xref:System.Numerics.BigInteger> valori. Ogni elemento viene quindi utilizzato come il quoziente in un'operazione di divisione che utilizza il <xref:System.Numerics.BigInteger.Divide%2A> metodo, l'operatore di divisione (/) e il <xref:System.Numerics.BigInteger.DivRem%2A> metodo.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> è 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se due valori sono uguali.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore Signed Long Integer e un valore <see cref="T:System.Numerics.BigInteger" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> metodo consente di definire l'operazione di confronto di uguaglianza per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metodo dell'istanza.  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore Signed Long Integer e un valore <see cref="T:System.Numerics.BigInteger" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> metodo consente di definire l'operazione di confronto di uguaglianza per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metodo dell'istanza.  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se i valori di due oggetti <see cref="T:System.Numerics.BigInteger" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodo definisce il funzionamento dell'operatore di uguaglianza per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodo dell'istanza.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore Unsigned Long Integer e un valore <see cref="T:System.Numerics.BigInteger" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodo consente di definire l'operazione di confronto di uguaglianza per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodo dell'istanza.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore Unsigned Long Integer e un valore <see cref="T:System.Numerics.BigInteger" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodo consente di definire l'operazione di confronto di uguaglianza per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodo dell'istanza.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore.</param>
        <param name="right">Secondo valore.</param>
        <summary>Esegue un'operazione <see langword="Or" /> (<see langword="XOr" />) bit per bit esclusiva su due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Risultato dell'operazione <see langword="Or" /> bit per bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il risultato di un bit per bit esclusivo `Or` operazione `true` se i valori dei due bit sono diversi; in caso contrario, è `false`. Nella tabella seguente vengono illustrate esclusivo `Or` operazione.  
  
|Bit x `left`|Bit x `right`|Valore restituito|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 Il <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> metodo consente al codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 Il <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> metodo esegue esclusivo bit per bit `Or` operazione su due <xref:System.Numerics.BigInteger> valori come se fossero entrambi nella rappresentazione in complemento a due con l'estensione del segno virtuale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definisce una conversione esplicita tra un oggetto <see cref="T:System.Numerics.BigInteger" /> e un altro tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Decimal" /> in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria del `value` parametro viene troncato prima della conversione.

 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. Poiché la conversione da <xref:System.Decimal> al <xref:System.Numerics.BigInteger> può coinvolgere il troncamento di una parte frazionaria di `value`, i compilatori di linguaggio non eseguono questa conversione automaticamente. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.   

 Per le lingue che non supportano gli operatori personalizzati, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 Nell'esempio seguente converte i singoli elementi in una matrice di <xref:System.Decimal> valori <xref:System.Numerics.BigInteger> oggetti e quindi Visualizza il risultato di ogni conversione. Si noti che qualsiasi frazionari fa parte di un <xref:System.Decimal> valore viene troncato durante la conversione.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione esplicita di un valore <see cref="T:System.Double" /> in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria del `value` parametro viene troncato prima della conversione.

 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. Poiché la conversione da <xref:System.Double> al <xref:System.Numerics.BigInteger> può coinvolgere il troncamento di una parte frazionaria di `value`, i compilatori di linguaggio non eseguono questa conversione automaticamente. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.

 Per le lingue che non supportano gli operatori personalizzati, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 Nell'esempio seguente converte i singoli elementi in una matrice di <xref:System.Double> valori <xref:System.Numerics.BigInteger> oggetti e quindi Visualizza il risultato di ogni conversione. Si noti che qualsiasi frazionari fa parte di un <xref:System.Double> valore viene troncato durante la conversione.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Double.NaN" />.  -oppure- Il valore di <paramref name="value" /> è <see cref="F:System.Double.PositiveInfinity" />.
 -oppure- Il valore di <paramref name="value" /> è <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Byte" />.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore byte senza segno.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CByte` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.   

 Poiché questa operazione definisce una conversione di narrowing, è possibile che venga generato un <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.Byte> tipo di dati. Senza perdita di precisione in risultante <xref:System.Byte> valore se la conversione ha esito positivo.

## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Byte> valori. Questo tipo gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo il <xref:System.Byte> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.Byte.MinValue" />.  -oppure- Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Decimal" />.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore <see cref="T:System.Decimal" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CDec` in Visual Basic) viene utilizzato.   

 Poiché questa operazione definisce una conversione di narrowing, è possibile che venga generato un <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.Decimal> tipo di dati. 

## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Decimal> valori. Questo tipo gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo il <xref:System.Decimal> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.Decimal.MinValue" />.  -oppure- Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Double" />.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore <see cref="T:System.Double" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CDbl` in Visual Basic) viene utilizzato.   

 Poiché il <xref:System.Numerics.BigInteger> valore può essere compreso nell'intervallo di <xref:System.Double> del tipo di dati, questa operazione è una conversione di narrowing. Se la conversione non riesce, non viene generato un <xref:System.OverflowException>. Al contrario, se il <xref:System.Numerics.BigInteger> valore è minore <xref:System.Double.MinValue?displayProperty=nameWithType>, il valore risultante <xref:System.Double> valore è <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Se il <xref:System.Numerics.BigInteger> valore è maggiore <xref:System.Double.MaxValue?displayProperty=nameWithType>, il valore risultante <xref:System.Double> valore <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 La conversione di un <xref:System.Numerics.BigInteger> a un <xref:System.Double> può comportare una perdita di precisione. In alcuni casi, la perdita di precisione può causare l'operazione di cast o conversione abbia esito positivo anche se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.Double> tipo di dati. Nell'esempio seguente viene illustrato questo concetto. Assegna il valore massimo di un <xref:System.Double> a due <xref:System.Numerics.BigInteger> variabili, incrementa una <xref:System.Numerics.BigInteger> variabile 9.999 e291 e verifica l'uguaglianza di due variabili. Come previsto, la chiamata al <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodo mostra che non sono uguali. Tuttavia, la conversione del più ampio <xref:System.Numerics.BigInteger> riletto a un <xref:System.Double> ha esito positivo, anche se il <xref:System.Numerics.BigInteger> valore ora supera <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Double> valori.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero con segno a 16 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore Signed Integer a 16 bit.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CShort` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.   

 Poiché questa operazione definisce una conversione di narrowing, è possibile che venga generato un <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.Int16> tipo di dati. Senza perdita di precisione in risultante <xref:System.Int16> valore se la conversione ha esito positivo.

## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Int16> valori. Questo tipo gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo il <xref:System.Int16> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.Int16.MinValue" />.  -oppure- Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero con segno a 32 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore intero con segno a 32 bit.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CInt` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.   

 Poiché questa operazione definisce una conversione di narrowing, è possibile che venga generato un <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.Int32> tipo di dati. Senza perdita di precisione in risultante <xref:System.Int16> valore se la conversione ha esito positivo.

## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Int32> valori. Questo tipo gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo il <xref:System.Int32> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.Int32.MinValue" />.  -oppure- Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero con segno a 64 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore intero con segno a 64 bit.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CLng` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.  

 Poiché questa operazione definisce una conversione di narrowing, è possibile che venga generato un <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.Int64> tipo di dati. 

## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Int64> valori. Questo tipo gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo il <xref:System.Int64> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.Int64.MinValue" />.  -oppure- Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un valore con segno a 8 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore a 8 bit con segno.  Questa API non è conforme a CLS. L'alternativa conforme è <see cref="T:System.Int16" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CSByte` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.  

 Poiché questa operazione definisce una conversione di narrowing, è possibile che venga generato un <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.SByte> tipo di dati. Senza perdita di precisione in risultante <xref:System.SByte> valore se la conversione ha esito positivo.

## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.SByte> valori. Questo tipo gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo il <xref:System.SByte> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.SByte.MinValue" />.  -oppure- Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un valore a virgola mobile e precisione singola.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore in virgola mobile a precisione singola.</summary>
        <returns>Oggetto che contiene la rappresentazione più vicina possibile del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati o la perdita di precisione. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CSng` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.    

 Poiché il <xref:System.Numerics.BigInteger> valore può essere compreso nell'intervallo di <xref:System.Single> del tipo di dati, questa operazione è una conversione di narrowing. Se la conversione non riesce, non viene generato un <xref:System.OverflowException>. Al contrario, se il <xref:System.Numerics.BigInteger> valore è minore <xref:System.Single.MinValue?displayProperty=nameWithType>, il valore risultante <xref:System.Single> valore è <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Se il <xref:System.Numerics.BigInteger> valore è maggiore <xref:System.Single.MaxValue?displayProperty=nameWithType>, il valore risultante <xref:System.Single> valore <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 La conversione di un <xref:System.Numerics.BigInteger> a un <xref:System.Single> può comportare una perdita di precisione. In alcuni casi, la perdita di precisione può causare l'operazione di cast o conversione abbia esito positivo anche se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.Single> tipo di dati. Nell'esempio seguente viene illustrato questo concetto. Assegna il valore massimo di un <xref:System.Single> a due <xref:System.Numerics.BigInteger> variabili, incrementa una <xref:System.Numerics.BigInteger> variabile 9.999 e291 e verifica l'uguaglianza di due variabili. Come previsto, la chiamata al <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodo mostra che non sono uguali. Tuttavia, la conversione del più ampio <xref:System.Numerics.BigInteger> riletto a un <xref:System.Single> ha esito positivo, anche se il <xref:System.Numerics.BigInteger> valore ora supera <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Single> valori.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero senza segno a 16 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore Unsigned Integer a 16 bit.  Questa API non è conforme a CLS. L'alternativa conforme è <see cref="T:System.Int32" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CUShort` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.    

 Poiché questa operazione definisce una conversione di narrowing, è possibile che venga generato un <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.UInt16> tipo di dati. Senza perdita di precisione in risultante <xref:System.UInt16> valore se la conversione ha esito positivo.

## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.UInt16> valori. Questo tipo gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo il <xref:System.UInt16> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.UInt16.MinValue" />.  -oppure- Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero senza segno a 32 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore intero senza segno a 32 bit.  Questa API non è conforme a CLS. L'alternativa conforme è <see cref="T:System.Int64" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CUInt` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.    

 Poiché questa operazione definisce una conversione di narrowing, è possibile che venga generato un <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.UInt32> tipo di dati. Senza perdita di precisione in risultante <xref:System.UInt32> valore se la conversione ha esito positivo.

## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.UInt32> valori. Questo tipo gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo il <xref:System.UInt32> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.UInt32.MinValue" />.  -oppure- Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero senza segno a 64 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore intero senza segno a 64 bit.  Questa API non è conforme a CLS. L'alternativa conforme è <see cref="T:System.Double" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CULng` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.    

 Poiché questa operazione definisce una conversione di narrowing, è possibile che venga generato un <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.UInt64> tipo di dati. Senza perdita di precisione in risultante <xref:System.UInt64> valore se la conversione ha esito positivo.

## Examples
 Nell'esempio seguente viene illustrata la conversione di <xref:System.Numerics.BigInteger> a <xref:System.UInt64> valori. Questo tipo gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo il <xref:System.UInt64> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.UInt64.MinValue" />.  -oppure- Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione esplicita di un valore <see cref="T:System.Single" /> in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria del `value` parametro viene troncato prima della conversione.
 
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. Poiché la conversione da <xref:System.Single> al <xref:System.Numerics.BigInteger> può coinvolgere il troncamento di una parte frazionaria di `value`, i compilatori di linguaggio non eseguono questa conversione automaticamente. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` in Visual Basic) viene utilizzato. Verranno inoltre visualizzati in caso contrario, un errore del compilatore.

 Per le lingue che non supportano gli operatori personalizzati, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 Nell'esempio seguente converte i singoli elementi in una matrice di <xref:System.Single> valori <xref:System.Numerics.BigInteger> oggetti e quindi Visualizza il risultato di ogni conversione. Si noti che qualsiasi frazionari fa parte di un <xref:System.Single> valore viene troncato durante la conversione.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Single.NaN" />.  -oppure- Il valore di <paramref name="value" /> è <see cref="F:System.Single.PositiveInfinity" />.
 -oppure- Il valore di <paramref name="value" /> è <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se un valore specificato è maggiore di un altro valore specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Signed Integer a 64 bit è maggiore di un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThan%2A> metodo definisce il funzionamento dell'operatore per maggiore <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo dell'istanza. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un <see cref="T:System.Numerics.BigInteger" /> è maggiore di un valore Signed Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThan%2A> metodo definisce il funzionamento dell'operatore per maggiore <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore di un altro valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThan%2A> metodo definisce il funzionamento dell'operatore per maggiore <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore di un Unsigned Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThan%2A> metodo definisce il funzionamento dell'operatore per maggiore <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore di un Unsigned Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThan%2A> metodo definisce il funzionamento dell'operatore per maggiore <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se un valore specificato è maggiore o uguale a un altro valore specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Signed Integer a 64 bit è maggiore o uguale a un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> metodo consente di definire il funzionamento di maggiore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore o uguale a un valore Signed Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> metodo consente di definire il funzionamento di maggiore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore o uguale a un altro valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> metodo consente di definire il funzionamento di maggiore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore o uguale a un valore Unsigned Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> metodo consente di definire il funzionamento di maggiore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Unsigned Integer a 64 bit è maggiore o uguale a un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> metodo consente di definire il funzionamento di maggiore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definisce una conversione implicita tra un oggetto <see cref="T:System.Numerics.BigInteger" /> e un altro tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un byte senza segno in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria del `value` parametro viene troncato prima della conversione.

 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Byte> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un Signed Integer a 16 bit in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Int16> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un intero con segno a 32 bit in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Int32> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un intero con segno a 64 bit in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Int64> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un Signed Integer a 8 bit in un valore <see cref="T:System.Numerics.BigInteger" />.  Questa API non è conforme a CLS. L'alternativa conforme è <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.SByte> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un Unsigned Integer a 16 bit in un valore <see cref="T:System.Numerics.BigInteger" />.  Questa API non è conforme a CLS. L'alternativa conforme è <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.UInt16> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un intero senza segno a 32 bit in un valore <see cref="T:System.Numerics.BigInteger" />.  Questa API non è conforme a CLS. L'alternativa conforme è <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.UInt32> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un intero senza segno a 64 bit in un valore <see cref="T:System.Numerics.BigInteger" />.  Questa API non è conforme a CLS. L'alternativa conforme è <see cref="T:System.Double" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che non comportano perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.UInt64> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da incrementare.</param>
        <summary>Incrementa un valore <see cref="T:System.Numerics.BigInteger" /> di 1.</summary>
        <returns>Valore del parametro <paramref name="value" /> incrementato di 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Increment%2A> metodo consente di definire l'operazione di incremento per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Alcuni linguaggi (ad esempio Visual Basic) che non dispongono di un operatore di incremento o che non supportano l'overload degli operatori è possono chiamare il <xref:System.Numerics.BigInteger.op_Increment%2A> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Poiché <xref:System.Numerics.BigInteger> oggetti non sono modificabili, il <xref:System.Numerics.BigInteger.op_Increment%2A> crea un nuovo operatore <xref:System.Numerics.BigInteger> oggetto il cui valore è uno rispetto al <xref:System.Numerics.BigInteger> oggetto rappresentato dal `value`. Pertanto, le chiamate ripetute a <xref:System.Numerics.BigInteger.op_Increment%2A> potrebbe essere conveniente.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se due valori numerici non sono uguali.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Signed Integer a 64 bit e un valore <see cref="T:System.Numerics.BigInteger" /> non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Lingue che non supportano gli operatori personalizzati possono testare la disuguaglianza utilizzando una delle tecniche seguenti:  
  
-   La chiamata di <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> istanza di metodo, che indica la relazione tra un <xref:System.Numerics.BigInteger> e un valore long integer.  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> istanza metodo e inversione del relativo valore.  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> e un Signed Integer a 64 bit non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Lingue che non supportano gli operatori personalizzati possono testare la disuguaglianza utilizzando una delle tecniche seguenti:  
  
-   La chiamata di <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo, che indica la relazione tra un <xref:System.Numerics.BigInteger> e un valore long integer.  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metodo e inversione del relativo valore.  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se due oggetti <see cref="T:System.Numerics.BigInteger" /> hanno valori diversi.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Lingue che non supportano gli operatori personalizzati possono testare la disuguaglianza utilizzando una delle tecniche seguenti:  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metodo, che indica la relazione tra due <xref:System.Numerics.BigInteger> oggetti.  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodo e inversione del relativo valore.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> e un Unsigned Integer a 64 bit non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Lingue che non supportano gli operatori personalizzati possono testare la disuguaglianza utilizzando una delle tecniche seguenti:  
  
-   La chiamata di <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo, che indica la relazione tra un <xref:System.Numerics.BigInteger> e un valore intero lungo senza segno.  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodo e inversione del relativo valore.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Unsigned Integer a 64 bit e un valore <see cref="T:System.Numerics.BigInteger" /> non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Lingue che non supportano gli operatori personalizzati possono testare la disuguaglianza utilizzando una delle tecniche seguenti:  
  
-   La chiamata di <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo, che indica la relazione tra un <xref:System.Numerics.BigInteger> e un valore intero lungo senza segno.  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodo e inversione del relativo valore.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valore di cui spostare i bit.</param>
        <param name="shift">Numero di bit in base al quale spostare <c>value</c> a sinistra.</param>
        <summary>Sposta un valore <see cref="T:System.Numerics.BigInteger" /> di un numero specificato di bit verso sinistra.</summary>
        <returns>Valore spostato a sinistra del numero specificato di bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LeftShift%2A> metodo definisce il funzionamento dell'operatore di spostamento a sinistra bit per bit per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  A differenza dell'operazione di spostamento a sinistra bit per bit con le primitive di integer, il <xref:System.Numerics.BigInteger.op_LeftShift%2A> metodo mantiene il segno di originale <xref:System.Numerics.BigInteger> valore.  
  
 Lingue che non supportano gli operatori personalizzati possono eseguire un'operazione di spostamento a sinistra bit per bit moltiplicando `value` da `BigInteger.Pow(2, shift)`. Nell'esempio seguente viene illustrato che i risultati sono identici ai risultati dell'utilizzo di questo operatore.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se un valore specificato è minore di un secondo valore specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Signed Integer a 64 bit è minore di un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThan%2A> metodo definisce il funzionamento dell'operatore per minore <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore di un Signed Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThan%2A> metodo definisce il funzionamento dell'operatore per minore <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore di un altro valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThan%2A> metodo definisce il funzionamento dell'operatore per minore <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metodo invece. Alcuni linguaggi è inoltre possono chiamare il <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore di un Unsigned Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThan%2A> metodo definisce il funzionamento dell'operatore per minore <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Unsigned Integer a 64 bit è minore di un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThan%2A> metodo definisce il funzionamento dell'operatore per minore <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se un valore specificato è minore o uguale a un altro valore specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Signed Integer a 64 bit è minore o uguale a un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> metodo definisce il funzionamento dell'operatore minore di o uguale a per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore o uguale a un Signed Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> metodo definisce il funzionamento dell'operatore minore di o uguale a per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore o uguale a un altro valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> metodo definisce il funzionamento dell'operatore minore di o uguale a per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Compare%2A> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore o uguale a un Unsigned Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> metodo definisce il funzionamento dell'operatore minore di o uguale a per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Unsigned Integer a 64 bit è minore o uguale a un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> metodo definisce il funzionamento dell'operatore minore di o uguale a per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valore da dividere.</param>
        <param name="divisor">Valore per cui dividere.</param>
        <summary>Restituisce il resto risultante dalla divisione di due valori <see cref="T:System.Numerics.BigInteger" /> specificati.</summary>
        <returns>Resto risultante dalla divisione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Modulus%2A> metodo definisce il funzionamento dell'operatore modulo per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> metodo invece.  
  
 Il segno del valore restituito dall'operazione modulo dipende dal segno del `dividend`: se `dividend` è positivo, l'operazione modulo restituisce un risultato positivo; in caso negativo, l'operazione modulo restituisce un risultato negativo. Il comportamento dell'operazione modulo con <xref:System.Numerics.BigInteger> valori è identico all'operazione di modulo con altri tipi integrali.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> è 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da moltiplicare.</param>
        <param name="right">Secondo valore da moltiplicare.</param>
        <summary>Moltiplica due valori <see cref="T:System.Numerics.BigInteger" /> specificati.</summary>
        <returns>Prodotto di <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Multiply%2A> metodo consente di definire il funzionamento dell'operatore di moltiplicazione per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore intero.</param>
        <summary>Restituisce il complemento a uno bit per bit di un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Complemento a uno bit per bit dell'oggetto <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_OnesComplement%2A> metodo consente di definire il funzionamento di bit per bit operatore complemento a uno per <xref:System.Numerics.BigInteger> valori. Bit per bit inverte operatore di complemento di uno ogni bit in un valore numerico. Vale a dire, bit `value` che sono 0 vengono impostati su 1 nel risultato e che sono pari a 1 bit vengono impostati su 0 nel risultato. Il <xref:System.Numerics.BigInteger.op_OnesComplement%2A> metodo consente al codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Lingue che non supportano gli operatori personalizzati possono essere in grado di chiamare il <xref:System.Numerics.BigInteger.op_OnesComplement%2A> metodo direttamente per eseguire un bit per bit di una operazione di complemento. Ad esempio:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valore di cui spostare i bit.</param>
        <param name="shift">Numero di bit in base al quale spostare <c>value</c> a destra.</param>
        <summary>Sposta un valore <see cref="T:System.Numerics.BigInteger" /> di un numero specificato di bit verso destra.</summary>
        <returns>Valore spostato a destra del numero specificato di bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_RightShift%2A> metodo definisce il funzionamento dell'operatore di spostamento a destra bit per bit per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono eseguire un'operazione di spostamento a destra bit per bit dividendo `value` da `BigInteger.Pow(2, shift)` e sottraendo 1 volte `shift` per i valori negativi. Nell'esempio seguente viene illustrato che i risultati sono identici ai risultati dell'utilizzo di questo operatore.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Se `shift` è maggiore o uguale al numero di bit in un numero positivo <xref:System.Numerics.BigInteger> valore, il risultato dell'operazione di spostamento a destra è <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Se `shift` è maggiore del numero di bit in un valore negativo <xref:System.Numerics.BigInteger> valore, il risultato dell'operazione di spostamento a destra è <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Valore da cui sottrarre (minuendo).</param>
        <param name="right">Valore da sottrarre (sottraendo).</param>
        <summary>Sottrae un valore <see cref="T:System.Numerics.BigInteger" /> da un altro valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Risultato della sottrazione di <paramref name="right" /> da <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Subtraction%2A> metodo definisce il funzionamento dell'operatore di sottrazione per <xref:System.Numerics.BigInteger> valori. Permette inoltre il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> metodo invece.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da negare.</param>
        <summary>Nega un valore BigInteger specificato.</summary>
        <returns>Risultato del parametro <paramref name="value" /> moltiplicato per il valore uno negativo (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> metodo definisce il funzionamento dell'operatore di negazione unario (o l'operatore inverso additivo) per <xref:System.Numerics.BigInteger> valori. L'operazione produce un valore che restituisce 0 (zero) quando viene aggiunto al numero originale. Linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Negate%2A> metodo invece.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 L'esempio seguente illustra tre modi diversi per negare il valore di un <xref:System.Numerics.BigInteger> oggetto.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore intero.</param>
        <summary>Restituisce il valore dell'operando <see cref="T:System.Numerics.BigInteger" />. Il segno dell'operando resta invariato.</summary>
        <returns>Valore dell'operando <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> metodo definisce il funzionamento dell'operatore unario positivo per <xref:System.Numerics.BigInteger> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte la rappresentazione di stringa di un numero nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa che contiene il numero da convertire.</param>
        <summary>Converte la rappresentazione di stringa di un numero nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valore equivalente al numero specificato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro deve essere la rappresentazione di stringa di un numero nel formato seguente.  
  
 [*ws*] [*sign*]*cifre*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo.|  
|*sign*|Un segno facoltativo. Caratteri segno validi sono determinati dal <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti.|  
|*digits*|Una sequenza di cifre comprese tra 0 e 9. Gli eventuali zeri iniziali vengono ignorati.|  
  
> [!NOTE]
>  La stringa specificata per il `value` parametro viene interpretato usando la <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stile. Non può contenere qualsiasi i separatori di gruppi o di un separatore decimale e non può avere una parte decimale.  
  
 Il `value` parametro viene analizzato tramite le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> oggetto che viene inizializzato per la lingua di sistema corrente. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Per analizzare una stringa usando le informazioni di formattazione delle impostazioni cultura specifiche, utilizzare il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> metodo.  
  
> [!IMPORTANT]
>  Se si utilizza il <xref:System.Numerics.BigInteger.Parse%2A> metodo per il round trip la rappresentazione di stringa di un <xref:System.Numerics.BigInteger> valore ottenuto come risultato il <xref:System.Numerics.BigInteger.ToString%2A> metodo, è consigliabile utilizzare il <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metodo con l'identificatore di formato "R" per generare la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore. In caso contrario, la rappresentazione di stringa del <xref:System.Numerics.BigInteger> mantiene solo i 50 cifre più significative del valore originale e i dati andranno perduti quando si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo per il ripristino di <xref:System.Numerics.BigInteger> valore.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la <xref:System.Numerics.BigInteger.Parse%28System.String%29> metodo per creare un'istanza di due <xref:System.Numerics.BigInteger> oggetti. Moltiplica ogni oggetto da un altro numero e quindi chiama il <xref:System.Numerics.BigInteger.Compare%2A> metodo per determinare la relazione tra i due valori.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> non è nel formato corretto.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che specifica il formato consentito di <c>value</c>.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valore equivalente al numero specificato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `style` parametro definisce gli elementi di stile (ad esempio, lo spazio vuoto, il simbolo di segno positivo o negativo, il simbolo di separatore di gruppo o il simbolo di separatore decimale) consentite nella `value` parametro per l'operazione di analisi abbia esito positivo. `styles` deve contenere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. Il `style` parametro rende il metodo di overload utili quando `value` contiene la rappresentazione di stringa di un valore esadecimale, quando il sistema di numero (decimale o esadecimale) rappresentato da `value` è noto solo in fase di esecuzione, o quando si non consentire lo spazio vuoto o un simbolo di segno `value`.  
  
 A seconda del valore di `style`, il `value` parametro può includere gli elementi seguenti:  
  
 [*ws*] [*$*] [*sign*] [*cifre*,]*cifre*[.* frazionarie*] [E [*sign*]*cifre_esponenziali*] [*ws*]  
  
 Se `style` include <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, il `value` parametro può contenere i seguenti elementi:  
  
 [*ws*]*cifre esadecimali*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo. Spazi vuoti possono essere visualizzati all'inizio di `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|*$*|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita per il <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti. Simbolo di valuta le impostazioni cultura correnti può essere incluse nel `value` se `style` include la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Un segno facoltativo. Il segno può essere visualizzati all'inizio di `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `value` per indicare un valore negativo se `style` include la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Una sequenza di cifre compreso tra 0 e 9. Per *frazionarie*, solo la cifra 0 è valida.|  
|*,*|Un simbolo di separatore di gruppo di impostazioni cultura specifiche. Separatore di gruppi di impostazioni cultura correnti può essere presente in `value` se `style` include la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale le impostazioni cultura correnti può essere incluse nel `value` se `style` include la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag. Solo la cifra 0 può essere visualizzati come una cifra frazionaria per l'operazione di analisi abbia esito positivo; Se *frazionarie* include qualsiasi altra cifra, un <xref:System.FormatException> viene generata un'eccezione.|  
|E|La "e" o il carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `value` parametro può rappresentare un numero in notazione esponenziale se `style` include la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esadecimali*|Una sequenza di cifre esadecimali da 0 a f, oppure tra 0 e F.|  
  
 Una stringa che contiene solo cifre (che corrisponde al <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) viene sempre analizzata correttamente. La maggior parte delle rimanenti <xref:System.Globalization.NumberStyles> membri controllano gli elementi che possono essere presenti, ma non deve essere presente nella stringa di input. Nella tabella seguente viene indicato come singoli <xref:System.Globalization.NumberStyles> membri interessano gli elementi che possono essere presenti in `value`.  
  
|Valore di `NumberStyles`|Elementi consentiti in `value` oltre alle cifre|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale () e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|La "e" o il carattere "E", che indica la notazione esponenziale, insieme a *cifre_esponenziali*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Elemento separatore (,) del gruppo.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Elemento valuta ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* elemento all'inizio o alla fine del `value`, *sign* all'inizio del `value`e il separatore decimale (*.*) simbolo. Il `value` parametro può inoltre utilizzare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, separatore di gruppi (*,*) e separatore decimale (*.*) elementi.|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale.|  
  
> [!IMPORTANT]
>  Se si utilizza il <xref:System.Numerics.BigInteger.Parse%2A> metodo per il round trip la rappresentazione di stringa di un <xref:System.Numerics.BigInteger> valore ottenuto come risultato il <xref:System.Numerics.BigInteger.ToString%2A> metodo, è consigliabile utilizzare il <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metodo con l'identificatore di formato "R" per generare la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore. In caso contrario, la rappresentazione di stringa del <xref:System.Numerics.BigInteger> mantiene solo i 50 cifre più significative del valore originale e i dati andranno perduti quando si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo per il ripristino di <xref:System.Numerics.BigInteger> valore.  
  
 A differenza di altri <xref:System.Globalization.NumberStyles> valori, che consentono di, ma non richiedono la presenza di particolari elementi di stile in `value`, la <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> valore dello stile significa che i singoli caratteri numerici in `value` vengono sempre interpretate come caratteri esadecimali. I caratteri esadecimali validi sono 0-9, A-F e -f. Gli unici altri flag che possono essere combinati con la `style` parametro vengono <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Il <xref:System.Globalization.NumberStyles> enumerazione include uno stile numero composto, <xref:System.Globalization.NumberStyles.HexNumber>, che include entrambi i flag di spazi vuoti.)  
  
> [!NOTE]
>  Se `value` è la rappresentazione di stringa di un numero esadecimale, non può essere preceduto da qualsiasi effetto (ad esempio `0x` o `&h`) che lo distingue come numero esadecimale. In questo modo la conversione a non riuscire.  
  
 Se `value` è una stringa esadecimale, il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metodo interpreta `value` come numero negativo archiviato tramite la rappresentazione in complemento a due se le prime due cifre esadecimali sono quelli maggiori o uguali a `0x80`. In altre parole, il metodo interpreta il bit più significativo del primo byte in `value` come bit di segno. Per assicurarsi che una stringa esadecimale viene correttamente interpretata come un numero positivo, la prima cifra `value` deve avere un valore pari a zero. Ad esempio, il metodo interpreta `0x80` come un valore negativo, ma interpreta `0x080` o `0x0080` come un valore positivo. Nell'esempio seguente viene illustrata la differenza tra stringhe esadecimali che rappresentano valori positivi e negativi.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Il `value` parametro viene analizzato tramite le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto che viene inizializzato per la lingua di sistema corrente. Per specificare le impostazioni cultura le cui informazioni di formattazione viene utilizzati per l'operazione di analisi, chiamare il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> rapporto di overload.  
  
   
  
## Examples  
 Nell'esempio seguente sono illustrate le chiamate per il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metodo con diversi valori possibili per il `style` parametro. Viene illustrato come interpretare una stringa come valore esadecimale e come impedire spazi e simboli.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  -oppure- <paramref name="style" /> include il flag <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> o <see cref="F:System.Globalization.NumberStyles.HexNumber" /> insieme a un altro valore.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> non è conforme al criterio di input specificato da <see cref="T:System.Globalization.NumberStyles" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Stringa che contiene un numero da convertire.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura relative a <c>value</c>.</param>
        <summary>Converte la rappresentazione di stringa di un numero in un formato specifico delle impostazioni cultura indicato nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valore equivalente al numero specificato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro deve essere la rappresentazione di stringa di un numero nel formato seguente:  
  
 [*ws*] [*sign*]*cifre*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo.|  
|*sign*|Un segno facoltativo. Caratteri segno validi sono determinati dal <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> proprietà del <xref:System.Globalization.NumberFormatInfo> oggetto restituito dal `provider` dell'oggetto <xref:System.IFormatProvider.GetFormat%2A> metodo.|  
|*digits*|Una sequenza di cifre comprese tra 0 e 9. Gli eventuali zeri iniziali vengono ignorati.|  
  
> [!NOTE]
>  La stringa specificata per il `value` parametro viene interpretato utilizzando il <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stile. Non può contenere qualsiasi i separatori di gruppi o di un separatore decimale e non può avere una parte decimale.  
  
> [!IMPORTANT]
>  Se si utilizza il <xref:System.Numerics.BigInteger.Parse%2A> metodo per il round trip la rappresentazione di stringa di un <xref:System.Numerics.BigInteger> valore ottenuto come risultato il <xref:System.Numerics.BigInteger.ToString%2A> metodo, è consigliabile utilizzare il <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metodo con l'identificatore di formato "R" per generare la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore. In caso contrario, la rappresentazione di stringa del <xref:System.Numerics.BigInteger> mantiene solo i 50 cifre più significative del valore originale e i dati andranno perduti quando si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo per il ripristino di <xref:System.Numerics.BigInteger> valore.  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura. Quando il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> metodo viene richiamato, viene chiamato il `provider` del parametro <xref:System.IFormatProvider.GetFormat%2A> metodo e lo passa a un <xref:System.Type> oggetto che rappresenta il <xref:System.Globalization.NumberFormatInfo> tipo. Il <xref:System.IFormatProvider.GetFormat%2A> metodo quindi restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni relative al formato del `value` parametro. Esistono tre modi per utilizzare il `provider` parametro per fornire informazioni di formattazione personalizzate per l'operazione di analisi:  
  
-   È possibile passare un <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che fornisce informazioni di formattazione. Il relativo <xref:System.Globalization.CultureInfo.GetFormat%2A> metodo restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche per impostazioni cultura.  
  
-   È possibile passare l'effettivo <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> appena restituisce se stesso.)  
  
-   È possibile passare un oggetto personalizzato che implementa <xref:System.IFormatProvider>. Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo crea e restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null`, la formattazione della `value` viene interpretato in base il <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura correnti.  
  
   
  
## Examples  
 Gli esempi seguenti illustrano due modalità per definire la tilde (~) come un segno negativo per la formattazione <xref:System.Numerics.BigInteger> valori. Si noti che per visualizzare il <xref:System.Numerics.BigInteger> valori nello stesso formato delle stringhe originali, il codice deve chiamare il <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodo e passarlo il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Nel primo esempio viene definita una classe che implementa <xref:System.IFormatProvider> e Usa la <xref:System.IFormatProvider.GetFormat%2A> per restituire il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Oggetto <xref:System.Numerics.BigInteger> oggetto possa quindi essere creata un'istanza con il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Nel secondo esempio è più semplice. Passa la <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione per il `provider` parametro.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> non è nel formato corretto.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che specifica il formato consentito di <c>value</c>.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura relative a <c>value</c>.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato e un formato specifico delle impostazioni cultura indicato nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valore equivalente al numero specificato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `style` parametro definisce gli elementi di stile (ad esempio, lo spazio vuoto, il simbolo di segno positivo o negativo, il simbolo di separatore di gruppo o il simbolo di separatore decimale) consentite nella `value` parametro per l'operazione di analisi abbia esito positivo. `styles` deve contenere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. Il `style` parametro rende il metodo di overload utili quando `value` contiene la rappresentazione di stringa di un valore esadecimale, quando il sistema di numero (decimale o esadecimale) rappresentato da `value` è noto solo in fase di esecuzione, o quando si non consentire lo spazio vuoto o un simbolo di segno `value`.  
  
 A seconda del valore di `style`, il `value` parametro può includere gli elementi seguenti:  
  
 [*ws*] [*$*] [*sign*] [*cifre*,]*cifre*[*. frazionarie*] [E [*sign*]*cifre_esponenziali*] [*ws*]  
  
 Se `style` include <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, il `value` parametro può includere gli elementi seguenti:  
  
 [*ws*]*cifre esadecimali*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo. Spazi vuoti possono essere visualizzati all'inizio di `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|*$*|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita dal <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> delle proprietà delle impostazioni cultura indicato dal `provider` parametro. Simbolo di valuta le impostazioni cultura correnti può essere incluse nel `value` se `style` include la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Un segno facoltativo. Il segno può essere visualizzati all'inizio di `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `value` per indicare un valore negativo se `style` include la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Una sequenza di cifre compreso tra 0 e 9. Per *frazionarie*, solo la cifra 0 è valida.|  
|*,*|Un simbolo di separatore di gruppo di impostazioni cultura specifiche. Il simbolo di separatore di gruppo di impostazioni cultura specificate da `provider` possono essere visualizzati nelle `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche. Il simbolo di separatore decimale delle impostazioni cultura designato da `provider` possono essere visualizzati nelle `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag. Solo la cifra 0 può essere visualizzati come una cifra frazionaria per l'operazione di analisi abbia esito positivo; Se *frazionarie* include qualsiasi altra cifra, un <xref:System.FormatException> viene generata un'eccezione.|  
|E|La "e" o il carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `value` parametro può rappresentare un numero in notazione esponenziale se `style` include la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esadecimali*|Una sequenza di cifre esadecimali da 0 a f, oppure tra 0 e F.|  
  
 Una stringa che contiene solo cifre (che corrisponde al <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) viene sempre analizzata correttamente. La maggior parte delle rimanenti <xref:System.Globalization.NumberStyles> membri controllano gli elementi che possono essere presenti, ma non deve essere presente nella stringa di input. Nella tabella seguente viene indicato come singoli <xref:System.Globalization.NumberStyles> membri interessano gli elementi che possono essere presenti in `value`.  
  
|Valore NumberStyles|Elementi consentiti nel valore oltre alle cifre|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale () e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|La "e" o il carattere "E", che indica la notazione esponenziale. insieme a *cifre_esponenziali*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Elemento separatore (,) del gruppo.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Elemento valuta ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* elemento all'inizio o alla fine del `value`, *sign* all'inizio di `value`e il simbolo di separatore decimale (.). Il `value` parametro può inoltre utilizzare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, il separatore di gruppi (,) e gli elementi il separatore decimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale.|  
  
> [!IMPORTANT]
>  Se si utilizza il <xref:System.Numerics.BigInteger.Parse%2A> metodo per il round trip la rappresentazione di stringa di un <xref:System.Numerics.BigInteger> valore ottenuto come risultato il <xref:System.Numerics.BigInteger.ToString%2A> metodo, è consigliabile utilizzare il <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metodo con l'identificatore di formato "R" per generare la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore. In caso contrario, la rappresentazione di stringa del <xref:System.Numerics.BigInteger> mantiene solo i 50 cifre più significative del valore originale e i dati andranno perduti quando si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo per il ripristino di <xref:System.Numerics.BigInteger> valore.  
  
 A differenza di altri <xref:System.Globalization.NumberStyles> valori, che consentono di ma che non richiedono la presenza di particolari elementi di stile in `value`, la <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> valore dello stile significa che i singoli caratteri numerici in `value` vengono sempre interpretate come caratteri esadecimali. I caratteri esadecimali validi sono 0-9, A-F e -f. Gli unici altri flag che possono essere combinati con la `style` parametro vengono <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Il <xref:System.Globalization.NumberStyles> enumerazione include uno stile numero composto, <xref:System.Globalization.NumberStyles.HexNumber>, che include entrambi i flag di spazi vuoti.)  
  
> [!NOTE]
>  Se `value` è la rappresentazione di stringa di un numero esadecimale, non può essere preceduto da qualsiasi effetto (ad esempio `0x` o `&h`) che lo distingue come numero esadecimale. In questo modo la conversione a non riuscire.  
  
 Se `value` è una stringa esadecimale, il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metodo interpreta `value` come numero negativo archiviato tramite la rappresentazione in complemento a due se le prime due cifre esadecimali sono quelli maggiori o uguali a `0x80`. In altre parole, il metodo interpreta il bit più significativo del primo byte in `value` come bit di segno. Per assicurarsi che una stringa esadecimale viene correttamente interpretata come un numero positivo, la prima cifra `value` deve avere un valore pari a zero. Ad esempio, il metodo interpreta `0x80` come un valore negativo, ma interpreta `0x080` o `0x0080` come un valore positivo. Nell'esempio seguente viene illustrata la differenza tra stringhe esadecimali che rappresentano valori positivi e negativi.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione. Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura relative al formato di `value`. In genere, `provider` può essere uno dei seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che fornisce informazioni sulla formattazione numeriche. Il relativo <xref:System.Globalization.CultureInfo.GetFormat%2A> metodo restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche.  
  
-   Oggetto <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> appena restituisce se stesso.)  
  
-   Un oggetto personalizzato che implementa <xref:System.IFormatProvider> e Usa la <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> per creare un'istanza e restituire il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null`, il <xref:System.Globalization.NumberFormatInfo> per le impostazioni cultura correnti dell'oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente effettua più chiamate per il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metodo utilizzando varie combinazioni di valori per il `style` e `provider` parametri.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Un numero di singole chiamate per il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metodo passare un'istanza delle operazioni seguenti `BigIntegerFormatProvider` (classe), che definisce una tilde (~) come il segno negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  -oppure- <paramref name="style" /> include il flag <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> o <see cref="F:System.Globalization.NumberStyles.HexNumber" /> insieme a un altro valore.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> non è conforme al criterio di input specificato da <paramref name="style" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Numero da elevare alla potenza di <c>exponent</c>.</param>
        <param name="exponent">Esponente per il quale elevare <c>value</c>.</param>
        <summary>Eleva alla potenza di un valore specificato il valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Risultato di <paramref name="value" /> elevato alla potenza di <paramref name="exponent" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.Pow%2A> metodo viene restituito 1 se il valore del parametro esponente è 0 o se i valori di entrambe le `value` e `exponent` i parametri sono pari a 0. Se `exponent` è 1, il <xref:System.Numerics.BigInteger.Pow%2A> restituisce `value`. Se `value` è negativo, il metodo restituisce un risultato negativo.  
  
 Questo metodo corrisponde al <xref:System.Math.Pow%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di elevamento a potenza un <xref:System.Numerics.BigInteger> valore e un esponente il cui valore compreso tra 0 e 10.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="exponent" /> è negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valore da dividere.</param>
        <param name="divisor">Valore per cui dividere.</param>
        <summary>Esegue una divisione intera su due valori <see cref="T:System.Numerics.BigInteger" /> e restituisce il resto.</summary>
        <returns>Resto risultante dalla divisione di <paramref name="dividend" /> per <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il segno del resto è il segno del `dividend` parametro.  
  
 Il <xref:System.Numerics.BigInteger.Remainder%2A> metodo viene implementato per lingue che non supportano gli operatori personalizzati. Il comportamento è identico alla divisione utilizzando l'operatore modulo.  
  
 Se necessario, il metodo esegue automaticamente la conversione implicita di altri tipi integrali a <xref:System.Numerics.BigInteger> oggetti prima di eseguire l'operazione di modulo.  
  
   
  
## Examples  
 Nell'esempio seguente vengono confrontati il resto i <xref:System.Numerics.BigInteger.DivRem%2A> con il resto restituito dal metodo il <xref:System.Numerics.BigInteger.Remainder%2A> metodo per stabilire che i due metodi calcolano resti identici.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> è 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un numero che indica il segno (negativo, positivo o zero) dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente.</summary>
        <value>Numero che indica il segno dell'oggetto <see cref="T:System.Numerics.BigInteger" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Numero </term><description> descrizione </description></listheader><item><term> -1 </term><description> il valore di questo oggetto è negativo.  </description></item><item><term> 0 </term><description> il valore di questo oggetto è 0 (zero).  </description></item><item><term> 1 </term><description> il valore di questo oggetto è positivo.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.Sign%2A> è equivalente alla proprietà di <xref:System.Math.Sign%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Valore da cui sottrarre (minuendo).</param>
        <param name="right">Valore da sottrarre (sottraendo).</param>
        <summary>Sottrae un valore <see cref="T:System.Numerics.BigInteger" /> da un altro e restituisce il risultato.</summary>
        <returns>Risultato della sottrazione di <paramref name="right" /> da <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I linguaggi che non supportano gli operatori personalizzati possono utilizzare il <xref:System.Numerics.BigInteger.Subtract%2A> metodo per eseguire sottrazioni utilizzando <xref:System.Numerics.BigInteger> valori.  
  
 Il <xref:System.Numerics.BigInteger.Subtract%2A> metodo è un sostituto utile per l'operatore di sottrazione quando si crea un <xref:System.Numerics.BigInteger> variabile tramite l'assegnazione la differenza risultante dalla sottrazione, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte un valore <see cref="T:System.Numerics.BigInteger" /> in una matrice di byte.</summary>
        <returns>Valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente convertito in una matrice di byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I singoli byte nella matrice restituita da questo metodo vengono visualizzati in ordine little-endian. Vale a dire, i byte meno significativi del valore precedono i byte di ordine superiore. Il primo byte della matrice riflette i primi otto bit del <xref:System.Numerics.BigInteger> valore, il secondo byte riflette l'otto bit successivo e così via. Ad esempio, il valore 1024 o 0x0400, viene archiviata come la seguente matrice a due byte.  
  
|Elemento|Valore byte|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 I valori negativi vengono scritti nella matrice utilizzando la rappresentazione in complemento a due nel possibile formato più compatto. Ad esempio, -1 viene rappresentato come un singolo byte il cui valore è `0xFF` invece che sotto forma di matrice con più elementi, ad esempio `0xFF`, `0xFF` o `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Poiché in complemento a due rappresentazione sempre interpreta il bit di ordine più elevato dell'ultimo byte nella matrice (il byte nella posizione <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) come bit di segno, il metodo restituisce una matrice di byte con un elemento aggiuntivo il cui valore è uguale a zero per evitare ambiguità tra i valori positivi che potrebbero altrimenti essere interpretati come impostare i bit di segno. Ad esempio, il valore 120 o `0x78` viene rappresentato come una matrice a byte singolo: `0x78`. Tuttavia, 128, o `0x80`, viene rappresentata come una matrice di byte di due: `0x80`, `0x00`.  
  
 È possibile round trip una <xref:System.Numerics.BigInteger> valore da archiviare in una matrice di byte e quindi eseguire il ripristino utilizzando il <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore.  
  
> [!CAUTION]
>  Se il codice modifica il valore di singoli byte nella matrice restituita da questo metodo prima di ripristinare il valore, è necessario assicurarsi che non si involontariamente modifica il bit di segno. Ad esempio, se le modifiche aumenta un valore positivo, in modo che l'ordine più elevato di bit nell'ultimo elemento della matrice di byte diventa impostato, che è possibile aggiungere un nuovo byte il cui valore è uguale a zero alla fine della matrice.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come alcune <xref:System.Numerics.BigInteger> i valori sono rappresentati in matrici di byte.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore numerico dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente nella rappresentazione di stringa equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte il valore numerico dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente nella rappresentazione di stringa equivalente.</summary>
        <returns>Rappresentazione di stringa del valore <see cref="T:System.Numerics.BigInteger" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.ToString> formati del metodo un <xref:System.Numerics.BigInteger> valore "R", o round trip, formato delle impostazioni cultura correnti. Se si desidera specificare un formato diverso o delle impostazioni cultura, usare gli altri overload del <xref:System.Numerics.BigInteger.ToString%2A> (metodo), come indicato di seguito:  
  
|Per utilizzare il formato|Per impostazioni cultura|Utilizzare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato round-trip ("R")|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Un formato specifico|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Un formato specifico|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore include un segno negativo se il relativo valore è negativo e una sequenza di cifre comprese tra 0 e 9 senza zeri iniziali. Il segno negativo è definito dal <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti.  
  
   
  
## Examples  
 L'esempio seguente mostra una <xref:System.Numerics.BigInteger> valore utilizzando il valore predefinito <xref:System.Numerics.BigInteger.ToString> metodo. Visualizza anche le rappresentazioni di stringa del <xref:System.Numerics.BigInteger> valore risultante dall'utilizzo di alcuni identificatori di formato standard. Gli esempi vengono visualizzati utilizzando le convenzioni di formattazione delle impostazioni cultura en-US.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore numerico dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente nella rappresentazione di stringa equivalente usando le informazioni di formattazione specifiche delle impostazioni cultura indicate.</summary>
        <returns>Rappresentazione di stringa del valore <see cref="T:System.Numerics.BigInteger" /> corrente nel formato specificato dal parametro <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> formati del metodo una <xref:System.Numerics.BigInteger> valore in "R" o round trip, formattare utilizzando il <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura specificata. Se si desidera specificare le impostazioni cultura correnti o un formato diverso, usare gli altri overload del <xref:System.Numerics.BigInteger.ToString%2A> (metodo), come indicato di seguito:  
  
|Per utilizzare il formato|Per impostazioni cultura|Utilizzare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato round-trip ("R")|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString>|  
|Un formato specifico|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Un formato specifico|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione. Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura sul formato della stringa restituita da questo metodo. Se `provider` viene `null`, la <xref:System.Numerics.BigInteger> valore viene formattato utilizzando il <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura correnti. L'unica proprietà il <xref:System.Globalization.NumberFormatInfo> oggetto che controlla la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore usando l'identificatore di formato generale è <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, che definisce il carattere che rappresenta il segno negativo.  
  
 Il `provider` parametro può essere uno dei seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che fornisce informazioni di formattazione.  
  
-   Il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
-   Un oggetto personalizzato che implementa <xref:System.IFormatProvider>. Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza di un oggetto personalizzato <xref:System.Globalization.NumberFormatInfo> oggetto che definisce la tilde (~) come un segno negativo. Il <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> metodo utilizza quindi l'oggetto personalizzato <xref:System.Globalization.NumberFormatInfo> oggetto per visualizzare un valore negativo <xref:System.Numerics.BigInteger> valore.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato numerico standard o personalizzato.</param>
        <summary>Converte il valore numerico dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente nella rappresentazione di stringa equivalente, usando il formato specificato.</summary>
        <returns>Rappresentazione di stringa del valore <see cref="T:System.Numerics.BigInteger" /> corrente nel formato specificato dal parametro <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.ToString%28System.String%29> formati del metodo una <xref:System.Numerics.BigInteger> valore in un formato specificato usando un <xref:System.Globalization.NumberFormatInfo> oggetto che rappresenta le convenzioni delle impostazioni cultura correnti. Se si desidera utilizzare il "R" o i round trip, formattare o specificare una lingua diversa, utilizzare gli altri overload del <xref:System.Numerics.BigInteger.ToString%2A> (metodo), come indicato di seguito:  
  
|Per utilizzare il formato|Per impostazioni cultura|Utilizzare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato round-trip ("R")|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString>|  
|Formato round-trip ("R")|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Un formato specifico|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il `format` parametro può essere qualsiasi [stringa numerica standard](~/docs/standard/base-types/standard-numeric-format-strings.md), o qualsiasi combinazione di [stringhe di formato numerico personalizzate](~/docs/standard/base-types/custom-numeric-format-strings.md). Se `format` è uguale a <xref:System.String.Empty?displayProperty=nameWithType> oppure `null`, il valore restituito dell'oggetto corrente <xref:System.Numerics.BigInteger> oggetto viene formattato con l'identificatore di formato round trip ("R"). Se `format` è qualsiasi altro valore, il metodo genera un <xref:System.FormatException>.  
  
 .NET Framework fornisce supporto di formattazione completo, come descritto in maggior dettaglio negli argomenti di formattazione seguenti:  
  
-   Per ulteriori informazioni sugli identificatori di formato numerico, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per ulteriori informazioni sul supporto per la formattazione in .NET Framework, vedere [formattazione dei tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Il formato della stringa restituita è determinato dal <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti. A seconda di `format` parametro, questo oggetto controlla i simboli, ad esempio il segno negativo, il separatore di gruppo e il simbolo di separatore decimale nella stringa di output. Per fornire informazioni di formattazione per le impostazioni cultura diverse da quelle correnti, chiamare il <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> rapporto di overload.  
  
   
  
## Examples  
 Nell'esempio seguente viene inizializzato un <xref:System.Numerics.BigInteger> valore e viene visualizzato tramite ogni stringa di formato standard e alcune stringhe di formato personalizzata.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è una stringa di formato valida.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato numerico standard o personalizzato.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore numerico dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente nella rappresentazione di stringa equivalente usando il formato specificato e le informazioni di formattazione specifiche delle impostazioni cultura indicate.</summary>
        <returns>Rappresentazione di stringa del valore corrente di <see cref="T:System.Numerics.BigInteger" />, come specificato dai parametri <paramref name="format" /> e <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> formati del metodo una <xref:System.Numerics.BigInteger> valore in un formato specificato utilizzando il <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura specificata. Se si desidera utilizzare il formato di round trip o impostazioni cultura predefinito, utilizzare gli altri overload del <xref:System.Numerics.BigInteger.ToString%2A> (metodo), come indicato di seguito:  
  
|Per utilizzare il formato|Per impostazioni cultura|Utilizzare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato round-trip ("R")|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString>|  
|Formato round-trip ("R")|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Un formato specifico|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 Il `format` parametro può essere qualsiasi [stringa numerica standard](~/docs/standard/base-types/standard-numeric-format-strings.md), o qualsiasi combinazione di [stringhe di formato numerico personalizzate](~/docs/standard/base-types/custom-numeric-format-strings.md). Se `format` è uguale a <xref:System.String.Empty?displayProperty=nameWithType> oppure `null`, il valore restituito dell'oggetto corrente <xref:System.Numerics.BigInteger> oggetto viene formattato con l'identificatore di formato round trip ("R"). Se `format` è qualsiasi altro valore, il metodo genera un <xref:System.FormatException>.  
  
 .NET Framework fornisce supporto di formattazione completo, come descritto in maggior dettaglio negli argomenti di formattazione seguenti:  
  
-   Per ulteriori informazioni sugli identificatori di formato numerico, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per ulteriori informazioni sul supporto per la formattazione in .NET Framework, vedere [formattazione dei tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione. Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura sul formato della stringa restituita da questo metodo. Quando il <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> metodo viene richiamato, viene chiamato il `provider` del parametro <xref:System.IFormatProvider.GetFormat%2A> metodo e lo passa a un <xref:System.Type> oggetto che rappresenta il <xref:System.Globalization.NumberFormatInfo> tipo. Il <xref:System.IFormatProvider.GetFormat%2A> metodo quindi restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni per la formattazione di `value` parametro, ad esempio il simbolo di segno negativo, il simbolo di separatore di gruppo o il simbolo di separatore decimale. Esistono tre modi per usare la `provider` parametro per fornire informazioni di formattazione per il <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> metodo:  
  
-   È possibile passare un <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che fornisce informazioni di formattazione. Il relativo <xref:System.Globalization.CultureInfo.GetFormat%2A> metodo restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche per impostazioni cultura.  
  
-   È possibile passare l'effettivo <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> appena restituisce se stesso.)  
  
-   È possibile passare un oggetto personalizzato che implementa <xref:System.IFormatProvider>. Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo crea e restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null`, la formattazione della stringa restituita è basata sul <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura correnti.  
  
   
  
## Examples  
 Nell'esempio seguente viene inizializzato un <xref:System.Numerics.BigInteger> valore e lo visualizza nella console utilizzando una stringa di formato standard e un <xref:System.Globalization.NumberFormatInfo> oggetto che definisce la tilde (~) come un segno negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è una stringa di formato valida.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova a convertire la rappresentazione di stringa di un numero nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente e restituisce un valore che indica se la conversione è stata eseguita correttamente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Rappresentazione di stringa di un numero.</param>
        <param name="result">Quando termina, questo metodo contiene l'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente al numero contenuto in <c>value</c> o zero (0) se la conversione non riesce. La conversione non riesce se il parametro <c>value</c> è <see langword="null" /> o se non è nel formato corretto. Questo parametro viene passato non inizializzato.</param>
        <summary>Prova a convertire la rappresentazione di stringa di un numero nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente e restituisce un valore che indica se la conversione è stata eseguita correttamente.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> metodo è simile al <xref:System.Numerics.BigInteger.Parse%28System.String%29> (metodo), ad eccezione del fatto che non genera un'eccezione se la conversione non riesce. Questo metodo elimina la necessità di utilizzare la gestione delle eccezioni per verificare la presenza di un <xref:System.FormatException> se `value` non è valido e non può essere analizzato correttamente.  
  
 Il `value` parametro deve essere la rappresentazione di stringa di un numero decimale nel formato seguente:  
  
 [*ws*] [*sign*]*cifre*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo.|  
|*sign*|Un segno facoltativo. Caratteri segno validi sono determinati dal <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti.|  
|*digits*|Una sequenza di cifre decimali comprese tra 0 e 9.|  
  
> [!NOTE]
>  La stringa specificata per il `value` parametro non può contenere qualsiasi i separatori di gruppi o di un separatore decimale e non può avere una parte decimale.  
  
 Il `value` parametro viene interpretato usando la <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stile. Oltre alle cifre decimali, sono consentiti solo spazi iniziali e finali con un segno iniziale. Per definire in modo esplicito gli elementi di stile con le informazioni di formattazione specifiche delle impostazioni cultura che possono essere presenti in `value`, chiamare il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodo.  
  
 Il `value` parametro viene analizzato tramite le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Questo overload interpreta tutte le cifre di `value` parametro come cifre decimali. Per analizzare la rappresentazione di stringa di un numero esadecimale, chiamare il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> invece l'overload.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> metodo per creare un'istanza di due <xref:System.Numerics.BigInteger> oggetti. Se le conversioni riesce, si moltiplica ogni oggetto da un altro numero e quindi chiama il <xref:System.Numerics.BigInteger.Compare%2A> metodo per determinare la relazione tra i due oggetti.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Rappresentazione di stringa di un numero. La stringa viene interpretata usando lo stile specificato da <c>style</c>.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che indica gli elementi di stile che possono essere presenti in <c>value</c>. Un valore tipico da specificare è <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura su <c>value</c>.</param>
        <param name="result">Quando termina, questo metodo contiene l'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente al numero contenuto in <c>value</c> o <see cref="P:System.Numerics.BigInteger.Zero" /> in caso di conversione non riuscita. La conversione non riesce se il parametro <c>value</c> è <see langword="null" /> o se non è in un formato conforme a <c>style</c>. Questo parametro viene passato non inizializzato.</param>
        <summary>Prova a convertire la rappresentazione di stringa di un numero in uno stile specificato e un formato specifico delle impostazioni cultura indicato nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente e restituisce un valore che indica se la conversione è stata eseguita correttamente.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodo è simile al <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> (metodo), ad eccezione del fatto che non genera un'eccezione se la conversione non riesce. Questo metodo elimina la necessità di utilizzare la gestione delle eccezioni per verificare la presenza di un <xref:System.FormatException> se `value` non è valido e non può essere analizzato correttamente.  
  
 Il `style` parametro definisce gli elementi di stile (ad esempio uno spazio vuoto o un segno positivo o negativo) che sono consentiti nel `value` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. A seconda del valore di `style`, il `value` parametro può includere gli elementi seguenti:  
  
 [*ws*] [*$*] [*sign*] [*cifre*,]*cifre*[.* frazionarie*] [E [*sign*]*cifre_esponenziali*] [*ws*]  
  
 Se il `style` includerà <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, il `value` parametro può includere gli elementi seguenti:  
  
 [*ws*]*cifre esadecimali*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo. Spazi vuoti possono essere visualizzati all'inizio di `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, o alla fine del `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|*$*|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita dal <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> proprietà del <xref:System.Globalization.NumberFormatInfo> oggetto restituito dal <xref:System.IFormatProvider.GetFormat%2A> metodo del `provider` parametro. Il simbolo di valuta può essere visualizzati `value` se `style` include la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Un segno facoltativo. Il segno può essere visualizzati all'inizio di `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `value` per indicare un valore negativo se `style` include la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*digits*|Una sequenza di cifre compreso tra 0 e 9.|  
|*,*|Separatore di gruppi di impostazioni cultura specifiche. Il separatore di gruppi di impostazioni cultura specificate da `provider` possono essere visualizzati nelle `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche. Il simbolo di separatore decimale delle impostazioni cultura specificate da `provider` possono essere visualizzati nelle `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*fractional_digits*|Una o più occorrenze della cifra 0. Cifre frazionarie visualizzabili nella `value` solo se `style` include la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|E|La "e" o il carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `value` parametro può rappresentare un numero in notazione esponenziale se `style` include la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*exponential_digits*|Una sequenza di cifre compreso tra 0 e 9. Il `value` parametro può rappresentare un numero in notazione esponenziale se `style` include la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esadecimali*|Una sequenza di cifre esadecimali da 0 a f, oppure tra 0 e F.|  
  
 Una stringa con solo cifre decimali (che corrisponde al <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flag) viene sempre analizzata correttamente. La maggior parte delle rimanenti <xref:System.Globalization.NumberStyles> membri controllano gli elementi che possono essere presenti, ma non deve essere presente, indicato in questa stringa di input. Nella tabella seguente viene indicato come singoli <xref:System.Globalization.NumberStyles> membri interessano gli elementi che possono essere presenti in `value`.  
  
|Non compositi `NumberStyles` valori|Elementi consentiti nel valore oltre alle cifre|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Cifre decimali.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale (*.*) e *frazionarie* elementi. Tuttavia, *frazionarie* deve essere costituito solo da uno o più cifre 0 o il metodo restituisce `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|La "e" o il carattere "E", che indica la notazione esponenziale, insieme a *cifre_esponenziali*. Se `value` rappresenta un numero in notazione esponenziale, non può avere un componente frazionario diverso da zero.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento prima *cifre*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento dopo *cifre*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Il separatore di gruppi (*,*) elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|La valuta (*$*) elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* elemento all'inizio o alla fine del `value`, *sign* all'inizio del `value`e il separatore decimale (*.*) simbolo. Il `value` parametro può inoltre utilizzare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il *ws*, *sign*, separatore di gruppi (*,*) e separatore decimale (*.*) elementi.|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale.|  
  
> [!IMPORTANT]
>  Se si utilizza il <xref:System.Numerics.BigInteger.TryParse%2A> metodo per il round trip la rappresentazione di stringa di un <xref:System.Numerics.BigInteger> valore ottenuto come risultato il <xref:System.Numerics.BigInteger.ToString%2A> metodo, è consigliabile utilizzare il <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metodo con l'identificatore di formato "R" per generare la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore. In caso contrario, la rappresentazione di stringa del <xref:System.Numerics.BigInteger> mantiene solo i 50 cifre più significative del valore originale e i dati andranno perduti quando si usa la <xref:System.Numerics.BigInteger.TryParse%2A> metodo per il ripristino di <xref:System.Numerics.BigInteger> valore.  
  
 Se il <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag viene utilizzato, `value` deve essere un valore esadecimale. Gli unici altri flag che possono essere presenti in `style` vengono <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Il <xref:System.Globalization.NumberStyles> enumerazione dispone di uno stile composto, <xref:System.Globalization.NumberStyles.HexNumber>, che include entrambi i flag di spazi vuoti.)  
  
> [!NOTE]
>  Se `value` è la rappresentazione di stringa di un numero esadecimale, non può essere preceduto da qualsiasi effetto (ad esempio `0x` o `&h`) che lo distingue come numero esadecimale. In questo modo la conversione a non riuscire.  
  
 Se `value` è una stringa esadecimale, il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodo interpreta `value` come numero negativo archiviato tramite la rappresentazione in complemento a due se le prime due cifre esadecimali sono quelli maggiori o uguali a `0x80`. In altre parole, il metodo interpreta il bit più significativo del primo byte in `value` come bit di segno. Per assicurarsi che una stringa esadecimale viene correttamente interpretata come un numero positivo, la prima cifra `value` deve avere un valore pari a zero. Ad esempio, il metodo interpreta `0x80` come un valore negativo, ma interpreta `0x080` o `0x0080` come un valore positivo. Nell'esempio seguente viene illustrata la differenza tra stringhe esadecimali che rappresentano valori positivi e negativi.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione. Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura relative al formato di `value`. Il `provider` parametro può essere uno dei seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che fornisce informazioni di formattazione. Il relativo <xref:System.Globalization.CultureInfo.GetFormat%2A> metodo restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche per impostazioni cultura.  
  
-   Oggetto <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> appena restituisce se stesso.)  
  
-   Un oggetto personalizzato che implementa <xref:System.IFormatProvider>. Il relativo <xref:System.IFormatProvider.GetFormat%2A> metodo crea e restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null`, il <xref:System.Globalization.NumberFormatInfo> per le impostazioni cultura correnti dell'oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente effettua alcune chiamate ai <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodo utilizzando varie combinazioni di valori per il `style` e `provider` parametri.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Un numero di singole chiamate per il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodo passare un'istanza delle operazioni seguenti `BigIntegerFormatProvider` (classe), che definisce una tilde (~) come il segno negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  -oppure- <paramref name="style" /> include il flag <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> o <see cref="F:System.Globalization.NumberStyles.HexNumber" /> insieme a un altro valore.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che rappresenta il numero 0 (zero).</summary>
        <value>Intero il cui valore è 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger> oggetto restituito da questa proprietà fornisce un'origine utile di un valore pari a zero per le assegnazioni e i confronti.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>