<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6058b5368fd11c472e3f58b2d14321fb07ab30c7" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52245602" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un intero con segno arbitrariamente grande.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger> è un tipo immutabile che rappresenta un integer arbitrariamente grande il cui valore in teoria non è limiti inferiori o superiori. I membri del <xref:System.Numerics.BigInteger> tipo sono strettamente paralleli a quelli di altri tipi integrali (la <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, e <xref:System.UInt64> tipi). Questo tipo è diverso dagli altri tipi integrali nella [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], che hanno un intervallo indicato da loro `MinValue` e `MaxValue` proprietà.  
  
> [!NOTE]
>  Poiché il <xref:System.Numerics.BigInteger> tipo non è modificabile (vedere [modificabilità e la struttura BigInteger](#mutability)) e non prevede alcun limite superiore o inferiore, un <xref:System.OutOfMemoryException> può essere generata per qualsiasi operazione che causa un <xref:System.Numerics.BigInteger> valore aumento eccessivo grandi dimensioni.  
  
## <a name="instantiating-a-biginteger-object"></a>Creare un'istanza di un oggetto BigInteger  
 È possibile creare un'istanza di un <xref:System.Numerics.BigInteger> oggetti in diversi modi:  
  
-   È possibile usare la `new` parola chiave e specificare qualsiasi valore a virgola mobile o integrale come parametro per il <xref:System.Numerics.BigInteger> costruttore. (Valori a virgola mobile vengono troncati prima che vengano assegnati al <xref:System.Numerics.BigInteger>.) L'esempio seguente illustra come usare il `new` parola chiave per creare un'istanza <xref:System.Numerics.BigInteger> valori.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   È possibile dichiarare un <xref:System.Numerics.BigInteger> variabile e assegnare un valore come verrebbe mostrata qualsiasi tipo numerico, a condizione che tale valore è un tipo integrale. Nell'esempio seguente usa l'assegnazione per creare un <xref:System.Numerics.BigInteger> valore da un <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   È possibile assegnare un valore decimale o a virgola mobile a un <xref:System.Numerics.BigInteger> se si esegue il cast di valore o convertirli prima dell'oggetto. Nell'esempio seguente viene eseguito il cast (in c#) o la conversione (in Visual Basic) in modo esplicito un <xref:System.Double> e una <xref:System.Decimal> valore un <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Questi metodi consentono di creare un'istanza di un <xref:System.Numerics.BigInteger> solo con tipi il cui valore è compreso nell'intervallo tra il valore numerico esistente. È possibile creare un'istanza di un <xref:System.Numerics.BigInteger> oggetto il cui valore può superare l'intervallo dei tipi numerici esistenti in uno dei tre modi:  
  
-   È possibile usare la `new` parola chiave e fornire una matrice di byte di qualsiasi dimensione per la <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> costruttore. Ad esempio:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   È possibile chiamare il <xref:System.Numerics.BigInteger.Parse%2A> oppure <xref:System.Numerics.BigInteger.TryParse%2A> metodi per convertire la rappresentazione di stringa di un numero a un <xref:System.Numerics.BigInteger>. Ad esempio:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   È possibile chiamare una `static` (`Shared` in Visual Basic) <xref:System.Numerics.BigInteger> metodo esegue alcune operazioni su un'espressione numerica e restituisce un calcolato <xref:System.Numerics.BigInteger> risultato. Nell'esempio seguente esegue questa operazione si <xref:System.UInt64.MaxValue?displayProperty=nameWithType> e l'assegnazione del risultato a un <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 Il valore inizializzato di un <xref:System.Numerics.BigInteger> è <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Esecuzione di operazioni su valori BigInteger  
 È possibile usare un <xref:System.Numerics.BigInteger> istanza come si userebbero qualsiasi altro tipo integrale. <xref:System.Numerics.BigInteger> esegue l'overload di operatori numerici standard per consentire di eseguire operazioni matematiche di base, ad esempio addizione, sottrazione, divisione, moltiplicazione, sottrazione, negazione e negazione unaria. È anche possibile usare gli operatori numerici standard per confrontare due <xref:System.Numerics.BigInteger> valori tra loro. Come altri tipi integrali <xref:System.Numerics.BigInteger> supporta anche il bit per bit `And`, `Or`, `XOr`, left shift e right shift (operatori). Per le lingue che non supportano gli operatori personalizzati, il <xref:System.Numerics.BigInteger> struttura fornisce inoltre metodi equivalenti per l'esecuzione di operazioni matematiche. Questi includono <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>e altri ancora.  
  
 Numero di membri del <xref:System.Numerics.BigInteger> struttura corrispondono direttamente ai membri di altri tipi integrali. Inoltre, <xref:System.Numerics.BigInteger> aggiunge membri simile al seguente:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, che restituisce un valore che indica il segno di un <xref:System.Numerics.BigInteger> valore.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, che restituisce il valore assoluto di un <xref:System.Numerics.BigInteger> valore.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, che restituisce sia il quoziente e resto di un'operazione di divisione.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, che restituisce il massimo comune divisore di due <xref:System.Numerics.BigInteger> valori.  
  
 Molti di questi membri aggiuntivi corrispondono ai membri del <xref:System.Math> (classe), che fornisce la funzionalità per lavorare con i tipi numerici primitivi.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Modificabilità e BigInteger (struttura)  
 Nell'esempio seguente crea un <xref:System.Numerics.BigInteger> dell'oggetto e quindi incrementa il valore di uno.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Sebbene questo esempio viene visualizzato per modificare il valore dell'oggetto esistente, questo non avviene. <xref:System.Numerics.BigInteger> gli oggetti non sono modificabili, vale a dire che internamente, common language runtime crea un nuovo <xref:System.Numerics.BigInteger> dell'oggetto e le assegna un valore più grande al suo valore precedente. Questo nuovo oggetto viene quindi restituito al chiamante.  
  
> [!NOTE]
>  Gli altri tipi numerici in .NET Framework sono anche non modificabili. Tuttavia, poiché il <xref:System.Numerics.BigInteger> tipo non dispone di alcun limiti inferiori o superiori, i relativi valori possono diventare estremamente grandi e ha un impatto apprezzabile sulle prestazioni.  
  
 Anche se questo processo è trasparente al chiamante, comportano una riduzione delle prestazioni. In alcuni casi, specialmente quando vengono eseguite operazioni ripetute in un ciclo su grandi <xref:System.Numerics.BigInteger> valori, la riduzione delle prestazioni può essere significativo. Nell'esempio seguente, ad esempio, un'operazione viene eseguita ripetutamente fino a un milione di volte e una <xref:System.Numerics.BigInteger> valore viene incrementato di uno ogni volta che l'operazione ha esito positivo.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 In tal caso, è possibile migliorare le prestazioni mediante l'esecuzione di tutte le assegnazioni intermediate per un <xref:System.Int32> variabile. Il valore finale della variabile può quindi essere assegnato i <xref:System.Numerics.BigInteger> oggetto quando il ciclo viene interrotto. Nell'esempio seguente viene illustrato questo concetto.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Utilizzo di stringhe esadecimali e matrici di Byte  
 Se si converte <xref:System.Numerics.BigInteger> i valori per le matrici di byte, o se si convertono le matrici di byte a <xref:System.Numerics.BigInteger> valori, è necessario considerare l'ordine dei byte. Il <xref:System.Numerics.BigInteger> struttura si aspetta che i singoli byte nella matrice di byte vengono visualizzati in ordine little-endian (vale a dire i byte meno significativo del valore precedono i byte di ordine superiore). È possibile eseguire il round trip una <xref:System.Numerics.BigInteger> valore chiamando il <xref:System.Numerics.BigInteger.ToByteArray%2A> metodo e quindi si passa il byte risultante di matrice per la <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Creare un'istanza di un <xref:System.Numerics.BigInteger> valore da una matrice di byte che rappresenta un valore di un altro tipo integrale, è possibile passare il valore integrale per il <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> (metodo) e quindi passare la matrice di byte risultante al <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore. Nell'esempio seguente crea una <xref:System.Numerics.BigInteger> valore da una matrice di byte che rappresenta un <xref:System.Int16> valore.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 Il <xref:System.Numerics.BigInteger> struttura si presuppone che i valori negativi vengono archiviati usando una rappresentazione di complemento a uno di due. Poiché il <xref:System.Numerics.BigInteger> struttura rappresenta un valore numerico con lunghezza non fissa, il <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore vengono sempre interpretati i bit più significativo dell'ultimo byte della matrice come bit di segno. Per impedire la <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore confonda di due rappresentazione di complemento di un valore negativo con la rappresentazione di segno e grandezza di un valore positivo, positivo valori in cui più bit significativi dell'ultimo byte nella matrice di byte solitamente sarebbe set deve includere un byte aggiuntivo il cui valore è 0. Ad esempio, 0xC0 0xBD 0xF0 0xFF è la rappresentazione esadecimale di little-endian di 1.000.000 o 4.293.967.296. Poiché il bit più significativo dell'ultimo byte nella matrice è attivato, il valore della matrice di byte verrebbe interpretato dal <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore come-1,000,000. Creare un'istanza di un <xref:System.Numerics.BigInteger> il cui valore è positivo, una matrice di byte cui elementi sono 0xC0 0xBD 0xF0 0xFF 0x00 deve essere passato al costruttore. Questa condizione è illustrata nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Creato da matrici di byte di <xref:System.Numerics.BigInteger.ToByteArray%2A> metodo dai valori positivi includere questo byte di valore zero aggiuntivo. Pertanto, il <xref:System.Numerics.BigInteger> struttura può correttamente il round trip dei valori assegnando loro a, e quindi ripristinarli dal, matrici di byte, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Tuttavia, potrebbe essere necessario aggiungere questo byte di valore pari a zero aggiuntiva per le matrici di byte che vengono creati dinamicamente dallo sviluppatore o che vengono restituiti dai metodi che convertono i valori interi senza segno a matrici di byte (ad esempio <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, e <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Durante l'analisi di una stringa esadecimale, il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> e <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodi presuppongono che, se è impostato il bit più significativo del primo byte nella stringa o se la prima cifra della stringa esadecimale rappresenta i quattro bit più bassi di un valore byte, il valore è rappresentati tramite la rappresentazione in complemento a due. Ad esempio, "FF01" sia "F01" rappresentano il valore decimale -255. Per differenziare positivi da valori negativi, i valori positivi devono includere uno zero iniziale. Gli overload pertinenti del <xref:System.Numerics.BigInteger.ToString%2A> metodo, quando vengono passati la stringa di formato "X", aggiungere uno zero iniziale per la stringa esadecimale restituito per i valori positivi. Questo rende possibile eseguire il round trip <xref:System.Numerics.BigInteger> valori mediante il <xref:System.Numerics.BigInteger.ToString%2A> e <xref:System.Numerics.BigInteger.Parse%2A> metodi, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Tuttavia, le stringhe esadecimali creato chiamando il `ToString` i metodi di altri tipi integrali o overload del <xref:System.Convert.ToString%2A> metodo che includono un `toBase` parametro non viene indicato il segno del valore o il tipo di dati di origine da cui è stata derivata la stringa esadecimale. Creazione di un'istanza correttamente un <xref:System.Numerics.BigInteger> valore da una stringa di questo tipo richiede una logica aggiuntiva. Nell'esempio seguente fornisce una possibile implementazione.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Matrice di valori byte in ordine little-endian.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando i valori di una matrice di byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I singoli byte il `value` matrice deve essere in ordine little-endian, dal livello più basso byte per byte più significativo. Ad esempio, il valore numerico 1.000.000.000.000 è rappresentato come illustrato nella tabella seguente:  
  
|||  
|-|-|  
|Stringa esadecimale|E8D4A51000|  
|Matrice di byte (indice minimo prima)|00 10 A5 D4 E8 00|  
  
 La maggior parte dei metodi che convertono i valori numerici in matrici di byte, ad esempio <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> e <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, restituire matrici di byte in ordine little-endian.  
  
 Il costruttore si aspetta valori positivi nella matrice di byte da usare la rappresentazione di segno e grandezza e i valori negativi da usare la rappresentazione in complemento a due. In altre parole, se l'ordine più elevato di bit del byte più significativo `value` è impostata, l'oggetto risultante <xref:System.Numerics.BigInteger> valore è negativo. A seconda dell'origine della matrice di byte, ciò potrebbe causare un valore positivo essere erroneamente interpretato come un valore negativo. Le matrici di byte in genere vengono generate nei modi seguenti:  
  
-   Chiamando il <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> (metodo). Poiché questo metodo restituisce una matrice di byte con il bit più significativo del byte più significativo nel set di matrice a zero per i valori positivi, non è Nessuna possibilità di un valore positivo come negativa, è preferibile formattarli. Senza modificarli create da matrici di byte i <xref:System.Numerics.BigInteger.ToByteArray%2A> sempre correttamente il round trip quando vengono passati al metodo il <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore.  
  
-   Chiamando il <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metodo e passando un signed integer come parametro. Poiché interi con segno a gestiscono la rappresentazione di segno e grandezza sia la rappresentazione in complemento a due, non è Nessuna possibilità di un valore positivo come negativa, è preferibile formattarli.  
  
-   Chiamando il <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> metodo e passando un integer senza segno come parametro. Poiché interi senza segno vengono rappresentati solo dalla grandezza, i valori positivi possono essere interpretati erroneamente come valori negativi. Per evitare questo problema, è possibile aggiungere un valore zero byte alla fine della matrice. L'esempio nella sezione successiva fornisce un'illustrazione.  
  
-   Tramite la creazione di una matrice di byte sia in modo statico o in modo dinamico senza necessariamente la chiamata a uno qualsiasi dei metodi precedenti, o modificando una matrice di byte esistente. Per impedire che i valori positivi vengano erroneamente interpretati come valori negativi, è possibile aggiungere un valore zero byte alla fine della matrice.  
  
 Se `value` è una classe vuota <xref:System.Byte> array, il nuovo <xref:System.Numerics.BigInteger> oggetto viene inizializzato su un valore di <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Se `value` viene `null`, il costruttore genera un <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 Nell'esempio seguente crea un <xref:System.Numerics.BigInteger> oggetto da una matrice di byte a 5 elementi il cui valore è {5, 4, 3, 2, 1}. Viene quindi visualizzato il <xref:System.Numerics.BigInteger> valore, rappresentato sotto forma di numeri decimali sia esadecimali, nella console. Un confronto della matrice di input con l'output di testo in modo chiaro perché questo overload del metodo il <xref:System.Numerics.BigInteger> costruttore di classe crea un <xref:System.Numerics.BigInteger> oggetto il cui valore è 4328719365 (o 0x102030405). Il primo elemento della matrice di byte, il cui valore è 5, definisce il valore del byte di ordine più basso di <xref:System.Numerics.BigInteger> oggetto, ovvero 0x05. Il secondo elemento della matrice di byte, il cui valore è 4, definisce il valore del secondo byte del <xref:System.Numerics.BigInteger> oggetto, ovvero 0x04 e così via.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 Nell'esempio seguente crea un'istanza di un numero positivo e negativo <xref:System.Numerics.BigInteger> valore, vengono passati per il <xref:System.Numerics.BigInteger.ToByteArray%2A> metodo, quindi viene ripristinato l'originale <xref:System.Numerics.BigInteger> valori dalla matrice di byte risultante. Si noti che i due valori sono rappresentati da matrici di byte identici. L'unica differenza tra di essi è in bit più significativo dell'ultimo elemento nella matrice di byte. Questo bit viene impostato (il valore del byte è 0xFF), se la matrice viene creata da un valore negativo <xref:System.Numerics.BigInteger> valore. Il bit non è impostato (il valore del byte è zero), se la matrice viene creata da un numero positivo <xref:System.Numerics.BigInteger> valore.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 L'esempio seguente illustra come assicurarsi che un valore positivo non è in modo non corretto creata un'istanza come un valore negativo tramite l'aggiunta di un byte il cui valore è uguale a zero alla fine della matrice.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Numero decimale.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando un valore <see cref="T:System.Decimal" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il risultato della chiamata di questo costruttore è identico all'assegnazione di in modo esplicito un <xref:System.Decimal> valore per un <xref:System.Numerics.BigInteger> variabile.  
  
 Chiamare questo costruttore può causare la perdita di dati. eventuale parte frazionaria `value` viene troncato quando si crea un <xref:System.Numerics.BigInteger> oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> costruttore per creare un'istanza di un <xref:System.Numerics.BigInteger> oggetto. Definisce una matrice di <xref:System.Decimal> valori e quindi passa ogni valore per il <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> costruttore. Si noti che il <xref:System.Decimal> valore viene troncato anziché arrotondata quando viene assegnato al <xref:System.Numerics.BigInteger> oggetto.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valore a virgola mobile e precisione doppia.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando un valore a virgola mobile con precisione doppia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria di `value` parametro viene troncato quando si crea un <xref:System.Numerics.BigInteger> oggetto.  
  
 A causa della mancanza di precisione del <xref:System.Double> tipo di dati, la chiamata a questo costruttore può causare la perdita di dati.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione esplicita di un <xref:System.Double> valore un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> costruttore per creare un'istanza di un <xref:System.Numerics.BigInteger> oggetto. Illustra anche la perdita di precisione che può verificarsi quando si usa il <xref:System.Double> tipo di dati. Oggetto <xref:System.Double> viene assegnato un valore di grandi dimensioni, che viene quindi assegnato a un <xref:System.Numerics.BigInteger> oggetto. Come illustrato nell'output, questa assegnazione comporta una perdita di precisione. Entrambi i valori vengono quindi incrementati di uno. L'output mostra che il <xref:System.Numerics.BigInteger> oggetto riflette il valore modificato, mentre il <xref:System.Double> oggetto non esiste.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Double.NaN" />.  
  
oppure 
Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Double.NegativeInfinity" />.  
  
oppure 
Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Intero con segno a 32 bit.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando un Signed Integer a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna perdita di precisione quando si crea un <xref:System.Numerics.BigInteger> oggetto utilizzando questo costruttore.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione di un <xref:System.Int32> valore un <xref:System.Numerics.BigInteger>.  
  
 Il <xref:System.Numerics.BigInteger> struttura non include costruttori con un parametro di tipo <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, o <xref:System.UInt16>. Tuttavia, il <xref:System.Int32> tipo supporta la conversione implicita di valori interi con e senza segno a 8 bit e a 16 bit a interi con segno a 32 bit. Di conseguenza, questo costruttore viene chiamato se `value` è uno di questi quattro tipi integrali.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> costruttore per creare un'istanza <xref:System.Numerics.BigInteger> valori da una matrice di interi a 32 bit. Usa inoltre la conversione implicita per assegnare ogni valore intero a 32 bit a un <xref:System.Numerics.BigInteger> variabile. Quindi confronta i due valori per stabilire che l'oggetto risultante <xref:System.Numerics.BigInteger> valori sono uguali.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Intero con segno a 64 bit.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> usando un valore intero con segno a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna perdita di precisione quando si crea un <xref:System.Numerics.BigInteger> oggetto utilizzando questo costruttore.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione di un <xref:System.Int64> valore un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> costruttore per creare un'istanza <xref:System.Numerics.BigInteger> valori da una matrice di interi a 64 bit. Usa inoltre la conversione implicita per assegnare ogni valore integer a 64 bit a un <xref:System.Numerics.BigInteger> variabile. Quindi confronta i due valori per stabilire che l'oggetto risultante <xref:System.Numerics.BigInteger> valori sono uguali.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valore a virgola mobile e precisione singola.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando un valore a virgola mobile con precisione singola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria di `value` parametro viene troncato quando si crea un <xref:System.Numerics.BigInteger> oggetto.  
  
 A causa della mancanza di precisione del <xref:System.Single> tipo di dati, la chiamata a questo costruttore può comportare una perdita di dati.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione esplicita di un <xref:System.Single> valore un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> costruttore per creare un'istanza di un <xref:System.Numerics.BigInteger> oggetto. Illustra anche la perdita di precisione che può verificarsi quando si usa il <xref:System.Single> tipo di dati. Oggetto <xref:System.Single> viene assegnato un valore negativo di grandi dimensioni, che viene quindi assegnato a un <xref:System.Numerics.BigInteger> oggetto. Come illustrato nell'output, questa assegnazione comporta una perdita di precisione. Entrambi i valori vengono quindi incrementati di uno. L'output mostra che il <xref:System.Numerics.BigInteger> oggetto riflette il valore modificato, mentre il <xref:System.Single> oggetto non esiste.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Single.NaN" />.  
  
oppure 
Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Single.NegativeInfinity" />.  
  
oppure 
Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valore intero senza segno a 32 bit.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> utilizzando un valore Unsigned Integer a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna perdita di precisione quando si crea un <xref:System.Numerics.BigInteger> utilizza questo costruttore.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione di un <xref:System.UInt32> valore un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> costruttore e un'istruzione di assegnazione per inizializzare <xref:System.Numerics.BigInteger> valori da una matrice di interi senza segno a 32 bit. Quindi confronta i due valori di dimostrare che i due metodi di inizializzazione di un <xref:System.Numerics.BigInteger> valore produce risultati identici.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Intero senza segno a 64 bit.</param>
        <summary>Inizializza una nuova istanza della struttura <see cref="T:System.Numerics.BigInteger" /> con un valore Unsigned Integer a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non vi è alcuna perdita di precisione quando si crea un <xref:System.Numerics.BigInteger> utilizza questo costruttore.  
  
 Il <xref:System.Numerics.BigInteger> valore risultante dalla chiamata di questo costruttore è identico al valore risultante dall'assegnazione di un <xref:System.UInt64> valore un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> costruttore per creare un'istanza di un <xref:System.Numerics.BigInteger> il cui valore è uguale all'oggetto <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Numero.</param>
        <summary>Ottiene il valore assoluto di un oggetto <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Valore assoluto di <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore assoluto di un numero è il numero senza segno, come illustrato nella tabella seguente.  
  
|Parametro `value`.|Valore restituito|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 Il <xref:System.Numerics.BigInteger.Abs%2A> metodo è equivalente al <xref:System.Math.Abs%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Numerics.BigInteger.Abs%2A> metodo per convertire un <xref:System.Numerics.BigInteger> valore dalla rappresentazione di complemento a uno di due di segno e grandezza prima di serializzarlo in un file. I dati nel file viene quindi deserializzati e assegnati a un nuovo <xref:System.Numerics.BigInteger> oggetto.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da sommare.</param>
        <param name="right">Secondo valore da sommare.</param>
        <summary>Somma due valori <see cref="T:System.Numerics.BigInteger" /> e restituisce il risultato.</summary>
        <returns>Somma di <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I linguaggi che non supportano l'overload degli operatori o gli operatori personalizzati possono utilizzare il <xref:System.Numerics.BigInteger.Add%2A> metodo per eseguire addizioni utilizzando <xref:System.Numerics.BigInteger> valori.  
  
 Il <xref:System.Numerics.BigInteger.Add%2A> metodo è un sostituto utile per l'operatore di addizione, quando si crea un <xref:System.Numerics.BigInteger> variabile assegnando alla VM una somma risultante dall'aggiunta, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Confronta due valori <see cref="T:System.Numerics.BigInteger" /> e restituisce un Integer che indica se il primo valore è minore, uguale o maggiore rispetto al secondo valore.</summary>
        <returns>Intero con segno che indica i valori relativi di <paramref name="left" /> e <paramref name="right" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore 
 </term><description> Condizione 
 </description></listheader><item><term> Minore di zero 
 </term><description><paramref name="left" /> è minore di <paramref name="right" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="left" /> è uguale a <paramref name="right" />.  
  
 </description></item><item><term> Maggiore di zero 
 </term><description><paramref name="left" /> è maggiore di <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se il <xref:System.Numerics.BigInteger> tipo non dispone di alcun intervallo fisso, i confronti di <xref:System.Numerics.BigInteger> valori non sono caratterizzati dalla mancanza di precisione che caratterizza il confronto di numeri a virgola mobile. Nell'esempio seguente vengono confrontate due <xref:System.Numerics.BigInteger> valori che differiscono di uno e ognuno dispone 1.896 cifre. Il <xref:System.Numerics.BigInteger.Compare%2A> metodo correttamente segnala che i due valori non sono uguali.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta il valore di questa istanza con un altro valore e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore dell'altro valore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Intero con segno a 64 bit da confrontare.</param>
        <summary>Confronta questa istanza con un intero con segno a 64 bit e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore del valore dell'intero con segno a 64 bit.</summary>
        <returns>Signed Integer che indica la relazione dell'istanza con <paramref name="other" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore restituito 
 </term><description> Descrizione 
 </description></listheader><item><term> Minore di zero 
 </term><description> L'istanza corrente è minore di <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> L'istanza corrente è uguale a <paramref name="other" />.  
  
 </description></item><item><term> Maggiore di zero 
 </term><description> L'istanza corrente è maggiore di <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `other` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> viene chiamato il metodo.  
  
   
  
## Examples  
 L'esempio seguente illustra il risultato della chiamata al metodo il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> metodo con i valori integrali.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Oggetto da confrontare.</param>
        <summary>Confronta questa istanza con un secondo <see cref="T:System.Numerics.BigInteger" /> e restituisce un Integer che indica se il valore di questa istanza è minore, uguale o maggiore rispetto al valore dell'oggetto specificato.</summary>
        <returns>Signed Integer che indica la relazione dell'istanza con <paramref name="other" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore restituito 
 </term><description> Descrizione 
 </description></listheader><item><term> Minore di zero 
 </term><description> L'istanza corrente è minore di <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> L'istanza corrente è uguale a <paramref name="other" />.  
  
 </description></item><item><term> Maggiore di zero 
 </term><description> L'istanza corrente è maggiore di <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo di <xref:System.Numerics.BigInteger.CompareTo%2A> metodo implementa il <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> (metodo). Utilizzato dagli oggetti di raccolte generiche per ordinare gli elementi nella raccolta.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> metodo per ordinare un elenco di `StarInfo` oggetti. Ogni `StarInfo` oggetto fornisce informazioni sul nome di una stella e della distanza da terra in miglia. `StarInfo` implementa il <xref:System.IComparable%601> dell'interfaccia, che abilita `StarInfo` gli oggetti in base a classi di raccolte generiche. Relativi <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementazione esegue semplicemente il wrapping di una chiamata a <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Il codice seguente crea poi quattro `StarInfo` degli oggetti e li archivia in un oggetto generico <xref:System.Collections.Generic.List%601> oggetto. Dopo il <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> viene chiamato il metodo `StarInfo` gli oggetti vengono visualizzati in base alla distanza da terra.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare.</param>
        <summary>Confronta questa istanza con un oggetto specificato e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore rispetto al valore dell'oggetto specificato.</summary>
        <returns>Signed Integer che indica la relazione dell'istanza corrente con il parametro <paramref name="obj" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore restituito 
 </term><description> Descrizione 
 </description></listheader><item><term> Minore di zero 
 </term><description> L'istanza corrente è minore di <paramref name="obj" />.  
  
 </description></item><item><term> Zero 
 </term><description> L'istanza corrente è uguale a <paramref name="obj" />.  
  
 </description></item><item><term> Maggiore di zero 
 </term><description> L'istanza corrente è maggiore di <paramref name="obj" />, oppure il parametro <paramref name="obj" /> è <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo di <xref:System.Numerics.BigInteger.CompareTo%2A> metodo implementa il <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> (metodo). Utilizzato dagli oggetti di raccolta non generica per ordinare gli elementi nella raccolta.  
  
 Il `obj` parametro deve essere uno dei seguenti:  
  
-   Oggetto il cui tipo di fase di esecuzione è <xref:System.Numerics.BigInteger>.  
  
-   Un' <xref:System.Object> variabile il cui valore `null`. Se il valore della `obj` parametro è `null`, il metodo restituisce 1, che indica che l'istanza corrente è maggiore di `obj`.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> metodo per confrontare un <xref:System.Numerics.BigInteger> con ogni elemento in una matrice di oggetti valore  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> non è un oggetto <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Intero senza segno a 64 bit da confrontare.</param>
        <summary>Confronta questa istanza con un intero senza segno a 64 bit e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore del valore dell'intero senza segno a 64 bit.</summary>
        <returns>Signed Integer che indica il valore relativo dell'istanza e <paramref name="other" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore restituito 
 </term><description> Descrizione 
 </description></listheader><item><term> Minore di zero 
 </term><description> L'istanza corrente è minore di <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> L'istanza corrente è uguale a <paramref name="other" />.  
  
 </description></item><item><term> Maggiore di zero 
 </term><description> L'istanza corrente è maggiore di <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valore da dividere.</param>
        <param name="divisor">Valore per cui dividere.</param>
        <summary>Divide un valore <see cref="T:System.Numerics.BigInteger" /> per un altro e restituisce il risultato.</summary>
        <returns>Quoziente della divisione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.Divide%2A> metodo esegue la divisione di interi; viene rimosso l'eventuale resto risultante dalla divisione. Per eseguire la divisione di interi mantenendo il resto, chiamare il <xref:System.Numerics.BigInteger.DivRem%2A> (metodo). Per recuperare solo il resto, chiamare il <xref:System.Numerics.BigInteger.Remainder%2A> (metodo).  
  
 Il <xref:System.Numerics.BigInteger.Divide%2A> metodo può essere utilizzato dai linguaggi che non supportano l'overload degli operatori. Il comportamento è identico alla divisione usando l'operatore di divisione.  
  
   
  
## Examples  
 L'esempio seguente crea una matrice di <xref:System.Numerics.BigInteger> valori. Ogni elemento viene quindi utilizzato come il quoziente di un'operazione di divisione che usa il <xref:System.Numerics.BigInteger.Divide%2A> metodo, l'operatore di divisione (/) e il <xref:System.Numerics.BigInteger.DivRem%2A> (metodo).  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> è 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Valore da dividere.</param>
        <param name="divisor">Valore per cui dividere.</param>
        <param name="remainder">Quando termina, questo metodo contiene un valore <see cref="T:System.Numerics.BigInteger" /> che rappresenta il resto dalla divisione. Questo parametro viene passato non inizializzato.</param>
        <summary>Divide un valore <see cref="T:System.Numerics.BigInteger" /> per un altro, restituisce il risultato e restituisce il resto in un parametro di output.</summary>
        <returns>Quoziente della divisione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di mantenere sia il quoziente che il resto risultante dalla divisione di interi. Se non è interessati al resto, usare il <xref:System.Numerics.BigInteger.Divide%2A> metodo o l'operatore di divisione; se si è solo interessato il resto, usare il <xref:System.Numerics.BigInteger.Remainder%2A> (metodo).  
  
 Il segno del valore restituito `remainder` valore è uguale a quello del `dividend` parametro.  
  
 Il comportamento dei <xref:System.Numerics.BigInteger.DivRem%2A> è identico a quello del metodo di <xref:System.Math.DivRem%2A?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 L'esempio seguente crea una matrice di <xref:System.Numerics.BigInteger> valori. Ogni elemento viene quindi utilizzato come il quoziente di un'operazione di divisione che usa il <xref:System.Numerics.BigInteger.Divide%2A> metodo, l'operatore di divisione (/) e il <xref:System.Numerics.BigInteger.DivRem%2A> (metodo).  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> è 0 (zero).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se due valori numerici sono uguali.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Valore intero con segno a 64 bit da confrontare.</param>
        <summary>Restituisce un valore che indica se l'istanza corrente e un intero con segno a 64 bit hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se il Signed Integer a 64 bit e l'istanza corrente hanno lo stesso valore; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `other` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene chiamato il metodo.  
  
 Per stabilire la relazione tra i due oggetti invece di testare l'uguaglianza, chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente crea una <xref:System.Numerics.BigInteger> oggetti da ogni tipo integrale eccetto <xref:System.UInt64>. Chiama quindi il <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> metodo per confrontare le <xref:System.Numerics.BigInteger> valore con il valore integer originale che è stato passato al <xref:System.Numerics.BigInteger> costruttore. Come illustrato nell'output, i valori sono uguali in ogni caso.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Oggetto da confrontare.</param>
        <summary>Restituisce un valore che indica se l'istanza corrente e un oggetto <see cref="T:System.Numerics.BigInteger" /> specificato hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se questo oggetto <see cref="T:System.Numerics.BigInteger" /> e <paramref name="other" /> hanno lo stesso valore; <see langword="false" /> in caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il <xref:System.IEquatable%601> interfaccia ed esegue leggermente migliori rispetto <xref:System.Numerics.BigInteger.Equals%28System.Object%29> perché non è necessario convertire le `other` parametro per un <xref:System.Numerics.BigInteger> oggetto.  
  
 Per stabilire la relazione tra due <xref:System.Numerics.BigInteger> gli oggetti invece di testare l'uguaglianza, chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 L'esempio seguente confronta la distanza approssimativa di stelle diversi da terra con la distanza di Indi Epsilon da terra per determinare se sono uguali. Nell'esempio viene utilizzato ogni overload della funzione di <xref:System.Numerics.BigInteger.Equals%2A> metodo per verificare l'uguaglianza.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare.</param>
        <summary>Restituisce un valore che indica se l'istanza corrente e un oggetto specificato hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se l'argomento di <paramref name="obj" /> è un oggetto <see cref="T:System.Numerics.BigInteger" /> e se il valore è uguale a quello dell'istanza <see cref="T:System.Numerics.BigInteger" /> corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `obj` l'argomento non è un <xref:System.Numerics.BigInteger> value, il metodo restituisce `false`. Il metodo restituisce `true` solo se `obj` è un <xref:System.Numerics.BigInteger> istanza il cui valore è uguale all'istanza corrente.  
  
 Per stabilire la relazione tra i due oggetti invece di testare l'uguaglianza, chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> (metodo).  
  
   
  
## Examples  
 L'esempio seguente definisce parallelo <xref:System.Object> e <xref:System.Numerics.BigInteger> matrici. Ogni elemento di una matrice ha lo stesso valore impostato per l'elemento corrispondente della seconda matrice. Come illustrato nell'esempio, l'istanza nell'output il <xref:System.Numerics.BigInteger> matrice viene considerata uguale all'istanza nel <xref:System.Object> matrice solo se quest'ultimo è un <xref:System.Numerics.BigInteger> e i relativi valori sono uguali.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Intero senza segno a 64 bit da confrontare.</param>
        <summary>Restituisce un valore che indica se l'istanza corrente e un intero senza segno a 64 bit hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se l'Unsigned Integer a 64 bit e l'istanza corrente hanno lo stesso valore; <see langword="false" /> in caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per stabilire la relazione tra i due oggetti invece di testare l'uguaglianza, chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 L'esempio seguente confronta la distanza approssimativa di stelle diversi da terra con la distanza di Indi Epsilon da terra per determinare se sono uguali. Nell'esempio viene utilizzato ogni overload della funzione di <xref:System.Numerics.BigInteger.Equals%2A> metodo per verificare l'uguaglianza.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore.</param>
        <param name="right">Secondo valore.</param>
        <summary>Trova il massimo comune divisore di due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Massimo comune divisore di <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il massimo comune divisore è il numero più grande in cui i due <xref:System.Numerics.BigInteger> valori possono essere suddivisi senza restituire il resto.  
  
 Se il `left` e `right` i parametri sono numeri diversi da zero, il metodo restituisce sempre almeno un valore pari a 1 perché tutti i numeri possono essere divisi per 1. Se dei parametri è zero, il metodo restituisce il valore assoluto del parametro diverso da zero. Se entrambi i valori sono da zero, il metodo restituisce zero.  
  
> [!NOTE]
>  Il massimo comune divisore di valori molto elevati di computing `left` e `right` può essere un'operazione richiede molto tempo.  
  
 Il valore restituito dal <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> è sempre positivo indipendentemente dal segno del metodo di `left` e `right` parametri.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata una chiamata per il <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> metodo e la gestione delle eccezioni necessaria per fornire informazioni utili su un <xref:System.ArgumentOutOfRangeException>. Il risultato indica che il massimo comune divisore di questi due numeri è 1.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente è un numero pari.</summary>
        <value>
          <see langword="true" /> se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> è un numero pari; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è una comoda funzionalità che indica se un <xref:System.Numerics.BigInteger> valore è divisibile uniformemente per due. È equivalente all'espressione seguente:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Se il valore dell'oggetto corrente <xref:System.Numerics.BigInteger> oggetto viene <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, la proprietà restituisce `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente è <see cref="P:System.Numerics.BigInteger.One" />.</summary>
        <value>
          <see langword="true" /> se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> è <see cref="P:System.Numerics.BigInteger.One" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà offre prestazioni notevolmente migliori rispetto a altri confronti con uno, ad esempio `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente è una potenza di due.</summary>
        <value>
          <see langword="true" /> se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> è una potenza di due; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà determina se un <xref:System.Numerics.BigInteger> valore ha un singolo bit diverso da zero impostata. Ciò significa che viene restituito `true` se il valore dell'oggetto corrente <xref:System.Numerics.BigInteger> oggetto è 1 (2, ovvero<sup>0</sup>) o qualsiasi maggiore potenza di due. Viene restituito `false` se il valore dell'oggetto corrente <xref:System.Numerics.BigInteger> oggetto è uguale a 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente è <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
        <value>
          <see langword="true" /> se il valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> è <see cref="P:System.Numerics.BigInteger.Zero" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà offre prestazioni notevolmente migliori rispetto a `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il logaritmo del numero specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Numero di cui è necessario trovare il logaritmo.</param>
        <summary>Restituisce il logaritmo naturale (in base <see langword="e" />) di un numero specificato.</summary>
        <returns>Logaritmo naturale (di base <see langword="e" />) di <paramref name="value" />, come mostrato nella tabella della sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro viene specificato come un numero in base 10.  
  
 Restituire la precisione dipende dal valore di questo metodo di accesso di `value`, come illustrato nella tabella seguente.  
  
|Firmare di `value` parametro|Valore restituito|  
|-------------------------------|------------------|  
|Positivo|Il logaritmo naturale del `value`; vale a dire, ln `value`, o log e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>.|  
|Negativo|<xref:System.Double.NaN>.|  
  
 Per la quale calcolare il logaritmo in base 10 di un <xref:System.Numerics.BigInteger> valore, chiamare il <xref:System.Numerics.BigInteger.Log10%2A> (metodo). Per calcolare il logaritmo di un numero in un'altra base, chiamare il <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> (metodo).  
  
 È possibile trovare la radice quadrata di un numero chiamando il <xref:System.Numerics.BigInteger.Log%2A> metodo con il <xref:System.Math.Exp%2A?displayProperty=nameWithType> (metodo). Si noti che il risultato viene <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> se il risultato è maggiore di <xref:System.Double.MaxValue?displayProperty=nameWithType>. L'esempio seguente calcola la radice quadrata di ciascun elemento nella matrice di <xref:System.Numerics.BigInteger> valori.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Questo metodo corrisponde al <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il logaritmo naturale di <paramref name="value" /> non è compreso nell'intervallo del tipo di dati <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Numero di cui trovare il logaritmo.</param>
        <param name="baseValue">Base del logaritmo.</param>
        <summary>Restituisce il logaritmo del numero specificato in una base specificata.</summary>
        <returns>Logaritmo di base <paramref name="baseValue" /> di <paramref name="value" />, come mostrato nella tabella della sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` e `baseValue` parametri vengono specificati come numeri di base 10.  
  
 Restituire la precisione valore del metodo dipende dal segno del `value` e il segno più e il valore di `baseValue`, come illustrato nella tabella seguente.  
  
|Parametro `value`.|Parametro `baseValue`.|Valore restituito|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) - oppure -(`baseValue` > 1)|logbaseValue (`value`)|  
|`value` < 0|(qualsiasi valore)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(qualsiasi valore)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(qualsiasi valore)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(qualsiasi valore)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Per la quale calcolare il logaritmo in base 10 di un <xref:System.Numerics.BigInteger> valore, chiamare il <xref:System.Numerics.BigInteger.Log10%2A> (metodo). Per calcolare il logaritmo naturale di un numero, chiamare il <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> (metodo).  
  
 Questo metodo corrisponde al <xref:System.Math.Log%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il logaritmo di <paramref name="value" /> non è compreso nell'intervallo del tipo di dati <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Numero di cui trovare il logaritmo.</param>
        <summary>Restituisce il logaritmo in base 10 del numero specificato.</summary>
        <returns>Logaritmo in base 10 di <paramref name="value" />, come mostrato nella tabella della sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro viene specificato come un numero in base 10.  
  
 Restituire la precisione valore del metodo dipende dal segno del `value`, come illustrato nella tabella seguente.  
  
|Segno del parametro value|Valore restituito|  
|-----------------------------|------------------|  
|Positivo|Logaritmo a base 10 del `value`; vale a dire log10`value`.|  
|Zero|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|Negativo|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 Per la quale calcolare il logaritmo naturale di un <xref:System.Numerics.BigInteger> valore, chiamare il <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> (metodo). Per calcolare il logaritmo di un numero in un'altra base, chiamare il <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> (metodo).  
  
 Questo metodo corrisponde al <xref:System.Math.Log10%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il logaritmo a base 10 di <paramref name="value" /> non è compreso nell'intervallo del tipo di dati <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce il maggiore di due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Parametro <paramref name="left" /> o <paramref name="right" />, qualunque sia il maggiore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo corrisponde al <xref:System.Math.Max%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Numerics.BigInteger.Max%2A> metodo per selezionare il numero più elevato in una matrice di <xref:System.Numerics.BigInteger> valori.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce il minore di due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Parametro <paramref name="left" /> o <paramref name="right" />, qualunque sia il minore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo corrisponde al <xref:System.Math.Min%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Numerics.BigInteger.Min%2A> metodo per selezionare il numero più piccolo in una matrice di <xref:System.Numerics.BigInteger> valori.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che rappresenta il numero negativo uno (-1).</summary>
        <value>Intero il cui valore è il numero negativo uno (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.MinusOne%2A> proprietà viene utilizzata per confrontare una <xref:System.Numerics.BigInteger> il valore su -1 o -1 per assegnare un <xref:System.Numerics.BigInteger> oggetto.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Numero da elevare alla potenza di <paramref name="exponent" /></param>
        <param name="exponent">Esponente per il quale elevare alla potenza <paramref name="value" />.</param>
        <param name="modulus">Numero per il quale eseguire la divisione di <paramref name="value" /> elevato alla potenza di <paramref name="exponent" />.</param>
        <summary>Esegue la divisione con modulo per un numero elevato alla potenza di un altro numero.</summary>
        <returns>Resto risultante dalla divisione di <paramref name="value" /><sup>exponent</sup> per <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.ModPow%2A> metodo valuta l'espressione seguente:  
  
 (baseValue ^ esponente) Modulus Mod  
  
 Per eseguire l'elevamento a potenza sui <xref:System.Numerics.BigInteger> valori senza divisione del modulo, usare il <xref:System.Numerics.BigInteger.Pow%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente fornisce una semplice illustrazione della chiamata al metodo il <xref:System.Numerics.BigInteger.ModPow%2A> (metodo).  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="modulus" /> è zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exponent" /> è negativo.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo numero da moltiplicare.</param>
        <param name="right">Secondo numero da moltiplicare.</param>
        <summary>Restituisce il prodotto di due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Prodotto dei parametri <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.Multiply%2A> metodo è implementato per le lingue che non supportano l'overload degli operatori. Il comportamento è identico alla moltiplicazione usando l'operatore di moltiplicazione. Inoltre, il <xref:System.Numerics.BigInteger.Multiply%2A> metodo è un sostituto utile per l'operatore di moltiplicazione quando si crea un <xref:System.Numerics.BigInteger> variabile assegnando alla VM un prodotto risultante dalla moltiplicazione, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Se necessario, questo metodo esegue automaticamente la conversione implicita di altri tipi integrali a <xref:System.Numerics.BigInteger> oggetti. Questa operazione viene illustrata nell'esempio nella sezione successiva, in cui il <xref:System.Numerics.BigInteger.Multiply%2A> metodo vengono passati due <xref:System.Int64> valori.  
  
   
  
## Examples  
 Nell'esempio seguente prova a eseguire la moltiplicazione con due valori long integer. Poiché il risultato supera l'intervallo di un long integer, un <xref:System.OverflowException> viene generata un'eccezione e il <xref:System.Numerics.BigInteger.Multiply%2A> metodo viene chiamato per gestire la moltiplicazione. Si noti che in c# richiede che si utilizzi il `checked` parola chiave (come in questo esempio) o il `/checked+` opzione del compilatore per assicurarsi che viene generata un'eccezione in un caso di overflow numerico.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da negare.</param>
        <summary>Nega un valore <see cref="T:System.Numerics.BigInteger" /> specificato.</summary>
        <returns>Risultato del parametro <paramref name="value" /> moltiplicato per il valore uno negativo (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La negazione ottiene l'inverso additivo di un numero. L'inverso additivo di un numero è un numero che produce un valore pari a zero quando viene aggiunto al numero originale.  
  
 Il <xref:System.Numerics.BigInteger.Negate%2A> metodo è implementato per le lingue che non supportano gli operatori personalizzati. Il comportamento è identico alla negazione utilizzando l'operatore di negazione unario. Inoltre, il <xref:System.Numerics.BigInteger.Negate%2A> metodo è un sostituto per l'operatore di negazione utile quando si crea un <xref:System.Numerics.BigInteger> variabile, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 Nell'esempio seguente vengono illustrati tre modi per negare il valore di un <xref:System.Numerics.BigInteger> oggetto.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che rappresenta il numero uno (1).</summary>
        <value>Oggetto il cui valore è il numero uno (1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.One%2A> proprietà viene in genere usata per confrontare una <xref:System.Numerics.BigInteger> il valore su 1 o 1 per assegnare un <xref:System.Numerics.BigInteger> oggetto.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da sommare.</param>
        <param name="right">Secondo valore da sommare.</param>
        <summary>Somma i valori di due oggetti <see cref="T:System.Numerics.BigInteger" /> specificati.</summary>
        <returns>Somma di <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Addition%2A> metodo consente di definire l'operazione di addizione per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Add%2A> metodo invece.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore.</param>
        <param name="right">Secondo valore.</param>
        <summary>Esegue un'operazione <see langword="And" /> bit per bit su due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Risultato dell'operazione <see langword="And" /> bit per bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> metodo consente di definire i bit per bit `And` operazione per <xref:System.Numerics.BigInteger> valori. Bit per bit `And` operazione imposta un bit di risultato solo se i bit corrispondenti `left` e `right` impostati anche, come illustrato nella tabella seguente.  
  
|Bit in `left`|Bit in `right`|Bit nel risultato|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 Il <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> metodo attiva un codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 Il <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> metodo esegue il bit per bit `And` operazione su due <xref:System.Numerics.BigInteger> valori come se fossero in rappresentazione in complemento a due con l'estensione del segno virtuale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore.</param>
        <param name="right">Secondo valore.</param>
        <summary>Esegue un'operazione <see langword="Or" /> bit per bit su due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Risultato dell'operazione <see langword="Or" /> bit per bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> metodo consente di definire i bit per bit `Or` operazione per <xref:System.Numerics.BigInteger> valori. Bit per bit `Or` operazione imposta un bit di risultato solo se uno o entrambi i bit corrispondenti nella `left` e `right` sono impostate, come illustrato nella tabella seguente.  
  
|Bit in `left`|Bit in `right`|Bit nel risultato|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 Il <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> metodo attiva un codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 Il <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> metodo esegue il bit per bit `Or` operazione su due <xref:System.Numerics.BigInteger> valori come se fossero in rappresentazione in complemento a due con l'estensione del segno virtuale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da decrementare.</param>
        <summary>Decrementa un valore <see cref="T:System.Numerics.BigInteger" /> di 1.</summary>
        <returns>Valore del parametro <paramref name="value" /> decrementato di 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Decrement%2A> metodo consente di definire l'operazione di decremento per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Subtract%2A> metodo invece. Ad esempio:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Perché <xref:System.Numerics.BigInteger> gli oggetti non sono modificabili, la <xref:System.Numerics.BigInteger.op_Decrement%2A> crea un nuovo operatore <xref:System.Numerics.BigInteger> oggetto il cui valore è una minore del <xref:System.Numerics.BigInteger> rappresentato dall'oggetto `value`. Ciò significa che le chiamate ripetute a <xref:System.Numerics.BigInteger.op_Decrement%2A> potrebbe risultare costoso.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valore da dividere.</param>
        <param name="divisor">Valore per cui dividere.</param>
        <summary>Divide un valore <see cref="T:System.Numerics.BigInteger" /> specificato per un altro valore <see cref="T:System.Numerics.BigInteger" /> specificato tramite una divisione intera.</summary>
        <returns>Risultato integrale della divisione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Division%2A> metodo consente di definire l'operazione di divisione per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Possono chiamare le lingue che non supportano l'overload degli operatori e gli operatori personalizzati di <xref:System.Numerics.BigInteger.Divide%2A> metodo invece.  
  
 È il metodo equivalente per l'operatore <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 L'esempio seguente crea una matrice di <xref:System.Numerics.BigInteger> valori. Ogni elemento viene quindi utilizzato come il quoziente di un'operazione di divisione che usa il <xref:System.Numerics.BigInteger.Divide%2A> metodo, l'operatore di divisione (/) e il <xref:System.Numerics.BigInteger.DivRem%2A> (metodo).  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> è 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se due valori sono uguali.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore Signed Long Integer e un valore <see cref="T:System.Numerics.BigInteger" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> metodo consente di definire l'operazione di confronto di uguaglianza per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> invece al metodo dell'istanza.  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore Signed Long Integer e un valore <see cref="T:System.Numerics.BigInteger" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> metodo consente di definire l'operazione di confronto di uguaglianza per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> invece al metodo dell'istanza.  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se i valori di due oggetti <see cref="T:System.Numerics.BigInteger" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodo definisce il funzionamento dell'operatore di uguaglianza per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> invece al metodo dell'istanza.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore Unsigned Long Integer e un valore <see cref="T:System.Numerics.BigInteger" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodo consente di definire l'operazione di confronto di uguaglianza per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> invece al metodo dell'istanza.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore Unsigned Long Integer e un valore <see cref="T:System.Numerics.BigInteger" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se i parametri <paramref name="left" /> e <paramref name="right" /> presentano lo stesso valore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodo consente di definire l'operazione di confronto di uguaglianza per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> invece al metodo dell'istanza.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore.</param>
        <param name="right">Secondo valore.</param>
        <summary>Esegue un'operazione <see langword="Or" /> (<see langword="XOr" />) bit per bit esclusiva su due valori <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Risultato dell'operazione <see langword="Or" /> bit per bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il risultato di un bit per bit esclusiva `Or` operazione viene `true` se i valori dei due bit sono diversi; in caso contrario, è `false`. La tabella seguente illustra l'esclusiva `Or` operazione.  
  
|Bit x `left`|Bit x `right`|Valore restituito|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 Il <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> metodo attiva un codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 Il <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> metodo esegue il bit per bit esclusiva `Or` operazione su due <xref:System.Numerics.BigInteger> valori come se fossero in rappresentazione in complemento a due con l'estensione del segno virtuale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definisce una conversione esplicita tra un oggetto <see cref="T:System.Numerics.BigInteger" /> e un altro tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Decimal" /> in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria di `value` parametro viene troncato prima della conversione.

 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. Poiché la conversione da <xref:System.Decimal> al <xref:System.Numerics.BigInteger> può comportare il troncamento eventuale parte frazionaria `value`, i compilatori di linguaggio non si eseguono questa conversione automaticamente. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.   

 Per le lingue che non supportano gli operatori personalizzati, è il metodo alternativo per <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 L'esempio seguente converte i singoli elementi in una matrice di <xref:System.Decimal> valori <xref:System.Numerics.BigInteger> oggetti e quindi Visualizza il risultato di ogni conversione. Si noti che qualsiasi frazionari fa parte di un <xref:System.Decimal> valore viene troncato durante la conversione.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione esplicita di un valore <see cref="T:System.Double" /> in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria di `value` parametro viene troncato prima della conversione.

 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. Poiché la conversione da <xref:System.Double> al <xref:System.Numerics.BigInteger> può comportare il troncamento eventuale parte frazionaria `value`, i compilatori di linguaggio non si eseguono questa conversione automaticamente. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.

 Per le lingue che non supportano gli operatori personalizzati, è il metodo alternativo per <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 L'esempio seguente converte i singoli elementi in una matrice di <xref:System.Double> valori <xref:System.Numerics.BigInteger> oggetti e quindi Visualizza il risultato di ogni conversione. Si noti che qualsiasi frazionari fa parte di un <xref:System.Double> valore viene troncato durante la conversione.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Double.NaN" />.  
  
oppure 
Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Double.PositiveInfinity" />.
  
oppure 
Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Byte" />.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore byte senza segno.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CByte` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.   

 Poiché questa operazione definisce una conversione di narrowing, può generare una <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Byte> tipo di dati. Non vi è alcuna perdita di precisione nel risultante <xref:System.Byte> valore se la conversione ha esito positivo.

## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Byte> valori. Gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Byte> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.Byte.MinValue" />.  
  
oppure 
Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Decimal" />.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore <see cref="T:System.Decimal" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CDec` in Visual Basic) viene usato.   

 Poiché questa operazione definisce una conversione di narrowing, può generare una <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Decimal> tipo di dati. 

## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Decimal> valori. Gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Decimal> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.Decimal.MinValue" />.  
  
oppure 
Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Double" />.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore <see cref="T:System.Double" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CDbl` in Visual Basic) viene usato.   

 Poiché il <xref:System.Numerics.BigInteger> valore può essere compreso nell'intervallo del <xref:System.Double> tipo di dati, questa operazione è una conversione di narrowing. Se la conversione ha esito negativo, non viene generato un <xref:System.OverflowException>. In alternativa, se il <xref:System.Numerics.BigInteger> valore è minore di <xref:System.Double.MinValue?displayProperty=nameWithType>, risultante <xref:System.Double> valore è <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Se il <xref:System.Numerics.BigInteger> valore è maggiore <xref:System.Double.MaxValue?displayProperty=nameWithType>, l'oggetto risultante <xref:System.Double> valore è <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 La conversione di un <xref:System.Numerics.BigInteger> a un <xref:System.Double> può comportare una perdita di precisione. In alcuni casi, la perdita di precisione può causare l'operazione di cast o conversione abbia esito positivo anche se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.Double> tipo di dati. Nell'esempio seguente viene illustrato questo concetto. Assegna il valore massimo di una <xref:System.Double> a due <xref:System.Numerics.BigInteger> variabili, incrementa una <xref:System.Numerics.BigInteger> variabile 9.999 e291 e le due variabili di test per verificarne l'uguaglianza. Come previsto, la chiamata al <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodologia è che non sono uguali. Tuttavia, la conversione della più ampia <xref:System.Numerics.BigInteger> valore di una <xref:System.Double> ha esito positivo, anche se il <xref:System.Numerics.BigInteger> valore ora supera <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Double> valori.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero con segno a 16 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore Signed Integer a 16 bit.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CShort` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.   

 Poiché questa operazione definisce una conversione di narrowing, può generare una <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Int16> tipo di dati. Non vi è alcuna perdita di precisione nel risultante <xref:System.Int16> valore se la conversione ha esito positivo.

## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Int16> valori. Gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Int16> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.Int16.MinValue" />.  
  
oppure 
Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero con segno a 32 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore intero con segno a 32 bit.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CInt` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.   

 Poiché questa operazione definisce una conversione di narrowing, può generare una <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Int32> tipo di dati. Non vi è alcuna perdita di precisione nel risultante <xref:System.Int16> valore se la conversione ha esito positivo.

## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Int32> valori. Gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Int32> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.Int32.MinValue" />.  
  
oppure 
Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero con segno a 64 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore intero con segno a 64 bit.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CLng` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.  

 Poiché questa operazione definisce una conversione di narrowing, può generare una <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Int64> tipo di dati. 

## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Int64> valori. Gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.Int64> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.Int64.MinValue" />.  
  
oppure 
Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un valore con segno a 8 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore a 8 bit con segno.  
  
Questa API non è conforme a CLS. L'alternativa conforme è <see cref="T:System.Int16" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CSByte` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.  

 Poiché questa operazione definisce una conversione di narrowing, può generare una <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.SByte> tipo di dati. Non vi è alcuna perdita di precisione nel risultante <xref:System.SByte> valore se la conversione ha esito positivo.

## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.SByte> valori. Gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.SByte> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.SByte.MinValue" />.  
  
oppure 
Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un valore a virgola mobile e precisione singola.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore in virgola mobile a precisione singola.</summary>
        <returns>Oggetto che contiene la rappresentazione più vicina possibile del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati o la perdita di precisione. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CSng` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.    

 Poiché il <xref:System.Numerics.BigInteger> valore può essere compreso nell'intervallo del <xref:System.Single> tipo di dati, questa operazione è una conversione di narrowing. Se la conversione ha esito negativo, non viene generato un <xref:System.OverflowException>. In alternativa, se il <xref:System.Numerics.BigInteger> valore è minore di <xref:System.Single.MinValue?displayProperty=nameWithType>, risultante <xref:System.Single> valore è <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Se il <xref:System.Numerics.BigInteger> valore è maggiore <xref:System.Single.MaxValue?displayProperty=nameWithType>, l'oggetto risultante <xref:System.Single> valore è <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 La conversione di un <xref:System.Numerics.BigInteger> a un <xref:System.Single> può comportare una perdita di precisione. In alcuni casi, la perdita di precisione può causare l'operazione di cast o conversione abbia esito positivo anche se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo di <xref:System.Single> tipo di dati. Nell'esempio seguente viene illustrato questo concetto. Assegna il valore massimo di una <xref:System.Single> a due <xref:System.Numerics.BigInteger> variabili, incrementa una <xref:System.Numerics.BigInteger> variabile 9.999 e291 e le due variabili di test per verificarne l'uguaglianza. Come previsto, la chiamata al <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodologia è che non sono uguali. Tuttavia, la conversione della più ampia <xref:System.Numerics.BigInteger> valore di una <xref:System.Single> ha esito positivo, anche se il <xref:System.Numerics.BigInteger> valore ora supera <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.Single> valori.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero senza segno a 16 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore Unsigned Integer a 16 bit.  
  
Questa API non è conforme a CLS. L'alternativa conforme è <see cref="T:System.Int32" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CUShort` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.    

 Poiché questa operazione definisce una conversione di narrowing, può generare una <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.UInt16> tipo di dati. Non vi è alcuna perdita di precisione nel risultante <xref:System.UInt16> valore se la conversione ha esito positivo.

## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.UInt16> valori. Gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.UInt16> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.UInt16.MinValue" />.  
  
oppure 
Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero senza segno a 32 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore intero senza segno a 32 bit.  
  
Questa API non è conforme a CLS. L'alternativa conforme è <see cref="T:System.Int64" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CUInt` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.    

 Poiché questa operazione definisce una conversione di narrowing, può generare una <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.UInt32> tipo di dati. Non vi è alcuna perdita di precisione nel risultante <xref:System.UInt32> valore se la conversione ha esito positivo.

## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.UInt32> valori. Gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.UInt32> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.UInt32.MinValue" />.  
  
oppure 
Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un intero senza segno a 64 bit.</param>
        <summary>Definisce una conversione esplicita di un oggetto <see cref="T:System.Numerics.BigInteger" /> in un valore intero senza segno a 64 bit.  
  
Questa API non è conforme a CLS. L'alternativa conforme è <see cref="T:System.Double" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. I compilatori di linguaggio non eseguono questa conversione automaticamente perché può comportare la perdita di dati. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` o `CULng` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.    

 Poiché questa operazione definisce una conversione di narrowing, può generare una <xref:System.OverflowException> in fase di esecuzione se il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.UInt64> tipo di dati. Non vi è alcuna perdita di precisione nel risultante <xref:System.UInt64> valore se la conversione ha esito positivo.

## Examples
 L'esempio seguente illustra la conversione di <xref:System.Numerics.BigInteger> a <xref:System.UInt64> valori. Gestisce anche un <xref:System.OverflowException> che viene generata perché il <xref:System.Numerics.BigInteger> valore è compreso nell'intervallo del <xref:System.UInt64> tipo di dati.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore di <paramref name="value" /> è minore di <see cref="F:System.UInt64.MinValue" />.  
  
oppure 
Il valore di <paramref name="value" /> è maggiore di <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione esplicita di un valore <see cref="T:System.Single" /> in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria di `value` parametro viene troncato prima della conversione.
 
 Gli overload del <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un <xref:System.Numerics.BigInteger> oggetto può essere convertito. Poiché la conversione da <xref:System.Single> al <xref:System.Numerics.BigInteger> può comportare il troncamento eventuale parte frazionaria `value`, i compilatori di linguaggio non si eseguono questa conversione automaticamente. Ma eseguono la conversione solo se un operatore di cast (in c#) o una funzione di conversione (ad esempio `CType` in Visual Basic) viene usato. In caso contrario, visualizzano un errore del compilatore.

 Per le lingue che non supportano gli operatori personalizzati, è il metodo alternativo per <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 L'esempio seguente converte i singoli elementi in una matrice di <xref:System.Single> valori <xref:System.Numerics.BigInteger> oggetti e quindi Visualizza il risultato di ogni conversione. Si noti che qualsiasi frazionari fa parte di un <xref:System.Single> valore viene troncato durante la conversione.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Single.NaN" />.  
  
oppure 
Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Single.PositiveInfinity" />.
  
oppure 
Il valore della proprietà <paramref name="value" /> è <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se un valore specificato è maggiore di un altro valore specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Signed Integer a 64 bit è maggiore di un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThan%2A> metodo consente di definire il funzionamento dell'operatore per greater than <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> invece al metodo dell'istanza. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un <see cref="T:System.Numerics.BigInteger" /> è maggiore di un valore Signed Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThan%2A> metodo consente di definire il funzionamento dell'operatore per greater than <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore di un altro valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThan%2A> metodo consente di definire il funzionamento dell'operatore per greater than <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore di un Unsigned Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThan%2A> metodo consente di definire il funzionamento dell'operatore per greater than <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore di un Unsigned Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThan%2A> metodo consente di definire il funzionamento dell'operatore per greater than <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se un valore specificato è maggiore o uguale a un altro valore specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Signed Integer a 64 bit è maggiore o uguale a un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> metodo consente di definire l'operazione di maggiore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore o uguale a un valore Signed Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> metodo consente di definire l'operazione di maggiore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore o uguale a un altro valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> metodo consente di definire l'operazione di maggiore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è maggiore o uguale a un valore Unsigned Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> metodo consente di definire l'operazione di maggiore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Unsigned Integer a 64 bit è maggiore o uguale a un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> metodo consente di definire l'operazione di maggiore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definisce una conversione implicita tra un oggetto <see cref="T:System.Numerics.BigInteger" /> e un altro tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un byte senza segno in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eventuale parte frazionaria di `value` parametro viene troncato prima della conversione.

 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di eseguire il cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che comporta la perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Byte> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un Signed Integer a 16 bit in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di eseguire il cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che comporta la perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Int16> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un intero con segno a 32 bit in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di eseguire il cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che comporta la perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Int32> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un intero con segno a 64 bit in un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di eseguire il cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che comporta la perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.Int64> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un Signed Integer a 8 bit in un valore <see cref="T:System.Numerics.BigInteger" />.  
  
Questa API non è conforme a CLS. L'alternativa conforme è <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di eseguire il cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che comporta la perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.SByte> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un Unsigned Integer a 16 bit in un valore <see cref="T:System.Numerics.BigInteger" />.  
  
Questa API non è conforme a CLS. L'alternativa conforme è <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di eseguire il cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che comporta la perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.UInt16> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un intero senza segno a 32 bit in un valore <see cref="T:System.Numerics.BigInteger" />.  
  
Questa API non è conforme a CLS. L'alternativa conforme è <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di eseguire il cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che comporta la perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.UInt32> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valore da convertire in un <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Definisce una conversione implicita di un intero senza segno a 64 bit in un valore <see cref="T:System.Numerics.BigInteger" />.  
  
Questa API non è conforme a CLS. L'alternativa conforme è <see cref="T:System.Double" />.</summary>
        <returns>Oggetto contenente il valore del parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le lingue che non supportano operatori impliciti, il metodo alternativo è <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 Gli overload del <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> il metodo per definire i tipi a cui o da cui un compilatore può convertire automaticamente un <xref:System.Numerics.BigInteger> valore senza un operatore di eseguire il cast esplicito (in c#) o una chiamata a una funzione di conversione (in Visual Basic). Essi sono di ampliamento che comporta la perdita di dati e non generano un <xref:System.OverflowException>. Questo overload consente al compilatore di gestire le conversioni da un <xref:System.UInt64> valore per un <xref:System.Numerics.BigInteger> valore, come illustrato nell'esempio seguente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da incrementare.</param>
        <summary>Incrementa un valore <see cref="T:System.Numerics.BigInteger" /> di 1.</summary>
        <returns>Valore del parametro <paramref name="value" /> incrementato di 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Increment%2A> metodo consente di definire l'operazione di incremento per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Alcuni linguaggi (ad esempio Visual Basic) che non dispongono di un operatore di incremento o che non supportano l'overload degli operatori possono chiamare il <xref:System.Numerics.BigInteger.op_Increment%2A> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Perché <xref:System.Numerics.BigInteger> oggetti non sono modificabili, il <xref:System.Numerics.BigInteger.op_Increment%2A> crea un nuovo operatore <xref:System.Numerics.BigInteger> oggetto il cui valore è una rispetto al <xref:System.Numerics.BigInteger> rappresentato dall'oggetto `value`. Di conseguenza, le chiamate ripetute a <xref:System.Numerics.BigInteger.op_Increment%2A> potrebbe risultare costoso.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se due valori numerici non sono uguali.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Signed Integer a 64 bit e un valore <see cref="T:System.Numerics.BigInteger" /> non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Lingue che non supportano gli operatori personalizzati è possono testare la disuguaglianza usando una delle tecniche seguenti:  
  
-   Chiama il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> istanza metodo, che indica la relazione tra un <xref:System.Numerics.BigInteger> e un valore intero long con segno.  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> istanza metodo e inversione del relativo valore.  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> e un Signed Integer a 64 bit non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Lingue che non supportano gli operatori personalizzati è possono testare la disuguaglianza usando una delle tecniche seguenti:  
  
-   Chiama il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo, che indica la relazione tra un <xref:System.Numerics.BigInteger> e un valore intero long con segno.  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> metodo e inversione del relativo valore.  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se due oggetti <see cref="T:System.Numerics.BigInteger" /> hanno valori diversi.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Lingue che non supportano gli operatori personalizzati è possono testare la disuguaglianza usando una delle tecniche seguenti:  
  
-   Chiama il <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metodo, che indica la relazione tra due <xref:System.Numerics.BigInteger> oggetti.  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> metodo e inversione del relativo valore.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> e un Unsigned Integer a 64 bit non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Lingue che non supportano gli operatori personalizzati è possono testare la disuguaglianza usando una delle tecniche seguenti:  
  
-   Chiama il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo, che indica la relazione tra un <xref:System.Numerics.BigInteger> e un valore unsigned long integer.  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodo e inversione del relativo valore.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Unsigned Integer a 64 bit e un valore <see cref="T:System.Numerics.BigInteger" /> non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Lingue che non supportano gli operatori personalizzati è possono testare la disuguaglianza usando una delle tecniche seguenti:  
  
-   Chiama il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo, che indica la relazione tra un <xref:System.Numerics.BigInteger> e un valore unsigned long integer.  
  
-   La chiamata di <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> metodo e inversione del relativo valore.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valore di cui spostare i bit.</param>
        <param name="shift">Numero di bit <paramref name="value" /> da spostare a sinistra.</param>
        <summary>Sposta un valore <see cref="T:System.Numerics.BigInteger" /> di un numero specificato di bit verso sinistra.</summary>
        <returns>Valore spostato a sinistra del numero specificato di bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LeftShift%2A> metodo definisce il funzionamento dell'operatore di spostamento a sinistra bit per bit per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  A differenza dell'operazione di spostamento a sinistra bit per bit con le primitive di integer, il <xref:System.Numerics.BigInteger.op_LeftShift%2A> metodo mantiene il segnale dell'originale <xref:System.Numerics.BigInteger> valore.  
  
 Lingue che non supportano gli operatori personalizzati possono eseguire un'operazione di spostamento a sinistra bit per bit moltiplicando `value` da `BigInteger.Pow(2, shift)`. Nell'esempio seguente mostra che i risultati sono identici ai risultati dell'uso di questo operatore.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se un valore specificato è minore di un secondo valore specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Signed Integer a 64 bit è minore di un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThan%2A> metodo consente di definire il funzionamento dell'operatore per minore <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore di un Signed Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThan%2A> metodo consente di definire il funzionamento dell'operatore per minore <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore di un altro valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThan%2A> metodo consente di definire il funzionamento dell'operatore per minore <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> metodo invece. Alcuni linguaggi possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore di un Unsigned Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThan%2A> metodo consente di definire il funzionamento dell'operatore per minore <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Unsigned Integer a 64 bit è minore di un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThan%2A> metodo consente di definire il funzionamento dell'operatore per minore <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se un valore specificato è minore o uguale a un altro valore specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Signed Integer a 64 bit è minore o uguale a un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> metodo consente di definire l'operazione di minore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Se `left` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore o uguale a un Signed Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> metodo consente di definire l'operazione di minore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Se `right` è un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oppure <xref:System.UInt32> valore, viene implicitamente convertito in un <xref:System.Int64> valore quando viene eseguita l'operazione.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore o uguale a un altro valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> metodo consente di definire l'operazione di minore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Compare%2A> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Numerics.BigInteger" /> è minore o uguale a un Unsigned Integer a 64 bit.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> metodo consente di definire l'operazione di minore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un Unsigned Integer a 64 bit è minore o uguale a un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> metodo consente di definire l'operazione di minore di o uguale all'operatore per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> metodo invece. Possono anche chiamare il <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> metodo direttamente, come illustrato nell'esempio seguente viene illustrato.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valore da dividere.</param>
        <param name="divisor">Valore per cui dividere.</param>
        <summary>Restituisce il resto risultante dalla divisione di due valori <see cref="T:System.Numerics.BigInteger" /> specificati.</summary>
        <returns>Resto risultante dalla divisione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Modulus%2A> metodo consente di definire il funzionamento dell'operatore del modulo per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> metodo invece.  
  
 Il segno del valore restituito dall'operazione di modulo dipende dal segno del `dividend`: se `dividend` è positivo, l'operazione modulo restituisce un risultato positivo; in caso negativo, l'operazione modulo restituisce un risultato negativo. Il comportamento dell'operazione modulo con <xref:System.Numerics.BigInteger> valori è identico all'operazione di modulo con altri tipi integrali.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> è 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da moltiplicare.</param>
        <param name="right">Secondo valore da moltiplicare.</param>
        <summary>Moltiplica due valori <see cref="T:System.Numerics.BigInteger" /> specificati.</summary>
        <returns>Prodotto di <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Multiply%2A> metodo consente di definire il funzionamento dell'operatore di moltiplicazione per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore intero.</param>
        <summary>Restituisce il complemento a uno bit per bit di un valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Complemento a uno bit per bit dell'oggetto <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_OnesComplement%2A> metodo consente di definire il funzionamento di bit per bit operatore complemento a uno per <xref:System.Numerics.BigInteger> valori. Bit per bit operatore complemento a uno consente di invertire ogni bit in un valore numerico. Vale a dire, bits in `value` che sono 0 vengono impostati su 1 nel risultato e che sono pari a 1 bit vengono impostati su 0 nel risultato. Il <xref:System.Numerics.BigInteger.op_OnesComplement%2A> metodo attiva un codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Lingue che non supportano gli operatori personalizzati possono essere in grado di chiamare il <xref:System.Numerics.BigInteger.op_OnesComplement%2A> metodo direttamente a eseguire un bit per bit di una operazione di complemento. Ad esempio:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valore di cui spostare i bit.</param>
        <param name="shift">Numero di bit in base al quale spostare <paramref name="value" /> a destra.</param>
        <summary>Sposta un valore <see cref="T:System.Numerics.BigInteger" /> di un numero specificato di bit verso destra.</summary>
        <returns>Valore spostato a destra del numero specificato di bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_RightShift%2A> metodo definisce il funzionamento dell'operatore di spostamento a destra bit per bit per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Lingue che non supportano gli operatori personalizzati possono eseguire un'operazione di spostamento a destra bit per bit dividendo `value` dal `BigInteger.Pow(2, shift)` sottraendo 1 volte `shift` per i valori negativi. Nell'esempio seguente mostra che i risultati sono identici ai risultati dell'uso di questo operatore.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Se `shift` è maggiore o uguale al numero di bit in un numero positivo <xref:System.Numerics.BigInteger> valore, il risultato dell'operazione di spostamento a destra è <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Se `shift` è maggiore del numero di bit in un valore negativo <xref:System.Numerics.BigInteger> valore, il risultato dell'operazione di spostamento a destra è <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Valore da cui sottrarre (minuendo).</param>
        <param name="right">Valore da sottrarre (sottraendo).</param>
        <summary>Sottrae un valore <see cref="T:System.Numerics.BigInteger" /> da un altro valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Risultato della sottrazione di <paramref name="right" /> da <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_Subtraction%2A> metodo definisce il funzionamento dell'operatore di sottrazione per <xref:System.Numerics.BigInteger> valori. Consente codice simile al seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> metodo invece.  
  
 Il metodo equivalente per l'operatore è <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore da negare.</param>
        <summary>Nega un valore BigInteger specificato.</summary>
        <returns>Risultato del parametro <paramref name="value" /> moltiplicato per il valore uno negativo (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> metodo consente di definire il funzionamento dell'operatore di negazione unario (o l'operatore inverso additivo) per <xref:System.Numerics.BigInteger> valori. L'operazione produce un valore che viene restituito 0 (zero) quando viene aggiunto al numero originale. I linguaggi che non supportano gli operatori personalizzati possono chiamare il <xref:System.Numerics.BigInteger.Negate%2A> metodo invece.  
  
 È il metodo equivalente per l'operatore <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 L'esempio seguente illustra tre modi diversi per negare il valore di un <xref:System.Numerics.BigInteger> oggetto.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valore intero.</param>
        <summary>Restituisce il valore dell'operando <see cref="T:System.Numerics.BigInteger" />. Il segno dell'operando resta invariato.</summary>
        <returns>Valore dell'operando <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> metodo definisce il funzionamento dell'operatore unario positivo per <xref:System.Numerics.BigInteger> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte la rappresentazione di stringa di un numero nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa che contiene il numero da convertire.</param>
        <summary>Converte la rappresentazione di stringa di un numero nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valore equivalente al numero specificato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro deve essere la rappresentazione di stringa di un numero nel formato seguente.  
  
 [*ws*] [*sign*]*cifre*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo.|  
|*sign*|Un segno facoltativo. Caratteri segno validi sono determinati dal <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti.|  
|*cifre*|Una sequenza di cifre comprese tra 0 e 9. Eventuali zeri iniziali vengono ignorati.|  
  
> [!NOTE]
>  La stringa specificata tramite il `value` parametro viene interpretato usando la <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stile. Non può contenere qualsiasi separatori di gruppi o un separatore decimale e non può avere una parte decimale.  
  
 Il `value` parametro viene analizzato tramite le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> oggetto inizializzato per impostazioni cultura correnti del sistema. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Per analizzare una stringa usando le informazioni di formattazione delle impostazioni cultura specifica, usare il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> (metodo).  
  
> [!IMPORTANT]
>  Se si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo eseguire il round trip la rappresentazione di stringa di un <xref:System.Numerics.BigInteger> valore ottenuto come risultato il <xref:System.Numerics.BigInteger.ToString%2A> metodo, è consigliabile usare il <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metodo con l'identificatore di formato "R" per generare la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore. In caso contrario, la rappresentazione di stringa del <xref:System.Numerics.BigInteger> mantiene solo il 50 cifre più significative del valore originale e i dati vadano perse quando si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo per ripristinare il <xref:System.Numerics.BigInteger> valore.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Numerics.BigInteger.Parse%28System.String%29> metodo per creare un'istanza di due <xref:System.Numerics.BigInteger> oggetti. Moltiplica ciascun oggetto da un altro numero e quindi chiama il <xref:System.Numerics.BigInteger.Compare%2A> metodo per stabilire la relazione tra i due valori.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Il formato di <paramref name="value" /> non è corretto.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che specifica il formato consentito di <paramref name="value" />.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valore equivalente al numero specificato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `style` parametro definisce gli elementi di stile (ad esempio, gli spazi vuoti, il simbolo di segno positivo o negativo, il simbolo di separatore di gruppi o il simbolo di separatore decimale) consentite nel `value` parametro per l'operazione di analisi abbia esito positivo. `styles` deve contenere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. Il `style` parametro, questo metodo di overload utili quando `value` contiene la rappresentazione di stringa del valore esadecimale, quando il sistema di numero (decimale o esadecimale) rappresentato da `value` è noto solo in fase di esecuzione o quando si non consentire spazio vuoto o un simbolo di segno `value`.  
  
 A seconda del valore di `style`, il `value` parametro può includere gli elementi seguenti:  
  
 [*ws*] [*$*] [*sign*] [*cifre*,]*cifre*[. *frazionarie*] [E [*sign*]*cifre_esponenziali*] [*ws*]  
  
 Se `style` comprende <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, il `value` parametro può contenere i seguenti elementi:  
  
 [*ws*]*cifre esadecimali*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo. Gli spazi vuoti possono essere visualizzati all'inizio di `value` se `style` include le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag che possono essere visualizzati alla fine del `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|*$*|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita per il <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti. Simbolo di valuta di cultura correnti può essere visualizzati nella `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Un segno facoltativo. Il segno può essere visualizzati all'inizio di `value` se `style` include le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati alla fine del `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `value` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*cifre*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Una sequenza di cifre da 0 a 9. Per la *frazionarie*, solo la cifra 0 non è valida.|  
|*,*|Un simbolo di separatore gruppo di impostazioni cultura specifiche. Separatore di gruppi di cultura correnti può essere visualizzati nella `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale di cultura correnti può essere visualizzati nella `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag. Può essere visualizzata solo la cifra 0 come numero frazionario per l'operazione di analisi abbia esito positivo; Se *frazionarie* include qualsiasi altra cifra, una <xref:System.FormatException> viene generata un'eccezione.|  
|E|Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `value` parametro può rappresentare un numero in notazione esponenziale se `style` include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esadecimali*|Una sequenza di cifre esadecimali da 0 a f o 0 e F.|  
  
> [!NOTE]
> Eventuali caratteri di terminazione null (u+0000) nella `s` vengono ignorati dall'operazione di analisi, indipendentemente dal valore della `style` argomento.

 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) sempre viene analizzata correttamente. La maggior parte delle rimanenti <xref:System.Globalization.NumberStyles> membri controllano gli elementi che possono essere presenti, ma non devono essere presenti, nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> membri interessano gli elementi che possono essere presenti in `value`.  
  
|Valore di `NumberStyles`|Elementi consentiti in `value` oltre alle cifre|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale (.) e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il "e" o il carattere "E, che indica la notazione esponenziale, insieme a" *cifre_esponenziali*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Elemento separatore (,) del gruppo.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|L'elemento di valuta ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* all'inizio o alla fine dell'elemento `value`, *sign* all'inizio del `value`e il separatore decimale (*.*) simbolo. Il `value` parametro anche possibile usare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, separatore di gruppi (*,*) e il punto decimale (*.*) elementi.|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale.|  
  
> [!IMPORTANT]
>  Se si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo eseguire il round trip la rappresentazione di stringa di un <xref:System.Numerics.BigInteger> valore ottenuto come risultato il <xref:System.Numerics.BigInteger.ToString%2A> metodo, è consigliabile usare il <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metodo con l'identificatore di formato "R" per generare la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore. In caso contrario, la rappresentazione di stringa del <xref:System.Numerics.BigInteger> mantiene solo il 50 cifre più significative del valore originale e i dati vadano perse quando si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo per ripristinare il <xref:System.Numerics.BigInteger> valore.  
  
 A differenza di altri <xref:System.Globalization.NumberStyles> valori, che consentono, ma non richiedono la presenza di elementi di stile specifico nel `value`, il <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> stile valore indica che i singoli caratteri numerici in `value` vengono sempre interpretate come caratteri esadecimali. I caratteri esadecimali validi sono 0-9, A-F e a-f. Gli unici altri flag che possono essere combinati con il `style` parametro vengono <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Il <xref:System.Globalization.NumberStyles> enumerazione include uno stile di numero composto, <xref:System.Globalization.NumberStyles.HexNumber>, che include entrambi i flag di spazi vuoti.)  
  
> [!NOTE]
>  Se `value` è la rappresentazione di stringa di un numero esadecimale, non può essere preceduto da qualsiasi effetto (ad esempio `0x` o `&h`) che lo distingue come numero esadecimale. In questo modo la conversione a non riuscire.  
  
 Se `value` è una stringa esadecimale, il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metodo interpreta `value` come un numero negativo archiviato tramite la rappresentazione in complemento a due se le prime due cifre esadecimali sono maggiori o uguali a `0x80`. In altre parole, il metodo interpreta il bit più significativo del primo byte in `value` come bit di segno. Per assicurarsi che una stringa esadecimale viene correttamente interpretata come un numero positivo, la prima cifra `value` deve avere un valore pari a zero. Ad esempio, il metodo interpreta `0x80` come un valore negativo, ma interpreta `0x080` o `0x0080` come un valore positivo. Nell'esempio seguente viene illustrata la differenza tra stringhe esadecimali che rappresentano i valori negativi e positivi.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Il `value` parametro viene analizzato tramite le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto inizializzato per impostazioni cultura correnti del sistema. Per specificare le impostazioni cultura le cui informazioni di formattazione viene utilizzati per l'operazione di analisi, chiamare il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> rapporto di overload.  
  
   
  
## Examples  
 Nell'esempio seguente illustra le chiamate per il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metodo con diversi valori possibili per il `style` parametro. Viene illustrato come interpretare una stringa come valore esadecimale e come disabilitare gli spazi e firmare i simboli.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  
  
oppure 
 <paramref name="style" /> include il contrassegno <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> o <see cref="F:System.Globalization.NumberStyles.HexNumber" /> insieme a un altro valore.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> non è conforme al criterio di input specificato da <see cref="T:System.Globalization.NumberStyles" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Stringa che contiene un numero da convertire.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura relative a <paramref name="value" />.</param>
        <summary>Converte la rappresentazione di stringa di un numero in un formato specifico delle impostazioni cultura indicato nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valore equivalente al numero specificato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro deve essere la rappresentazione di stringa di un numero nel formato seguente:  
  
 [*ws*] [*sign*]*cifre*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo.|  
|*sign*|Un segno facoltativo. Caratteri segno validi sono determinati dal <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> delle proprietà delle <xref:System.Globalization.NumberFormatInfo> oggetto restituito dal `provider` dell'oggetto <xref:System.IFormatProvider.GetFormat%2A> (metodo).|  
|*cifre*|Una sequenza di cifre comprese tra 0 e 9. Eventuali zeri iniziali vengono ignorati.|  
  
> [!NOTE]
>  La stringa specificata tramite il `value` parametro viene interpretato mediante il <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stile. Non può contenere qualsiasi separatori di gruppi o un separatore decimale e non può avere una parte decimale.  
  
> [!IMPORTANT]
>  Se si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo eseguire il round trip la rappresentazione di stringa di un <xref:System.Numerics.BigInteger> valore ottenuto come risultato il <xref:System.Numerics.BigInteger.ToString%2A> metodo, è consigliabile usare il <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metodo con l'identificatore di formato "R" per generare la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore. In caso contrario, la rappresentazione di stringa del <xref:System.Numerics.BigInteger> mantiene solo il 50 cifre più significative del valore originale e i dati vadano perse quando si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo per ripristinare il <xref:System.Numerics.BigInteger> valore.  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura. Quando il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> metodo viene richiamato, viene chiamato il `provider` del parametro <xref:System.IFormatProvider.GetFormat%2A> metodo e lo passa a un <xref:System.Type> oggetto che rappresenta il <xref:System.Globalization.NumberFormatInfo> tipo. Il <xref:System.IFormatProvider.GetFormat%2A> metodo quindi restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni relative al formato del `value` parametro. Esistono tre modi per usare il `provider` parametro per fornire informazioni di formattazione personalizzate per l'operazione di analisi:  
  
-   È possibile passare un <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che forniscono informazioni di formattazione. Relativi <xref:System.Globalization.CultureInfo.GetFormat%2A> restituzione del metodo di <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche per impostazioni cultura.  
  
-   È possibile passare l'oggetto effettivo <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> semplicemente restituisce se stesso.)  
  
-   È possibile passare un oggetto personalizzato che implementa <xref:System.IFormatProvider>. Relativi <xref:System.IFormatProvider.GetFormat%2A> metodo crea un'istanza e restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null`, la formattazione dei `value` viene interpretato in base il <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura correnti.  
  
   
  
## Examples  
 Gli esempi seguenti illustrano due modi per definire la tilde (~) come un segno negativo per la formattazione <xref:System.Numerics.BigInteger> valori. Si noti che per visualizzare il <xref:System.Numerics.BigInteger> valori nello stesso formato delle stringhe originali, il codice deve chiamare il <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> (metodo) e passarlo di <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Nel primo esempio viene definita una classe che implementa <xref:System.IFormatProvider> e Usa le <xref:System.IFormatProvider.GetFormat%2A> per restituire il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Oggetto <xref:System.Numerics.BigInteger> oggetto può quindi essere creata un'istanza con il codice seguente:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Nel secondo esempio è più semplice. Passa il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione per il `provider` parametro.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Il formato di <paramref name="value" /> non è corretto.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che specifica il formato consentito di <paramref name="value" />.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura relative a <paramref name="value" />.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato e un formato specifico delle impostazioni cultura indicato nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valore equivalente al numero specificato nel parametro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `style` parametro definisce gli elementi di stile (ad esempio, gli spazi vuoti, il simbolo di segno positivo o negativo, il simbolo di separatore di gruppi o il simbolo di separatore decimale) consentite nel `value` parametro per l'operazione di analisi abbia esito positivo. `styles` deve contenere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. Il `style` parametro, questo metodo di overload utili quando `value` contiene la rappresentazione di stringa del valore esadecimale, quando il sistema di numero (decimale o esadecimale) rappresentato da `value` è noto solo in fase di esecuzione o quando si non consentire spazio vuoto o un simbolo di segno `value`.  
  
 A seconda del valore di `style`, il `value` parametro può includere gli elementi seguenti:  
  
 [*ws*] [*$*] [*sign*] [*cifre*,]*cifre*[*. frazionarie*] [E [*sign*]*cifre_esponenziali*] [*ws*]  
  
 Se `style` comprende <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, il `value` parametro può includere gli elementi seguenti:  
  
 [*ws*]*cifre esadecimali*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo. Gli spazi vuoti possono essere visualizzati all'inizio di `value` se `style` include le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag che possono essere visualizzati alla fine del `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|*$*|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita dal <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> delle proprietà delle impostazioni cultura indicato dal `provider` parametro. Simbolo di valuta di cultura correnti può essere visualizzati nella `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Un segno facoltativo. Il segno può essere visualizzati all'inizio di `value` se `style` include le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati alla fine del `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `value` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*cifre*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Una sequenza di cifre da 0 a 9. Per la *frazionarie*, solo la cifra 0 non è valida.|  
|*,*|Un simbolo di separatore gruppo di impostazioni cultura specifiche. Il simbolo di separatore di gruppi di impostazioni cultura specificate da `provider` possono essere visualizzati in `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche. Il simbolo di separatore decimale delle impostazioni cultura designato da `provider` possono essere visualizzati in `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag. Può essere visualizzata solo la cifra 0 come numero frazionario per l'operazione di analisi abbia esito positivo; Se *frazionarie* include qualsiasi altra cifra, una <xref:System.FormatException> viene generata un'eccezione.|  
|E|Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `value` parametro può rappresentare un numero in notazione esponenziale se `style` include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esadecimali*|Una sequenza di cifre esadecimali da 0 a f o 0 e F.|  
  
> [!NOTE]
> Eventuali caratteri di terminazione null (u+0000) nella `s` vengono ignorati dall'operazione di analisi, indipendentemente dal valore della `style` argomento.

 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) sempre viene analizzata correttamente. La maggior parte delle rimanenti <xref:System.Globalization.NumberStyles> membri controllano gli elementi che possono essere presenti, ma non devono essere presenti, nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> membri interessano gli elementi che possono essere presenti in `value`.  
  
|Valore NumberStyles|Elementi consentiti nel valore oltre alle cifre|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale (.) e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il "e" o un carattere "E, che indica la notazione esponenziale". insieme a *cifre_esponenziali*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Elemento separatore (,) del gruppo.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|L'elemento di valuta ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* all'inizio o alla fine dell'elemento `value`, *sign* all'inizio di `value`e il simbolo di separatore decimale (.). Il `value` parametro anche possibile usare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, il separatore di gruppi (,) e gli elementi il separatore decimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale.|  
  
> [!IMPORTANT]
>  Se si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo eseguire il round trip la rappresentazione di stringa di un <xref:System.Numerics.BigInteger> valore ottenuto come risultato il <xref:System.Numerics.BigInteger.ToString%2A> metodo, è consigliabile usare il <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metodo con l'identificatore di formato "R" per generare la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore. In caso contrario, la rappresentazione di stringa del <xref:System.Numerics.BigInteger> mantiene solo il 50 cifre più significative del valore originale e i dati vadano perse quando si usa la <xref:System.Numerics.BigInteger.Parse%2A> metodo per ripristinare il <xref:System.Numerics.BigInteger> valore.  
  
 A differenza di altri <xref:System.Globalization.NumberStyles> valori, che consentono, ma non richiedono la presenza di elementi di stile specifico nel `value`, il <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> stile valore indica che i singoli caratteri numerici in `value` vengono sempre interpretate come caratteri esadecimali. I caratteri esadecimali validi sono 0-9, A-F e a-f. Gli unici altri flag che possono essere combinati con il `style` parametro vengono <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Il <xref:System.Globalization.NumberStyles> enumerazione include uno stile di numero composto, <xref:System.Globalization.NumberStyles.HexNumber>, che include entrambi i flag di spazi vuoti.)  
  
> [!NOTE]
>  Se `value` è la rappresentazione di stringa di un numero esadecimale, non può essere preceduto da qualsiasi effetto (ad esempio `0x` o `&h`) che lo distingue come numero esadecimale. In questo modo la conversione a non riuscire.  
  
 Se `value` è una stringa esadecimale, il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metodo interpreta `value` come un numero negativo archiviato tramite la rappresentazione in complemento a due se le prime due cifre esadecimali sono maggiori o uguali a `0x80`. In altre parole, il metodo interpreta il bit più significativo del primo byte in `value` come bit di segno. Per assicurarsi che una stringa esadecimale viene correttamente interpretata come un numero positivo, la prima cifra `value` deve avere un valore pari a zero. Ad esempio, il metodo interpreta `0x80` come un valore negativo, ma interpreta `0x080` o `0x0080` come un valore positivo. Nell'esempio seguente viene illustrata la differenza tra stringhe esadecimali che rappresentano i valori negativi e positivi.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione. Relativi <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura relative al formato di `value`. In genere, `provider` può essere una qualsiasi delle operazioni seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che fornisce informazioni sulla formattazione numeriche. Relativi <xref:System.Globalization.CultureInfo.GetFormat%2A> restituzione del metodo di <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche.  
  
-   Oggetto <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> semplicemente restituisce se stesso.)  
  
-   Un oggetto personalizzato che implementa <xref:System.IFormatProvider> e Usa le <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> per creare un'istanza e restituire il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null`, il <xref:System.Globalization.NumberFormatInfo> dell'oggetto per la lingua corrente viene utilizzata.  
  
   
  
## Examples  
 Nell'esempio seguente effettua più chiamate per il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metodo usando varie combinazioni di valori per il `style` e `provider` parametri.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Un numero delle singole chiamate per il <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metodo passare un'istanza delle opzioni seguenti `BigIntegerFormatProvider` (classe), che definisce una tilde (~) come il segno negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  
  
oppure 
 <paramref name="style" /> include il contrassegno <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> o <see cref="F:System.Globalization.NumberStyles.HexNumber" /> insieme a un altro valore.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> non è conforme al criterio di input specificato da <paramref name="style" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Numero da elevare alla potenza di <paramref name="exponent" /></param>
        <param name="exponent">Esponente per il quale elevare alla potenza <paramref name="value" />.</param>
        <summary>Eleva alla potenza di un valore specificato il valore <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Risultato di <paramref name="value" /> elevato alla potenza di <paramref name="exponent" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.Pow%2A> metodo restituisce 1 se il valore del parametro esponente è 0, o se i valori di entrambi i `value` e `exponent` parametri sono pari a 0. Se `exponent` è 1, il <xref:System.Numerics.BigInteger.Pow%2A> restituzione del metodo `value`. Se `value` è negativo, il metodo restituisce un risultato negativo.  
  
 Questo metodo corrisponde al <xref:System.Math.Pow%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di elevamento a potenza un' <xref:System.Numerics.BigInteger> valore e un esponente il cui valore è compreso tra 0 e 10.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="exponent" /> è negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valore da dividere.</param>
        <param name="divisor">Valore per cui dividere.</param>
        <summary>Esegue una divisione intera su due valori <see cref="T:System.Numerics.BigInteger" /> e restituisce il resto.</summary>
        <returns>Resto risultante dalla divisione di <paramref name="dividend" /> per <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il segno del resto è il segno del `dividend` parametro.  
  
 Il <xref:System.Numerics.BigInteger.Remainder%2A> metodo è implementato per le lingue che non supportano gli operatori personalizzati. Il comportamento è identico alla divisione usando l'operatore modulo.  
  
 Se necessario, il metodo esegue automaticamente la conversione implicita di altri tipi integrali a <xref:System.Numerics.BigInteger> oggetti prima di eseguire l'operazione di modulo.  
  
   
  
## Examples  
 L'esempio seguente confronta il resto del <xref:System.Numerics.BigInteger.DivRem%2A> con il resto restituito dal metodo di <xref:System.Numerics.BigInteger.Remainder%2A> metodo per stabilire che i due metodi calcolano resti identiche.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> è 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un numero che indica il segno (negativo, positivo o zero) dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente.</summary>
        <value>Numero che indica il segno dell'oggetto <see cref="T:System.Numerics.BigInteger" />, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Number 
 </term><description> Descrizione 
 </description></listheader><item><term> -1 
 </term><description> Il valore di questo oggetto è negativo.  
  
 </description></item><item><term> 0 
 </term><description> Il valore di questo oggetto è 0 (zero).  
  
 </description></item><item><term> 1 
 </term><description> Il valore di questo oggetto è positivo.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.Sign%2A> è equivalente alla proprietà di <xref:System.Math.Sign%2A?displayProperty=nameWithType> metodo per i tipi numerici primitivi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Valore da cui sottrarre (minuendo).</param>
        <param name="right">Valore da sottrarre (sottraendo).</param>
        <summary>Sottrae un valore <see cref="T:System.Numerics.BigInteger" /> da un altro e restituisce il risultato.</summary>
        <returns>Risultato della sottrazione di <paramref name="right" /> da <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I linguaggi che non supportano gli operatori personalizzati possono utilizzare il <xref:System.Numerics.BigInteger.Subtract%2A> metodo per eseguire sottrazioni utilizzando <xref:System.Numerics.BigInteger> valori.  
  
 Il <xref:System.Numerics.BigInteger.Subtract%2A> metodo è un sostituto utile per l'operatore di sottrazione quando si crea un <xref:System.Numerics.BigInteger> variabile assegnando alla VM la differenza che risultante dalla sottrazione, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte un valore <see cref="T:System.Numerics.BigInteger" /> in una matrice di byte.</summary>
        <returns>Valore dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente convertito in una matrice di byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I singoli byte nella matrice restituita da questo metodo vengono visualizzati in ordine little-endian. Vale a dire i byte meno significativo del valore precedono i byte di ordine superiore. Il primo byte della matrice riflette i primi otto bit del <xref:System.Numerics.BigInteger> valore, il secondo byte riflette otto bit successivo e così via. Ad esempio, il valore 1024 o 0x0400, viene archiviato come la seguente matrice di byte di due:  
  
|Elemento|Valore byte|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 I valori negativi vengono scritti nella matrice usando la rappresentazione in complemento a due nel possibile formato più compatto. Ad esempio, -1 è rappresentato come un singolo byte il cui valore è `0xFF` anziché come una matrice con più elementi, ad esempio `0xFF`, `0xFF` o `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Poiché in complemento a due rappresentazione sempre interpreta il bit più significativo dell'ultimo byte della matrice (il byte nella posizione <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) come bit di segno, il metodo restituisce una matrice di byte con un elemento supplementare il cui valore è uguale a zero per evitare ambiguità tra i valori positivi che in caso contrario, potrebbero essere interpretati come impostare i bit di segno. Ad esempio, il valore di 120 o `0x78` è rappresentato come una matrice a byte singolo: `0x78`. Tuttavia, 128, oppure `0x80`, viene rappresentato come una matrice a due byte: `0x80`, `0x00`.  
  
 È possibile eseguire il round trip una <xref:System.Numerics.BigInteger> valore archiviandolo in una matrice di byte e quindi ripristinarlo tramite il <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> costruttore.  
  
> [!CAUTION]
>  Se il codice modifica il valore dei singoli byte nella matrice restituita da questo metodo prima di ripristinare il valore, è necessario assicurarsi di non modificare inavvertitamente il bit di segno. Ad esempio, se le modifiche incrementa un valore positivo, in modo che l'ordine più elevato di bit nell'ultimo elemento della matrice di byte diventa impostato, che è possibile aggiungere un nuovo byte il cui valore è uguale a zero alla fine della matrice.  
  
   
  
## Examples  
 L'esempio seguente illustra come alcune <xref:System.Numerics.BigInteger> i valori sono rappresentati nelle matrici di byte.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore numerico dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente nella rappresentazione di stringa equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte il valore numerico dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente nella rappresentazione di stringa equivalente.</summary>
        <returns>Rappresentazione di stringa del valore <see cref="T:System.Numerics.BigInteger" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.ToString> formati del metodo un <xref:System.Numerics.BigInteger> valore del "R" o eseguire il round trip, formato delle impostazioni cultura correnti. Se si desidera specificare un formato diverso o delle impostazioni cultura, usare gli altri overload del <xref:System.Numerics.BigInteger.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato round-trip ("R")|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Un formato specifico|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Un formato specifico|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore include un segno negativo se il valore è negativo e una sequenza di cifre comprese tra 0 e 9 senza zeri iniziali. Il segno negativo è definito dal <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti.  
  
   
  
## Examples  
 L'esempio seguente mostra una <xref:System.Numerics.BigInteger> valore usando il valore predefinito <xref:System.Numerics.BigInteger.ToString> (metodo). Visualizza anche le rappresentazioni di stringa del <xref:System.Numerics.BigInteger> valore risultante dall'utilizzo di alcuni identificatori di formato standard. Gli esempi vengono visualizzati utilizzando le convenzioni di formattazione delle impostazioni cultura en-US.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Stringhe di formato numerico standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Stringhe di formato numerico personalizzato</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore numerico dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente nella rappresentazione di stringa equivalente usando le informazioni di formattazione specifiche delle impostazioni cultura indicate.</summary>
        <returns>Rappresentazione di stringa del valore <see cref="T:System.Numerics.BigInteger" /> corrente nel formato specificato dal parametro <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> formati del metodo una <xref:System.Numerics.BigInteger> valore in "R" o eseguire il round trip, formattare utilizzando il <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura specificata. Se si desidera specificare le impostazioni cultura correnti o un formato diverso, usare gli altri overload del <xref:System.Numerics.BigInteger.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato round-trip ("R")|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString>|  
|Un formato specifico|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Un formato specifico|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione. Relativi <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura sul formato della stringa restituita da questo metodo. Se `provider` viene `null`, il <xref:System.Numerics.BigInteger> valore viene formattato utilizzando le <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura correnti. L'unica proprietà del <xref:System.Globalization.NumberFormatInfo> oggetto che controlla la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore con l'identificatore di formato generale è <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, che definisce il carattere che rappresenta il segno negativo.  
  
 Il `provider` parametro può essere uno dei seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che forniscono informazioni di formattazione.  
  
-   Il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
-   Un oggetto personalizzato che implementa <xref:System.IFormatProvider>. Relativi <xref:System.IFormatProvider.GetFormat%2A> restituzione del metodo di <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
   
  
## Examples  
 Nell'esempio seguente crea un'istanza di un oggetto personalizzato <xref:System.Globalization.NumberFormatInfo> oggetto che definisce la tilde (~) come un segno negativo. Il <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> metodo Usa quindi l'oggetto personalizzato <xref:System.Globalization.NumberFormatInfo> dell'oggetto per visualizzare un valore negativo <xref:System.Numerics.BigInteger> valore.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato numerico standard o personalizzato.</param>
        <summary>Converte il valore numerico dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente nella rappresentazione di stringa equivalente, usando il formato specificato.</summary>
        <returns>Rappresentazione di stringa del valore <see cref="T:System.Numerics.BigInteger" /> corrente nel formato specificato dal parametro <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.ToString%28System.String%29> formati del metodo una <xref:System.Numerics.BigInteger> valore in un formato specificato usando un <xref:System.Globalization.NumberFormatInfo> oggetto che rappresenta le convenzioni delle impostazioni cultura correnti. Se si desidera utilizzare il "R" o eseguire il round trip, formattare o specificare una lingua diversa, usare gli altri overload del <xref:System.Numerics.BigInteger.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato round-trip ("R")|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString>|  
|Formato round-trip ("R")|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Un formato specifico|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il `format` parametro può essere qualunque [stringa numerica standard](~/docs/standard/base-types/standard-numeric-format-strings.md), o qualsiasi combinazione di [stringhe di formato numerico personalizzate](~/docs/standard/base-types/custom-numeric-format-strings.md). Se `format` è uguale a <xref:System.String.Empty?displayProperty=nameWithType> oppure viene `null`, il valore restituito dell'oggetto corrente <xref:System.Numerics.BigInteger> oggetto viene formattato con l'identificatore di formato round trip ("R"). Se `format` è qualsiasi altro valore, il metodo genera un <xref:System.FormatException>.  
  
 .NET Framework fornisce supporto di formattazione completo, che è descritti più dettagliatamente nella formattazione negli argomenti seguenti:  
  
-   Per altre informazioni sugli identificatori di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per altre informazioni sul supporto per la formattazione in .NET Framework, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Il formato della stringa restituita è determinato dal <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti. A seconda di `format` parametro, questo oggetto consente di controllare i simboli, ad esempio il segno negativo, il separatore di gruppi e il simbolo di separatore decimale nella stringa di output. Per fornire informazioni di formattazione per le impostazioni cultura diverse da quelle correnti, chiamare il <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> rapporto di overload.  
  
   
  
## Examples  
 Nell'esempio seguente viene inizializzato un <xref:System.Numerics.BigInteger> valore e lo visualizza con ogni stringa di formato standard e alcune stringhe di formato personalizzato.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è una stringa di formato valida.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Stringhe di formato numerico standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Stringhe di formato numerico personalizzato</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato numerico standard o personalizzato.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore numerico dell'oggetto <see cref="T:System.Numerics.BigInteger" /> corrente nella rappresentazione di stringa equivalente usando il formato specificato e le informazioni di formattazione specifiche delle impostazioni cultura indicate.</summary>
        <returns>Rappresentazione di stringa del valore corrente di <see cref="T:System.Numerics.BigInteger" />, come specificato dai parametri <paramref name="format" /> e <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> formati del metodo una <xref:System.Numerics.BigInteger> valore in un formato specificato utilizzando il <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura specificata. Se si desidera usare il formato round trip o impostazioni cultura predefinite, usare gli altri overload del <xref:System.Numerics.BigInteger.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato round-trip ("R")|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString>|  
|Formato round-trip ("R")|Impostazioni cultura specifiche|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Un formato specifico|Impostazioni cultura (corrente) predefinite|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 Il `format` parametro può essere qualunque [stringa numerica standard](~/docs/standard/base-types/standard-numeric-format-strings.md), o qualsiasi combinazione di [stringhe di formato numerico personalizzate](~/docs/standard/base-types/custom-numeric-format-strings.md). Se `format` è uguale a <xref:System.String.Empty?displayProperty=nameWithType> oppure viene `null`, il valore restituito dell'oggetto corrente <xref:System.Numerics.BigInteger> oggetto viene formattato con l'identificatore di formato round trip ("R"). Se `format` è qualsiasi altro valore, il metodo genera un <xref:System.FormatException>.  
  
 .NET Framework fornisce supporto di formattazione completo, che è descritti più dettagliatamente nella formattazione negli argomenti seguenti:  
  
-   Per altre informazioni sugli identificatori di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per altre informazioni sul supporto per la formattazione in .NET Framework, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione. Relativi <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura sul formato della stringa restituita da questo metodo. Quando il <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> metodo viene richiamato, viene chiamato il `provider` del parametro <xref:System.IFormatProvider.GetFormat%2A> metodo e lo passa a un <xref:System.Type> oggetto che rappresenta il <xref:System.Globalization.NumberFormatInfo> tipo. Il <xref:System.IFormatProvider.GetFormat%2A> metodo quindi restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni per la formattazione di `value` parametro, ad esempio il simbolo di segno negativo, il simbolo di separatore di gruppi o il simbolo di separatore decimale. Esistono tre modi per usare la `provider` parametro per fornire informazioni di formattazione per il <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> metodo:  
  
-   È possibile passare un <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che forniscono informazioni di formattazione. Relativi <xref:System.Globalization.CultureInfo.GetFormat%2A> restituzione del metodo di <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche per impostazioni cultura.  
  
-   È possibile passare l'oggetto effettivo <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> semplicemente restituisce se stesso.)  
  
-   È possibile passare un oggetto personalizzato che implementa <xref:System.IFormatProvider>. Relativi <xref:System.IFormatProvider.GetFormat%2A> metodo crea un'istanza e restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null`, la formattazione della stringa restituita è basata sul <xref:System.Globalization.NumberFormatInfo> oggetto delle impostazioni cultura correnti.  
  
   
  
## Examples  
 L'esempio seguente Inizializza una <xref:System.Numerics.BigInteger> valore e lo visualizza nella console usando una stringa di formato standard e un <xref:System.Globalization.NumberFormatInfo> oggetto che definisce la tilde (~) come un segno negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è una stringa di formato valida.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Stringhe di formato numerico standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Stringhe di formato numerico personalizzato</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova a convertire la rappresentazione di stringa di un numero nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente e restituisce un valore che indica se la conversione è stata eseguita correttamente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Rappresentazione di stringa di un numero.</param>
        <param name="result">Quando questo metodo restituisce un risultato, esso contiene <see cref="T:System.Numerics.BigInteger" /> equivalente al numero contenuto in <paramref name="value" />, oppure zero (0) in caso di errore nella conversione. La conversione non viene eseguita se il parametro <paramref name="value" /> è <see langword="null" />, o non è nel formato corretto. Questo parametro viene passato non inizializzato.</param>
        <summary>Prova a convertire la rappresentazione di stringa di un numero nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente e restituisce un valore che indica se la conversione è stata eseguita correttamente.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> metodo è simile al <xref:System.Numerics.BigInteger.Parse%28System.String%29> metodo, ad eccezione del fatto che non genera un'eccezione se la conversione non riesce. Questo metodo elimina la necessità di usare la gestione delle eccezioni da testare per una <xref:System.FormatException> se `value` non è valido e non può essere analizzata correttamente.  
  
 Il `value` parametro deve essere la rappresentazione di stringa di un numero decimale nel formato seguente:  
  
 [*ws*] [*sign*]*cifre*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo.|  
|*sign*|Un segno facoltativo. Caratteri segno validi sono determinati dal <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti.|  
|*cifre*|Una sequenza di cifre decimali comprese tra 0 e 9.|  
  
> [!NOTE]
>  La stringa specificata tramite la `value` parametro non può contenere qualsiasi separatori di gruppi o un separatore decimale, e non può avere una parte decimale.  
  
 Il `value` parametro viene interpretato usando la <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> stile. Oltre a cifre decimali, sono consentiti solo spazi iniziali e finali con un segno iniziale. Definire in modo esplicito gli elementi di stile con le informazioni di formattazione specifiche delle impostazioni cultura che possono essere presenti in `value`, chiamare il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> (metodo).  
  
 Il `value` parametro viene analizzato tramite le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Questo overload interpreta tutte le cifre di `value` parametro come cifre decimali. Per analizzare la rappresentazione di stringa di un numero esadecimale, chiamare il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> invece l'overload.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> metodo per creare un'istanza di due <xref:System.Numerics.BigInteger> oggetti. Se le conversioni hanno esito positivo, si moltiplica ogni oggetto da un altro numero e quindi chiama il <xref:System.Numerics.BigInteger.Compare%2A> metodo per stabilire la relazione tra i due oggetti.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Rappresentazione di stringa di un numero. La stringa viene interpreta usando lo stile specificato da <paramref name="style" />.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che indica gli elementi di stile che possono essere presenti in <paramref name="value" />. Un valore tipico da specificare è <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura relativamente a <paramref name="value" />.</param>
        <param name="result">Quando questo metodo restituisce un risultato, esso contiene <see cref="T:System.Numerics.BigInteger" /> equivalente al numero contenuto in <paramref name="value" />, oppure <see cref="P:System.Numerics.BigInteger.Zero" /> in caso di errore nella conversione. La conversione non viene eseguita se il parametro <paramref name="value" /> è <see langword="null" /> oppure è in un formato non conforme a <paramref name="style" />. Questo parametro viene passato non inizializzato.</param>
        <summary>Prova a convertire la rappresentazione di stringa di un numero in uno stile specificato e un formato specifico delle impostazioni cultura indicato nell'oggetto <see cref="T:System.Numerics.BigInteger" /> equivalente e restituisce un valore che indica se la conversione è stata eseguita correttamente.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodo è simile al <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metodo, ad eccezione del fatto che non genera un'eccezione se la conversione non riesce. Questo metodo elimina la necessità di usare la gestione delle eccezioni da testare per una <xref:System.FormatException> se `value` non è valido e non può essere analizzato correttamente.  
  
 Il `style` parametro definisce gli elementi di stile (ad esempio lo spazio vuoto o un segno positivo o negativo) sono consentiti nel `value` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. A seconda del valore di `style`, il `value` parametro può includere gli elementi seguenti:  
  
 [*ws*] [*$*] [*sign*] [*cifre*,]*cifre*[. *frazionarie*] [E [*sign*]*cifre_esponenziali*] [*ws*]  
  
 Se il `style` includerà <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, il `value` parametro può includere gli elementi seguenti:  
  
 [*ws*]*cifre esadecimali*[*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo. Gli spazi vuoti possono essere visualizzati all'inizio di `value` se `style` include le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, o alla fine del `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|*$*|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita dal <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> proprietà del <xref:System.Globalization.NumberFormatInfo> oggetto restituito dal <xref:System.IFormatProvider.GetFormat%2A> metodo il `provider` parametro. Il simbolo di valuta può essere visualizzati nella `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Un segno facoltativo. Il segno può essere visualizzati all'inizio di `value` se `style` include le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati alla fine del `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `value` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*cifre*|Una sequenza di cifre da 0 a 9.|  
|*,*|Un separatore di gruppi di impostazioni cultura specifiche. Il separatore di gruppi di impostazioni cultura specificate da `provider` possono essere visualizzati in `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche. Il simbolo di separatore decimale della lingua specificata da `provider` possono essere visualizzati in `value` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*fractional_digits*|Una o più occorrenze della cifra 0. Cifre frazionarie visualizzabili nella `value` solo se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|E|Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `value` parametro può rappresentare un numero in notazione esponenziale se `style` include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*exponential_digits*|Una sequenza di cifre da 0 a 9. Il `value` parametro può rappresentare un numero in notazione esponenziale se `style` include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esadecimali*|Una sequenza di cifre esadecimali da 0 a f o 0 e F.|  
  
> [!NOTE]
> Eventuali caratteri di terminazione null (u+0000) nella `s` vengono ignorati dall'operazione di analisi, indipendentemente dal valore della `style` argomento.

 Una stringa con solo cifre decimali (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flag) sempre viene analizzata correttamente. La maggior parte delle rimanenti <xref:System.Globalization.NumberStyles> membri controllano gli elementi che possono essere presenti, ma non deve essere presente, in questa stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> membri interessano gli elementi che possono essere presenti in `value`.  
  
|Non compositi `NumberStyles` valori|Elementi consentiti nel valore oltre alle cifre|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Cifre decimali.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale (*.*) e *frazionarie* elementi. Tuttavia *frazionarie* deve essere costituito solo da uno o più cifre 0 o il metodo restituisce `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il "e" o il carattere "E, che indica la notazione esponenziale, insieme a" *cifre_esponenziali*. Se `value` rappresenta un numero nella notazione esponenziale non può avere un componente frazionario di diverso da zero.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento prima *cifre*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento dopo *cifre*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Il separatore di gruppi (*,*) elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|La valuta (*$*) elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* all'inizio o alla fine dell'elemento `value`, *sign* all'inizio del `value`e il separatore decimale (*.*) simbolo. Il `value` parametro anche possibile usare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il *ws*, *sign*, separatore di gruppi (*,*) e il punto decimale (*.*) elementi.|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `value` non può rappresentare un numero esadecimale.|  
  
> [!IMPORTANT]
>  Se si usa la <xref:System.Numerics.BigInteger.TryParse%2A> metodo eseguire il round trip la rappresentazione di stringa di un <xref:System.Numerics.BigInteger> valore ottenuto come risultato il <xref:System.Numerics.BigInteger.ToString%2A> metodo, è consigliabile usare il <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> metodo con l'identificatore di formato "R" per generare la rappresentazione di stringa del <xref:System.Numerics.BigInteger> valore. In caso contrario, la rappresentazione di stringa del <xref:System.Numerics.BigInteger> mantiene solo il 50 cifre più significative del valore originale e i dati vadano perse quando si usa la <xref:System.Numerics.BigInteger.TryParse%2A> metodo per ripristinare il <xref:System.Numerics.BigInteger> valore.  
  
 Se il <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag viene utilizzato, `value` deve essere un valore esadecimale. Gli unici altri flag che possono essere presenti in `style` vengono <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Il <xref:System.Globalization.NumberStyles> enumerazione dispone di uno stile composto, <xref:System.Globalization.NumberStyles.HexNumber>, che include entrambi i flag di spazi vuoti.)  
  
> [!NOTE]
>  Se `value` è la rappresentazione di stringa di un numero esadecimale, non può essere preceduto da qualsiasi effetto (ad esempio `0x` o `&h`) che lo distingue come numero esadecimale. In questo modo la conversione a non riuscire.  
  
 Se `value` è una stringa esadecimale, il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodo interpreta `value` come un numero negativo archiviato tramite la rappresentazione in complemento a due se le prime due cifre esadecimali sono maggiori o uguali a `0x80`. In altre parole, il metodo interpreta il bit più significativo del primo byte in `value` come bit di segno. Per assicurarsi che una stringa esadecimale viene correttamente interpretata come un numero positivo, la prima cifra `value` deve avere un valore pari a zero. Ad esempio, il metodo interpreta `0x80` come un valore negativo, ma interpreta `0x080` o `0x0080` come un valore positivo. Nell'esempio seguente viene illustrata la differenza tra stringhe esadecimali che rappresentano i valori negativi e positivi.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione. Relativi <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura relative al formato di `value`. Il `provider` parametro può essere uno dei seguenti:  
  
-   Oggetto <xref:System.Globalization.CultureInfo> oggetto che rappresenta le impostazioni cultura che forniscono informazioni di formattazione. Relativi <xref:System.Globalization.CultureInfo.GetFormat%2A> restituzione del metodo di <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche per impostazioni cultura.  
  
-   Oggetto <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni sulla formattazione numeriche. (L'implementazione di <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> semplicemente restituisce se stesso.)  
  
-   Un oggetto personalizzato che implementa <xref:System.IFormatProvider>. Relativi <xref:System.IFormatProvider.GetFormat%2A> metodo crea un'istanza e restituisce il <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni di formattazione.  
  
 Se `provider` viene `null`, il <xref:System.Globalization.NumberFormatInfo> dell'oggetto per la lingua corrente viene utilizzata.  
  
   
  
## Examples  
 Nell'esempio seguente effettua alcune chiamate per il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodo usando varie combinazioni di valori per il `style` e `provider` parametri.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Un numero delle singole chiamate per il <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> metodo passare un'istanza delle opzioni seguenti `BigIntegerFormatProvider` (classe), che definisce una tilde (~) come il segno negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  
  
oppure 
 <paramref name="style" /> include il contrassegno <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> o <see cref="F:System.Globalization.NumberStyles.HexNumber" /> insieme a un altro valore.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che rappresenta il numero 0 (zero).</summary>
        <value>Intero il cui valore è 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Numerics.BigInteger> oggetto restituito da questa proprietà fornisce un'utile origine di un valore pari a zero per le assegnazioni e i confronti.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>