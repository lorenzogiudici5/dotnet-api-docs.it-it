<Type Name="D3DImage" FullName="System.Windows.Interop.D3DImage">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="67a591e7f26a5181b8d03d81e8af4ab098e8eb98" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30661055" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class D3DImage : System.Windows.Media.ImageSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi D3DImage extends System.Windows.Media.ImageSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Interop.D3DImage" />
  <TypeSignature Language="VB.NET" Value="Public Class D3DImage&#xA;Inherits ImageSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class D3DImage : System::Windows::Media::ImageSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.ImageSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Oggetto <see cref="T:System.Windows.Media.ImageSource" /> che visualizza una superficie Direct3D creata dall'utente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la <xref:System.Windows.Interop.D3DImage> classe per ospitare contenuto Direct3D in un'applicazione Windows Presentation Foundation (WPF).  
  
 Chiamare il <xref:System.Windows.Interop.D3DImage.Lock%2A> metodo per modificare il contenuto Direct3D visualizzato dal <xref:System.Windows.Interop.D3DImage>. Chiamare il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodo per assegnare una superficie Direct3D a un <xref:System.Windows.Interop.D3DImage>. Chiamare il <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> metodo per tenere traccia degli aggiornamenti all'area di Direct3D. Chiamare il <xref:System.Windows.Interop.D3DImage.Unlock%2A> metodo per visualizzare le aree modificate.  
  
 Il <xref:System.Windows.Interop.D3DImage> classe gestisce due buffer di visualizzazione, ovvero il *buffer nascosto* e *buffer front-*. Il buffer rappresenta la superficie di Direct3D.  Le modifiche apportate al buffer nascosto vengono copiate nel front buffer quando si chiama il <xref:System.Windows.Interop.D3DImage.Unlock%2A> (metodo), in cui vengono visualizzati nell'hardware. In alcuni casi, il front buffer non è più disponibile. La mancanza di disponibilità può essere causata dal blocco dello schermo, applicazioni Direct3D esclusive a schermo intero, cambio utente o altre attività di sistema. In questo caso, l'applicazione WPF notifica gestendo il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> evento.  Modalità di risposta dell'applicazione nel front buffer non sono più disponibili dipende dal tipo di attivazione WPF per eseguire il fallback per il rendering software. Il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodo presenta un overload che accetta un parametro che specifica se il fallback WPF per il rendering software.  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-does-not-fall-back-to-software-rendering"></a>Risponde a un Buffer anteriore disponibile quando WPF non eseguire il fallback software Rendering  
 Quando si chiama il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload o chiamare il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> eseguire l'overload con il `enableSoftwareFallback` parametro impostato su `false`, il sistema di rendering rilascia il riferimento al buffer nascosto quando il front buffer non è più disponibile e non è visualizzato. Quando il buffer anteriore è nuovamente disponibile, il sistema di rendering genera il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> evento per notificare all'applicazione WPF.  È possibile creare un gestore eventi per il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> riavviare il rendering con una superficie Direct3D valida dell'evento. Per riavviare il rendering, è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-falls-back-to-software-rendering"></a>Risponde a un Buffer anteriore disponibile quando esegue il fallback di WPF per il Rendering Software  
 Quando si chiama il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> eseguire l'overload con il `enableSoftwareFallback` parametro impostato su `true`, il sistema di rendering mantiene il relativo riferimento al buffer nascosto quando il front buffer non è disponibile, in modo non è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> quando all'inizio buffer sarà nuovamente disponibile.  Potrebbero verificarsi situazioni in cui il dispositivo dell'utente non è più disponibile.  In questo caso, chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> per rilasciare il riferimento di WPF al buffer nascosto.  Per reimpostare il dispositivo, è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> con il `backBuffer` parametro impostato su `null`e quindi chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> con `backBuffer` impostato su una superficie Direct3D valida.  
  
> [!NOTE]
>  Le prestazioni dipendono notevolmente le impostazioni dell'area di Direct3D. Per ulteriori informazioni, vedere [considerazioni sulle prestazioni per l'interoperabilità di WPF e Direct3D9](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  
  
> [!NOTE]
>  Il <xref:System.Windows.Interop.D3DImage> classe non visualizza contenuto Direct3D quando WPF il rendering software, ad esempio tramite una connessione Desktop remoto, a meno che non si chiama <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> e specificare `true` per il `enableSoftwareFallback` parametro.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come dichiarare un <xref:System.Windows.Interop.D3DImage> in XAML. È necessario eseguire il mapping di <xref:System.Windows.Interop> dello spazio dei nomi, perché non è incluso negli spazi dei nomi XAML predefinito. Per ulteriori informazioni, vedere [procedura dettagliata: Hosting di contenuto Direct3D9 in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-xaml[System.Windows.Interop.D3DImage#10](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La risoluzione dello schermo predefinito è 1/96 di pollice.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage (double dpiX, double dpiY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 dpiX, float64 dpiY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dpiX As Double, dpiY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage(double dpiX, double dpiY);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dpiX">Risoluzione dello schermo sull'asse x.</param>
        <param name="dpiY">Risoluzione dello schermo sull'asse y.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Interop.D3DImage" /> con la risoluzione dello schermo specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La risoluzione dello schermo predefinito è 1/96 di pollice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="dpiX" /> o <paramref name="dpiY" /> è minore di zero.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect">Oggetto <see cref="T:System.Windows.Int32Rect" /> che rappresenta l'area modificata.</param>
        <summary>Specifica l'area del buffer nascosto che è stata modificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> metodo per indicare le modifiche apportate dal codice al buffer nascosto. Per eseguire il rendering dell'area modificata nel buffer nascosto necessario un'area modificata corrispondente <xref:System.Windows.Interop.D3DImage>.  
  
 Chiamare il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> e <xref:System.Windows.Interop.D3DImage.Lock%2A> prima di chiamare i metodi di <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> metodo.  
  
 Chiamare il <xref:System.Windows.Interop.D3DImage.Unlock%2A> metodo per copiare le aree modificate nel front buffer.  
  
> [!NOTE]
>  Dopo alcune chiamate al <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> (metodo), le aree modificate vengono unite in un'unica area. Ciò significa che è necessario disporre di dati validi di fuori di aree modificate.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare il <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> per specificare l'area modificata nel buffer nascosto. Per ulteriori informazioni, vedere [procedura dettagliata: Hosting di contenuto Direct3D9 in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La bitmap non è stata bloccata tramite una chiamata al metodo <see cref="M:System.Windows.Interop.D3DImage.Lock" /> o <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />.  
  
 oppure  
  
 Il buffer nascosto non è stato assegnato tramite una chiamata al metodo <see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Una o più delle condizioni seguenti sono vere.  
  
 <paramref name="dirtyRect.X" /> &lt; 0  
  
 <paramref name="dirtyRect.Y" /> &lt; 0  
  
 <paramref name="dirtyRect.Width" /> &lt; 0 o <paramref name="dirtyRect.Width" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /><paramref name="dirtyRect.Height" /> &lt; 0 o <paramref name="dirtyRect.Height" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clone modificabile dell'oggetto <see cref="T:System.Windows.Interop.D3DImage" />, eseguendo copie complete dei valori di tale oggetto. Durante la copia delle proprietà di dipendenza, questo metodo copia i riferimenti a risorse e le associazioni dati (che potrebbero non essere più risolti), ma non le animazioni né i relativi valori correnti.</summary>
        <returns>Clone modificabile dell'oggetto corrente. La proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto clonato sarà <see langword="false" />, anche se la proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto di origine è <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per produrre copie modificabili di bloccata <xref:System.Windows.Freezable> oggetti (o qualsiasi <xref:System.Windows.Freezable> oggetto). Per comodità, questo metodo nasconde la versione ereditata con un'implementazione fortemente tipizzata.  
  
 Per ulteriori informazioni, vedere <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Oggetto da clonare.</param>
        <summary>Rende l'istanza un clone (copia completa) dell'oggetto <see cref="T:System.Windows.Freezable" /> specificato usando i valori di proprietà di base (non animati).</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ CloneCurrentValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clone modificabile dell'oggetto <see cref="T:System.Windows.Interop.D3DImage" />, eseguendo copie complete dei valori correnti di tale oggetto. I riferimenti alle risorse, i data binding e le animazioni non vengono copiati, mentre vengono copiati i relativi valori correnti.</summary>
        <returns>Clone modificabile dell'oggetto corrente. La proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto clonato sarà <see langword="false" />, anche se la proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto di origine è <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per produrre copie modificabili di bloccata <xref:System.Windows.Freezable> oggetti (o qualsiasi <xref:System.Windows.Freezable> oggetto). Per comodità, questo metodo nasconde la versione ereditata con un'implementazione fortemente tipizzata.  
  
 Per ulteriori informazioni, vedere <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Costruttore <see cref="T:System.Windows.Freezable" /> da duplicare.</param>
        <summary>Rende l'istanza un clone (copia completa) modificabile dell'oggetto <see cref="T:System.Windows.Freezable" /> specificato usando i valori di proprietà correnti.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CopyBackBuffer">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.Media.Imaging.BitmapSource CopyBackBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CopyBackBuffer" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CopyBackBuffer () As BitmapSource" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::Media::Imaging::BitmapSource ^ CopyBackBuffer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.BitmapSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia software di <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> che corrisponde a una copia software dello stato corrente del buffer nascosto; in caso contrario, <see langword="null" /> se non è possibile leggere il buffer nascosto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> metodo viene chiamato dal client, ad esempio il sistema di stampa e <xref:System.Windows.Media.Imaging.RenderTargetBitmap> classe.  
  
 Eseguire l'override di <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> metodo per implementare la logica personalizzata e restituire un oggetto diverso <xref:System.Windows.Media.Imaging.BitmapSource>. Ad esempio, è possibile restituire un segnaposto <xref:System.Windows.Media.Imaging.BitmapSource> se il valore predefinito <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> implementazione restituisce `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando è implementato in una classe derivata, crea una nuova istanza della classe derivata <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <returns>Nuova istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si deriva dal <xref:System.Windows.Interop.D3DImage> (classe), è necessario eseguire l'override di <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> metodo per consentire la corretta clonazione. L'implementazione predefinita esegue un `return new D3DImage()`, che non sarà corretto se l'istanza è una classe diversa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!D3DImage ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera risorse ed esegue altre operazioni di pulizia prima che l'oggetto <see cref="T:System.Windows.Interop.D3DImage" /> venga recuperato tramite Garbage Collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override del metodo <xref:System.Object.Finalize%2A>. Il codice dell'applicazione non deve chiamare questo metodo. un oggetto `Finalize` metodo viene richiamato automaticamente durante l'operazione di garbage collection, a meno che la finalizzazione del garbage collector non è stata disabilitata da una chiamata al <xref:System.GC.SuppressFinalize%2A> metodo.  
  
 Per ulteriori informazioni, vedere [metodi Finalize e distruttori](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md), e [si esegue l'override del metodo Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override sealed bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">Non ha effetto.</param>
        <summary>Rende l'oggetto <see cref="T:System.Windows.Interop.D3DImage" /> immodificabile o determina se può essere reso immodificabile.</summary>
        <returns>
          <see langword="false" /> in tutti i casi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Interop.D3DImage> classe non consente il blocco perché le modifiche sono sempre a causa della disponibilità del front-buffer.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Istanza da copiare.</param>
        <summary>Si prenda ad esempio una copia bloccata di <see cref="T:System.Windows.Freezable" /> specificato utilizzando valori della proprietà di base (non-animati).</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Oggetto <see cref="T:System.Windows.Freezable" /> da copiare e bloccare.</param>
        <summary>Rende l’istanza corrente una copia bloccata di <see cref="T:System.Windows.Freezable" />specificato. Se l'oggetto ha proprietà di dipendenza animate, i valori animati correnti vengono copiati.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public override sealed double Height { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Height" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'altezza di <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <value>Altezza di <see cref="T:System.Windows.Interop.D3DImage" /> espressa in unità di misura. Un'unità di misura è 1/96 di pollice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di <xref:System.Windows.Interop.D3DImage.Height%2A> possono cambiare quando viene assegnato un nuovo buffer nascosto da una chiamata al <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailable">
      <MemberSignature Language="C#" Value="public bool IsFrontBufferAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrontBufferAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrontBufferAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrontBufferAvailable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se un front buffer esiste.</summary>
        <value>
          <see langword="true" /> se un front buffer esiste; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In alcuni casi, il front buffer non è più disponibile. La mancanza di disponibilità può essere causata dal blocco dello schermo, applicazioni Direct3D esclusive a schermo intero, cambio utente o altre attività di sistema. In questo caso, l'applicazione WPF notifica gestendo il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> evento.  Modalità di risposta dell'applicazione nel front buffer non sono più disponibili dipende dal tipo di attivazione WPF per eseguire il fallback per il rendering software. Il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodo presenta un overload che accetta un parametro che specifica se il fallback WPF per il rendering software. Per ulteriori informazioni, vedere la sezione osservazioni nel <xref:System.Windows.Interop.D3DImage> classe.  
  
<a name="dependencyPropertyInfo_IsFrontBufferAvailable"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come controllare il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A> proprietà durante il rendering della destinazione di composizione. Per ulteriori informazioni, vedere [procedura dettagliata: Hosting di contenuto Direct3D9 in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#2](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
        <altmember cref="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsFrontBufferAvailableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsFrontBufferAvailableChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la proprietà <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /> cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gestire il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> per ricevere una notifica quando viene modificato lo stato del buffer anteriore. Modalità di risposta dell'applicazione nel front buffer non sono più disponibili dipende dal tipo di attivazione WPF per eseguire il fallback per il rendering software. Il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodo presenta un overload che accetta un parametro che specifica se il fallback WPF per il rendering software. Per ulteriori informazioni, vedere la sezione osservazioni nel <xref:System.Windows.Interop.D3DImage> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFrontBufferAvailableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFrontBufferAvailableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFrontBufferAvailableProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blocca <see cref="T:System.Windows.Interop.D3DImage" /> e consente l'esecuzione di operazioni nel buffer nascosto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.Interop.D3DImage.Lock%2A> metodo per modificare il buffer chiamando il <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> e <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodi. Mentre il <xref:System.Windows.Interop.D3DImage> è bloccato, l'applicazione può inoltre eseguire il rendering della superficie Direct3D assegnata al buffer nascosto.  
  
> [!NOTE]
>  Il <xref:System.Windows.Interop.D3DImage.Lock%2A> metodo si blocca quando il sistema di rendering legge il buffer nascosto per aggiornare il front buffer. Utilizzare il <xref:System.Windows.Interop.D3DImage.TryLock%2A> metodo per evitare il blocco per un periodo illimitato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare il <xref:System.Windows.Interop.D3DImage.Lock%2A> metodo per abilitare gli aggiornamenti al buffer nascosto. Per ulteriori informazioni, vedere [procedura dettagliata: Hosting di contenuto Direct3D9 in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il conteggio dei blocchi equivale a <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.Media.ImageMetadata Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageMetadata Metadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Metadata" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Metadata As ImageMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageMetadata ^ Metadata { System::Windows::Media::ImageMetadata ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i metadati associati all'origine dell'immagine.</summary>
        <value>
          <see langword="null" /> in tutti i casi.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PixelHeight">
      <MemberSignature Language="C#" Value="public int PixelHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelHeight { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'altezza di <see cref="T:System.Windows.Interop.D3DImage" /> espressa in pixel.</summary>
        <value>Altezza di <see cref="T:System.Windows.Interop.D3DImage" /> espressa in pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> possono cambiare quando viene assegnato un nuovo buffer nascosto da una chiamata al <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> proprietà per specificare l'area modificata nel buffer nascosto. Per ulteriori informazioni, vedere [procedura dettagliata: Hosting di contenuto Direct3D9 in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelWidth" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PixelWidth">
      <MemberSignature Language="C#" Value="public int PixelWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelWidth { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la larghezza di <see cref="T:System.Windows.Interop.D3DImage" /> espressa in pixel.</summary>
        <value>Larghezza di <see cref="T:System.Windows.Interop.D3DImage" /> espressa in pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> possono cambiare quando viene assegnato un nuovo buffer nascosto da una chiamata al <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> proprietà per specificare l'area modificata nel buffer nascosto. Per ulteriori informazioni, vedere [procedura dettagliata: Hosting di contenuto Direct3D9 in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelHeight" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBackBuffer">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Assegna una superficie Direct3D come origine del buffer nascosto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="backBufferType">Tipo di superficie Direct3D. Deve essere un oggetto <see cref="T:System.Windows.Interop.D3DResourceType" /> valido.</param>
        <param name="backBuffer">Superficie Direct3D da assegnare come buffer nascosto.</param>
        <summary>Assegna una superficie Direct3D come origine del buffer nascosto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodo per assegnare una superficie Direct3D al buffer nascosto.  
  
> [!NOTE]
>  Le prestazioni dipendono notevolmente le impostazioni dell'area di Direct3D. Per ulteriori informazioni, vedere [considerazioni sulle prestazioni per l'interoperabilità di WPF e Direct3D9](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  
  
 La chiamata di <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload è identica alla chiamata al metodo il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> eseguire l'overload con il `enableSoftwareFallback` parametro impostato su `false`. Quando si chiama <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> o chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> con il `enableSoftwareFallback` parametro impostato su `false`, il sistema di rendering rilascia il riferimento al buffer nascosto quando anteriore buffer non è più disponibile e viene visualizzato nulla. Quando il buffer anteriore è nuovamente disponibile, il sistema di rendering genera il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> evento per notificare all'applicazione WPF.  È possibile creare un gestore eventi per il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> riavviare il rendering con una superficie Direct3D valida dell'evento. Per riavviare il rendering, è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  
  
 L'elenco seguente mostra le impostazioni del buffer nascosto necessarie per il `IDirect3DSurface9` tipo.  
  
-   `D3DFMT_A8R8G8B8` o `D3DFMT_X8R8G8B8`  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 Il campionamento multiplo è consentito su `IDirect3DSurface9Ex` copre solo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodo per assegnare una superficie Direct3D. Per ulteriori informazioni, vedere [procedura dettagliata: Hosting di contenuto Direct3D9 in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Windows.Interop.D3DImage" /> non è stato bloccato tramite una chiamata al metodo <see cref="M:System.Windows.Interop.D3DImage.Lock" /> o <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="backBufferType" /> non è un oggetto <see cref="T:System.Windows.Interop.D3DResourceType" /> valido.</exception>
        <exception cref="T:System.ArgumentException">I parametri di creazione per <paramref name="backBuffer" /> non soddisfano i requisiti per <paramref name="backBufferType" /> o il dispositivo <paramref name="backBuffer" /> non è valido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per accedere alle risorse non gestite. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer, bool enableSoftwareFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr, enableSoftwareFallback As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
        <Parameter Name="enableSoftwareFallback" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="backBufferType">Tipo di superficie Direct3D. Deve essere un oggetto <see cref="T:System.Windows.Interop.D3DResourceType" /> valido.</param>
        <param name="backBuffer">Superficie Direct3D da assegnare come buffer nascosto.</param>
        <param name="enableSoftwareFallback">
          <see langword="true" /> per eseguire il fallback nel rendering software; in caso contrario, <see langword="false" />.</param>
        <summary>Assegna una superficie Direct3D come origine del buffer nascosto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload o chiamare il <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> eseguire l'overload con il `enableSoftwareFallback` parametro impostato su `false`, il sistema di rendering rilascia il riferimento al buffer nascosto quando il front buffer non è più disponibile e non è visualizzato. Quando il buffer anteriore è nuovamente disponibile, il sistema di rendering genera il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> evento per notificare all'applicazione WPF.  È possibile creare un gestore eventi per il <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> riavviare il rendering con una superficie Direct3D valida dell'evento. Per riavviare il rendering, è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  
  
 Quando si chiama <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> con il `enableSoftwareFallback` parametro impostato su `true`, il sistema di rendering mantiene il relativo riferimento al buffer nascosto quando il front buffer non è disponibile, in modo non è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> quando il buffer anteriore è disponibile nuovamente.  Potrebbero verificarsi situazioni in cui il dispositivo dell'utente non è più disponibile.  In questo caso, chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> per rilasciare il riferimento di WPF al buffer nascosto.  Per reimpostare il dispositivo, è necessario chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> con `backBuffer` impostato su `null`e quindi chiamare <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> con `backBuffer` impostato su una superficie Direct3D valida.  
  
 L'elenco seguente mostra le impostazioni del buffer nascosto necessarie per il `IDirect3DSurface9` tipo.  
  
-   `D3DFMT_A8R8G8B8` o `D3DFMT_X8R8G8B8`  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 Il campionamento multiplo è consentito su `IDirect3DSurface9Ex` copre solo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervallo di attesa dell'acquisizione del blocco.</param>
        <summary>Tenta di bloccare <see cref="T:System.Windows.Interop.D3DImage" /> e attende per l'intervallo specificato.</summary>
        <returns>
          <see langword="true" /> se il blocco è stato acquisito; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è impostato su <see cref="P:System.Windows.Duration.Automatic" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il conteggio dei blocchi equivale a <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Decrementa il conteggio dei blocchi per <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il conteggio dei blocchi per il <xref:System.Windows.Interop.D3DImage> raggiunge lo zero, il <xref:System.Windows.Interop.D3DImage> è completamente sbloccato. Il <xref:System.Windows.Interop.D3DImage> è contrassegnato per il rendering se l'immagine è stata modificata aree che sono state specificate tramite le precedenti chiamate al <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> metodo.  
  
 Quando vengono eseguito il commit delle modifiche e il rendering viene eseguito, eventuali chiamate aggiuntive dal <xref:System.Windows.Interop.D3DImage.Lock%2A> blocco di metodo fino a quando il thread di rendering è copiato il contenuto del buffer nascosto nel front buffer. Questa sincronizzazione è possibile evitare gli elementi di visualizzazione, ad esempio di rimozione.  
  
> [!NOTE]
>  Non aggiornare l'area di Direct3D durante il <xref:System.Windows.Interop.D3DImage> è sbloccato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare il <xref:System.Windows.Interop.D3DImage.Unlock%2A> metodo per copiare il buffer nascosto aggiornato nel front buffer. Per ulteriori informazioni, vedere [procedura dettagliata: Hosting di contenuto Direct3D9 in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public override sealed double Width { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Width" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la larghezza di <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <value>Larghezza di <see cref="T:System.Windows.Interop.D3DImage" /> espressa in unità di misura. Un'unità di misura è 1/96 di pollice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di <xref:System.Windows.Interop.D3DImage.Width%2A> possono cambiare quando viene assegnato un nuovo buffer nascosto da una chiamata al <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
  </Members>
</Type>