<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ParallelMergeOptions.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53cc52c2fdc311942111dafa5de93e39f3ca04a7b.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3cc52c2fdc311942111dafa5de93e39f3ca04a7b</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Linq.ParallelMergeOptions">
          <source>Specifies the preferred type of <bpt id="p1">*</bpt>output merge<ept id="p1">*</ept> to use in a query.</source>
          <target state="translated">Specifica il tipo di <bpt id="p1">*</bpt>output merge<ept id="p1">*</ept> preferito da usare in una query.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Linq.ParallelMergeOptions">
          <source>In other words, it indicates how PLINQ should merge the results from the various partitions back into a single result sequence.</source>
          <target state="translated">In altre parole, indica come PLINQ deve unire i risultati dalle varie partizioni in una singola sequenza di risultati.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Linq.ParallelMergeOptions">
          <source>This is a hint only, and may not be respected by the system when parallelizing all queries.</source>
          <target state="translated">Si tratta solo di un suggerimento, che potrebbe non essere rispettato dal sistema durante la parallelizzazione di tutte le query.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>Use <ph id="ph1">`NotBuffered`</ph> for queries that will be consumed and output as streams, this has the lowest latency between beginning query execution and elements being yielded.</source>
          <target state="translated">Utilizzare <ph id="ph1">`NotBuffered`</ph> per le query che verranno utilizzate e come flussi di output, questa è la più bassa latenza tra l'esecuzione di query di inizio e la restituzione degli elementi.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>For some queries, such as those involving a sort (OrderBy, OrderByDescending), buffering is essential and a hint of NotBuffered or AutoBuffered will be ignored.</source>
          <target state="translated">Per alcune query, ad esempio quelli che comportano un ordinamento (OrderBy, OrderByDescending), il buffer è essenziale e un suggerimento di NotBuffered o AutoBuffered verrà ignorato.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>However, queries that are created by using the AsOrdered operator can be streamed as long as no further sorting is performed within the query itself.</source>
          <target state="translated">Tuttavia, le query che vengono create utilizzando l'operatore AsOrdered possono essere trasmesso fino a quando nessun altro ordinamento viene eseguito all'interno della query stessa.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>Use <ph id="ph1">`AutoBuffered`</ph> for most cases; this is the default.</source>
          <target state="translated">Utilizzare <ph id="ph1">`AutoBuffered`</ph> per la maggior parte dei casi; questo è il valore predefinito.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>It strikes a balance between latency and overall performance.</source>
          <target state="translated">Fornisce un equilibrio tra la latenza e le prestazioni complessive.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>Use <ph id="ph1">`FullyBuffered`</ph> for queries when the entire output can be processed before the information is needed.</source>
          <target state="translated">Utilizzare <ph id="ph1">`FullyBuffered`</ph> per le query quando l'intero output può essere elaborato prima che siano necessarie le informazioni.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Linq.ParallelMergeOptions">
          <source>This option offers the best performance when all of the output can be accumulated before yielding any information, though it is not suitable for stream processing or showing partial results mid-query.</source>
          <target state="translated">Questa opzione offre prestazioni ottimali quando tutto l'output può essere accumulati prima di generare qualsiasi informazione, anche se non è adatto per l'elaborazione del flusso o visualizzazione parziale di risultati durante la query.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.AutoBuffered">
          <source>Use a merge with output buffers of a size chosen by the system.</source>
          <target state="translated">Utilizzare un'unione con i buffer di output di una dimensione scelta dal sistema.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.AutoBuffered">
          <source>Results will accumulate into an output buffer before they are available to the consumer of the query.</source>
          <target state="translated">I risultati verranno accumulati in un buffer di output prima di essere disponibili all'utente della query.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.Default">
          <source>Use the default merge type, which is AutoBuffered.</source>
          <target state="translated">Utilizzare il tipo di unione predefinito, ovvero AutoBuffered.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.FullyBuffered">
          <source>Use a merge with full output buffers.</source>
          <target state="translated">Utilizzare un'unione con buffer di output completi.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.FullyBuffered">
          <source>The system will accumulate all of the results before making any of them available to the consumer of the query.</source>
          <target state="translated">Tutti i risultati verranno accumulati dal sistema in un buffer di output prima di essere resi disponibili all'utente della query.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.NotBuffered">
          <source>Use a merge without output buffers.</source>
          <target state="translated">Utilizzare un'unione senza buffer di output.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Linq.ParallelMergeOptions.NotBuffered">
          <source>As soon as result elements have been computed, make that element available to the consumer of the query.</source>
          <target state="translated">Non appena gli elementi del risultato sono stati calcolati, vengono resi disponibili all'utente della query.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>