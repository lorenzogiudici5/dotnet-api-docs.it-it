<Type Name="ParallelEnumerable" FullName="System.Linq.ParallelEnumerable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4b686dbc81426d35a9770a61e48e915687e4d437" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51878074" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ParallelEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ParallelEnumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.ParallelEnumerable" />
  <TypeSignature Language="VB.NET" Value="Public Module ParallelEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ParallelEnumerable abstract sealed" />
  <TypeSignature Language="F#" Value="type ParallelEnumerable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce un set di metodi per l'esecuzione di query su oggetti che implementano ParallelQuery{TSource}. È l'equivalente parallelo di <see cref="T:System.Linq.Enumerable" />.</summary>
    <remarks>To be added.</remarks>
    <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Aggregate&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Applica in parallelo una funzione accumulatore a una sequenza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``1(System.Linq.ParallelQuery{``0},System.Func{``0,``0,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As ParallelQuery(Of TSource), func As Func(Of TSource, TSource, TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TSource, TSource&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Source, 'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Una sequenza su cui aggregare.</param>
        <param name="func">Funzione accumulatore da richiamare per ogni elemento.</param>
        <summary>Applica in parallelo una funzione accumulatore a una sequenza.</summary>
        <returns>Valore finale dell'accumulatore.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="func" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``2(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As ParallelQuery(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate)) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; -&gt; 'Accumulate" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TAccumulate">Tipo del valore dell'accumulatore.</typeparam>
        <param name="source">Una sequenza su cui aggregare.</param>
        <param name="seed">Valore iniziale dell'accumulatore.</param>
        <param name="func">Funzione accumulatore da richiamare per ogni elemento.</param>
        <summary>Applica in parallelo una funzione accumulatore a una sequenza. Il valore di inizializzazione specificato viene usato come valore iniziale dell'accumulatore.</summary>
        <returns>Valore finale dell'accumulatore.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="func" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As ParallelQuery(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seed, func, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TAccumulate">Tipo del valore dell'accumulatore.</typeparam>
        <typeparam name="TResult">Il tipo del valore risultante.</typeparam>
        <param name="source">Una sequenza su cui aggregare.</param>
        <param name="seed">Valore iniziale dell'accumulatore.</param>
        <param name="func">Funzione accumulatore da richiamare per ogni elemento.</param>
        <param name="resultSelector">Una funzione per trasformare il valore finale dell'accumulatore nel valore risultante.</param>
        <summary>Applica in parallelo una funzione accumulatore a una sequenza. Il valore di inizializzazione specificato viene usato come valore iniziale dell'accumulatore e la funzione specificata viene usata per selezionare il valore risultante.</summary>
        <returns>Il valore finale trasformato dell'accumulatore.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="func" /> o <paramref name="resultSelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TAccumulate&gt; seedFactory, Func&lt;TAccumulate,TSource,TAccumulate&gt; updateAccumulatorFunc, Func&lt;TAccumulate,TAccumulate,TAccumulate&gt; combineAccumulatorsFunc, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TAccumulate&gt; seedFactory, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; updateAccumulatorFunc, class System.Func`3&lt;!!TAccumulate, !!TAccumulate, !!TAccumulate&gt; combineAccumulatorsFunc, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},System.Func{``1},System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As ParallelQuery(Of TSource), seedFactory As Func(Of TAccumulate), updateAccumulatorFunc As Func(Of TAccumulate, TSource, TAccumulate), combineAccumulatorsFunc As Func(Of TAccumulate, TAccumulate, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TAccumulate&gt; ^ seedFactory, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ updateAccumulatorFunc, Func&lt;TAccumulate, TAccumulate, TAccumulate&gt; ^ combineAccumulatorsFunc, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Accumulate&gt; * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Accumulate, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seedFactory, updateAccumulatorFunc, combineAccumulatorsFunc, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seedFactory" Type="System.Func&lt;TAccumulate&gt;" />
        <Parameter Name="updateAccumulatorFunc" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="combineAccumulatorsFunc" Type="System.Func&lt;TAccumulate,TAccumulate,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TAccumulate">Tipo del valore dell'accumulatore.</typeparam>
        <typeparam name="TResult">Il tipo del valore risultante.</typeparam>
        <param name="source">Una sequenza su cui aggregare.</param>
        <param name="seedFactory">Funzione che restituisce il valore iniziale dell'accumulatore.</param>
        <param name="updateAccumulatorFunc">Funzione accumulatore da richiamare su ogni elemento in una partizione.</param>
        <param name="combineAccumulatorsFunc">Funzione accumulatore da richiamare sul risultato dell'accumulatore prodotto da ogni partizione.</param>
        <param name="resultSelector">Una funzione per trasformare il valore finale dell'accumulatore nel valore risultante.</param>
        <summary>Applica in parallelo una funzione accumulatore a una sequenza. Questo overload non è disponibile nell'implementazione sequenziale.</summary>
        <returns>Il valore finale trasformato dell'accumulatore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è specifico per le query eseguita in parallelo. Una query eseguita in parallelo potrebbe partizionare la sequenza di origine dati in più sottosequenze (partizioni). Il `updateAccumulatorFunc` viene richiamata su ogni elemento all'interno di partizioni. Ogni partizione restituisce quindi un singolo risultato accumulato. Il `combineAccumulatorsFunc` viene quindi richiamata sui risultati di ogni partizione per produrre un singolo elemento. Questo elemento viene quindi trasformato dal `resultSelector` (funzione).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="seedFactory" /> o <paramref name="updateAccumulatorFunc" /> o <paramref name="combineAccumulatorsFunc" /> o <paramref name="resultSelector" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; updateAccumulatorFunc, Func&lt;TAccumulate,TAccumulate,TAccumulate&gt; combineAccumulatorsFunc, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; updateAccumulatorFunc, class System.Func`3&lt;!!TAccumulate, !!TAccumulate, !!TAccumulate&gt; combineAccumulatorsFunc, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As ParallelQuery(Of TSource), seed As TAccumulate, updateAccumulatorFunc As Func(Of TAccumulate, TSource, TAccumulate), combineAccumulatorsFunc As Func(Of TAccumulate, TAccumulate, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ updateAccumulatorFunc, Func&lt;TAccumulate, TAccumulate, TAccumulate&gt; ^ combineAccumulatorsFunc, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Accumulate, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seed, updateAccumulatorFunc, combineAccumulatorsFunc, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="updateAccumulatorFunc" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="combineAccumulatorsFunc" Type="System.Func&lt;TAccumulate,TAccumulate,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TAccumulate">Tipo del valore dell'accumulatore.</typeparam>
        <typeparam name="TResult">Il tipo del valore risultante.</typeparam>
        <param name="source">Una sequenza su cui aggregare.</param>
        <param name="seed">Valore iniziale dell'accumulatore.</param>
        <param name="updateAccumulatorFunc">Funzione accumulatore da richiamare su ogni elemento in una partizione.</param>
        <param name="combineAccumulatorsFunc">Funzione accumulatore da richiamare sul risultato dell'accumulatore prodotto da ogni partizione.</param>
        <param name="resultSelector">Una funzione per trasformare il valore finale dell'accumulatore nel valore risultante.</param>
        <summary>Applica in parallelo una funzione accumulatore a una sequenza. Questo overload non è disponibile nell'implementazione sequenziale.</summary>
        <returns>Il valore finale trasformato dell'accumulatore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è specifico per l'elaborazione di una query eseguita in parallelo. Una query eseguita in parallelo potrebbe partizionare la sequenza di origine dati in più sottosequenze (partizioni). Il `updateAccumulatorFunc` viene richiamata su ogni elemento all'interno di partizioni. Ogni partizione restituisce quindi un singolo risultato accumulato. Il `combineAccumulatorsFunc` viene quindi richiamata sui risultati di ogni partizione per produrre un singolo elemento. Questo elemento viene quindi trasformato dal `resultSelector` (funzione).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="updateAccumulatorFunc" /> o <paramref name="combineAccumulatorsFunc" /> o <paramref name="resultSelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.All``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza ai cui elementi applicare il predicato.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Determina in parallelo se tutti gli elementi di una sequenza soddisfano una condizione.</summary>
        <returns>True se ogni elemento della sequenza di origine supera il test per il predicato specificato o se la sequenza è vuota; in caso contrario, false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se una sequenza parallela contiene elementi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As ParallelQuery(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di cui verificare il contenuto.</param>
        <summary>Determina se una sequenza parallela contiene elementi.</summary>
        <returns>È true se la sequenza di origine contiene elementi; in caso contrario, false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo Any provoca un merge completamente memorizzato nel buffer deve essere eseguita prima che venga restituito il risultato. Il comportamento di unione può influire sulle prestazioni o provocare un'eccezione di memoria nei tipi enumerabili. Per evitare il comportamento di unione, usare l'overload di qualsiasi che accetta un parametro di Func, altrimenti usare un metodo alternativo, ad esempio FirstOrDefault.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza ai cui elementi sarà applicato il predicato.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Determina in parallelo se un elemento di una sequenza soddisfa una condizione.</summary>
        <returns>È true se un qualsiasi elemento nella sequenza di origine supera il test nel predicato specificato; in caso contrario, false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsEnumerable``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsEnumerable(Of TSource) (source As ParallelQuery(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ AsEnumerable(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsEnumerable : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsEnumerable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza di cui eseguire il cast come oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Converte un oggetto <see cref="T:System.Linq.ParallelQuery`1" /> in <see cref="T:System.Collections.Generic.IEnumerable`1" /> per forzare la valutazione sequenziale della query.</summary>
        <returns>Sequenza di input digitata come oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsOrdered">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery AsOrdered (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery AsOrdered(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsOrdered(System.Linq.ParallelQuery)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsOrdered (source As ParallelQuery) As ParallelQuery" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery ^ AsOrdered(System::Linq::ParallelQuery ^ source);" />
      <MemberSignature Language="F#" Value="static member AsOrdered : System.Linq.ParallelQuery -&gt; System.Linq.ParallelQuery" Usage="System.Linq.ParallelEnumerable.AsOrdered source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di input.</param>
        <summary>Consente di trattare un'origine dati come se fosse ordinata, eseguendo l'override dell'impostazione predefinita non ordinata. AsOrdered può essere richiamato solo in sequenze non generiche restituite da AsParallel, ParallelEnumerable.Range e ParallelEnumerable.Repeat.</summary>
        <returns>Sequenza di origine che manterrà l'ordine originale nei successivi operatori di query.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esiste una tensione naturale tra prestazioni e il mantenimento dell'ordine di elaborazione parallela. Per impostazione predefinita, una query eseguita in parallelo si comporta come se l'ordinamento dei risultati è arbitrario a meno che non AsOrdered viene applicato o è un operatore OrderBy esplicito nella query. Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">generata se <paramref name="source" /> non contiene elementi 
oppure 
se AsOrdered viene chiamato a metà percorso tramite una query. Può essere chiamato immediatamente dopo <see cref="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)" />, <see cref="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)" /> o <see cref="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsOrdered&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsOrdered&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsOrdered&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsOrdered``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsOrdered(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsOrdered(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsOrdered : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsOrdered source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di input.</param>
        <summary>Consente di trattare un'origine dati come se fosse ordinata, eseguendo l'override dell'impostazione predefinita non ordinata. AsOrdered può essere richiamato solo in sequenze generiche restituite da AsParallel, ParallelEnumerable.Range e ParallelEnumerable.Repeat.</summary>
        <returns>Sequenza di origine che manterrà l'ordine originale nei successivi operatori di query.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esiste una tensione naturale tra prestazioni e il mantenimento dell'ordine di elaborazione parallela. Per impostazione predefinita, una query eseguita in parallelo si comporta come se l'ordinamento dei risultati è arbitrario a meno che non AsOrdered viene applicato o è un operatore OrderBy esplicito nella query. Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Generata se <paramref name="source" /> non contiene elementi 
oppure 
se <paramref name="source" /> non è AsParallel, ParallelEnumerable.Range o ParallelEnumerable.Repeat.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AsParallel">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Consente la parallelizzazione di una query.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo associa la query di PLINQ. Per altre informazioni, vedere [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AsParallel">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery AsParallel (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery AsParallel(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsParallel (source As IEnumerable) As ParallelQuery" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery ^ AsParallel(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member AsParallel : System.Collections.IEnumerable -&gt; System.Linq.ParallelQuery" Usage="System.Linq.ParallelEnumerable.AsParallel source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> da convertire in <see cref="T:System.Linq.ParallelQuery" />.</param>
        <summary>Consente la parallelizzazione di una query.</summary>
        <returns>Origine come ParallelQuery da associare ai metodi di estensione ParallelEnumerable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Linq.ParallelEnumerable.Cast%2A> operatore può essere utilizzato per convertire un oggetto ParallelQuery in una ParallelQuery (t).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsParallel&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsParallel&lt;TSource&gt; (this System.Collections.Concurrent.Partitioner&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsParallel&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Concurrent.Partitioner{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsParallel(Of TSource) (source As Partitioner(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsParallel(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsParallel : System.Collections.Concurrent.Partitioner&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsParallel source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Partitioner sulla sequenza di input.</param>
        <summary>Consente la parallelizzazione di una query, come viene originata da un partitioner che è responsabile della suddivisione della sequenza di input in partizioni.</summary>
        <returns>Elemento <paramref name="source" /> come ParallelQuery da associare ai metodi di estensione ParallelEnumerable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetOrderedPartitions del partitioner origine metodo viene utilizzato quando l'ordinamento è abilitata, mentre l'oggetto GetPartitions del partitioner viene usato se l'ordinamento non è abilitata (impostazione predefinita). Gli oggetti GetDynamicPartitions e GetDynamicOrderedPartitions il partitioner di origine non vengono utilizzati. Per altre informazioni ed esempi, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsParallel&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsParallel&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsParallel&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsParallel(Of TSource) (source As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsParallel(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsParallel : seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsParallel source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> da convertire in <see cref="T:System.Linq.ParallelQuery`1" />.</param>
        <summary>Consente la parallelizzazione di una query.</summary>
        <returns>Origine come <see cref="T:System.Linq.ParallelQuery`1" /> da associare ai metodi di estensione ParallelEnumerable.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsSequential&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsSequential&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsSequential&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsSequential``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSequential(Of TSource) (source As ParallelQuery(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ AsSequential(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsSequential : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsSequential source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Oggetto <see cref="T:System.Linq.ParallelQuery`1" /> da convertire in <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Converte un oggetto <see cref="T:System.Linq.ParallelQuery`1" /> in <see cref="T:System.Collections.Generic.IEnumerable`1" /> per forzare la valutazione sequenziale della query.</summary>
        <returns>Origine come <see cref="T:System.Collections.Generic.IEnumerable`1" /> da associare ai metodi di estensione sequenziale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni, vedere [conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md) e [procedura: controllare l'ordinamento in una Query PLINQ](~/docs/standard/parallel-programming/how-to-control-ordering-in-a-plinq-query.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsUnordered&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsUnordered&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsUnordered&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsUnordered``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsUnordered(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsUnordered(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsUnordered : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsUnordered source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di input.</param>
        <summary>Consente di trattare una query intermedia come se non vi fosse alcun ordinamento implicito tra gli elementi.</summary>
        <returns>Sequenza di origine con ordine arbitrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 AsUnordered può offrire vantaggi sulle prestazioni durante l'ordinamento non è richiesto in una parte di una query. Per impostazione predefinita, PLINQ considerati una sequenza di input non ordinato se non si specifica AsOrdered o OrderBy. Tuttavia, se ordinamento è stata attivata ed non è più necessario, quindi AsUnordered può essere utilizzato per disattivare tale funzionalità durante la query e questo può comportare vantaggi nelle prestazioni. L'operatore AsUnordered non riprodurre in modo casuale la sequenza di origine; ma rimuove semplicemente il requisito di ordinamento per gli operatori successivi. Se l'origine è ordinata, gli operatori successivi potrebbero mantenere tale ordinamento se è più efficiente per eseguire questa operazione. AsUnordered può essere chiamato in un punto qualsiasi nella query. non dovrà essere chiamato immediatamente dopo AsParallel. Per altre informazioni, vedere [Understanding aumento di velocità in PLINQ](~/docs/standard/parallel-programming/understanding-speedup-in-plinq.md) e [conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;int&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma o il conteggio degli elementi della sequenza è superiore a <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;int64&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma o il conteggio degli elementi della sequenza è superiore a <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di origine.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <returns>Restituisce la media della sequenza di valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">Sequenza di valori usati per calcolare una media. La media della sequenza di valori.<paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma o il conteggio degli elementi della sequenza è superiore a <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma o il conteggio degli elementi della sequenza è superiore a <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <exception cref="T:System.OverflowException">Generata come eccezione interna in <see cref="T:System.AggregateException" />. La funzione <paramref name="selector" /> restituisce un valore maggiore di MaxValue per il tipo di elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <exception cref="T:System.OverflowException">Generata come eccezione interna in <see cref="T:System.AggregateException" />. La funzione <paramref name="selector" /> restituisce un valore maggiore di MaxValue per il tipo di elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma o il conteggio degli elementi della sequenza è superiore a <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <exception cref="T:System.OverflowException">Generata come eccezione interna in <see cref="T:System.AggregateException" />. La funzione <paramref name="selector" /> restituisce un valore maggiore di MaxValue per il tipo di elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma o il conteggio degli elementi della sequenza è superiore a <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <exception cref="T:System.OverflowException">Generata come eccezione interna in <see cref="T:System.AggregateException" />. La funzione <paramref name="selector" /> restituisce un valore maggiore di MaxValue per il tipo di elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <exception cref="T:System.OverflowException">Generata come eccezione interna in <see cref="T:System.AggregateException" />. La funzione <paramref name="selector" /> restituisce un valore maggiore di MaxValue per il tipo di elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <exception cref="T:System.OverflowException">Generata come eccezione interna in <see cref="T:System.AggregateException" />. La funzione <paramref name="selector" /> restituisce un valore maggiore di MaxValue per il tipo di elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma o il conteggio degli elementi della sequenza è superiore a <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <exception cref="T:System.OverflowException">Generata come eccezione interna in <see cref="T:System.AggregateException" />. La funzione <paramref name="selector" /> restituisce un valore maggiore di MaxValue per il tipo di elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma o il conteggio degli elementi della sequenza è superiore a <see cref="F:System.Int64.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <exception cref="T:System.OverflowException">Generata come eccezione interna in <see cref="T:System.AggregateException" />. La funzione <paramref name="selector" /> restituisce un valore maggiore di MaxValue per il tipo di elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <exception cref="T:System.OverflowException">Generata come eccezione interna in <see cref="T:System.AggregateException" />. La funzione <paramref name="selector" /> restituisce un valore maggiore di MaxValue per il tipo di elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Una sequenza di valori usata per calcolare una media.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la media di una sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Media della sequenza dei valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <exception cref="T:System.OverflowException">Generata come eccezione interna in <see cref="T:System.AggregateException" />. La funzione <paramref name="selector" /> restituisce un valore maggiore di MaxValue per il tipo di elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Cast``1(System.Linq.ParallelQuery)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As ParallelQuery) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Cast(System::Linq::ParallelQuery ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Linq.ParallelQuery -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo in cui convertire gli elementi della <c>origine</c> per.</typeparam>
        <param name="source">Sequenza che contiene gli elementi da convertire.</param>
        <summary>Converte gli elementi di un oggetto ParallelQuery nel tipo specificato.</summary>
        <returns>Sequenza che contiene ogni elemento della sequenza di origine convertito nel tipo specificato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.InvalidCastException">Il tipo di sequenza di origine potrebbe non essere convertito a <paramref name="TResult" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena due sequenze parallele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Concat(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Concat : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Concat (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Questo parametro di tipo non viene usato.</typeparam>
        <param name="first">Questo parametro non viene usato.</param>
        <param name="second">Questo parametro non viene usato.</param>
        <summary>Questo overload di Concat non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è presente per impedire l'utilizzo di Concat con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore di Concat verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eccezione che si verifica quando viene chiamato questo metodo.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Concat(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Concat : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Concat (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi delle sequenze di input.</typeparam>
        <param name="first">Prima sequenza da concatenare.</param>
        <param name="second">Sequenza da concatenare alla prima sequenza.</param>
        <summary>Concatena due sequenze parallele.</summary>
        <returns>Sequenza che contiene gli elementi concatenati delle due sequenze di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> o <paramref name="second" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Consente di stabilire in parallelo se una sequenza contiene un elemento specifico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.ParallelQuery{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As ParallelQuery(Of TSource), value As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TSource value);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.ParallelQuery&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.ParallelEnumerable.Contains (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza in cui individuare un valore.</param>
        <param name="value">Valore da individuare nella sequenza .</param>
        <summary>Determina in parallelo se una sequenza contiene un elemento specificato usando l'operatore di confronto di uguaglianza predefinito.</summary>
        <returns>È true se la sequenza di origine contiene un elemento con il valore specificato; in caso contrario, false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.ParallelQuery{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As ParallelQuery(Of TSource), value As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TSource value, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.ParallelQuery&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.Contains (source, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza in cui individuare un valore.</param>
        <param name="value">Valore da individuare nella sequenza .</param>
        <param name="comparer">Operatore di confronto uguaglianze per confrontare valori.</param>
        <summary>Determina in parallelo se una sequenza contiene un elemento specificato usando un oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> specificato.</summary>
        <returns>È true se la sequenza di origine contiene un elemento con il valore specificato; in caso contrario, false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il numero di elementi in una sequenza parallela.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As ParallelQuery(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza che contiene gli elementi da contare.</param>
        <summary>Restituisce il numero di elementi in una sequenza parallela.</summary>
        <returns>Numero di elementi nella sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Il numero di elementi nel database di origine è maggiore di <see cref="F:System.Int32.MaxValue" />. (In questo caso l'InnerException è <see cref="T:System.OverflowException" />) oppure si sono verificate una o più eccezioni durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza che contiene gli elementi da contare.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Restituisce un valore che rappresenta il numero di elementi nella sequenza parallela specificata che soddisfano una condizione.</summary>
        <returns>Numero che rappresenta quanti elementi nella sequenza specificata soddisfano la condizione nella funzione predicato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Il numero di elementi nel database di origine è maggiore di <see cref="F:System.Int32.MaxValue" />. (In questo caso l'InnerException è <see cref="T:System.OverflowException" />) oppure si sono verificate una o più eccezioni durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce gli elementi della sequenza parallela specificata o il valore specificato in una raccolta singleton se la sequenza è vuota.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza per cui restituire un valore predefinito se è vuota.</param>
        <summary>Restituisce gli elementi della sequenza parallela specificata o il valore predefinito del parametro di tipo in una raccolta singleton se la sequenza è vuota.</summary>
        <returns>Sequenza che contiene default(TSource) se <paramref name="source" /> è vuoto; in caso contrario, <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.ParallelQuery{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As ParallelQuery(Of TSource), defaultValue As TSource) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.ParallelQuery&lt;'Source&gt; * 'Source -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza per cui restituire il valore specificato se è vuota.</param>
        <param name="defaultValue">Valore da restituire se la sequenza è vuota.</param>
        <summary>Restituisce gli elementi della sequenza parallela specificata o il valore specificato in una raccolta singleton se la sequenza è vuota.</summary>
        <returns>Sequenza che contiene defaultValue se <paramref name="source" /> è vuoto; in caso contrario, <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce elementi distinti da una sequenza parallela usando l'operatore di confronto di uguaglianza predefinito per confrontare i valori.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Distinct(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza da cui rimuovere elementi duplicati.</param>
        <summary>Restituisce elementi distinti da una sequenza parallela usando l'operatore di confronto di uguaglianza predefinito per confrontare i valori.</summary>
        <returns>Sequenza che contiene elementi distinti dalla sequenza di origine.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Distinct(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza da cui rimuovere elementi duplicati.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per confrontare i valori.</param>
        <summary>Restituisce elementi distinti da una sequenza parallela usando un oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> specificato per confrontare valori.</summary>
        <returns>Sequenza che contiene elementi distinti dalla sequenza di origine.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ElementAt``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As ParallelQuery(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale viene restituito un elemento.</param>
        <param name="index">Indice in base zero dell'elemento da recuperare.</param>
        <summary>Restituisce l'elemento in corrispondenza dell'indice specificato in una sequenza parallela.</summary>
        <returns>L'elemento alla posizione specificata nella sequenza di origine.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0 oppure maggiore o uguale al numero di elementi di <paramref name="source" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ElementAtOrDefault``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As ParallelQuery(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale viene restituito un elemento.</param>
        <param name="index">Indice in base zero dell'elemento da recuperare.</param>
        <summary>Restituisce l'elemento in corrispondenza di un indice specificato in una sequenza parallela o un valore predefinito se l'indice non è incluso nell'intervallo.</summary>
        <returns>default(TSource) se l'indice è esterno ai limiti della sequenza di origine; in caso contrario, l'elemento in corrispondenza della posizione specificata nella sequenza di origine.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Function Empty(Of TResult) () As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">Tipo da assegnare al parametro di tipo della sequenza generica restituita.</typeparam>
        <summary>Restituisce un oggetto ParallelQuery{TResult} vuoto con l'argomento tipo specificato.</summary>
        <returns>Sequenza vuota il cui argomento tipo è <paramref name="TResult" />.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produce la differenza insiemistica di due sequenze parallele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Questo parametro di tipo non viene usato.</typeparam>
        <param name="first">Questo parametro non viene usato.</param>
        <param name="second">Questo parametro non viene usato.</param>
        <summary>Questo overload di Except non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esiste, per impedire l'utilizzo di questo overload tranne che con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore Except verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eccezione che si verifica quando viene chiamato questo metodo.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi delle sequenze di input.</typeparam>
        <param name="first">Verrà restituita una sequenza i cui elementi non si trovano anche in <c>second</c>.</param>
        <param name="second">Sequenza i cui elementi, se presenti anche nella prima sequenza, saranno rimossi dalla sequenza restituita.</param>
        <summary>Produce la differenza di set di due sequenze parallele usando l'operatore di confronto di uguaglianza predefinito per confrontare i valori.</summary>
        <returns>Sequenza che contiene la differenza insiemistica degli elementi delle due sequenze.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> o <paramref name="second" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Questo parametro di tipo non viene usato.</typeparam>
        <param name="first">Questo parametro non viene usato.</param>
        <param name="second">Questo parametro non viene usato.</param>
        <param name="comparer">Questo parametro non viene usato.</param>
        <summary>Questo overload di Except non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esiste, per impedire l'utilizzo di questo overload tranne che con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore Except verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eccezione che si verifica quando viene chiamato questo metodo.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi delle sequenze di input.</typeparam>
        <param name="first">Verrà restituita una sequenza i cui elementi non si trovano anche in <c>second</c>.</param>
        <param name="second">Sequenza i cui elementi, se presenti anche nella prima sequenza, saranno rimossi dalla sequenza restituita.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per confrontare i valori.</param>
        <summary>Produce la differenza di set di due sequenze parallele usando l'oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> specificato per confrontare i valori.</summary>
        <returns>Sequenza che contiene la differenza insiemistica degli elementi delle due sequenze.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> o <paramref name="second" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il primo elemento di una sequenza parallela.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.First``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza di cui restituire il primo elemento.</param>
        <summary>Restituisce il primo elemento di una sequenza parallela.</summary>
        <returns>Il primo elemento nella sequenza specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la query non viene ordinata, il primo elemento è non deterministico. Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.First``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale viene restituito un elemento.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Restituisce il primo elemento in una sequenza parallela che soddisfa una condizione specificata.</summary>
        <returns>Il primo elemento nella sequenza che supera il test nella funzione predicato specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la query non viene ordinata, il primo elemento è non deterministico. Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">Nessun elemento in <paramref name="source" /> soddisfa la condizione in <paramref name="predicate" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il primo elemento di una sequenza parallela o un valore predefinito se la sequenza non contiene elementi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza di cui restituire il primo elemento.</param>
        <summary>Restituisce il primo elemento di una sequenza parallela o un valore predefinito se la sequenza non contiene elementi.</summary>
        <returns>default(TSource) se <paramref name="source" /> è vuoto; in caso contrario, il primo elemento di <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la query non viene ordinata, il primo elemento è non deterministico. Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale viene restituito un elemento.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Restituisce il primo elemento della sequenza parallela che soddisfa una condizione o un valore predefinito se un tale elemento non viene trovato.</summary>
        <returns>default(TSource) se <paramref name="source" /> è vuoto o se nessun elemento supera il test specificato dal predicato; in caso contrario, il primo elemento di <paramref name="source" /> che supera il test specificato dal predicato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la query non viene ordinata, il primo elemento è non deterministico. Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static void ForAll&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Action&lt;TSource&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForAll&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ForAll``1(System.Linq.ParallelQuery{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ForAll(Of TSource) (source As ParallelQuery(Of TSource), action As Action(Of TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void ForAll(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForAll : System.Linq.ParallelQuery&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; unit" Usage="System.Linq.ParallelEnumerable.ForAll (source, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="action" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Elemento <see cref="T:System.Linq.ParallelQuery`1" /> i cui elementi verranno elaborati da <c>action</c>.</param>
        <param name="action">Elemento Action da richiamare su ogni elemento.</param>
        <summary>Richiama in parallelo l'azione specificata per ogni elemento in <paramref name="source" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo è un modo efficiente per elaborare l'output da una query eseguita in parallelo poiché non richiede un passaggio di tipo merge alla fine. Per altre informazioni, vedere [opzioni di Merge in PLINQ](~/docs/standard/parallel-programming/merge-options-in-plinq.md) oppure [conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md). Poiché questo metodo produce un effetto collaterale, può essere utilizzato per osservare l'effettivo ordine di esecuzione in una query parallela.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raggruppa in parallelo gli elementi di una sequenza secondo una funzione selettore di chiave.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As ParallelQuery(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Oggetto OrderedParallelQuery{TSource} che contiene elementi da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <summary>Raggruppa in parallelo gli elementi di una sequenza secondo una funzione selettore di chiave specificata.</summary>
        <returns>Sequenza di gruppi in ordine decrescente sulla base di <paramref name="TKey" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>&gt;.</typeparam>
        <param name="source">Oggetto <see cref="T:System.Linq.OrderedParallelQuery`1" /> che contiene gli elementi da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IComparer`1" /> per confrontare le chiavi.</param>
        <summary>Raggruppa in parallelo gli elementi di una sequenza secondo una funzione selettore di chiave specificata e confronta le chiavi usando un oggetto <see cref="T:System.Collections.Generic.IComparer`1" /> specificato.</summary>
        <returns>Sequenza di gruppi in ordine decrescente sulla base di <paramref name="TKey" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As ParallelQuery(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Tipo degli elementi contenuti nell'oggetto <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Oggetto <see cref="T:System.Linq.OrderedParallelQuery`1" /> che contiene gli elementi da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <param name="elementSelector">Funzione per eseguire il mapping di ogni elemento di origine a un elemento in un oggetto <see cref="T:System.Linq.IGrouping`2" />.</param>
        <summary>Raggruppa in parallelo gli elementi di una sequenza in base a una funzione selettore di chiave specificata e proietta gli elementi di ogni gruppo usando una funzione specificata.</summary>
        <returns>Sequenza di gruppi in ordine decrescente sulla base di <paramref name="TKey" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Tipo degli elementi contenuti in IGrouping.</typeparam>
        <param name="source">Oggetto OrderedParallelQuery{TSource} che contiene elementi da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <param name="elementSelector">Funzione per eseguire il mapping di ogni elemento di origine a un elemento di IGrouping.</param>
        <param name="comparer">Oggetto IComparer{TSource} per confrontare le chiavi.</param>
        <summary>Raggruppa in parallelo gli elementi di una sequenza secondo una funzione selettore di chiave. Le chiavi vengono confrontate usando un operatore di confronto e gli elementi di ogni gruppo vengono proiettati usando una funzione specificata.</summary>
        <returns>Sequenza di gruppi in ordine decrescente sulla base di <paramref name="TKey" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <typeparam name="TResult">Il tipo di valore restituito da <c>resultSelector</c>.</typeparam>
        <param name="source">Sequenza di cui raggruppare gli elementi.</param>
        <param name="keySelector">Funzione per estrarre la chiave per ogni elemento.</param>
        <param name="resultSelector">Funzione per creare un valore di risultato da ogni gruppo.</param>
        <summary>Raggruppa in parallelo gli elementi di una sequenza in base a una funzione selettore di chiave specificata e crea un valore risultante da ciascun gruppo e relativa chiave.</summary>
        <returns>Sequenza di elementi di tipo <paramref name="TResult" /> dove ogni elemento rappresenta una proiezione su un gruppo e sulla relativa chiave.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <typeparam name="TResult">Il tipo di valore restituito da <c>resultSelector</c>.</typeparam>
        <param name="source">Sequenza di cui raggruppare gli elementi.</param>
        <param name="keySelector">Funzione per estrarre la chiave per ogni elemento.</param>
        <param name="resultSelector">Funzione per creare un valore di risultato da ogni gruppo.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per confrontare le chiavi.</param>
        <summary>Raggruppa in parallelo gli elementi di una sequenza in base a una funzione selettore di chiave specificata e crea un valore risultante da ciascun gruppo e relativa chiave. Le chiavi vengono confrontati usando un operatore di confronto specificato.</summary>
        <returns>Sequenza di gruppi.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Tipo degli elementi in ogni IGrouping{TKey, TElement}.</typeparam>
        <typeparam name="TResult">Il tipo di valore restituito da <c>resultSelector</c>.</typeparam>
        <param name="source">Sequenza di cui raggruppare gli elementi.</param>
        <param name="keySelector">Funzione per estrarre la chiave per ogni elemento.</param>
        <param name="elementSelector">Funzione per eseguire il mapping di ogni elemento di origine a un elemento di IGrouping&lt;TKey, TElement&gt;.</param>
        <param name="resultSelector">Funzione per creare un valore di risultato da ogni gruppo.</param>
        <summary>Raggruppa in parallelo gli elementi di una sequenza in base a una funzione selettore di chiave specificata e crea un valore risultante da ciascun gruppo e relativa chiave. Gli elementi di ogni gruppo vengono proiettati usando una funzione specificata.</summary>
        <returns>Sequenza di elementi di tipo <paramref name="TResult" /> dove ogni elemento rappresenta una proiezione su un gruppo e sulla relativa chiave.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Tipo degli elementi in ogni IGrouping{TKey, TElement}.</typeparam>
        <typeparam name="TResult">Il tipo di valore restituito da <c>resultSelector</c>.</typeparam>
        <param name="source">Sequenza di cui raggruppare gli elementi.</param>
        <param name="keySelector">Funzione per estrarre la chiave per ogni elemento.</param>
        <param name="elementSelector">Funzione per eseguire il mapping di ogni elemento di origine a un elemento di IGrouping{Key, TElement}.</param>
        <param name="resultSelector">Funzione per creare un valore di risultato da ogni gruppo.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per confrontare le chiavi.</param>
        <summary>Raggruppa gli elementi di una sequenza in base a una funzione del selettore principale specificata e crea un valore risultante da ciascun gruppo e relativa chiave. I valori delle chiavi vengono confrontati usando un operatore di confronto specificato e gli elementi di ogni gruppo vengono proiettati usando una funzione specificata.</summary>
        <returns>Sequenza di elementi di tipo <paramref name="TResult" /> dove ogni elemento rappresenta una proiezione su un gruppo e sulla relativa chiave.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Correla in parallelo gli elementi di due sequenze in base all'uguaglianza delle chiavi e raggruppa i risultati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TInner">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TKey">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TResult">Questo parametro di tipo non viene usato.</typeparam>
        <param name="outer">Questo parametro non viene usato.</param>
        <param name="inner">Questo parametro non viene usato.</param>
        <param name="outerKeySelector">Questo parametro non viene usato.</param>
        <param name="innerKeySelector">Questo parametro non viene usato.</param>
        <param name="resultSelector">Questo parametro non viene usato.</param>
        <summary>Questo overload di GroupJoin non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è presente per impedire l'utilizzo di GroupJoin con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore di GroupJoin verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Tipo degli elementi della prima sequenza.</typeparam>
        <typeparam name="TInner">Tipo degli elementi della seconda sequenza.</typeparam>
        <typeparam name="TKey">Tipo delle chiavi restituite dalle funzioni del selettore principale.</typeparam>
        <typeparam name="TResult">Tipo degli elementi di risultato.</typeparam>
        <param name="outer">Prima sequenza da unire.</param>
        <param name="inner">Sequenza da unire alla prima sequenza.</param>
        <param name="outerKeySelector">Funzione per estrarre la chiave di aggiunta da ogni elemento della prima sequenza.</param>
        <param name="innerKeySelector">Funzione per estrarre la chiave di aggiunta da ogni elemento della seconda sequenza.</param>
        <param name="resultSelector">Funzione per creare un elemento di risultato da un elemento dalla prima sequenza e una raccolta di elementi corrispondenti dalla seconda sequenza.</param>
        <summary>Correla in parallelo gli elementi di due sequenze in base all'uguaglianza delle chiavi e raggruppa i risultati. Per confrontare le chiavi viene usato l'operatore di confronto uguaglianze predefinito.</summary>
        <returns>Sequenza che contiene elementi di tipo <paramref name="TResult" /> ottenuti eseguendo un join raggruppato di due sequenze.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TInner">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TKey">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TResult">Questo parametro di tipo non viene usato.</typeparam>
        <param name="outer">Questo parametro non viene usato.</param>
        <param name="inner">Questo parametro non viene usato.</param>
        <param name="outerKeySelector">Questo parametro non viene usato.</param>
        <param name="innerKeySelector">Questo parametro non viene usato.</param>
        <param name="resultSelector">Questo parametro non viene usato.</param>
        <param name="comparer">Questo parametro non viene usato.</param>
        <summary>Questo overload di GroupJoin non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è presente per impedire l'utilizzo di GroupJoin con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore di GroupJoin verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eccezione che si verifica quando viene chiamato questo metodo.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Tipo degli elementi della prima sequenza.</typeparam>
        <typeparam name="TInner">Tipo degli elementi della seconda sequenza.</typeparam>
        <typeparam name="TKey">Tipo delle chiavi restituite dalle funzioni del selettore principale.</typeparam>
        <typeparam name="TResult">Tipo degli elementi di risultato.</typeparam>
        <param name="outer">Prima sequenza da unire.</param>
        <param name="inner">Sequenza da unire alla prima sequenza.</param>
        <param name="outerKeySelector">Funzione per estrarre la chiave di aggiunta da ogni elemento della prima sequenza.</param>
        <param name="innerKeySelector">Funzione per estrarre la chiave di aggiunta da ogni elemento della seconda sequenza.</param>
        <param name="resultSelector">Funzione per creare un elemento di risultato da un elemento dalla prima sequenza e una raccolta di elementi corrispondenti dalla seconda sequenza.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per la codifica hash e il confronto delle chiavi.</param>
        <summary>Correla in parallelo gli elementi di due sequenze in base all'uguaglianza delle chiavi e raggruppa i risultati. Per confrontare le chiavi, viene usato un oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> specificato.</summary>
        <returns>Sequenza che contiene elementi di tipo <paramref name="TResult" /> ottenuti eseguendo un join raggruppato di due sequenze.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produce l'intersezione insiemistica delle due sequenze parallele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Questo parametro di tipo non viene usato.</typeparam>
        <param name="first">Questo parametro non viene usato.</param>
        <param name="second">Questo parametro non viene usato.</param>
        <summary>Questo overload di Intersect non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è presente per impedire l'utilizzo di intersezione con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore Intersect verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eccezione che si verifica quando viene chiamato questo metodo.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi delle sequenze di input.</typeparam>
        <param name="first">Sequenza di cui vengono restituiti gli elementi distinti presenti anche in <c>second</c>.</param>
        <param name="second">Sequenza di cui vengono restituiti gli elementi distinti presenti anche nella prima sequenza.</param>
        <summary>Produce l'intersezione di set di due sequenze parallele usando l'operatore di confronto di uguaglianza predefinito per confrontare i valori.</summary>
        <returns>Sequenza che contiene gli elementi che formano l'intersezione insiemistica delle due sequenze.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Questo parametro di tipo non viene usato.</typeparam>
        <param name="first">Questo parametro non viene usato.</param>
        <param name="second">Questo parametro non viene usato.</param>
        <param name="comparer">Questo parametro non viene usato.</param>
        <summary>Questo overload di Intersect non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è presente per impedire l'utilizzo di intersezione con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore Intersect verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eccezione che si verifica quando viene chiamato questo metodo.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi delle sequenze di input.</typeparam>
        <param name="first">Sequenza di cui vengono restituiti gli elementi distinti presenti anche in <c>second</c>.</param>
        <param name="second">Sequenza di cui vengono restituiti gli elementi distinti presenti anche nella prima sequenza.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per confrontare i valori.</param>
        <summary>Produce l'intersezione di set di due sequenze parallele usando l'oggetto IEqualityComparer{T} specificato per confrontare i valori.</summary>
        <returns>Sequenza che contiene gli elementi che formano l'intersezione insiemistica delle due sequenze.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Correla in parallelo gli elementi di due sequenze in base alle chiavi corrispondenti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TInner">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TKey">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TResult">Questo parametro di tipo non viene usato.</typeparam>
        <param name="outer">Questo parametro non viene usato.</param>
        <param name="inner">Questo parametro non viene usato.</param>
        <param name="outerKeySelector">Questo parametro non viene usato.</param>
        <param name="innerKeySelector">Questo parametro non viene usato.</param>
        <param name="resultSelector">Questo parametro non viene usato.</param>
        <summary>Questo overload di Join non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene richiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload esiste per impedire l'utilizzo di Join con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore di Join verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Tipo degli elementi della prima sequenza.</typeparam>
        <typeparam name="TInner">Tipo degli elementi della seconda sequenza.</typeparam>
        <typeparam name="TKey">Tipo delle chiavi restituite dalle funzioni del selettore principale.</typeparam>
        <typeparam name="TResult">Tipo degli elementi di risultato.</typeparam>
        <param name="outer">Prima sequenza da unire.</param>
        <param name="inner">Sequenza da unire alla prima sequenza.</param>
        <param name="outerKeySelector">Funzione per estrarre la chiave di aggiunta da ogni elemento della prima sequenza.</param>
        <param name="innerKeySelector">Funzione per estrarre la chiave di aggiunta da ogni elemento della seconda sequenza.</param>
        <param name="resultSelector">Funzione per creare un elemento di risultato da due elementi corrispondenti.</param>
        <summary>Correla in parallelo gli elementi di due sequenze in base alle chiavi corrispondenti. Per confrontare le chiavi viene usato l'operatore di confronto uguaglianze predefinito.</summary>
        <returns>Sequenza che contiene elementi di tipo <paramref name="TResult" /> ottenuti eseguendo un inner join di due sequenze.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TInner">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TKey">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TResult">Questo parametro di tipo non viene usato.</typeparam>
        <param name="outer">Questo parametro non viene usato.</param>
        <param name="inner">Questo parametro non viene usato.</param>
        <param name="outerKeySelector">Questo parametro non viene usato.</param>
        <param name="innerKeySelector">Questo parametro non viene usato.</param>
        <param name="resultSelector">Questo parametro non viene usato.</param>
        <param name="comparer">Questo parametro non viene usato.</param>
        <summary>Questo overload di Join non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene richiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è presente per impedire l'utilizzo di Join con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore di Join verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eccezione che si verifica quando viene chiamato questo metodo.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Tipo degli elementi della prima sequenza.</typeparam>
        <typeparam name="TInner">Tipo degli elementi della seconda sequenza.</typeparam>
        <typeparam name="TKey">Tipo delle chiavi restituite dalle funzioni del selettore principale.</typeparam>
        <typeparam name="TResult">Tipo degli elementi di risultato.</typeparam>
        <param name="outer">Prima sequenza da unire.</param>
        <param name="inner">Sequenza da unire alla prima sequenza.</param>
        <param name="outerKeySelector">Funzione per estrarre la chiave di aggiunta da ogni elemento della prima sequenza.</param>
        <param name="innerKeySelector">Funzione per estrarre la chiave di aggiunta da ogni elemento della seconda sequenza.</param>
        <param name="resultSelector">Funzione per creare un elemento di risultato da due elementi corrispondenti.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per la codifica hash e il confronto delle chiavi.</param>
        <summary>Correla in parallelo gli elementi di due sequenze in base alle chiavi corrispondenti. Per confrontare le chiavi, viene usato un oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> specificato.</summary>
        <returns>Sequenza che contiene elementi di tipo <paramref name="TResult" /> ottenuti eseguendo un inner join di due sequenze.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="action" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'ultimo elemento di una sequenza parallela.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale viene restituito l'ultimo elemento.</param>
        <summary>Restituisce l'ultimo elemento di una sequenza parallela.</summary>
        <returns>Il valore dell'ultima posizione nella sequenza di origine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la query non viene ordinata, l'ultimo elemento è non deterministico. Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale viene restituito un elemento.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Restituisce l'ultimo elemento di una sequenza parallela che soddisfa una condizione specificata.</summary>
        <returns>Ultimo elemento nella sequenza che supera il test nella funzione predicato specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la query non viene ordinata, l'ultimo elemento è non deterministico. Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">Nessun elemento in <paramref name="source" /> soddisfa la condizione in <paramref name="predicate" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'ultimo elemento di una sequenza parallela o un valore predefinito se la sequenza non contiene elementi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale viene restituito un elemento.</param>
        <summary>Restituisce l'ultimo elemento di una sequenza parallela o un valore predefinito se la sequenza non contiene elementi.</summary>
        <returns>default() se la sequenza di origine è vuota; in caso contrario, l'ultimo elemento nella sequenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la query non viene ordinata, l'ultimo elemento è non deterministico. Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale viene restituito un elemento.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Restituisce l'ultimo elemento di una sequenza parallela che soddisfa una condizione o un valore predefinito se un elemento di tale tipo non viene trovato.</summary>
        <returns>default() se la sequenza è vuota o se nessun elemento supera il test nella funzione predicato; in caso contrario, l'ultimo elemento che supera il test nella funzione predicato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la query non viene ordinata, l'ultimo elemento è non deterministico. Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un oggetto Int64 che rappresenta il numero totale di elementi in una sequenza parallela.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As ParallelQuery(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza che contiene gli elementi da contare.</param>
        <summary>Restituisce un oggetto Int64 che rappresenta il numero totale di elementi in una sequenza parallela.</summary>
        <returns>Numero di elementi nella sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Il numero di elementi nel database di origine è maggiore di <see cref="F:System.Int64.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.OverflowException">Il risultato calcolato è maggiore di <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza che contiene gli elementi da contare.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Restituisce un oggetto Int64 che rappresenta quanti elementi in una sequenza parallela soddisfano una condizione.</summary>
        <returns>Numero che rappresenta quanti elementi nella sequenza specificata soddisfano la condizione nella funzione predicato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Il numero di elementi nel database di origine è maggiore di <see cref="F:System.Int64.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.OverflowException">Il risultato calcolato è maggiore di <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nella sequenza di origine.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <summary>Restituisce il valore massimo in una sequenza parallela di valori.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TResult">Il tipo di valore restituito da <c>selettore</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore massimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore massimo.</summary>
        <returns>Valore massimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <summary>Restituisce il valore minimo in una sequenza parallela di valori.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TResult">Il tipo di valore restituito da <c>selettore</c>.</typeparam>
        <param name="source">Sequenza di valori di cui determinare il valore minimo.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Richiama in parallelo una funzione di trasformazione su ogni elemento di una sequenza e restituisce il valore minimo.</summary>
        <returns>Valore minimo della sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non contiene elementi e <paramref name="TSource" /> è un tipo di valore non nullable.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OfType``1(System.Linq.ParallelQuery)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As ParallelQuery) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ OfType(System::Linq::ParallelQuery ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Linq.ParallelQuery -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Il tipo in base al quale filtrare gli elementi della sequenza.</typeparam>
        <param name="source">Sequenza di cui filtrare gli elementi.</param>
        <summary>Filtra gli elementi di un oggetto ParallelQuery in base a un tipo specificato.</summary>
        <returns>Sequenza che contiene elementi della sequenza di input del tipo .</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordina in parallelo gli elementi di una sequenza in ordine ascendente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Sequenza di valori da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <summary>Dispone in parallelo gli elementi di una sequenza in ordine crescente in base a una chiave.</summary>
        <returns>Oggetto OrderedParallelQuery{TSource} i cui elementi sono ordinati in base a una chiave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza dell'implementazione sequenziale, ciò non è un ordinamento stabile. Per ottenere un ordinamento stabile, modificare una query nel formato: ordinati var = origine. Select((e,i) = > new {E =, e ho = i:<0}). OrderBy((v) = > v.e). ThenBy (v = > v). Select((v) = > v.e);  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Sequenza di valori da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <param name="comparer">Oggetto IComparer{TKey} per confrontare chiavi.</param>
        <summary>Dispone in parallelo gli elementi di una sequenza in ordine crescente usando un operatore di confronto specificato.</summary>
        <returns>Oggetto OrderedParallelQuery{TSource} i cui elementi sono ordinati in base a una chiave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza dell'implementazione sequenziale, ciò non è un ordinamento stabile. Vedere la sezione Osservazioni per <xref:System.Linq.ParallelEnumerable.OrderBy%2A> per un approccio all'implementazione di un ordinamento stabile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordina in senso decrescente gli elementi di una sequenza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderByDescending(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Sequenza di valori da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <summary>Dispone in parallelo gli elementi di una sequenza in ordine decrescente in base a una chiave.</summary>
        <returns>Oggetto OrderedParallelQuery{TSource} i cui elementi sono disposti in ordine decrescente in base a una chiave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza dell'implementazione sequenziale, ciò non è un ordinamento stabile. Vedere la sezione Osservazioni per <xref:System.Linq.ParallelEnumerable.OrderBy%2A> per un approccio all'implementazione di un ordinamento stabile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderByDescending(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Sequenza di valori da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <param name="comparer">Oggetto IComparer{TKey} per confrontare chiavi.</param>
        <summary>Ordina in senso decrescente gli elementi di una sequenza usando un operatore di confronto specificato.</summary>
        <returns>Oggetto OrderedParallelQuery{TSource} i cui elementi sono disposti in ordine decrescente in base a una chiave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza dell'implementazione sequenziale, ciò non è un ordinamento stabile. Vedere la sezione Osservazioni per <xref:System.Linq.ParallelEnumerable.OrderBy%2A> per un approccio all'implementazione di un ordinamento stabile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="KeySelector" /> è un riferimento null (Nothing in Visual Basic)..</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Range (start As Integer, count As Integer) As ParallelQuery(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::ParallelQuery&lt;int&gt; ^ Range(int start, int count);" />
      <MemberSignature Language="F#" Value="static member Range : int * int -&gt; System.Linq.ParallelQuery&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Range (start, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Il primo valore intero della sequenza.</param>
        <param name="count">Il numero di valori interi sequenziali da generare</param>
        <summary>Genera una sequenza parallela di numeri integrali all'interno di un intervallo specificato.</summary>
        <returns>Elemento IEnumerable&lt;Int32&gt; in C# o IEnumerable(Of Int32) in Visual Basic che contiene un intervallo di numeri integrali sequenziali.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di 0 oppure <paramref name="start" /> + <paramref name="count" /> - 1 è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Repeat(Of TResult) (element As TResult, count As Integer) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Repeat(TResult element, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : 'Result * int -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Repeat (element, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Il tipo del valore da ripetere nella sequenza di risultato.</typeparam>
        <param name="element">Valore da ripetere.</param>
        <param name="count">Numero che esprime quante volte il valore è ripetuto nella sequenza generata.</param>
        <summary>Genera una sequenza parallela che contiene un valore ripetuto.</summary>
        <returns>Sequenza che contiene un valore ripetuto.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di 0.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Reverse``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Reverse(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori da invertire.</param>
        <summary>Inverte l'ordine degli elementi in una sequenza parallela.</summary>
        <returns>Sequenza i cui elementi corrispondono a quelli della sequenza di input, in ordine inverso.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proietta in parallelo ogni elemento di una sequenza in un nuovo form.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Select(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TResult">Tipo degli elementi restituiti dal selettore.</typeparam>
        <param name="source">Sequenza di valori su cui richiamare una funzione di trasformazione.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Proietta in parallelo ogni elemento di una sequenza in un nuovo form incorporando l'indice dell'elemento.</summary>
        <returns>Sequenza i cui elementi sono il risultato del richiamo alla funzione di trasformazione su ogni elemento di <paramref name="source" />, in base all'indice fornito a <paramref name="selector" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.OverflowException">Il numero di elementi enumerati dalla query è superiore a <see cref="F:System.Int32.MaxValue" />. Questa condizione può verificarsi in scenari di flusso.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Select(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TResult">Tipo degli elementi restituiti dal selettore.</typeparam>
        <param name="source">Sequenza di valori su cui richiamare una funzione di trasformazione.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Proietta in parallelo ogni elemento di una sequenza in un nuovo form.</summary>
        <returns>Sequenza i cui elementi sono il risultato della chiamata alla funzione di trasformazione su ogni elemento di <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proietta in parallelo ogni elemento di una sequenza a un oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> e semplifica le sequenze risultanti in un'unica sequenza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, IEnumerable(Of TResult))) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Result&gt;&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TResult">Tipo degli elementi della sequenza restituita dal selettore.</typeparam>
        <param name="source">Sequenza di valori da proiettare.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Proietta in parallelo ogni elemento di una sequenza a un oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> e semplifica le sequenze risultanti in un'unica sequenza.</summary>
        <returns>Sequenza i cui elementi sono il risultato della chiamata alla funzione di trasformazione uno-a-molti su ogni elemento della sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer, IEnumerable(Of TResult))) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Result&gt;&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TResult">Tipo degli elementi della sequenza restituita dal selettore.</typeparam>
        <param name="source">Sequenza di valori da proiettare.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Proietta in parallelo ogni elemento di una sequenza a un oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> e semplifica le sequenze risultanti in un'unica sequenza. L'indice di ogni elemento di origine viene usato nella maschera proiettata di tale elemento.</summary>
        <returns>Sequenza i cui elementi sono il risultato della chiamata alla funzione di trasformazione uno-a-molti su ogni elemento della sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">Il numero di elementi enumerati dalla query è superiore a <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As ParallelQuery(Of TSource), collectionSelector As Func(Of TSource, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi intermedi raccolti da <c>collectionSelector</c>.</typeparam>
        <typeparam name="TCollection">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TResult">Tipo degli elementi nella sequenza risultante.</typeparam>
        <param name="source">Sequenza di valori da proiettare.</param>
        <param name="collectionSelector">Funzione di trasformazione da applicare a ogni elemento di origine; il secondo parametro della funzione rappresenta l'indice dell'elemento di origine.</param>
        <param name="resultSelector">Funzione per creare un elemento di risultato da un elemento dalla prima sequenza e una raccolta di elementi corrispondenti dalla seconda sequenza.</param>
        <summary>Proietta ogni elemento di una sequenza a un oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" />, semplifica le sequenze risultanti in un'unica sequenza e richiama una funzione del selettore di risultato su ogni elemento al suo interno.</summary>
        <returns>Sequenza i cui elementi sono il risultato ottenuto richiamando la funzione di trasformazione uno-a-molti <paramref name="collectionSelector" /> su ogni elemento di <paramref name="source" /> basato sull'indice fornito a <paramref name="collectionSelector" /> ed eseguendo quindi il mapping di ogni elemento della sequenza e del corrispondente elemento di origine a un elemento di risultato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">Il numero di elementi enumerati dalla query è superiore a <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As ParallelQuery(Of TSource), collectionSelector As Func(Of TSource, Integer, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi intermedi raccolti da <c>collectionSelector</c>.</typeparam>
        <typeparam name="TCollection">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TResult">Tipo degli elementi da restituire.</typeparam>
        <param name="source">Sequenza di valori da proiettare.</param>
        <param name="collectionSelector">Funzione di trasformazione da applicare a ogni elemento di origine; il secondo parametro della funzione rappresenta l'indice dell'elemento di origine.</param>
        <param name="resultSelector">Funzione per creare un elemento di risultato da un elemento dalla prima sequenza e una raccolta di elementi corrispondenti dalla seconda sequenza.</param>
        <summary>Proietta ogni elemento di una sequenza a un oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" />, semplifica le sequenze risultanti in un'unica sequenza e richiama una funzione del selettore di risultato su ogni elemento al suo interno. L'indice di ogni elemento di origine viene usato nella maschera intermedia proiettata di tale elemento.</summary>
        <returns>Sequenza i cui elementi sono il risultato ottenuto richiamando la funzione di trasformazione uno-a-molti <paramref name="collectionSelector" /> su ogni elemento di <paramref name="source" /> basato sull'indice fornito a <paramref name="collectionSelector" /> ed eseguendo quindi il mapping di ogni elemento della sequenza e del corrispondente elemento di origine a un elemento di risultato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">Il numero di elementi enumerati dalla query è superiore a <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se due sequenze parallele sono uguali confrontando gli elementi tramite l'uso di un operatore di confronto uguaglianze predefinito per il loro tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Questo parametro di tipo non viene usato.</typeparam>
        <param name="first">Questo parametro non viene usato.</param>
        <param name="second">Questo parametro non viene usato.</param>
        <summary>Questo overload di SequenceEqual non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload esiste per impedire l'utilizzo di SequenceEqual con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore di SequenceEqual verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Generato ogni volta che viene chiamato questo metodo.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi delle sequenze di input.</typeparam>
        <param name="first">Sequenza da confrontare alla seconda.</param>
        <param name="second">Sequenza da confrontare alla prima sequenza di input.</param>
        <summary>Determina se due sequenze parallele sono uguali confrontando gli elementi mediante l'operatore di confronto di uguaglianza predefinito per il relativo tipo.</summary>
        <returns>È true se le due sequenze di origine hanno la stessa lunghezza e gli elementi corrispondenti risultano uguali in base all'operatore di confronto di uguaglianza predefinito per il relativo tipo; in caso contrario, false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> o <paramref name="second" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Questo parametro di tipo non viene usato.</typeparam>
        <param name="first">Questo parametro non viene usato.</param>
        <param name="second">Questo parametro non viene usato.</param>
        <param name="comparer">Questo parametro non viene usato.</param>
        <summary>Questo overload di SequenceEqual non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload esiste per impedire l'utilizzo di SequenceEqual con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore di SequenceEqual verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Generato ogni volta che viene chiamato questo metodo.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi delle sequenze di input.</typeparam>
        <param name="first">Sequenza da confrontare con <c>second</c>.</param>
        <param name="second">Sequenza da confrontare alla prima sequenza di input.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> da usare per confrontare gli elementi.</param>
        <summary>Determina se due sequenze parallele sono uguali confrontandone gli elementi mediante un oggetto IEqualityComparer{T} specificato.</summary>
        <returns>È true se le due sequenze di origine hanno la stessa lunghezza e gli elementi corrispondenti risultano uguali in base all'operatore di confronto di uguaglianza predefinito per il relativo tipo; in caso contrario, false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> o <paramref name="second" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'unico elemento di una sequenza parallela e genera un'eccezione se nella sequenza non è presente esattamente un solo elemento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza di cui restituire il singolo elemento.</param>
        <summary>Restituisce l'unico elemento di una sequenza parallela e genera un'eccezione se nella sequenza non è presente esattamente un solo elemento.</summary>
        <returns>Singolo elemento della sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">La sequenza di input contiene più elementi. oppure la sequenza di input è vuota.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza di cui restituire il singolo elemento.</param>
        <param name="predicate">Funzione per testare un elemento per una condizione.</param>
        <summary>Restituisce l'unico elemento di una sequenza parallela che soddisfa una condizione specificata e genera un'eccezione se esistono più elementi di tale tipo.</summary>
        <returns>Singolo elemento della sequenza di input che soddisfa una condizione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">Nessun elemento soddisfa la condizione in <paramref name="predicate" />. -oppure- Nessun elemento soddisfa la condizione in <paramref name="predicate" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'unico elemento di una sequenza parallela o un valore predefinito se la sequenza è vuota. Questo metodo genera un'eccezione se nella sequenza esiste più di un elemento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza di cui restituire il singolo elemento.</param>
        <summary>Restituisce l'unico elemento di una sequenza parallela o un valore predefinito se la sequenza è vuota. Questo metodo genera un'eccezione se nella sequenza esiste più di un elemento.</summary>
        <returns>Il singolo elemento della sequenza di input o default() se la sequenza non contiene elementi.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> presenta più di un elemento.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza di cui restituire il singolo elemento.</param>
        <param name="predicate">Funzione per testare un elemento per una condizione.</param>
        <summary>Restituisce l'unico elemento di una sequenza parallela che soddisfa una condizione specificata o un valore predefinito se tale elemento esiste. Questo metodo genera un'eccezione se più di un elemento soddisfa la condizione.</summary>
        <returns>Il singolo elemento della sequenza di input che soddisfa la condizione o default() se tale elemento non viene trovato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> è vuoto oppure restituisce più elementi.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Skip``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As ParallelQuery(Of TSource), count As Integer) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Skip(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale vengono restituiti gli elementi.</param>
        <param name="count">Il numero di elementi da ignorare prima di restituire gli elementi rimanenti.</param>
        <summary>Ignora un numero specificato di elementi in una sequenza parallela e restituisce gli elementi rimanenti.</summary>
        <returns>Sequenza che contiene gli elementi presenti dopo l'indice specificato nella sequenza di input.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se count > origine. Count (), non vengono restituiti elementi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">Il numero è maggiore di <see cref="F:System.Int32.MaxValue" /></exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ignora gli elementi in una sequenza parallela finché la condizione specificata non restituisce true, quindi restituisce gli elementi rimanenti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ SkipWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale vengono restituiti gli elementi.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Ignora gli elementi in una sequenza parallela finché la condizione specificata non restituisce true, quindi restituisce gli elementi rimanenti.</summary>
        <returns>Sequenza che contiene gli elementi dalla sequenza di input a partire dal primo elemento nella serie lineare che non supera il test specificato dal predicato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ SkipWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale vengono restituiti gli elementi.</param>
        <param name="predicate">Funzione per verificare ogni elemento di origine per una condizione; il secondo parametro della funzione rappresenta l'indice dell'elemento di origine.</param>
        <summary>Ignora gli elementi in una sequenza parallela finché la condizione specificata non restituisce true, quindi restituisce gli elementi rimanenti. L'indice dell'elemento viene usato nella logica della funzione predicativa.</summary>
        <returns>Sequenza che contiene gli elementi dalla sequenza di input a partire dal primo elemento nella serie lineare che non supera il test specificato dal predicato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">Il numero di elementi enumerati dalla query è superiore a <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Decimal.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Double.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Int64.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Decimal.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Double.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Int64.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Single.MaxValue" />. oppure una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <summary>Calcola in parallelo la somma di una sequenza di valori.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Single.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la somma della sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Decimal.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la somma della sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Double.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nella sequenza di origine.</typeparam>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la somma della sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la somma della sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Int64.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la somma della sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Decimal.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la somma della sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Double.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la somma della sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Int32.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la somma della sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Int64.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la somma della sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Single.MaxValue" />. oppure una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza di valori di cui calcolare la somma.</param>
        <param name="selector">Funzione di trasformazione da applicare a ogni elemento.</param>
        <summary>Calcola in parallelo la somma della sequenza di valori ottenuti richiamando una funzione di trasformazione su ogni elemento della sequenza di input.</summary>
        <returns>Somma dei valori previsti nella sequenza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="selector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La somma è maggiore di <see cref="F:System.Single.MaxValue" />. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Take&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Take``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As ParallelQuery(Of TSource), count As Integer) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Take(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale vengono restituiti gli elementi.</param>
        <param name="count">Numero di elementi da restituire.</param>
        <summary>Restituisce un numero specificato di elementi contigui dall'inizio di una sequenza parallela.</summary>
        <returns>Sequenza che contiene il numero specificato di elementi, dall'inizio della sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce elementi di una sequenza parallela finché una condizione specificata restituisce true.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ TakeWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale vengono restituiti gli elementi.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Restituisce elementi di una sequenza parallela finché una condizione specificata restituisce true.</summary>
        <returns>Sequenza che contiene gli elementi della sequenza di input che precedono l'elemento in corrispondenza del quale il test non viene più superato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ TakeWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Sequenza dalla quale vengono restituiti gli elementi.</param>
        <param name="predicate">Funzione per verificare ogni elemento di origine per una condizione; il secondo parametro della funzione rappresenta l'indice dell'elemento di origine.</param>
        <summary>Restituisce elementi di una sequenza parallela finché una condizione specificata restituisce true. L'indice dell'elemento viene usato nella logica della funzione predicativa.</summary>
        <returns>Sequenza che contiene gli elementi della sequenza di input che precedono l'elemento in corrispondenza del quale il test non viene più superato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">Più di <see cref="F:System.Int32.MaxValue" /> elementi vengono enumerati da questa query.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un successivo ordinamento in parallelo degli elementi di una sequenza in ordine ascendente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenBy(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Oggetto OrderedParallelQuery{TSource} che contiene elementi da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <summary>Esegue in parallelo un ordinamento successivo crescente in base a una chiave degli elementi di una sequenza.</summary>
        <returns>Oggetto OrderedParallelQuery{TSource} i cui elementi sono ordinati in base a una chiave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza dell'implementazione sequenziale, ciò non è un ordinamento stabile. Vedere la sezione Osservazioni per <xref:System.Linq.ParallelEnumerable.OrderBy%2A> per un approccio all'implementazione di un ordinamento stabile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenBy(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Oggetto OrderedParallelQuery{TSource} che contiene elementi da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <param name="comparer">Oggetto IComparer{TKey} per confrontare chiavi.</param>
        <summary>Esegue in parallelo un ordinamento successivo in senso crescente degli elementi di una sequenza usando un operatore di confronto specificato.</summary>
        <returns>Oggetto OrderedParallelQuery{TSource} i cui elementi sono ordinati in base a una chiave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza dell'implementazione sequenziale, ciò non è un ordinamento stabile. Vedere la sezione Osservazioni per <xref:System.Linq.ParallelEnumerable.OrderBy%2A> per un approccio all'implementazione di un ordinamento stabile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un successivo ordinamento in parallelo degli elementi di una sequenza in ordine discendente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenByDescending(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Oggetto OrderedParallelQuery{TSource} che contiene elementi da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <summary>Esegue in parallelo un ordinamento successivo decrescente in base a una chiave degli elementi di una sequenza.</summary>
        <returns>Sequenza i cui elementi vengono ordinati in senso decrescente in base a una chiave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza dell'implementazione sequenziale, ciò non è un ordinamento stabile. Vedere la sezione Osservazioni per <xref:System.Linq.ParallelEnumerable.OrderBy%2A> per un approccio all'implementazione di un ordinamento stabile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenByDescending(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Oggetto OrderedParallelQuery{TSource} che contiene elementi da ordinare.</param>
        <param name="keySelector">Funzione per estrarre una chiave da un elemento.</param>
        <param name="comparer">Oggetto IComparer{TKey} per confrontare chiavi.</param>
        <summary>Esegue in parallelo un ordinamento successivo in senso decrescente degli elementi di una sequenza usando un operatore di confronto specificato.</summary>
        <returns>Sequenza i cui elementi vengono ordinati in senso decrescente in base a una chiave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza dell'implementazione sequenziale, ciò non è un ordinamento stabile. Vedere la sezione Osservazioni per <xref:System.Linq.ParallelEnumerable.OrderBy%2A> per un approccio all'implementazione di un ordinamento stabile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToArray``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray(Of TSource) (source As ParallelQuery(Of TSource)) As TSource()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;TSource&gt; ^ ToArray(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToArray : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source[]" Usage="System.Linq.ParallelEnumerable.ToArray source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza da cui creare una matrice.</param>
        <summary>Crea una matrice da un oggetto <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
        <returns>Oggetto che contiene gli elementi dalla sequenza di input .</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un oggetto <see cref="T:System.Collections.Generic.Dictionary`2" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Sequenza da cui creare un oggetto <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="keySelector">Funzione per estrarre una chiave da ogni elemento.</param>
        <summary>Crea un oggetto <see cref="T:System.Collections.Generic.Dictionary`2" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" /> secondo una funzione del selettore principale specificata.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.Dictionary`2" /> che contiene chiavi e valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">
          <paramref name="keySelector" /> produce una chiave che è un riferimento Null (Nothing in Visual Basic). oppure <paramref name="keySelector" /> genera chiavi duplicate per due elementi. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Sequenza da cui creare un oggetto <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="keySelector">Funzione per estrarre una chiave da ogni elemento.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per confrontare le chiavi.</param>
        <summary>Crea un oggetto <see cref="T:System.Collections.Generic.Dictionary`2" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" /> secondo una funzione del selettore principale specificata e un operatore di confronto principale.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.Dictionary`2" /> che contiene chiavi e valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">
          <paramref name="keySelector" /> produce una chiave che è un riferimento Null (Nothing in Visual Basic). oppure <paramref name="keySelector" /> genera chiavi duplicate per due elementi. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Il tipo di valore restituito da <c>elementSelector</c>.</typeparam>
        <param name="source">Sequenza da cui creare un oggetto <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="keySelector">Funzione per estrarre una chiave da ogni elemento.</param>
        <param name="elementSelector">Funzione di trasformazione per produrre un valore dell'elemento di risultato da ogni elemento.</param>
        <summary>Crea un oggetto <see cref="T:System.Collections.Generic.Dictionary`2" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" /> secondo le funzioni specificate del selettore principale e del selettore di elementi.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.Dictionary`2" /> che contiene valori di tipo <paramref name="TElement" /> selezionati dalla sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">
          <paramref name="keySelector" /> produce una chiave che è un riferimento Null (Nothing in Visual Basic). oppure <paramref name="keySelector" /> genera chiavi duplicate per due elementi. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Il tipo di valore restituito da <c>elementSelector</c>.</typeparam>
        <param name="source">Sequenza da cui creare un oggetto <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="keySelector">Funzione per estrarre una chiave da ogni elemento.</param>
        <param name="elementSelector">Funzione di trasformazione per produrre un valore dell'elemento di risultato da ogni elemento.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per confrontare le chiavi.</param>
        <summary>Crea un oggetto <see cref="T:System.Collections.Generic.Dictionary`2" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" /> secondo una funzione specificata del selettore principale, un operatore di confronto principale e una funzione del selettore di elementi.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.Dictionary`2" /> che contiene valori di tipo <paramref name="TElement" /> selezionati dalla sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">
          <paramref name="keySelector" /> produce una chiave che è un riferimento Null (Nothing in Visual Basic). oppure <paramref name="keySelector" /> genera chiavi duplicate per due elementi. -oppure- Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToList``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToList(Of TSource) (source As ParallelQuery(Of TSource)) As List(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::List&lt;TSource&gt; ^ ToList(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToList : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Collections.Generic.List&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToList source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi della <c>origine</c>.</typeparam>
        <param name="source">Sequenza da cui creare un oggetto <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Crea un oggetto <see cref="T:System.Collections.Generic.List`1" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
        <returns>Oggetto <see cref="T:System.Collections.Generic.List`1" /> che contiene gli elementi dalla sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLookup&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un oggetto <see cref="T:System.Linq.ILookup`2" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Sequenza da cui creare un oggetto <see cref="T:System.Linq.ILookup`2" />.</param>
        <param name="keySelector">Funzione per estrarre una chiave da ogni elemento.</param>
        <summary>Crea un oggetto <see cref="T:System.Linq.ILookup`2" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" /> secondo una funzione del selettore principale specificata.</summary>
        <returns>Oggetto <see cref="T:System.Linq.ILookup`2" /> che contiene chiavi e valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <param name="source">Sequenza da cui creare un oggetto <see cref="T:System.Linq.ILookup`2" />.</param>
        <param name="keySelector">Funzione per estrarre una chiave da ogni elemento.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per confrontare le chiavi.</param>
        <summary>Crea un oggetto <see cref="T:System.Linq.ILookup`2" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" /> secondo una funzione del selettore principale specificata e un operatore di confronto principale.</summary>
        <returns>Oggetto <see cref="T:System.Linq.ILookup`2" /> che contiene chiavi e valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Il tipo di valore restituito da <c>elementSelector</c>.</typeparam>
        <param name="source">Sequenza da cui creare un oggetto <see cref="T:System.Linq.ILookup`2" />.</param>
        <param name="keySelector">Funzione per estrarre una chiave da ogni elemento.</param>
        <param name="elementSelector">Funzione di trasformazione per produrre un valore dell'elemento di risultato da ogni elemento.</param>
        <summary>Crea un oggetto <see cref="T:System.Linq.ILookup`2" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" /> secondo le funzioni specificate del selettore principale e del selettore di elementi.</summary>
        <returns>Oggetto <see cref="T:System.Linq.ILookup`2" /> che contiene valori di tipo <paramref name="TElement" /> selezionati dalla sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <typeparam name="TKey">Il tipo della chiave restituita da <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Il tipo di valore restituito da <c>elementSelector</c>.</typeparam>
        <param name="source">Sequenza da cui creare un oggetto <see cref="T:System.Linq.ILookup`2" />.</param>
        <param name="keySelector">Funzione per estrarre una chiave da ogni elemento.</param>
        <param name="elementSelector">Funzione di trasformazione per produrre un valore dell'elemento di risultato da ogni elemento.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per confrontare le chiavi.</param>
        <summary>Crea un oggetto <see cref="T:System.Linq.ILookup`2" /> da un oggetto <see cref="T:System.Linq.ParallelQuery`1" /> secondo una funzione specificata del selettore principale, un operatore di confronto principale e una funzione del selettore di elementi.</summary>
        <returns>Elemento Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) che contiene valori di tipo TElement selezionati dalla sequenza di input.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produce l'unione insiemistica delle due sequenze parallele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Questo parametro di tipo non viene usato.</typeparam>
        <param name="first">Questo parametro non viene usato.</param>
        <param name="second">Questo parametro non viene usato.</param>
        <summary>Questo overload di Union non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è presente per impedire l'utilizzo di unione con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. L'operatore Union in caso contrario, verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eccezione che si verifica quando viene chiamato questo metodo.</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi delle sequenze di input.</typeparam>
        <param name="first">Sequenza i cui elementi distinti formano il primo set dell'unione.</param>
        <param name="second">Sequenza i cui elementi distinti formano il secondo set dell'unione.</param>
        <summary>Produce l'unione di set delle due sequenze parallele usando l'operatore di confronto di uguaglianza predefinito.</summary>
        <returns>Sequenza che contiene gli elementi di entrambe le sequenze di input, tranne i duplicati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> o <paramref name="second" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Questo parametro di tipo non viene usato.</typeparam>
        <param name="first">Questo parametro non viene usato.</param>
        <param name="second">Questo parametro non viene usato.</param>
        <param name="comparer">Questo parametro non viene usato.</param>
        <summary>Questo overload di Union non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene chiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è presente per impedire l'utilizzo di unione con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. L'operatore Union in caso contrario, verrebbe visualizzato per l'associazione di implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eccezione che si verifica quando viene chiamato questo metodo.</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi delle sequenze di input.</typeparam>
        <param name="first">Sequenza i cui elementi distinti formano il primo set dell'unione.</param>
        <param name="second">Sequenza i cui elementi distinti formano il secondo set dell'unione.</param>
        <param name="comparer">Oggetto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> per confrontare i valori.</param>
        <summary>Produce l'unione di set di due sequenze parallele usando un oggetto IEqualityComparer{T} specificato.</summary>
        <returns>Sequenza che contiene gli elementi di entrambe le sequenze di input, tranne i duplicati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> o <paramref name="second" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Filtra in parallelo una sequenza di valori in base a un predicato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Where(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi di origine.</typeparam>
        <param name="source">Sequenza da filtrare.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Filtra in parallelo una sequenza di valori in base a un predicato.</summary>
        <returns>Sequenza che contiene elementi della sequenza di input che soddisfano la condizione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Where(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi di origine.</typeparam>
        <param name="source">Sequenza da filtrare.</param>
        <param name="predicate">Funzione per testare ogni elemento rispetto a una condizione.</param>
        <summary>Filtra in parallelo una sequenza di valori in base a un predicato. L'indice di ogni elemento viene usato nella logica della funzione predicato.</summary>
        <returns>Sequenza che contiene elementi della sequenza di input che soddisfano la condizione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> o <paramref name="predicate" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">Il numero di elementi enumerati dalla query è superiore a <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="WithCancellation&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithCancellation&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithCancellation&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithCancellation``1(System.Linq.ParallelQuery{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithCancellation(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WithCancellation : System.Linq.ParallelQuery&lt;'Source&gt; * System.Threading.CancellationToken -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithCancellation (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Oggetto ParallelQuery su cui impostare l'opzione.</param>
        <param name="cancellationToken">Token di annullamento.</param>
        <summary>Imposta l'oggetto <see cref="T:System.Threading.CancellationToken" /> da associare alla query.</summary>
        <returns>Oggetto ParallelQuery che rappresenta la stessa query come origine, ma con il token di annullamento registrato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <paramref name="cancellationToken" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="WithCancellation" /> viene utilizzato più volte nella query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/80b14640-edfa-4153-be1b-3e003d3e9c1a">Procedura: annullare una query PLINQ</related>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annullamento</related>
      </Docs>
    </Member>
    <Member MemberName="WithDegreeOfParallelism&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithDegreeOfParallelism&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int degreeOfParallelism);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithDegreeOfParallelism&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 degreeOfParallelism) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithDegreeOfParallelism``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithDegreeOfParallelism(Of TSource) (source As ParallelQuery(Of TSource), degreeOfParallelism As Integer) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithDegreeOfParallelism(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int degreeOfParallelism);" />
      <MemberSignature Language="F#" Value="static member WithDegreeOfParallelism : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithDegreeOfParallelism (source, degreeOfParallelism)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="degreeOfParallelism" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Oggetto ParallelQuery su cui impostare il limite in gradi di parallelismo.</param>
        <param name="degreeOfParallelism">Grado di parallelismo per la query. Il valore predefinito è Math.Min(<see cref="P:System.Environment.ProcessorCount" />, <see langword="MAX_SUPPORTED_DOP" />) dove <see langword="MAX_SUPPORTED_DOP" /> è 512.</param>
        <summary>Imposta il grado di parallelismo da usare in una query. Il grado di parallelismo è il numero massimo di attività eseguite contemporaneamente che saranno usate per elaborare la query.</summary>
        <returns>Oggetto ParallelQuery che rappresenta la stessa query come origine, con il limite di gradi di parallelismo impostato.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="degreeOfParallelism" /> è minore di 1 o maggiore di 511.</exception>
        <exception cref="T:System.InvalidOperationException">WithDegreeOfParallelism viene utilizzato più volte nella query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="WithExecutionMode&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithExecutionMode&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Linq.ParallelExecutionMode executionMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithExecutionMode&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Linq.ParallelExecutionMode executionMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithExecutionMode``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelExecutionMode)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithExecutionMode(Of TSource) (source As ParallelQuery(Of TSource), executionMode As ParallelExecutionMode) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithExecutionMode(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Linq::ParallelExecutionMode executionMode);" />
      <MemberSignature Language="F#" Value="static member WithExecutionMode : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelExecutionMode -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithExecutionMode (source, executionMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="executionMode" Type="System.Linq.ParallelExecutionMode" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Oggetto ParallelQuery su cui impostare l'opzione.</param>
        <param name="executionMode">Modalità in cui eseguire la query.</param>
        <summary>Imposta la modalità di esecuzione della query.</summary>
        <returns>Oggetto ParallelQuery che rappresenta la stessa query come origine, ma con la modalità di esecuzione registrata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità di esecuzione specifica se PLINQ tenterà di eseguire il fallback per l'esecuzione sequenziale se rileva alcune forme di query. Per altre informazioni ed esempi, vedere [procedura: specificare la modalità di esecuzione in PLINQ](~/docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="executionMode" /> non è un valore valido di <see cref="T:System.Linq.ParallelExecutionMode" />.</exception>
        <exception cref="T:System.InvalidOperationException">WithExecutionMode viene utilizzato più volte nella query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="WithMergeOptions&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithMergeOptions&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Linq.ParallelMergeOptions mergeOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithMergeOptions&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Linq.ParallelMergeOptions mergeOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithMergeOptions``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelMergeOptions)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithMergeOptions(Of TSource) (source As ParallelQuery(Of TSource), mergeOptions As ParallelMergeOptions) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithMergeOptions(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Linq::ParallelMergeOptions mergeOptions);" />
      <MemberSignature Language="F#" Value="static member WithMergeOptions : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelMergeOptions -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithMergeOptions (source, mergeOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="mergeOptions" Type="System.Linq.ParallelMergeOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi del <c>origine</c>.</typeparam>
        <param name="source">Oggetto ParallelQuery su cui impostare l'opzione.</param>
        <param name="mergeOptions">Opzioni di merge da impostare per la query.</param>
        <summary>Imposta le opzioni di merge per la query, che specificano la modalità di memorizzazione dell'output nel buffer da parte della query.</summary>
        <returns>Oggetto ParallelQuery che rappresenta la stessa query come origine, ma con le opzioni di merge registrate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> è un riferimento null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mergeOptions" /> non è un valore valido di <see cref="T:System.Linq.ParallelMergeOptions" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="WithMergeOptions" /> viene utilizzato più volte nella query.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e8f7be3b-88de-4f33-ab14-dc008e76c1ba">Opzioni di merge in PLINQ</related>
        <related type="Article" href="https://msdn.microsoft.com/library/0f33b527-e91a-4550-a39a-e63e396fd831">Procedura: specificare le opzioni di merge in PLINQ</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unisce in parallelo due sequenze tramite la funzione predicato specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.ParallelQuery&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (first As ParallelQuery(Of TFirst), second As IEnumerable(Of TSecond), resultSelector As Func(Of TFirst, TSecond, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Zip(System::Linq::ParallelQuery&lt;TFirst&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ second, Func&lt;TFirst, TSecond, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.ParallelQuery&lt;'First&gt; * seq&lt;'Second&gt; * Func&lt;'First, 'Second, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Zip (first, second, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TSecond">Questo parametro di tipo non viene usato.</typeparam>
        <typeparam name="TResult">Questo parametro di tipo non viene usato.</typeparam>
        <param name="first">Questo parametro non viene usato.</param>
        <param name="second">Questo parametro non viene usato.</param>
        <param name="resultSelector">Questo parametro non viene usato.</param>
        <summary>Questo overload di Zip non dovrebbe mai essere chiamato. Questo metodo è contrassegnato come obsoleto e genera sempre <see cref="T:System.NotSupportedException" /> quando viene richiamato.</summary>
        <returns>Questo overload genera sempre <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è presente per impedire l'utilizzo del file Zip con un'origine dati a sinistra di tipo <xref:System.Linq.ParallelQuery%601> e un'origine dati di tipo <xref:System.Collections.Generic.IEnumerable%601>. In caso contrario, l'operatore di Zip può sembrare binding per l'implementazione in parallelo, ma in realtà sarebbe associato all'implementazione sequenziale.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Eccezione che si verifica quando viene chiamato questo metodo.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.ParallelQuery&lt;TFirst&gt; first, System.Linq.ParallelQuery&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TFirst&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (first As ParallelQuery(Of TFirst), second As ParallelQuery(Of TSecond), resultSelector As Func(Of TFirst, TSecond, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Zip(System::Linq::ParallelQuery&lt;TFirst&gt; ^ first, System::Linq::ParallelQuery&lt;TSecond&gt; ^ second, Func&lt;TFirst, TSecond, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.ParallelQuery&lt;'First&gt; * System.Linq.ParallelQuery&lt;'Second&gt; * Func&lt;'First, 'Second, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Zip (first, second, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Tipo degli elementi della prima sequenza.</typeparam>
        <typeparam name="TSecond">Tipo degli elementi della seconda sequenza.</typeparam>
        <typeparam name="TResult">Tipo degli elementi restituiti.</typeparam>
        <param name="first">Prima sequenza da comprimere.</param>
        <param name="second">Seconda sequenza da comprimere.</param>
        <param name="resultSelector">Funzione per creare un elemento di risultato da due elementi corrispondenti.</param>
        <summary>Unisce in parallelo due sequenze tramite la funzione predicato specificata.</summary>
        <returns>Sequenza che contiene elementi di tipo <paramref name="TResult" /> ottenuti eseguendo un pairwise <paramref name="resultSelector" /> su due sequenze. Se le sequenze hanno lunghezze diverse, la sequenza più lunga viene troncata in base alla lunghezza della sequenza più corta.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> o <paramref name="second" /> o <paramref name="resultSelector" /> è un riferimento Null (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">La query è stata annullata con il token passato tramite <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Una o più eccezioni si sono verificate durante la valutazione della query.</exception>
      </Docs>
    </Member>
  </Members>
</Type>