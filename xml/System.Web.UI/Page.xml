<Type Name="Page" FullName="System.Web.UI.Page">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="57ad865c267961e0b64c7a4656688a27eb6c1487" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34311414" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Page : System.Web.UI.TemplateControl, System.Web.IHttpHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Web.UI.TemplateControl implements class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits TemplateControl&#xA;Implements IHttpHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Web::UI::TemplateControl, System::Web::IHttpHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.TemplateControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("ASPXCodeBehind")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un file ASPX, noto anche come pagina Web Form, richiesto da un server che ospita un'applicazione Web ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Web.UI.Page> classe è associata a file con estensione aspx. Questi file vengono compilati in fase di esecuzione come <xref:System.Web.UI.Page> oggetti e memorizzato nella cache nella memoria del server.  
  
 Se si desidera creare una pagina Web Form utilizzando la tecnica di code-behind, derivare da questa classe. Rapido di applicazioni (RAD development) le finestre di progettazione, ad esempio Microsoft Visual Studio, utilizzano automaticamente questo modello per creare pagine Web Form.  
  
 Il <xref:System.Web.UI.Page> oggetto funge da contenitore di denominazione per tutti i controlli server in una pagina, ad eccezione di quelli che implementano il <xref:System.Web.UI.INamingContainer> interfaccia o controlli figlio di controlli che implementano questa interfaccia.  
  
 La <xref:System.Web.UI.Page> classe è un controllo che funge da interfaccia utente per l'applicazione Web e pertanto deve essere analizzata le per verificare che le procedure consigliate per scrivere codice protetto e proteggere le applicazioni vengono seguiti. Per informazioni generali su questi argomenti, vedere [Panoramica di Web applicazione minacce alla sicurezza](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: procedure consigliate per criteri di sicurezza](http://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), e [concetti principali sulla sicurezza](~/docs/standard/security/key-security-concepts.md). Per ulteriori informazioni, vedere [protezione dei controlli Standard](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [come: messaggi di errore visualizzato](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [procedura: proteggere dagli attacchi tramite Script in un'applicazione Web per l'applicazione HTML Codifica stringhe](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), e [Introduzione ai controlli di convalida](http://msdn.microsoft.com/library/3c0e7514-cff2-4bed-936d-ee3f7b740190).  
  
   
  
## Examples  
 Un progetto di sito Web di Visual Studio con codice sorgente è disponibile a complemento di questo argomento: [scaricare](http://go.microsoft.com/fwlink/?LinkId=192425).  
  
 Esempio di codice riportato di seguito viene illustrato come la <xref:System.Web.UI.Page> classe viene utilizzata nel modello di pagina code-behind. Si noti che il file di origine code-behind dichiara una classe parziale che eredita da una classe di base di pagina. La classe di base di pagina può essere <xref:System.Web.UI.Page>, oppure può essere un'altra classe che deriva da <xref:System.Web.UI.Page>. Si noti inoltre che la classe parziale consente il file code-behind utilizzare i controlli definiti sulla pagina senza la necessità per definirli come membri di campo.  
  
 [!code-csharp[System.Web.UI.Page_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx.cs#2)]
 [!code-vb[System.Web.UI.Page_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx.vb#2)]  
  
 Esempio di codice seguente viene illustrato il file con estensione aspx che corrisponde al file di origine di codice precedente.  
  
> [!IMPORTANT]
>  L'esempio include una casella di testo che accetta l'input dell'utente e rappresenta quindi una potenziale minaccia alla sicurezza. Per impostazione predefinita, le pagine Web ASP.NET verificano che l'input dell'utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx#1)]  
  
 È necessario utilizzare la direttiva e utilizzare il `Inherits` e `CodeFile` attributi per collegare il file code-behind per il file con estensione aspx. In questo esempio, il `Inherits` attributo indica il `MyCodeBehind` classe e `CodeFile` attributo indica il percorso del file specifici della lingua che contiene la classe.  
  
 Esempio di codice seguente viene illustrato il modello di pagina a file singolo e come accedere il <xref:System.Web.UI.Page.IsPostBack%2A> proprietà e <xref:System.Web.UI.Page.Response%2A> proprietà del <xref:System.Web.UI.Page>.  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/vb/pageexample.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore predefinito inizializza tutti i campi in base ai valori predefiniti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddContentTemplate">
      <MemberSignature Language="C#" Value="protected internal void AddContentTemplate (string templateName, System.Web.UI.ITemplate template);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddContentTemplate(string templateName, class System.Web.UI.ITemplate template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddContentTemplate(System.String,System.Web.UI.ITemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddContentTemplate (templateName As String, template As ITemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddContentTemplate(System::String ^ templateName, System::Web::UI::ITemplate ^ template);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateName" Type="System.String" />
        <Parameter Name="template" Type="System.Web.UI.ITemplate" />
      </Parameters>
      <Docs>
        <param name="templateName">Nome del modello di contenuto da aggiungere.</param>
        <param name="template">Modello di contenuto.</param>
        <summary>Viene chiamato durante l'inizializzazione della pagina per creare un insieme di contenuto (dai controlli di contenuto) che viene inviato a una pagina master se la pagina corrente o la pagina master fa riferimento a una pagina master.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Esiste già un modello di contenuto con lo stesso nome.</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOnPreRenderCompleteAsync">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra i delegati dei gestori eventi di inizio e di fine per una pagina asincrona.</summary>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Delegato del metodo <see cref="T:System.Web.BeginEventHandler" />.</param>
        <param name="endHandler">Delegato del metodo <see cref="T:System.Web.EndEventHandler" />.</param>
        <summary>Registra i delegati dei gestori eventi di inizio e di fine che non richiedono informazioni sullo stato per una pagina asincrona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> per aggiungere gestori eventi in una pagina Web asincrona.  
  
 È possibile registrare più gestori asincroni; Tuttavia, un solo gestore viene eseguito contemporaneamente. Se si desidera elaborare simultaneamente più metodi asincroni, è necessario utilizzare un unico <xref:System.Web.BeginEventHandler> (metodo) e avviare più operazioni asincrone da tale gestore.  
  
 I gestori asincroni vengono chiamati tra il <xref:System.Web.UI.Control.PreRender> e <xref:System.Web.UI.Page.PreRenderComplete> eventi.  
  
 Prima di tutto, tutti <xref:System.Web.UI.Page> eventi (tramite il <xref:System.Web.UI.Control.PreRender> evento) Esegui e quindi ogni registrati <xref:System.Web.BeginEventHandler> metodo viene chiamato. Al termine, il gestore corrispondente <xref:System.Web.EndEventHandler> metodo viene chiamato. Se sono presenti più gestori asincroni, viene chiamato il gestore successivo.  
  
 Dopo i gestori di eventi asincroni registrati vengono chiamati il resto degli eventi di pagina, a partire dal <xref:System.Web.UI.Page.PreRenderComplete> evento.  
  
   
  
## Examples  
 Esempio di codice seguente utilizza una richiesta asincrona per visualizzare il codice sorgente HTML della pagina predefinita del server Web locale in un <xref:System.Web.UI.WebControls.TextBox> controllo.  
  
> [!IMPORTANT]
>  L'esempio include una casella di testo che accetta l'input dell'utente e rappresenta quindi una potenziale minaccia alla sicurezza. Per impostazione predefinita, le pagine Web ASP.NET verificano che l'input dell'utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La direttiva della pagina <see langword="&lt;async&gt;" /> non è impostata su <see langword="true" />.  \- oppure - Il metodo <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> viene chiamato dopo l'evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> o <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler, state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginHandler">Delegato del metodo <see cref="T:System.Web.BeginEventHandler" />.</param>
        <param name="endHandler">Delegato del metodo <see cref="T:System.Web.EndEventHandler" />.</param>
        <param name="state">Oggetto contenente le informazioni sullo stato per i gestori eventi.</param>
        <summary>Registra i delegati del gestore eventi di inizio e di fine per una pagina asincrona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> metodo per aggiungere gestori che richiedono informazioni sullo stato a una pagina Web asincrona. L'oggetto passato nel `state` parametro può essere qualsiasi oggetto che l'applicazione richiede per trasferire informazioni tra i delegati del gestore eventi specificati nella `beginHandler` e `endHandler` parametri.  
  
 È possibile registrare più gestori asincroni; Tuttavia, un solo gestore viene eseguito contemporaneamente. Se si desidera elaborare simultaneamente più metodi asincroni, è necessario utilizzare un unico <xref:System.Web.BeginEventHandler> (metodo) e avviare più operazioni asincrone da tale gestore.  
  
 I gestori asincroni vengono chiamati tra il <xref:System.Web.UI.Control.PreRender> e <xref:System.Web.UI.Page.PreRenderComplete> eventi.  
  
 Prima di tutto, tutti <xref:System.Web.UI.Page> eventi (tramite il <xref:System.Web.UI.Control.PreRender> evento) Esegui e quindi ogni registrati <xref:System.Web.BeginEventHandler> metodo viene chiamato. Al termine, il gestore corrispondente <xref:System.Web.EndEventHandler> metodo viene chiamato. Se sono presenti più gestori asincroni, viene chiamato il gestore successivo.  
  
 Dopo i gestori di eventi asincroni registrati vengono chiamati il resto degli eventi di pagina, a partire dal <xref:System.Web.UI.Page.PreRenderComplete> evento.  
  
   
  
## Examples  
 Esempio di codice seguente utilizza una richiesta asincrona per visualizzare il codice sorgente HTML della pagina predefinita del server Web locale in un <xref:System.Web.UI.WebControls.TextBox> controllo.  
  
> [!IMPORTANT]
>  L'esempio include una casella di testo che accetta l'input dell'utente e rappresenta quindi una potenziale minaccia alla sicurezza. Per impostazione predefinita, le pagine Web ASP.NET verificano che l'input dell'utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La direttiva della pagina <see langword="&lt;async&gt;" /> non è impostata su <see langword="true" />.  \- oppure - Il metodo <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> viene chiamato dopo l'evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> o <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected internal void AddWrappedFileDependencies (object virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddWrappedFileDependencies(object virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddWrappedFileDependencies(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddWrappedFileDependencies (virtualFileDependencies As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddWrappedFileDependencies(System::Object ^ virtualFileDependencies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Oggetto <see cref="T:System.Object" /> contenente l'elenco dei nomi di file.</param>
        <summary>Aggiunge un elenco di file dipendenti che costituiscono la pagina corrente. Questo metodo viene utilizzato internamente dal framework della pagina ASP.NET e non è destinato a un utilizzo diretto dal codice.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.AddWrappedFileDependencies%2A> metodo aggiunge un elenco di file, ad esempio i file di controllo utente, che costituiscono la pagina corrente. Se uno di questi file vengono modificati, alla successiva richiesta viene compilata l'intera pagina. Questo metodo supporta l'infrastruttura .NET Framework e non può essere utilizzato direttamente dal codice.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.HttpApplicationState" /> relativo alla richiesta Web corrente.</summary>
        <value>I dati correnti nella classe <see cref="T:System.Web.HttpApplicationState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page.Application_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Application_Sample1/CS/applicationcs.aspx#1)]
 [!code-vb[Page.Application_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Application_Sample1/VB/applicationvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="AspCompatBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AspCompatBeginProcessRequest (System.Web.HttpContext context, AsyncCallback cb, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AspCompatBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback cb, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AspCompatBeginProcessRequest (context As HttpContext, cb As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AspCompatBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ cb, System::Object ^ extraData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="cb" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">Oggetto <see cref="T:System.Web.HttpContext" /> contenente informazioni sulla richiesta corrente.</param>
        <param name="cb">Metodo di callback.</param>
        <param name="extraData">Tutti i dati aggiuntivi necessari per l'elaborazione della richiesta in modo identico a una richiesta ASP.</param>
        <summary>Avvia una richiesta di risorse ASP (Active Server Page). Questo metodo viene fornito per supportare la compatibilità con applicazioni ASP legacy.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non chiamare questo metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AspCompatEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AspCompatEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AspCompatEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AspCompatEndProcessRequest(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Pagina ASP generata dalla richiesta.</param>
        <summary>Termina una richiesta di risorse ASP (Active Server Page). Questo metodo viene fornito per supportare la compatibilità con applicazioni ASP legacy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non chiamare questo metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatMode">
      <MemberSignature Language="C#" Value="protected bool AspCompatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AspCompatMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AspCompatMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AspCompatMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AspCompatMode { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta un valore che indica se la pagina può essere eseguita in un thread STA (Apartment a thread singolo, Single-Threaded Apartment).</summary>
        <value>
          <see langword="true" /> se la pagina supporta codice ASP (Active Server Pages), altrimenti <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se impostato su `true`, questa proprietà è la pagina deve essere eseguito in un thread apartment a thread singolo (STA). In questo modo la pagina per chiamare i componenti, ad esempio componenti sviluppati con Visual Basic 6.0. Impostando questa proprietà su `true` consente inoltre la pagina per chiamare i componenti COM+ che richiedono l'accesso a oggetti incorporati ASP non gestiti. Queste opzioni sono accessibili tramite ASP `ObjectContext` oggetto o `OnStartPage` metodo.  
  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare il `aspcompat` attributo `true` utilizzando la direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta la proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncMode">
      <MemberSignature Language="C#" Value="protected bool AsyncMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AsyncMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AsyncMode { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta un valore che indica se la pagina viene elaborata in modo sincrono o asincrono.</summary>
        <value>
          <see langword="true" /> se la pagina viene elaborata in modo asincrono, altrimenti <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.AsyncMode%2A> proprietà è impostata tramite il <xref:System.Web.UI.Page> parser quando viene generato il codice della pagina. Utilizzare il `Async` attributo della direttiva di impostare questo valore.  
  
 Le pagine asincrone non funzionano quando il `AspCompat` attributo è impostato su `true` o `Transaction` attributo è impostato su un valore diverso da `Disabled` nella direttiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AsyncPageBeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AsyncPageBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AsyncPageBeginProcessRequest (context As HttpContext, callback As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AsyncPageBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ callback, System::Object ^ extraData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">Oggetto <see cref="T:System.Web.HttpContext" /> della richiesta.</param>
        <param name="callback">Metodo di callback che consente di notificare il completamento del processo.</param>
        <param name="extraData">Dati sullo stato per il metodo asincrono.</param>
        <summary>Inizia l'elaborazione di una richiesta di pagina asincrona.</summary>
        <returns>Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento alla richiesta asincrona.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AsyncPageEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AsyncPageEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AsyncPageEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AsyncPageEndProcessRequest(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Oggetto <see cref="T:System.IAsyncResult" /> che fa riferimento a una richiesta asincrona in sospeso.</param>
        <summary>Termina l'elaborazione di una richiesta di pagina asincrona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan AsyncTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AsyncTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AsyncTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica l'intervallo di timeout utilizzato durante l'elaborazione di attività asincrone.</summary>
        <value>Un oggetto <see cref="T:System.TimeSpan" /> che contiene l'intervallo di tempo consentito per il completamento dell'attività asincrona. L'intervallo di tempo predefinito è 45 secondi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il timeout asincrono della pagina rappresenta la quantità di tempo di attesa della pagina per eseguire attività asincrone. Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare l'intervallo di timeout asincrono pagina usando del file di configurazione Web o nella direttiva. I valori impostati nella sezione di configurazione della pagina vengono sovrascritti dalla direttiva della pagina.  
  
 Definire l'attività asincrona utilizzando il <xref:System.Web.UI.PageAsyncTask> classe e registrare un gestore di timeout un inizio e di fine. Se l'attività asincrona non viene completata nell'intervallo di tempo specificato, verrà richiamato il gestore di timeout.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.Page.AsyncTimeout%2A> proprietà con il <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> e <xref:System.Web.UI.Page.RegisterAsyncTask%2A> metodi. Si noti l'utilizzo di gestori di inizio, fine e timeout. Nell'esempio viene introdotto un ritardo artificiale per illustrare il caso di un'attività asincrona che supera il tempo per l'attività come specificato nella <xref:System.Web.UI.Page.AsyncTimeout%2A> proprietà. In uno scenario reale, un'attività asincrona può essere usata per eseguire chiamate al database o la generazione di immagini, ad esempio, e il gestore di timeout fornisce una riduzione del se l'attività non viene eseguita in un periodo di tempo specificato. Si noti che il <xref:System.Web.UI.Page.AsyncTimeout%2A> proprietà è impostata nella direttiva della pagina.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà è stata impostata su un valore negativo.</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="AutoPostBackControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control AutoPostBackControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control AutoPostBackControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AutoPostBackControl" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPostBackControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ AutoPostBackControl { System::Web::UI::Control ^ get(); void set(System::Web::UI::Control ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il controllo nella pagina per eseguire i postback.</summary>
        <value>Controllo utilizzato per eseguire i postback.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta un valore che indica se l'output della pagina viene inserito nel buffer.</summary>
        <value>
          <see langword="true" /> se l'output della pagina viene inserito nel buffer, altrimenti <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare il <xref:System.Web.UI.Page.Buffer%2A> attributo `true` utilizzando la direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta la proprietà.  
  
> [!NOTE]
>  Il <xref:System.Web.UI.Page.Buffer%2A> proprietà imposta e ottiene il <xref:System.Web.HttpResponse.BufferOutput%2A> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.Caching.Cache" /> associato all'applicazione in cui risiede la pagina.</summary>
        <value>L'oggetto <see cref="T:System.Web.Caching.Cache" /> associato all'applicazione della pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione <xref:System.Web.Caching.Cache> oggetto consente di archiviare e recuperare dati arbitrari nelle richieste successive. La cache non è associata a una sessione utente o di pagina. Utilizzato principalmente per migliorare le prestazioni dell'applicazione. Per ulteriori informazioni, vedere [la memorizzazione nella cache di dati dell'applicazione](http://msdn.microsoft.com/library/206f977d-7860-4d20-bdd5-c3b3d8479f3d). Per ulteriori informazioni sulla differenza tra l'applicazione di memorizzazione nella cache e la cache di output di pagina, vedere [Cenni preliminari sulla memorizzazione nella cache di ASP.NET](http://msdn.microsoft.com/library/5ec28012-4972-4dc3-b3e8-9d20401fe11d).  
  
   
  
## Examples  
 Esempio di codice seguente consente di inserire la somma di due interi nel <xref:System.Web.Caching.Cache?displayProperty=nameWithType> utilizzando il <xref:System.Web.UI.Page.Cache%2A?displayProperty=nameWithType> proprietà. Viene quindi recuperato il valore utilizzando il <xref:System.Web.Caching.Cache.Get%2A?displayProperty=nameWithType> metodo e viene scritto in un <xref:System.Web.UI.WebControls.Label> controllo server Web.  
  
 [!code-csharp[System.Web.Page.Cache_Replacement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/CS/pagecachecs.aspx#1)]
 [!code-vb[System.Web.Page.Cache_Replacement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/VB/pagecachevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Non è stata creata un'istanza di <see cref="T:System.Web.Caching.Cache" />.</exception>
        <altmember cref="T:System.Web.Caching.Cache" />
      </Docs>
    </Member>
    <Member MemberName="ClientQueryString">
      <MemberSignature Language="C#" Value="public string ClientQueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientQueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientQueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientQueryString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientQueryString { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la parte relativa alla stringa di query dell'URL richiesto.</summary>
        <value>La parte relativa alla stringa di query dell'URL richiesto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.ClientQueryString%2A> proprietà contiene la parte della stringa di query dell'URL richiesto dal browser. Se, ad esempio, l'URL richiesto è "http://www.contoso.com/default.aspx?id=100", il <xref:System.Web.UI.Page.ClientQueryString%2A> conterrà proprietà "id = 100". Il <xref:System.Web.UI.Page.ClientQueryString%2A> codificata di proprietà, utilizzare il <xref:System.Web.HttpServerUtility.UrlDecode%2A?displayProperty=nameWithType> metodo decodificare la stringa di query.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.ClientScriptManager ClientScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ClientScriptManager ClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientScript As ClientScriptManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ClientScriptManager ^ ClientScript { System::Web::UI::ClientScriptManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientScriptManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Web.UI.ClientScriptManager" /> utilizzato per gestire, registrare e aggiungere script nella pagina.</summary>
        <value>Un oggetto <see cref="T:System.Web.UI.ClientScriptManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Web.UI.Page.ClientScript%2A> proprietà da ottenere un <xref:System.Web.UI.ClientScriptManager> oggetto che può essere usato per registrare, gestire e aggiungere uno script a una pagina Web. Per altre informazioni, vedere la classe <xref:System.Web.UI.ClientScriptManager>.  
  
 Il <xref:System.Web.UI.ClientScriptManager> classe è nuova in [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] e sostituisce <xref:System.Web.UI.Page> classe metodi per la gestione di script che ora sono deprecate.  
  
   
  
## Examples  
 Per un esempio, vedere il <xref:System.Web.UI.ClientScriptManager> Cenni preliminari sulla classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="ClientTarget">
      <MemberSignature Language="C#" Value="public string ClientTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientTarget" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientTarget As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientTarget { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che consente di eseguire l'override del rilevamento automatico delle funzionalità del browser e di specificare il rendering di una pagina per client che utilizzano browser specifici.</summary>
        <value>Un oggetto <see cref="T:System.String" /> che specifica le funzionalità del browser che si desidera ignorare.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non si imposta il <xref:System.Web.UI.Page.ClientTarget%2A> proprietà, il <xref:System.Web.HttpBrowserCapabilities> oggetto associato di <xref:System.Web.UI.Page.Request%2A?displayProperty=nameWithType> proprietà rifletterà le funzionalità del browser del client. Se si imposta questa proprietà, utilizza la pagina associata al valore (alias) che fornisce funzionalità del browser è disabilitato il rilevamento del browser client.  
  
 Il file di configurazione radice Web. config sul computer server Web definisce gli alias predefiniti seguenti che è possibile utilizzare come una sintassi abbreviata per le stringhe agente utente comuni:  
  
-   `uplevel`, che consente di specificare le funzionalità del browser equivalente a Internet Explorer 6.0.  
  
-   `downlevel`, che consente di specificare le funzionalità del browser equivalente ai browser meno recenti che non supportano lo script client. È possibile utilizzare l'alias per determinare come funzionerebbero le pagine Web in un browser che dispone di script client disabilitato.  
  
 È possibile impostare l'alias a livello di programmazione utilizzando questa proprietà, oppure è possibile impostare in modo dichiarativo utilizzando la `ClientTarget` attributo della direttiva.  
  
 È possibile definire un alias aggiuntivi nel `clientTarget` sezione del file Web. config a livello di applicazione. Per ulteriori informazioni, vedere [clientTarget Element (Schema delle impostazioni ASP.NET)](http://msdn.microsoft.com/library/17a0fa6e-a065-49cc-b900-ef73eda6a922).  
  
   
  
## Examples  
 L'esempio di codice seguente definisce un `ie302` alias e include sezioni necessarie per configurare l'applicazione nel file Web. config. Usando questo alias, è possibile impostare il <xref:System.Web.UI.Page.ClientTarget%2A> proprietà `ie302` e personalizzare le pagine in modo specifico per i browser Internet Explorer 3.02.  
  
```  
<configuration>  
  <system.web>  
   <clientTarget>  
    <add alias="ie302" useragent="Mozilla/2.0 (compatible; MSIE 3.02; Windows NT 3.5)" />  
   </clientTarget>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public int CodePage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CodePage { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta l'identificatore della tabella codici per l'oggetto <see cref="T:System.Web.UI.Page" /> corrente.</summary>
        <value>Un intero che rappresenta l'identificatore della tabella codici per l'oggetto <see cref="T:System.Web.UI.Page" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare il `CodePage` attributo sul valore desiderato utilizzando la direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta la proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta il tipo MIME HTTP per l'oggetto <see cref="T:System.Web.HttpResponse" /> associato alla pagina.</summary>
        <value>Il tipo MIME HTTP associato alla pagina corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare il `ContentType` attributo mediante la direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta la proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal override System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.HttpContext" /> associato alla pagina.</summary>
        <value>Un oggetto <see cref="T:System.Web.HttpContext" /> che contiene informazioni associate alla pagina corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà fornisce l'accesso programmatico al contesto di che esecuzione della pagina, incluse le informazioni sulla richiesta, risposta, sessione e dell'applicazione.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Web.UI.Page.Context%2A> proprietà a cui accedere il <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> e <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> metodi e <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> proprietà. L'esempio crea tre eccezioni personalizzate tramite il <xref:System.Web.HttpContext.AddError%2A> metodo e viene utilizzato il <xref:System.Web.HttpContext.AllErrors%2A> proprietà per caricare queste eccezioni in una matrice. Quindi scrive la matrice alla pagina contenente e utilizza il <xref:System.Web.HttpContext.ClearError%2A> metodo per cancellare tutti gli errori del <xref:System.Web.UI.Page.Context%2A> proprietà.  
  
 [!code-csharp[System.Web.UI.Page.Context#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Context/CS/pagecontextcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Context#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Context/VB/pagecontextvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriter">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.UI.HtmlTextWriter CreateHtmlTextWriter (System.IO.TextWriter tw);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Web.UI.HtmlTextWriter CreateHtmlTextWriter(class System.IO.TextWriter tw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateHtmlTextWriter (tw As TextWriter) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriter(System::IO::TextWriter ^ tw);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="tw">Classe <see cref="T:System.IO.TextWriter" /> utilizzata per creare l'oggetto <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <summary>Crea un oggetto <see cref="T:System.Web.UI.HtmlTextWriter" /> per eseguire il rendering del contenuto della pagina.</summary>
        <returns>Oggetto <see cref="T:System.Web.UI.HtmlTextWriter" /> o <see cref="T:System.Web.UI.Html32TextWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> metodo crea un <xref:System.IO.TextWriter> tramite il <xref:System.Web.HttpRequest.Browser%2A> proprietà del <xref:System.Web.HttpContext.Request%2A> oggetto associato alla richiesta di pagina. È possibile aggiungere un riferimento a un <xref:System.Web.UI.HtmlTextWriter> nel `browserCaps` sezione di configurazione. Eseguire l'override di <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> metodo per effettuare una ricerca personalizzata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> metodo per creare un'istanza di un oggetto personalizzato <xref:System.Web.UI.HtmlTextWriter> oggetto denominato `MyHtmlTextWriter`. Il <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> metodo sottoposto a override nel `MyPage` (classe), che deriva da <xref:System.Web.UI.Page>, in modo che `MyHtmlTextWriter` esegue il rendering di controlli server ASP.NET quando viene richiesta la pagina. Si noti che in questo esempio impedisce all'adattatore <xref:System.IO.TextWriter> comportamento.  
  
 [!code-csharp[Page_CreateHtmlTextWriter#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/CS/page_createhtmltextwriter.cs#2)]
 [!code-vb[Page_CreateHtmlTextWriter#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/VB/page_createhtmltextwriter.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Html32TextWriter" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriterFromType">
      <MemberSignature Language="C#" Value="public static System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType (System.IO.TextWriter tw, Type writerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType(class System.IO.TextWriter tw, class System.Type writerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateHtmlTextWriterFromType (tw As TextWriter, writerType As Type) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriterFromType(System::IO::TextWriter ^ tw, Type ^ writerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
        <Parameter Name="writerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tw">Classe <see cref="T:System.IO.TextWriter" /> utilizzata per creare l'oggetto <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <param name="writerType">Tipo di writer di testo da creare.</param>
        <summary>Crea un oggetto <see cref="T:System.Web.UI.HtmlTextWriter" /> specificato per il rendering del contenuto della pagina.</summary>
        <returns>Un oggetto <see cref="T:System.Web.UI.HtmlTextWriter" /> che esegue il rendering del contenuto della pagina.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato internamente negli adattatori di pagina.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Il parametro <paramref name="writerType" /> è impostato su un tipo non valido.</exception>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public string Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Culture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Culture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta l'ID delle impostazioni cultura per l'oggetto <see cref="T:System.Threading.Thread" /> associato alla pagina.</summary>
        <value>Un ID delle impostazioni cultura valido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il `Culture` attributo della direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta il valore di questa proprietà. Inoltre, è possibile impostare in modo esplicito il valore di <xref:System.Web.UI.Page.Culture%2A> proprietà a livello di codice o un elemento di Web. config file.  
  
 Il <xref:System.Web.UI.Page.Culture%2A> proprietà viene utilizzata per localizzare il contenuto della pagina. È possibile impostarlo su qualsiasi ID delle impostazioni cultura valido. Ad esempio, il `en-us` ID delle impostazioni cultura imposta l'American while in lingua inglese, il `fr` ID delle impostazioni cultura imposta il francese. È inoltre possibile impostare il valore `auto` che eseguirà il rilevamento automatico del browser della lingua preferita e impostarla. Il rilevamento automatico della lingua può essere qualificato con un valore predefinito, ad esempio `auto:en-us`.  
  
 Per ulteriori informazioni, vedere il <xref:System.Globalization.CultureInfo> Cenni preliminari sulla classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
      </Docs>
    </Member>
    <Member MemberName="DesignerInitialize">
      <MemberSignature Language="C#" Value="public void DesignerInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DesignerInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DesignerInitialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub DesignerInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DesignerInitialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esegue l'inizializzazione dell'istanza della classe <see cref="T:System.Web.UI.Page" /> richiesta dagli strumenti per lo sviluppo rapido di applicazioni (RAD, Rapid Application Development), qualsiasi essa sia. Questo metodo è usato solo in fase di progettazione.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.UserControl.DesignerInitialize" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackMode">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackMode () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un insieme <see cref="T:System.Collections.Specialized.NameValueCollection" /> di dati di cui è stato eseguito il postback nella pagina tramite un comando POST o GET.</summary>
        <returns>Un oggetto <see cref="T:System.Collections.Specialized.NameValueCollection" /> che contiene i dati del form. Se per il postback è stato utilizzato il comando POST, verranno restituite le informazioni relative al form dall'oggetto <see cref="P:System.Web.UI.Page.Context" />. Se per il postback è stato utilizzato il comando GET, verranno restituite le informazioni relative alla stringa di query. Se quella pagina non era mai stata richiesta prima, viene restituito il valore <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.DeterminePostBackMode%2A> metodo restituisce un <xref:System.Collections.Specialized.NameValueCollection> oggetto che contiene i dati eseguito il postback della pagina. La presenza della pagina nascosti VIEWSTATE ed EVENTTARGET viene utilizzato per determinare se si è verificato un evento di postback. Il <xref:System.Web.UI.Page.IsPostBack%2A> proprietà viene impostata quando il <xref:System.Web.UI.Page.DeterminePostBackMode%2A> metodo viene chiamato.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackModeUnvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackModeUnvalidated" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackModeUnvalidated () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackModeUnvalidated();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una raccolta nome-valore di dati inviata nella pagina utilizzando un comando POST o GET, senza eseguire la convalida delle richieste ASP.NET.</summary>
        <returns>Oggetto che contiene i dati del form non convalidati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni, vedere la classe <xref:System.Web.UnvalidatedRequestValues>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEventValidation">
      <MemberSignature Language="C#" Value="public virtual bool EnableEventValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableEventValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableEventValidation" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableEventValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableEventValidation { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la pagina esegue la convalida degli eventi di postback e di callback.</summary>
        <value>
          <see langword="true" /> se la pagina esegue la convalida degli eventi postback e callback; in caso contrario <see langword="false" />. L'impostazione predefinita è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Web.UI.Page.EnableEventValidation%2A> è impostata su `true`, ASP.NET convalida che un evento di controllo ha avuto origine dall'interfaccia utente di cui è stato eseguito il rendering da tale controllo. Un controllo Registra gli eventi durante il rendering e quindi eseguirne la convalida durante la gestione di postback o callback. Ad esempio, se un controllo elenco include opzioni numerate 1, 2 o 3 quando viene eseguito il rendering della pagina e se viene ricevuta una richiesta di postback che specifica il numero di opzione 4, ASP.NET genera un'eccezione. Per impostazione predefinita, tutti i controlli basati sugli eventi in ASP.NET utilizzano questa funzionalità.  
  
 Se si scrive uno script di client che modifica un controllo nel client in fase di esecuzione, è necessario utilizzare il <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metodo per evitare errori di convalida evento false.  
  
> [!IMPORTANT]
>  Questa funzionalità riduce il rischio di richieste di postback non autorizzate o malintenzionate e i callback. Si consiglia di non disattivare la convalida degli eventi.  
  
 Impostare il <xref:System.Web.UI.Page.EnableEventValidation%2A> proprietà impostando il `enableEventValidation` attributo della direttiva o `enableEventValidation` attributo dell'elemento nel file Web. config. Se si imposta questa proprietà nel codice, è necessario impostare prima dell'inizializzazione della pagina.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Web.UI.Page.EnableEventValidation" /> è stata impostata dopo l'inizializzazione della pagina.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
        <altmember cref="T:System.Web.UI.SupportsEventValidationAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public override bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la pagina conserva il proprio stato di visualizzazione e lo stato di visualizzazione dei controlli server in essa contenuti quando termina la richiesta della pagina corrente.</summary>
        <value>
          <see langword="true" /> se la pagina conserva lo stato di visualizzazione, altrimenti <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sui motivi per cui è consigliabile disabilitare lo stato di visualizzazione, vedere <xref:System.Web.UI.Control.EnableViewState%2A?displayProperty=nameWithType>.  
  
 Anche se <xref:System.Web.UI.Page.EnableViewState%2A> è `false`, la pagina può contenere un campo nascosto visualizzazione stato che viene utilizzato da ASP.NET per rilevare un postback.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Web.UI.Page.EnableViewState%2A> proprietà `false` quando viene caricata la pagina. Disabilita lo stato di visualizzazione per il <xref:System.Web.UI.Page> oggetto, ovvero le informazioni sullo stato di visualizzazione per la pagina né tutti i controlli contenuti nella pagina vengono salvate.  
  
> [!IMPORTANT]
>  L'esempio include una casella di testo che accetta l'input dell'utente e rappresenta quindi una potenziale minaccia alla sicurezza. Per impostazione predefinita, le pagine Web ASP.NET verificano che l'input dell'utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/CS/page_enableviewstate.cs#1)]
 [!code-vb[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/VB/page_enableviewstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewStateMac" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewStateMac">
      <MemberSignature Language="C#" Value="public bool EnableViewStateMac { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewStateMac" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewStateMac" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableViewStateMac As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableViewStateMac { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se ASP.NET deve eseguire un controllo dei codici MAC (Message Authentication Check) nello stato di visualizzazione della pagina quando viene eseguito il postback della pagina dal client.</summary>
        <value>
          <see langword="true" /> se lo stato di visualizzazione deve essere sottoposto al controllo MAC e codificato, altrimenti <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo stato di visualizzazione MAC è una versione crittografata della variabile nascosta in modo permanente lo stato di visualizzazione della pagina a quando la pagina viene inviata al browser. Quando questa proprietà è impostata su `true`, lo stato di visualizzazione crittografato viene controllato per verificare che non sia stato modificato sul client.  
  
 Non impostare questa proprietà nel codice. Impostare il `EnableViewStateMac` attributo mediante la direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta la proprietà.  
  
> [!IMPORTANT]
>  Questo attributo non deve mai essere impostato su `false` nel sito Web di produzione, anche se l'applicazione o pagina non utilizza lo stato di visualizzazione. Lo stato di visualizzazione MAC consente di garantire la sicurezza di altre funzioni ASP.NET oltre lo stato di visualizzazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewState" />
      </Docs>
    </Member>
    <Member MemberName="ErrorPage">
      <MemberSignature Language="C#" Value="public string ErrorPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ErrorPage" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorPage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorPage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la pagina di errore alla quale è reindirizzato il browser richiedente nel caso di un'eccezione di pagina non gestita.</summary>
        <value>La pagina di errore alla quale è reindirizzato il browser.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page_ErrorPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_ErrorPage/CS/page_errorpage.cs.aspx#1)]
 [!code-vb[Page_ErrorPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_ErrorPage/VB/page_errorpage.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteRegisteredAsyncTasks">
      <MemberSignature Language="C#" Value="public void ExecuteRegisteredAsyncTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteRegisteredAsyncTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecuteRegisteredAsyncTasks ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecuteRegisteredAsyncTasks();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia l'esecuzione di un'attività asincrona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definire un'attività asincrona utilizzando il <xref:System.Web.UI.PageAsyncTask> classe. Dopo l'attività è definito e viene registrato con la pagina utilizzando la <xref:System.Web.UI.Page.RegisterAsyncTask%2A> (metodo), il <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> metodo può essere richiamato per iniziare l'attività asincrona.  
  
 Il <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> metodo viene chiamato automaticamente nel punto in cui l'elaborazione della pagina eventuali registrate attività asincrone, se presenti, vengono richiamati per una pagina non asincrona. Questa chiamata automatica di <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> si verifica subito prima di <xref:System.Web.UI.Page.PreRenderComplete> evento. Chiamare il <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> metodo per attività che si desidera richiamare in un momento diverso da chiamata automatica di questo metodo. Si noti che verranno eseguite solo una volta anche se le attività asincrone <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> può essere chiamato più volte.  
  
 Il <xref:System.Web.UI.Page.AsyncTimeout%2A> viene reimpostata a ogni chiamata al <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> metodo. L'ultimo valore della <xref:System.Web.UI.Page.AsyncTimeout%2A> prima di richiamare il <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> metodo ha la precedenza. Se un'attività asincrona richiede più il <xref:System.Web.UI.Page.AsyncTimeout%2A>, le attività successive richiamate durante tale <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> timeout della chiamata vengono immediatamente.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.Page.AsyncTimeout%2A> proprietà con il <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> e <xref:System.Web.UI.Page.RegisterAsyncTask%2A> metodi. Si noti l'utilizzo di gestori di inizio, fine e timeout. Nell'esempio viene introdotto un ritardo artificiale per illustrare il caso di un'attività asincrona che supera il tempo per l'attività come specificato nella <xref:System.Web.UI.Page.AsyncTimeout%2A> proprietà. In uno scenario reale, un'attività asincrona può essere usata per eseguire chiamate al database o la generazione di immagini, ad esempio, e il gestore di timeout fornisce una riduzione del se l'attività non viene eseguita in un periodo di tempo specificato.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Si è verificata un'eccezione nell'attività asincrona.</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="FileDependencies">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList FileDependencies { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList FileDependencies" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.FileDependencies" />
      <MemberSignature Language="VB.NET" Value="Protected Property FileDependencies As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::ArrayList ^ FileDependencies {  void set(System::Collections::ArrayList ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is HttpResponse.AddFileDependencies. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta una matrice di file dalla quale dipende l'oggetto <see cref="T:System.Web.HttpResponse" /> corrente.</summary>
        <value>La matrice di file dalla quale dipende l'oggetto <see cref="T:System.Web.HttpResponse" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La proprietà è stata deprecata. Utilizzare il <xref:System.Web.HttpResponse.AddFileDependencies%2A> (metodo) o <xref:System.Web.HttpResponse.AddFileDependency%2A> metodo la <xref:System.Web.HttpResponse> classe.  
  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare il `FileDependencies` attributo `true` utilizzando la direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta la proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public override System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Identificatore del controllo da ricercare.</param>
        <summary>Cerca un controllo server con l'identificatore specificato nel contenitore dei nomi della pagina.</summary>
        <returns>Il controllo specificato oppure <see langword="null" /> se il controllo specificato non esiste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.FindControl%2A> metodo può essere utilizzato per accedere a un controllo cui <xref:System.Web.UI.Control.ID%2A> non è disponibile in fase di progettazione. Il metodo effettua la ricerca solo della pagina immediato di primo livello contenitore; viene eseguita non in modo ricorsivo ricerca per i controlli nei contenitori di denominazione contenuti nella pagina. Per accedere a controlli in un contenitore di denominazione subordinato, chiamare il `FindControl` metodo del contenitore.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Web.UI.Page.FindControl%2A> metodo per individuare i controlli all'interno dei modelli. In questo esempio, due <xref:System.Web.UI.WebControls.Repeater> i controlli vengono definiti; ognuna viene illustrato un modo diverso per rilevare il <xref:System.Web.UI.WebControls.LinkButton.Click> evento di un <xref:System.Web.UI.WebControls.LinkButton> all'interno del modello di elemento repeater.  
  
 [!code-aspx-csharp[System.Web.UI.Page_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/cs/pagefindcontrolcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/vb/pagefindcontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlForm Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As HtmlForm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlForm ^ Form { System::Web::UI::HtmlControls::HtmlForm ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il form HTML della pagina.</summary>
        <value>L'oggetto <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> associato alla pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Web.UI.Page.Form%2A> proprietà per accedere ai metodi e proprietà del <xref:System.Web.UI.HtmlControls.HtmlForm> oggetto che costituisce la base della gerarchia del controllo nella pagina.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected override void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FrameworkInitialize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub FrameworkInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void FrameworkInitialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizializza l'albero dei controlli durante la generazione della pagina in base alla natura dichiarativa della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.FrameworkInitialize%2A> metodo inizializza la <xref:System.Web.UI.Page> dell'oggetto e crea la struttura di controllo in base alla natura dichiarativa della pagina. Il <xref:System.Web.UI.Page.FrameworkInitialize%2A> metodo sottoposto a override per la generazione di codice e di analisi di pagina per la <xref:System.Web.UI.Page> classe per una pagina dichiarativa. In genere, si consiglia di non sulla necessità di eseguire l'override di questo metodo. Se si esegue l'override, assicurarsi di chiamare la classe base <xref:System.Web.UI.Page.FrameworkInitialize%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="GetDataItem">
      <MemberSignature Language="C#" Value="public object GetDataItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetDataItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetDataItem" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDataItem () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetDataItem();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'elemento di dati in cima allo stack del contesto dell'associazione dati.</summary>
        <returns>L'oggetto in cima allo stack del contesto dell'associazione dati.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Non esiste un contesto dell'associazione dati per la pagina.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientEvent">
      <MemberSignature Language="C#" Value="public string GetPostBackClientEvent (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientEvent(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientEvent(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientEvent(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Controllo server che riceve il postback dell'evento client.</param>
        <param name="argument">Oggetto <see cref="T:System.String" /> passato a <see cref="M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)" />.</param>
        <summary>Ottiene un riferimento che può essere usato in un evento client per eseguire il postback al server per il controllo specificato e con gli argomenti dell'evento indicati.</summary>
        <returns>Stringa che rappresenta l'evento client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere la <xref:System.Web.UI.ClientScriptManager> classe per le alternative a questo membro obsoleto.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.Button.OnClientClick" />
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackClientHyperlink. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Controllo server per l'elaborazione del postback.</param>
        <param name="argument">Parametro passato al controllo server.</param>
        <summary>Ottiene un riferimento, all'inizio del quale viene aggiunto <see langword="javascript:" />, utilizzabile in un evento client per eseguire il postback nel server per il controllo specificato e con gli argomenti dell'evento specificati.</summary>
        <returns>Una stringa che rappresenta una chiamata JavaScript alla funzione di postback contenente l'ID del controllo di destinazione e gli argomenti dell'evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere il <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> metodo per un'alternativa a questo membro obsoleto.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una stringa utilizzabile in un evento client per causare il postback nel server. Questo metodo è stato deprecato. Utilizzare in alternativa il metodo <see cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" /> nella classe <see cref="T:System.Web.UI.ClientScriptManager" />.</summary>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Controllo server per l'elaborazione del postback sul server.</param>
        <summary>Restituisce una stringa utilizzabile in un evento client per causare il postback nel server. La stringa di riferimento è definita dall'oggetto <see cref="T:System.Web.UI.Control" /> specificato.</summary>
        <returns>Stringa che, quando viene trattata come script nel client, avvia il postback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è stato deprecato. Utilizzare in alternativa il metodo <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> nella classe <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#2)]
 [!code-vb[Page_GetPostBackEventReference#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Controllo server per l'elaborazione del postback.</param>
        <param name="argument">Parametro passato al controllo server.</param>
        <summary>Restituisce una stringa utilizzabile in un evento client per causare il postback nel server. La stringa del riferimento è definita dal controllo specificato che gestisce il postback e da un argomento stringa contenente informazioni aggiuntive sull'evento.</summary>
        <returns>Stringa che, quando viene trattata come script nel client, avvia il postback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è stato deprecato. Utilizzare in alternativa il metodo <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> nella classe <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#1)]
 [!code-vb[Page_GetPostBackEventReference#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetTypeHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetTypeHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetTypeHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetTypeHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un codice hash generato da oggetti <see cref="T:System.Web.UI.Page" /> a loro volta generati in fase di esecuzione. Questo codice hash appartiene esclusivamente alla gerarchia di controlli dell'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Il codice hash generato in fase di esecuzione. Il valore predefinito è 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esegue l'override di questo metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValidators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection GetValidators (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ValidatorCollection GetValidators(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetValidators(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValidators (validationGroup As String) As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::ValidatorCollection ^ GetValidators(System::String ^ validationGroup);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Gruppo di convalida da restituire oppure <see langword="null" /> per restituire il gruppo di convalida predefinito.</param>
        <summary>Restituisce un insieme di validator dei controlli per un gruppo di convalida specificato.</summary>
        <returns>Un insieme <see cref="T:System.Web.UI.ValidatorCollection" /> contenente i validator dei controlli per il gruppo di convalida specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.GetValidators%2A> metodo restituisce tutti gli oggetti di convalida associati a un gruppo di convalida specifici. È possibile restituire il gruppo di convalida predefinito (tutti i controlli di convalida associati ai controlli senza il `ValidationGroup` set di proprietà) impostando il `validationGroup` parametro `null`.  
  
 Per convalidare i membri del gruppo di convalida, è possibile enumerare la raccolta e la chiamata di <xref:System.Web.UI.IValidator.Validate%2A> di ogni convalida il metodo restituito.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Web.UI.Page.GetValidators%2A> per restituire il gruppo di convalida predefinito.  
  
 [!code-csharp[PageGetValidators#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageGetValidators/CS/pagegetvalidatorscs.aspx#1)]
 [!code-vb[PageGetValidators#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageGetValidators/VB/pagegetvalidatorsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.Validate(System.String)" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
      </Docs>
    </Member>
    <Member MemberName="GetWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected object GetWrappedFileDependencies (string[] virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetWrappedFileDependencies(string[] virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetWrappedFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetWrappedFileDependencies (virtualFileDependencies As String()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetWrappedFileDependencies(cli::array &lt;System::String ^&gt; ^ virtualFileDependencies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Matrice di stringhe contenente i percorsi di file virtuali.</param>
        <summary>Restituisce un elenco di nomi di file fisici che corrispondono a un elenco di percorsi di file virtuali.</summary>
        <returns>Un oggetto contenente un elenco di percorsi di file fisici.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.GetWrappedFileDependencies%2A> metodo ottiene un elenco di file, ad esempio i file di controllo utente, che costituiscono la pagina corrente. Se uno di questi file vengono modificato, alla successiva richiesta viene compilata l'intera pagina. Esegue l'override di questo metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlHead Header { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlHead Header" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Header" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Header As HtmlHead" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlHead ^ Header { System::Web::UI::HtmlControls::HtmlHead ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlHead</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'intestazione di documento della pagina se l'elemento <see langword="head" /> è definito con un tag <see langword="runat=server" /> nella dichiarazione della pagina.</summary>
        <value>Controllo <see cref="T:System.Web.UI.HtmlControls.HtmlHead" /> che contiene l'intestazione di pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.Header%2A> proprietà ottiene un riferimento a un <xref:System.Web.UI.HtmlControls.HtmlHead> che è possibile utilizzare per impostare le informazioni di intestazione di documento per la pagina. Il <xref:System.Web.UI.HtmlControls.HtmlHead> consente di aggiungere informazioni quali fogli di stile, le regole di stile, un titolo e metadati per il `head` elemento.  
  
> [!NOTE]
>  Aggiunta di stili a livello di codice utilizzando i metodi del <xref:System.Web.UI.IStyleSheet> interfaccia durante i postback asincroni non è supportata. Quando si aggiungono funzionalità AJAX a una pagina Web, i postback asincroni aggiornano aree della pagina senza aggiornare la pagina intera. Per ulteriori informazioni, vedere [Panoramica di Microsoft Ajax](http://msdn.microsoft.com/library/be84d9b3-b7cd-47d7-8494-be4abfaad9cb).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come accedere il <xref:System.Web.UI.HtmlControls.HtmlHead> controllare a livello di codice mediante il <xref:System.Web.UI.Page.Header%2A> proprietà. Oggetto `title` elemento e `style` elemento vengono aggiunti per il `head` elemento della pagina.  
  
 [!code-aspx-csharp[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/CS/htmlheadclasscs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/VB/htmlheadclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlHead" />
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlLink" />
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public override string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un identificatore per una particolare istanza della classe <see cref="T:System.Web.UI.Page" />.</summary>
        <value>L'identificatore dell'istanza della classe <see cref="T:System.Web.UI.Page" />. Il valore predefinito è '_Page'.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="public virtual char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char IdSeparator { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il carattere utilizzato per separare gli identificatori di controllo durante la compilazione di un ID univoco per un controllo in una pagina.</summary>
        <value>Il carattere utilizzato per separare gli identificatori di controllo. Il valore predefinito è impostato dall'istanza <see cref="T:System.Web.UI.Adapters.PageAdapter" /> che esegue il rendering della pagina. La proprietà <see cref="P:System.Web.UI.Page.IdSeparator" /> è un campo del lato server e non deve essere modificata.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.ID" />
      </Docs>
    </Member>
    <Member MemberName="InitComplete">
      <MemberSignature Language="C#" Value="public event EventHandler InitComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InitComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.InitComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InitComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ InitComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica alla fine della fase di inizializzazione della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.InitComplete> eventi viene chiamato alla fine della fase di inizializzazione della pagina. In questa fase del ciclo di vita della pagina, tutti dichiarati i controlli nella pagina vengono inizializzati, ma lo stato della pagina non è ancora popolato. È possibile accedere a controlli del server, ma non ancora conterranno le informazioni restituite da parte dell'utente.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [NIB: utilizzo degli eventi](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="InitializeCulture">
      <MemberSignature Language="C#" Value="protected virtual void InitializeCulture ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeCulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitializeCulture" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeCulture ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeCulture();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta le proprietà <see cref="P:System.Web.UI.Page.Culture" /> e <see cref="P:System.Web.UI.Page.UICulture" /> per il thread corrente della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.InitializeCulture%2A> (metodo) non contiene alcuna logica di codifica. Gli sviluppatori di estendere la funzionalità del controllo il <xref:System.Web.UI.Page> classe può eseguire l'override di <xref:System.Web.UI.Page.InitializeCulture%2A> metodo per inizializzare il <xref:System.Web.UI.Page.Culture%2A> e <xref:System.Web.UI.Page.UICulture%2A> informazioni per la pagina.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.Web.UI.Page.FrameworkInitialize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InitOutputCache">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza la cache di output per la richiesta della pagina corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non deve essere usato direttamente dal codice. Per abilitare e gestire la memorizzazione nella cache di output per una pagina, utilizzare uno di questi approcci:  
  
-   Impostare le opzioni in modo dichiarativo utilizzando la direttiva nel file con estensione aspx.  
  
-   Utilizzare i metodi e le proprietà di <xref:System.Web.HttpCachePolicy> (classe), che viene esposto dal `Response.Cache` oggetto nel codice della pagina.  
  
 Per ulteriori informazioni, vedere [la memorizzazione nella cache le pagine ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected internal virtual void InitOutputCache (System.Web.UI.OutputCacheParameters cacheSettings);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitOutputCache(class System.Web.UI.OutputCacheParameters cacheSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Web.UI.OutputCacheParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub InitOutputCache (cacheSettings As OutputCacheParameters)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void InitOutputCache(System::Web::UI::OutputCacheParameters ^ cacheSettings);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheSettings" Type="System.Web.UI.OutputCacheParameters" />
      </Parameters>
      <Docs>
        <param name="cacheSettings">Oggetto <see cref="T:System.Web.UI.OutputCacheParameters" /> contenente le impostazioni della cache.</param>
        <summary>Inizializza la cache di output per la richiesta della pagina corrente in base a un oggetto <see cref="T:System.Web.UI.OutputCacheParameters" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è necessario chiamare questo metodo. Per abilitare e gestire la memorizzazione nella cache di output per una pagina, utilizzare la direttiva nel file aspx, o i metodi e proprietà del <xref:System.Web.HttpCachePolicy> classe. Sono accessibili tramite `Response.Cache` sintassi dichiarazione code-behind o blocco di file di codice della pagina. Per ulteriori informazioni, vedere [la memorizzazione nella cache le pagine ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Il profilo della cache non è stato trovato.  \- oppure - Manca una direttiva o un attributo relativo al profilo delle impostazioni di configurazione.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il percorso delle impostazioni della cache di output non è valido.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">Intervallo di tempo durante il quale gli oggetti memorizzati nella cache di output sono validi.</param>
        <param name="varyByHeader">Elenco di intestazioni separate da punto e virgola in base a cui varia il contenuto proveniente dalla cache di output.</param>
        <param name="varyByCustom">Intestazione HTTP di <see langword="Vary" />.</param>
        <param name="location">Uno dei valori di <see cref="T:System.Web.UI.OutputCacheLocation" />.</param>
        <param name="varyByParam">Elenco separato da punto e virgola di parametri ricevuti da un metodo GET o POST in base a cui varia il contenuto proveniente dalla cache di output.</param>
        <summary>Inizializza la cache di output per la richiesta della pagina corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è necessario chiamare questo metodo. Per abilitare e gestire la memorizzazione nella cache di output per una pagina, utilizzare la direttiva nel file aspx, o i metodi e proprietà del <xref:System.Web.HttpCachePolicy> classe. Sono accessibili tramite `Response.Cache` sintassi nel codice della pagina. Per ulteriori informazioni, vedere [la memorizzazione nella cache le pagine ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">È stato specificato un valore non valido per <paramref name="location" />.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByContentEncoding As String, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByContentEncoding, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByContentEncoding" Type="System.String" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">Intervallo di tempo durante il quale gli oggetti memorizzati nella cache di output sono validi.</param>
        <param name="varyByContentEncoding">Elenco separato da punto e virgola di set di caratteri (codifiche del contenuto) in base a cui varia il contenuto proveniente dalla cache di output.</param>
        <param name="varyByHeader">Elenco di intestazioni separate da punto e virgola in base a cui varia il contenuto proveniente dalla cache di output.</param>
        <param name="varyByCustom">Intestazione HTTP di <see langword="Vary" />.</param>
        <param name="location">Uno dei valori di <see cref="T:System.Web.UI.OutputCacheLocation" />.</param>
        <param name="varyByParam">Elenco separato da punto e virgola di parametri ricevuti da un metodo GET o POST in base a cui varia il contenuto proveniente dalla cache di output.</param>
        <summary>Inizializza la cache di output per la richiesta della pagina corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è necessario chiamare questo metodo. Per abilitare e gestire la memorizzazione nella cache di output per una pagina, utilizzare la direttiva nel file con estensione aspx, o i metodi e proprietà del <xref:System.Web.HttpCachePolicy> classe. Sono accessibili tramite `Response.Cache` sintassi nel codice della pagina. Per ulteriori informazioni, vedere [la memorizzazione nella cache le pagine ASP.NET](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">È stato specificato un valore non valido per <paramref name="location" />.</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la pagina viene elaborata in modo asincrono.</summary>
        <value>
          <see langword="true" /> se la pagina è in modalità asincrona, altrimenti <see langword="false" />;</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Web.UI.Page.IsAsync%2A> proprietà per determinare se la pagina Web è in esecuzione in modalità asincrona. Queste informazioni sono utili se è necessario modificarne il comportamento a seconda che la pagina sia asincrona controlli o al codice della pagina. Per ulteriori informazioni sulla programmazione asincrona, vedere [operazioni asincrone](~/docs/framework/data/adonet/sql/asynchronous-operations.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCallback">
      <MemberSignature Language="C#" Value="public bool IsCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCallback { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la richiesta della pagina è dovuta a un callback.</summary>
        <value>
          <see langword="true" /> se la richiesta della pagina è dovuta a un callback; in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere [implementazione di callback Client senza postback](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsClientScriptBlockRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave stringa dello script client da ricercare.</param>
        <summary>Determina se il blocco di script client con la chiave specificata è registrato con la pagina.</summary>
        <returns>
          <see langword="true" /> se il blocco di script è registrato, altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A?displayProperty=nameWithType> per evitare inutile dello script lato client. Ciò è particolarmente importante se lo script richiede una grande quantità di risorse server da creare.  
  
 Il metodo <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> è stato deprecato. Utilizzare il <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metodo la <xref:System.Web.UI.ClientScriptManager> classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> metodo in combinazione con il <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> metodo. Se il codice ECMAScript scritto nel blocco di dichiarazione del codice non è già stato registrato, come determinato da <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, quindi un <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> chiamata.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsCrossPagePostBack">
      <MemberSignature Language="C#" Value="public bool IsCrossPagePostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCrossPagePostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCrossPagePostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCrossPagePostBack { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la pagina è coinvolta in un cross-page postback.</summary>
        <value>
          <see langword="true" /> se la pagina è coinvolta in una cross-page request, altrimenti <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET fornisce due meccanismi per trasferire il controllo da una pagina a un altro. È possibile utilizzare il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo per trasferire l'elaborazione tra le pagine oppure può inviare una richiesta di cross-pagina tramite l'assegnazione di un URL di pagina per il <xref:System.Web.UI.WebControls.IButtonControl.PostBackUrl%2A> proprietà di un controllo pulsante che implementa il <xref:System.Web.UI.WebControls.IButtonControl> interfaccia.  
  
 In entrambi i casi il <xref:System.Web.UI.Page.PreviousPage%2A> proprietà pagina conterrà un oggetto che rappresenta la pagina precedente o di origine. Se, ad esempio, A Page Invia a pagina B, A Page <xref:System.Web.UI.Page.IsCrossPagePostBack%2A> proprietà (accessibile tramite il <xref:System.Web.UI.Page.PreviousPage%2A> proprietà) sarà `true` e pagina B <xref:System.Web.UI.Page.PreviousPage%2A> proprietà avrà il nome di Page A.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.IButtonControl.PostBackUrl" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBack">
      <MemberSignature Language="C#" Value="public bool IsPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBack { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il rendering della pagina viene eseguito per la prima volta o se la pagina viene caricata in risposta a un postback.</summary>
        <value>
          <see langword="true" /> se la pagina viene caricata in risposta al postback di un client, altrimenti <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per una spiegazione della differenza tra i postback e i callback, vedere [implementazione di callback Client senza postback](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come verificare il valore del <xref:System.Web.UI.Page.IsPostBack%2A> proprietà quando viene caricata la pagina per determinare se la pagina viene eseguito il rendering per la prima volta o che sta eseguendo un postback. Se la pagina viene sottoposta a rendering per la prima volta, il codice chiama il <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> metodo.  
  
 Contiene il markup della pagina (non illustrato) <xref:System.Web.UI.WebControls.RequiredFieldValidator> i controlli che visualizzano gli asterischi se viene immessa alcuna voce per un campo di input obbligatorio. La chiamata <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> determina la visualizzazione immediata quando la pagina viene eseguito il rendering, anziché attendere che l'utente fa clic sul pulsante di invio degli asterischi. Dopo un postback, non è necessario chiamare <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>, poiché tale metodo viene chiamato durante la <xref:System.Web.UI.Page> ciclo di vita.  
  
 [!code-csharp[System.Web.UI.Page.Validate#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.Page.IsCallback" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBackEventControlRegistered">
      <MemberSignature Language="C#" Value="public bool IsPostBackEventControlRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBackEventControlRegistered" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBackEventControlRegistered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBackEventControlRegistered { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il controllo nella pagina utilizzato per eseguire i postback è stato registrato.</summary>
        <value>
          <see langword="true" /> se il controllo è stato inizializzato. In caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsReusable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReusable { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.IHttpHandler.IsReusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è possibile riutilizzare l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
        <value>
          <see langword="false" /> in tutti i casi.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.IHttpHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsStartupScriptRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave stringa dello script di avvio da ricercare.</param>
        <summary>Determina se lo script di avvio del client è stato registrato con l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>
          <see langword="true" /> se lo script di avvio è stato registrato, altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare <xref:System.Web.UI.Page.RegisterStartupScript%2A?displayProperty=nameWithType> per evitare inutile dello script lato client. Ciò è particolarmente importante se lo script richiede una grande quantità di risorse server da creare.  
  
 Il metodo <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> è stato deprecato. Utilizzare il <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metodo la <xref:System.Web.UI.ClientScriptManager> classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.Page.RegisterStartupScript%2A> metodo in combinazione con il <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> metodo. Se il codice ECMAScript scritto nel blocco di dichiarazione del codice non è già stato registrato, come determinato da <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>, quindi un <xref:System.Web.UI.Page.RegisterStartupScript%2A> chiamata.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la convalida della pagina è stata eseguita con esito positivo.</summary>
        <value>
          <see langword="true" /> se la convalida ha avuto esito positivo, altrimenti <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per questa proprietà restituire `true`, è necessario convalidare tutti i controlli di convalida server nel gruppo di convalida corrente. È necessario controllare questa proprietà solo dopo aver chiamato il <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> , metodo o un insieme di `CausesValidation` proprietà `true` nel `OnServerClick` gestore eventi per un controllo server ASP.NET che avvia l'elaborazione del modulo. Questi controlli server includono il <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.HtmlControls.HtmlButton>, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, <xref:System.Web.UI.WebControls.ImageButton>, e <xref:System.Web.UI.WebControls.LinkButton> classi.  
  
 Se si forza la convalida di un gruppo di convalida utilizzando il <xref:System.Web.UI.Page.Validate%2A> (metodo), quindi tutti i controlli di convalida nel gruppo di convalida specificato vengano convalidati anche.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Web.UI.Page.IsValid%2A> proprietà per impostare un'istruzione condizionale. Se la proprietà restituisce `true`, `Text` proprietà del `lblOutput` NFS è impostata su "Pagina è valida!" In caso contrario, è impostata su "Alcuni dei campi obbligatori sono vuoti".  
  
 [!code-csharp[System.Web.UI.Page.Validate#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Validate#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La proprietà <see cref="P:System.Web.UI.Page.IsValid" /> viene chiamata prima dell'esecuzione della convalida.</exception>
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="M:System.Web.UI.Page.Validate" />
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un elenco di oggetti archiviati nel contesto della pagina.</summary>
        <value>Un riferimento a un oggetto <see cref="T:System.Collections.IDictionary" /> contenente oggetti archiviati nel contesto della pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Web.UI.Page.Items%2A> proprietà per archiviare gli oggetti con la stessa durata della richiesta della pagina. Questa proprietà è di sola lettura. Tuttavia, è possibile aggiungere oggetti per il <xref:System.Collections.IDictionary> restituito.  
  
 Gli oggetti aggiunti al <xref:System.Web.UI.Page.Items%2A> proprietà sono disponibili per tutta la durata della pagina, pertanto è possibile aggiungere oggetti per il <xref:System.Web.UI.Page.Items%2A> proprietà eventi nelle prime fasi di vita della pagina e accedere a tali oggetti durante gli eventi successivi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.LCID" />
      <MemberSignature Language="VB.NET" Value="Public Property LCID As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LCID { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta l'identificatore delle impostazioni locali per l'oggetto <see cref="T:System.Threading.Thread" /> associato alla pagina.</summary>
        <value>L'identificatore delle impostazioni locali da passare all'oggetto <see cref="T:System.Threading.Thread" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Il `LCID` attributo può essere impostato nella direttiva del file con estensione aspx, tuttavia, il metodo preferito di impostare l'identificatore delle impostazioni locali è tramite l'utilizzo del <xref:System.Web.UI.Page.Culture%2A> e <xref:System.Web.UI.Page.UICulture%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
        <altmember cref="P:System.Web.UI.Page.UICulture" />
      </Docs>
    </Member>
    <Member MemberName="LoadComplete">
      <MemberSignature Language="C#" Value="public event EventHandler LoadComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LoadComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.LoadComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LoadComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica alla fine della fase di caricamento del ciclo di vita della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.LoadComplete> evento si verifica dopo il postback di tutti i dati e dello stato di visualizzazione dati verrà caricato nella pagina e dopo il <xref:System.Web.UI.Control.OnLoad%2A> metodo è stato chiamato per tutti i controlli della pagina.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [NIB: utilizzo degli eventi](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="LoadPageStateFromPersistenceMedium">
      <MemberSignature Language="C#" Value="protected internal virtual object LoadPageStateFromPersistenceMedium ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object LoadPageStateFromPersistenceMedium() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function LoadPageStateFromPersistenceMedium () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ LoadPageStateFromPersistenceMedium();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Carica le informazioni salvate relative allo stato di visualizzazione sull'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Lo stato di visualizzazione salvato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> metodo utilizza il <xref:System.Web.UI.PageStatePersister.Load%2A> metodo il <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> oggetto a cui fa riferimento il <xref:System.Web.UI.Page.PageStatePersister%2A> proprietà per caricare lo stato di visualizzazione le informazioni salvate per la <xref:System.Web.UI.Page> oggetto.  
  
 ASP.NET include due discendenti del <xref:System.Web.UI.PageStatePersister> (classe), il <xref:System.Web.UI.HiddenFieldPageStatePersister> classe che consente di salvare le informazioni sullo stato in un campo nascosto incluso nella pagina ASP.NET, e <xref:System.Web.UI.SessionPageStatePersister> classe che consente di salvare lo stato nel <xref:System.Web.UI.Page.Session%2A> associato il richiesta.  
  
 Per salvare lo stato nella posizione di propria scelta, è necessario creare un nuovo discendente della <xref:System.Web.UI.PageStatePersister> classe che salva e carica lo stato sul supporto di persistenza di propria scelta. Per un esempio di creazione di un nuovo <xref:System.Web.UI.PageStatePersister> , vedere la <xref:System.Web.UI.PageStatePersister> classe.  
  
 Se si utilizza .NET Framework versione 1.0 o 1.1, eseguire l'override di questo metodo se si desidera caricare il <xref:System.Web.UI.Page> dello stato da un elemento diverso da un campo nascosto. Se si sceglie di eseguire questa operazione, è inoltre necessario sostituire il <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="MaintainScrollPositionOnPostBack">
      <MemberSignature Language="C#" Value="public bool MaintainScrollPositionOnPostBack { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="VB.NET" Value="Public Property MaintainScrollPositionOnPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaintainScrollPositionOnPostBack { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se dopo il postback l'utente deve essere riportato nella stessa posizione nel browser client. Questa proprietà sostituisce la proprietà <see cref="P:System.Web.UI.Page.SmartNavigation" /> obsoleta.</summary>
        <value>
          <see langword="true" /> se la posizione nel client deve essere mantenuta, altrimenti <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando le pagine Web vengono registrate nel server, l'utente viene restituito nella parte superiore della pagina. Nelle pagine Web lungo, ciò significa che l'utente disponga di scorrere la pagina dell'ultima posizione della pagina.  
  
 Quando il <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> è impostata su `true`, l'utente viene invece restituito all'ultima posizione della pagina.  
  
 Impostare il <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> proprietà il [@ Page](http://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) direttiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Oggetto <see cref="T:System.String" /> che rappresenta il percorso virtuale.</param>
        <summary>Recupera il percorso fisico al quale è associato un percorso virtuale, assoluto o relativo, oppure un percorso relativo all'applicazione.</summary>
        <returns>Il percorso fisico associato al percorso virtuale o al percorso relativo all'applicazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Il <xref:System.Web.UI.Page.MapPath%2A> proprietà potrebbero contenere informazioni riservate sull'ambiente di hosting. Il valore restituito non deve essere visibile agli utenti.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Web.UI.Page.MapPath%2A> per ottenere il percorso fisico di una sottocartella. Viene quindi aggiunto il nome del file che viene letto dal <xref:System.Web.UI.WebControls.TextBox.Text%2A> proprietà di un <xref:System.Web.UI.WebControls.TextBox> controllo. Il risultato è il percorso fisico assoluto al file.  
  
 [!code-csharp[Page_MapPath_ResponseEncoding#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/CS/page_mappath_responseencoding.cs.aspx#1)]
 [!code-vb[Page_MapPath_ResponseEncoding#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/VB/page_mappath_responseencoding.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Master">
      <MemberSignature Language="C#" Value="public System.Web.UI.MasterPage Master { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.MasterPage Master" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Master" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Master As MasterPage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::MasterPage ^ Master { System::Web::UI::MasterPage ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.MasterPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la pagina master che determina l'aspetto generale della pagina.</summary>
        <value>Oggetto <see cref="T:System.Web.UI.MasterPage" /> associato a questa pagina, se esistente; in caso contrario <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.Master%2A> proprietà restituisce il <xref:System.Web.UI.MasterPage> oggetto associato a questa pagina. Questa proprietà è di sola lettura. Tuttavia, è possibile impostare le proprietà di <xref:System.Web.UI.MasterPage> restituito.  
  
 Il <xref:System.Web.UI.Page.Master%2A> proprietà è valida solo nelle pagine che fanno riferimento a una pagina master nel <xref:System.Web.UI.Page.MasterPageFile%2A> proprietà. Se si accede di <xref:System.Web.UI.Page.Master%2A> proprietà in una pagina che non fa riferimento a una pagina master, `null` viene restituito. Il contenuto di una pagina master non è disponibile solo dopo il <xref:System.Web.UI.Page.PreInit> è stato generato l'evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.MasterPageFile" />
      </Docs>
    </Member>
    <Member MemberName="MasterPageFile">
      <MemberSignature Language="C#" Value="public virtual string MasterPageFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MasterPageFile" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MasterPageFile" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MasterPageFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ MasterPageFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il percorso virtuale della pagina master.</summary>
        <value>Percorso virtuale della pagina master.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.MasterPageFile%2A> proprietà è un percorso virtuale (dalla radice dell'applicazione) del file pagina master associato a questa pagina. Il <xref:System.Web.UI.Page.MasterPageFile%2A> proprietà può essere impostata solo nel <xref:System.Web.UI.Page.PreInit> evento, il tentativo di impostare il <xref:System.Web.UI.Page.MasterPageFile%2A> proprietà dopo il <xref:System.Web.UI.Page.PreInit> genererà l'evento un <xref:System.InvalidOperationException> eccezione. Se il <xref:System.Web.UI.Page.MasterPageFile%2A> proprietà non è valida, un'eccezione di tipo <xref:System.Web.HttpException> più avanti nel ciclo di vita della pagina, ma viene generata alcuna eccezione quando la proprietà è impostata <xref:System.Web.UI.Page.PreInit> evento.  
  
 Pagine che presentano il <xref:System.Web.UI.Page.MasterPageFile%2A> set di proprietà sono pagine di contenuto e pertanto può contenere controlli solo a livello superiore che sono <xref:System.Web.UI.WebControls.Content> controlli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Web.UI.Page.MasterPageFile" /> viene impostata al termine dell'evento <see cref="E:System.Web.UI.Page.PreInit" />.</exception>
        <exception cref="T:System.Web.HttpException">Il file specificato nella proprietà <see cref="P:System.Web.UI.Page.MasterPageFile" /> non esiste.  \- oppure - La pagina non include un controllo <see cref="T:System.Web.UI.WebControls.Content" /> come controllo di primo livello.</exception>
        <altmember cref="P:System.Web.UI.Page.Master" />
      </Docs>
    </Member>
    <Member MemberName="MaxPageStateFieldLength">
      <MemberSignature Language="C#" Value="public int MaxPageStateFieldLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPageStateFieldLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPageStateFieldLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPageStateFieldLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la lunghezza massima del campo dello stato della pagina.</summary>
        <value>La lunghezza massima, espressa in byte, del campo dello stato della pagina. Il valore predefinito è -1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> è impostata su un numero positivo, lo stato di visualizzazione inviato al browser client viene suddiviso in più campi nascosti e il valore di ogni campo è minore della dimensione specificata nella <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> proprietà.  
  
 L'impostazione di <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> proprietà su un numero negativo (predefinito) indica che il campo dello stato di visualizzazione non deve essere suddiviso in blocchi. L'impostazione di <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> su un numero ridotto può comportare una riduzione delle prestazioni.  
  
 Impostare il valore della <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> proprietà del file Web. config.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> non è uguale a -1 o a uno numero positivo.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> è stata impostata dopo l'inizializzazione della pagina.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaDescription">
      <MemberSignature Language="C#" Value="public string MetaDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il contenuto dell'elemento <see langword="meta" /> "description".</summary>
        <value>Contenuto dell'elemento <see langword="meta" /> "description".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` elementi possono essere utilizzati per migliorare gli elenchi dei motori di ricerca. "Descrizione" `meta` elemento è utilizzato da alcuni motori di ricerca per migliorare le anteprime di elenco.  
  
 Se è presente alcuna "descrizione" `meta` elemento il `head` elemento di markup della pagina, il `meta` elemento viene aggiunto alla pagina quando viene eseguito il rendering della pagina. Se il markup della pagina dispone già di una "descrizione" `meta` elemento, questa proprietà ottiene o imposta il `content` attributo del `meta` elemento.  
  
 È inoltre possibile impostare questa proprietà nella direttiva.  
  
   
  
## Examples  
 Se si imposta la <xref:System.Web.UI.Page.MetaDescription%2A> proprietà di una pagina "Panoramica di ASP.NET", l'elemento seguente verrà visualizzata nel codice viene eseguito il rendering HTML:  
  
 `<meta name="description" content="ASP.NET Overview" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La pagina non dispone di un controllo intestazione (un elemento <see langword="head" /> con l'attributo <see langword="runat" /> impostato su "server").</exception>
        <altmember cref="P:System.Web.UI.Page.MetaKeywords" />
      </Docs>
    </Member>
    <Member MemberName="MetaKeywords">
      <MemberSignature Language="C#" Value="public string MetaKeywords { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaKeywords" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaKeywords" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaKeywords As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaKeywords { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il contenuto dell'elemento <see langword="meta" /> "keywords".</summary>
        <value>Contenuto dell'elemento <see langword="meta" /> "keywords".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` elementi possono essere utilizzati per migliorare gli elenchi dei motori di ricerca. Le parole "chiave" `meta` elemento non viene utilizzato affatto o è assegnato un peso molto basso dai motori di ricerca principale.  
  
 Se è presente alcuna "parole chiave" `meta` elemento il `head` elemento di markup della pagina, il `meta` elemento viene aggiunto alla pagina quando viene eseguito il rendering della pagina. Se il markup della pagina dispone già di un "parole chiave" `meta` elemento, questa proprietà ottiene o imposta il `content` attributo del `meta` elemento.  
  
 È inoltre possibile impostare questa proprietà nella direttiva.  
  
   
  
## Examples  
 Se si imposta la <xref:System.Web.UI.Page.MetaKeywords%2A> proprietà di una pagina "HTML, CSS, XML, JavaScript", l'elemento seguente verrà visualizzata nel codice viene eseguito il rendering HTML:  
  
 `<meta name="keywords" content=" HTML,CSS,XML,JavaScript" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La pagina non dispone di un controllo intestazione (un elemento <see langword="head" /> con l'attributo <see langword="runat" /> impostato su "server").</exception>
        <altmember cref="P:System.Web.UI.Page.MetaDescription" />
      </Docs>
    </Member>
    <Member MemberName="ModelBindingExecutionContext">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelBindingExecutionContext As ModelBindingExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelBindingExecutionContext ^ ModelBindingExecutionContext { System::Web::ModelBinding::ModelBindingExecutionContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelBindingExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il contesto di esecuzione dell'associazione del modello.</summary>
        <value>Contesto di esecuzione dell'associazione del modello. Se il contesto di esecuzione dell'associazione di modello è <see langword="null" />, ne viene creato e restituito uno nuovo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelState">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelStateDictionary ModelState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelStateDictionary ModelState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelState As ModelStateDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelStateDictionary ^ ModelState { System::Web::ModelBinding::ModelStateDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelStateDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto dizionario di stato del modello che contiene lo stato del modello e della convalida dell'associazione del modello.</summary>
        <value>Oggetto del dizionario di stato del modello.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per una serie di esercitazioni sull'uso di associazione di modelli con Web Form, vedere [associazione del modello e Web Form](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Web.UI.Control.Init" /> per inizializzare la pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.OnInit%2A> metodo effettua le operazioni di inizializzazione e di configurazione necessarie per creare un <xref:System.Web.UI.Page> istanza. In questa fase del ciclo di vita della pagina, i controlli server dichiarati nella pagina vengono inizializzati allo stato predefinito; Tuttavia, lo stato di visualizzazione di ogni controllo non è ancora popolato. Un controllo nella pagina non è possibile accedere ad altri controlli di server nella pagina durante il `Page_Init` fase, indipendentemente dal fatto che gli altri controlli siano controlli padre o figlio. Altri controlli server non è necessariamente essere creato e pronto per l'accesso.  
  
 Il <xref:System.Web.UI.Page.OnInit%2A> metodo viene chiamato dopo il <xref:System.Web.UI.Page.OnPreInit%2A> (metodo) e prima di <xref:System.Web.UI.Page.OnInitComplete%2A> metodo.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Web.UI.Page.OnInit%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInitComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInitComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Web.UI.Page.InitComplete" /> dopo l'inizializzazione della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.OnInitComplete%2A> metodo viene chiamato al termine dell'inizializzazione della pagina. In questa fase del ciclo di vita della pagina, tutti dichiarati i controlli nella pagina vengono inizializzati, ma lo stato di visualizzazione della pagina non è ancora popolato. È possibile accedere a controlli del server, ma non ancora conterranno le informazioni restituite da parte dell'utente.  
  
 Il <xref:System.Web.UI.Page.OnInitComplete%2A> metodo si verifica alla fine del <xref:System.Web.UI.Page> della fase di inizializzazione e prima della fase di caricamento.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Web.UI.Page.OnInitComplete%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLoadComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Web.UI.Page.LoadComplete" /> alla fine della fase di caricamento della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.OnLoadComplete%2A> metodo viene chiamato alla fine della fase di caricamento della pagina. A questo punto nel ciclo di vita della pagina, tutti i dati di postback e i dati dello stato di visualizzazione viene caricato in controlli della pagina.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Web.UI.Page.OnLoadComplete%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreInit">
      <MemberSignature Language="C#" Value="protected virtual void OnPreInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Web.UI.Page.PreInit" /> all'inizio della fase di inizializzazione della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.OnPreInit%2A> metodo viene chiamato all'inizio della fase di inizializzazione della pagina.  
  
 Dopo il <xref:System.Web.UI.Page.OnPreInit%2A> metodo viene chiamato, le informazioni sulla personalizzazione viene caricati e il tema della pagina, se presente, viene inizializzato. È anche la fase preferenziale per definire in modo dinamico un <xref:System.Web.UI.PageTheme> o <xref:System.Web.UI.MasterPage> per la pagina.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Web.UI.Page.OnPreInit%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnPreLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreLoad(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Web.UI.Page.PreLoad" /> dopo il caricamento dei dati relativi al postback nei controlli server della pagina ma prima dell'evento <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.OnPreLoad%2A> metodo viene chiamato dopo che tutti i postback dati restituiti da parte dell'utente viene caricati. In questa fase del ciclo di vita della pagina, informazioni sullo stato di visualizzazione dati di postback per dichiarare e controlli e controlli creati durante la fase di inizializzazione vengono caricati i controlli della pagina.  
  
 Controlli creati nel <xref:System.Web.UI.Page.OnPreLoad%2A> metodo vengono caricato anche i dati dello stato di visualizzazione e postback.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Web.UI.Page.OnPreLoad%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRenderComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRenderComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRenderComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreRenderComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreRenderComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Web.UI.Page.PreRenderComplete" /> dopo l'evento <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> e prima del rendering della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.OnPreRenderComplete%2A> viene chiamato durante la fase di prerendering del ciclo di vita della pagina. In questa fase del ciclo di vita della pagina, vengono creati tutti i controlli e la pagina è pronta per il rendering dell'output.  
  
 Si tratta dell'ultimo evento chiamato prima che venga salvato lo stato di visualizzazione della pagina.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Web.UI.Page.OnPreRenderComplete%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSaveStateComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSaveStateComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSaveStateComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSaveStateComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSaveStateComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> contenente i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Web.UI.Page.SaveStateComplete" /> dopo il salvataggio dello stato della pagina sul supporto di persistenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.OnSaveStateComplete%2A> metodo viene chiamato quando le informazioni sullo stato per il controllo sono stato scritto sul supporto di persistenza della pagina. Le informazioni sullo stato viene scritto sul supporto di persistenza tramite la chiamata di <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> metodo.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per ulteriori informazioni, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il metodo <xref:System.Web.UI.Page.OnSaveStateComplete%2A> consente inoltre alle classi derivate di gestire l'evento senza associare un delegato. È la tecnica consigliata per la gestione dell'evento in una classe derivata.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si esegue l'override <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> in una classe derivata, assicurarsi di chiamare la classe base <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> metodo in modo che i delegati registrati ricevano l'evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="public System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'adattatore che esegue il rendering della pagina per il browser richiedente specificato.</summary>
        <value>L'oggetto <see cref="T:System.Web.UI.Adapters.PageAdapter" /> che esegue il rendering della pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.PageAdapter%2A> proprietà restituisce l'oggetto specifico <xref:System.Web.UI.Adapters.PageAdapter> modifica il comportamento dell'oggetto di <xref:System.Web.UI.Page> oggetto per il browser richiedente.  
  
 La specifica <xref:System.Web.UI.Adapters.PageAdapter> oggetto viene determinato esaminando le caratteristiche di in ingresso <xref:System.Web.UI.Page.Request%2A> oggetto. Quando viene scelto un adattatore per la richiesta, tutti gli eventi del ciclo di vita nel <xref:System.Web.UI.Adapters.PageAdapter> oggetto di eseguire l'override di eventi corrispondenti nel <xref:System.Web.UI.Page> oggetto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageStatePersister">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.PageStatePersister PageStatePersister { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.PageStatePersister PageStatePersister" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageStatePersister" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property PageStatePersister As PageStatePersister" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::PageStatePersister ^ PageStatePersister { System::Web::UI::PageStatePersister ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.PageStatePersister</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.UI.PageStatePersister" /> associato alla pagina.</summary>
        <value>Un oggetto <see cref="T:System.Web.UI.PageStatePersister" /> associato alla pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Richieste e risposte HTTP sono intrinsecamente senza state. Per mantenere lo stato tra le richieste HTTP, è possono archiviare le pagine ASP.NET <xref:System.Web.UI.Page> stato. Questo stato, lo stato di visualizzazione, denominato costituito dalla pagina e le impostazioni di controllo e i dati che costituiscono la pagina e i controlli vengono visualizzati come se sono uguali a quelle che l'utente visti e con dal durante l'ultimo round trip alla pagina. Sono disponibili diversi meccanismi per archiviare lo stato di visualizzazione tra le richieste successive nella stessa pagina. La classe astratta <xref:System.Web.UI.PageStatePersister> rappresenta la classe base per questi meccanismi di archiviazione dello stato.  
  
 Gli sviluppatori di pagine in genere non dovrà utilizzare il <xref:System.Web.UI.Page.PageStatePersister%2A> proprietà. Il <xref:System.Web.UI.Page.PageStatePersister%2A> proprietà viene usata principalmente dagli sviluppatori di controlli per estendere la funzionalità del <xref:System.Web.UI.Page> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="postEventArgumentID">
      <MemberSignature Language="C#" Value="public const string postEventArgumentID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventArgumentID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventArgumentID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventArgumentID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventArgumentID;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Una stringa che definisce il campo nascosto EVENTARGUMENT nella pagina di cui è stato eseguito il rendering.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventSourceID" />
      </Docs>
    </Member>
    <Member MemberName="postEventSourceID">
      <MemberSignature Language="C#" Value="public const string postEventSourceID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventSourceID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventSourceID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventSourceID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventSourceID;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Una stringa che definisce il campo nascosto EVENTTARGET nella pagina di cui è stato eseguito il rendering.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventArgumentID" />
      </Docs>
    </Member>
    <Member MemberName="PreInit">
      <MemberSignature Language="C#" Value="public event EventHandler PreInit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreInit" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreInit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreInit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreInit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica prima dell'inizializzazione della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento consente di selezionare le condizioni della richiesta di pagina, ad esempio se la pagina viene caricata in risposta a un postback. È inoltre possibile verificare i valori delle proprietà di profilo.  
  
 L'evento consente di impostare i valori utilizzati in un secondo momento nel ciclo di vita della pagina. In modo dinamico è possibile impostare una pagina master o un tema per la pagina richiesta e crea controlli dinamici.  
  
 Per ulteriori informazioni su come <xref:System.Web.UI.Page.PreInit> evento adatta nel ciclo di vita ASP.NET, vedere [Panoramica del ciclo di vita della pagina ASP.NET](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
      </Docs>
    </Member>
    <Member MemberName="PreLoad">
      <MemberSignature Language="C#" Value="public event EventHandler PreLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreLoad" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreLoad As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreLoad;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica prima dell'evento <see cref="E:System.Web.UI.Control.Load" /> della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.PreLoad> evento viene generato dopo l'elaborazione dati di tutti i postback e prima di <xref:System.Web.UI.Control.Load> evento. È un secondo tentativo di caricare i dati di postback prima di <xref:System.Web.UI.Page.OnLoadComplete%2A> evento. Per ulteriori informazioni sulla gestione degli eventi, vedere [NIB: utilizzo degli eventi](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
      </Docs>
    </Member>
    <Member MemberName="PreRenderComplete">
      <MemberSignature Language="C#" Value="public event EventHandler PreRenderComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRenderComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreRenderComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRenderComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRenderComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica prima del rendering del contenuto della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.PreRenderComplete> evento viene generato quando il prerendering del ciclo di vita della pagina è stata completata. In questa fase del ciclo di vita della pagina, vengono creati tutti i controlli, qualsiasi paginazione necessaria viene completata e la pagina è pronta per il rendering dell'output.  
  
 Si tratta dell'ultimo evento generato prima che venga salvato lo stato di visualizzazione della pagina.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [NIB: utilizzo degli eventi](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
      </Docs>
    </Member>
    <Member MemberName="PreviousPage">
      <MemberSignature Language="C#" Value="public System.Web.UI.Page PreviousPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page PreviousPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PreviousPage" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousPage As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Page ^ PreviousPage { System::Web::UI::Page ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la pagina che ha trasferito il controllo alla pagina corrente.</summary>
        <value>L'oggetto <see cref="T:System.Web.UI.Page" /> che rappresenta la pagina che ha trasferito il controllo alla pagina corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo o utilizzare tra pagine di registrazione per il trasferimento dell'elaborazione da una pagina ASP.NET a un'altra, la pagina di origine contiene informazioni sulla richiesta che potrebbero essere necessarie per la pagina di destinazione. È possibile utilizzare il <xref:System.Web.UI.Page.PreviousPage%2A> proprietà per accedere alle informazioni.  
  
 Se la pagina corrente viene eseguito il rendering in seguito a una richiesta diretta, non un trasferimento o cross-post da un'altra pagina, il <xref:System.Web.UI.Page.PreviousPage%2A> contiene proprietà `null`.  
  
   
  
## Examples  
 L'esempio seguente è contenuto in due parti. La prima è una pagina ASP.NET che usa il <xref:System.Web.HttpServerUtility.Transfer%2A> metodo, esposto nel modello di pagina come `Server.Transfer("path")`. La seconda parte è la pagina di destinazione, che utilizza il <xref:System.Web.UI.Page.PreviousPage%2A> proprietà per ottenere il titolo della prima pagina.  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Main.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Main.aspx#1)]  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Notify.aspx#2)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Notify.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">All'utente corrente non è consentito accedere alla pagina precedente.  - oppure - Il routing ASP.NET è in uso e l'URL della pagina precedente è un URL indirizzato. Quando ASP.NET controlla le autorizzazioni di accesso, presuppone che l'URL sia un percorso effettivo a un file. Poiché non si tratta del caso con un URL indirizzato, il controllo non riesce.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ProcessRequest (context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessRequest(System::Web::HttpContext ^ context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.IHttpHandler.ProcessRequest(System.Web.HttpContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">Oggetto <see cref="T:System.Web.HttpContext" /> che fornisce riferimenti agli oggetti intrinseci del server, ad esempio <see cref="P:System.Web.HttpContext.Request" />, <see cref="P:System.Web.HttpContext.Response" /> e <see cref="P:System.Web.HttpContext.Session" />, utilizzati per gestire le richieste HTTP.</param>
        <summary>Imposta gli oggetti server intrinseci dell'oggetto <see cref="T:System.Web.UI.Page" />, ad esempio le proprietà <see cref="P:System.Web.UI.Page.Context" />, <see cref="P:System.Web.UI.Page.Request" />, <see cref="P:System.Web.UI.Page.Response" /> e <see cref="P:System.Web.UI.Page.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è necessario chiamare questo metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Context" />
        <altmember cref="P:System.Web.UI.Page.Request" />
        <altmember cref="P:System.Web.UI.Page.Response" />
        <altmember cref="P:System.Web.UI.Page.Application" />
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(class System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RaisePostBackEvent(System.Web.UI.IPostBackEventHandler,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (sourceControl As IPostBackEventHandler, eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::Web::UI::IPostBackEventHandler ^ sourceControl, System::String ^ eventArgument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceControl" Type="System.Web.UI.IPostBackEventHandler" />
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceControl">Controllo server ASP.NET che ha causato il postback. Questo controllo deve implementare l'interfaccia <see cref="T:System.Web.UI.IPostBackEventHandler" />.</param>
        <param name="eventArgument">Argomento relativo al postback.</param>
        <summary>Notifica al controllo server che ha causato il postback che dovrà gestire un evento di postback in entrata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page> chiama il <xref:System.Web.UI.Page.RaisePostBackEvent%2A> metodo quando si verifica un postback. Questa chiamata si verifica nel ciclo di vita della pagina al termine di notifica durante il caricamento e modifica, ma prima che si verifichi il rendering preliminare.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Web.UI.Page.RaisePostBackEvent%2A> metodo per notificare ad ASP.NET che, quando un oggetto personalizzato, viene generato un evento postback `userButton` si fa clic sul controllo server.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterArrayDeclaration(string arrayName, string arrayValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Nome della matrice nella quale dichiarare il valore.</param>
        <param name="arrayValue">Valore da includere nella matrice.</param>
        <summary>Dichiara un valore che viene dichiarato come dichiarazione di matrice ECMAScript quando viene eseguito il rendering della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato dai controlli basati su script per produrre una dichiarazione all'interno di una matrice in modo che sia possibile utilizzare una libreria di script client con tutti i controlli dello stesso tipo.  
  
 Il metodo <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> è stato deprecato. Utilizzare il <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> metodo la <xref:System.Web.UI.ClientScriptManager> classe.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> metodo per dichiarare una matrice, `myArray`, che contiene tre oggetti denominati `x`, `y`, e `z`. L'esempio definisce e registra un script di avvio mediante il <xref:System.Web.UI.Page.RegisterStartupScript%2A> metodo. Quando il codice ECMAScript `doClick` funzione viene chiamata dalla pagina che contiene il codice, la matrice e i relativi oggetti vengono inizializzati.  
  
 [!code-csharp[Page_RegisterArrayDeclaration#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/CS/page_registerarraydeclaration.cs.aspx#1)]
 [!code-vb[Page_RegisterArrayDeclaration#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/VB/page_registerarraydeclaration.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncTask">
      <MemberSignature Language="C#" Value="public void RegisterAsyncTask (System.Web.UI.PageAsyncTask task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterAsyncTask(class System.Web.UI.PageAsyncTask task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAsyncTask (task As PageAsyncTask)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAsyncTask(System::Web::UI::PageAsyncTask ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Web.UI.PageAsyncTask" />
      </Parameters>
      <Docs>
        <param name="task">Oggetto <see cref="T:System.Web.UI.PageAsyncTask" /> che definisce l'attività asincrona.</param>
        <summary>Registra una nuova attività asincrona con la pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definire un'attività asincrona utilizzando il <xref:System.Web.UI.PageAsyncTask> classe. Quando l'attività è definito, utilizzare il <xref:System.Web.UI.Page.RegisterAsyncTask%2A> metodo per registrare l'attività con la pagina. Dopo la registrazione dell'attività, richiamare il <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> metodo per avviare l'attività asincrona.  
  
 Il <xref:System.Web.UI.Page.RegisterAsyncTask%2A> metodo può essere utilizzato con pagine sincrone e asincrone.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.Page.AsyncTimeout%2A> proprietà con il <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> e <xref:System.Web.UI.Page.RegisterAsyncTask%2A> metodi. Si noti l'utilizzo di gestori di inizio, fine e timeout. Nell'esempio viene introdotto un ritardo artificiale per illustrare il caso di un'attività asincrona che supera il tempo per l'attività come specificato nella <xref:System.Web.UI.Page.AsyncTimeout%2A> proprietà. In uno scenario reale, un'attività asincrona può essere usata per eseguire chiamate al database o la generazione di immagini, ad esempio, e il gestore di timeout fornisce una riduzione del se l'attività non viene eseguita in un periodo di tempo specificato.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'attività asincrona è <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public virtual void RegisterClientScriptBlock (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterClientScriptBlock(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterClientScriptBlock (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterClientScriptBlock(System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterClientScriptBlock(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave univoca che identifica un blocco di script.</param>
        <param name="script">Contenuto dello script che viene inviato al client.</param>
        <summary>Crea blocchi di script del lato client nella risposta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo script sul lato client viene creato immediatamente dopo il tag di apertura del <xref:System.Web.UI.Page> dell'oggetto `<form runat= server>` elemento. Assicurarsi di comprendere l'apertura e chiusura `<script>` elementi per lo script di blocco specificato nella stringa di `script` parametro.  
  
 Poiché questo metodo utilizza una chiave per identificare il blocco di script, il blocco di script non deve essere generato nel flusso di output ogni volta che viene richiesto da un'istanza del controllo server diverso. Utilizzando una chiave riduce anche la probabilità di blocchi di script diversi controlli interferiscano tra loro.  
  
 I blocchi con lo stesso di script `key` i valori dei parametri vengono considerati duplicati.  
  
> [!NOTE]
>  Ricordarsi di includere i tag di commento HTML lo script in modo che non vengono visualizzato se il browser richiedente non supporta gli script.  
  
 Il metodo <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> è stato deprecato. Utilizzare in alternativa il metodo <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> nella classe <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> metodo in combinazione con il <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> metodo. Se il codice ECMAScript nel blocco di dichiarazione del codice non è già stato registrato, come determinato dalla <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> chiamata.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public virtual void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Nome univoco del campo nascosto di cui eseguire il rendering.</param>
        <param name="hiddenFieldInitialValue">Valore da generare nel form nascosto.</param>
        <summary>Consente ai controlli server di registrare automaticamente un campo nascosto sul form. Il campo verrà inviato all'oggetto <see cref="T:System.Web.UI.Page" /> quando viene eseguito il rendering del controllo server <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Web.UI.Page.RegisterHiddenField%2A> è stato deprecato. Utilizzare il <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metodo la <xref:System.Web.UI.ClientScriptManager> classe.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Web.UI.Page.RegisterHiddenField%2A> consentono di creare il codice ECMAScript che viene passato al browser. Il nome del campo nascosto è impostato su `myHiddenField` e il relativo valore è impostato su "Benvenuti Microsoft". Il <xref:System.Web.UI.Page.RegisterStartupScript%2A> chiamate al metodo di `myHiddenField` valore quando l'utente sceglie un pulsante nella pagina.  
  
> [!IMPORTANT]
>  L'esempio include un campo nascosto, ovvero una potenziale minaccia alla sicurezza. Per impostazione predefinita, è necessario convalidare il valore di un campo nascosto come si farebbe con il valore di una casella di testo. Le pagine Web di ASP.NET verificano che l'input utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#1)]
 [!code-vb[Page_RegisterHiddenField#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterOnSubmitStatement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterOnSubmitStatement (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterOnSubmitStatement(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave univoca che identifica un blocco di script.</param>
        <param name="script">Script del lato client da inviare al client.</param>
        <summary>Consente a una pagina di accedere all'evento <see langword="OnSubmit" /> del client. Lo script deve essere una chiamata di funzione a codice client registrato altrove.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> è stato deprecato. Utilizzare il <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metodo la <xref:System.Web.UI.ClientScriptManager> classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> per accedere a uno script che risponde quando si fa clic sul pulsante di invio sul lato client. Quando si verifica questo evento, il codice ECMAScript registrato viene eseguito sul client.  
  
> [!IMPORTANT]
>  L'esempio include un campo nascosto, ovvero una potenziale minaccia alla sicurezza. Per impostazione predefinita, è necessario convalidare il valore di un campo nascosto come si farebbe con il valore di una casella di testo. Le pagine Web di ASP.NET verificano che l'input utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#2)]
 [!code-vb[Page_RegisterHiddenField#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void RegisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Controllo da registrare.</param>
        <summary>Registra un controllo in modo che il relativo stato del controllo debba essere mantenuto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controlli personalizzati di server che utilizzano lo stato del controllo è necessario chiamare il <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> metodo per ogni richiesta perché la registrazione dello stato del controllo non viene salvata dalla richiesta a richiesta durante un evento postback. È consigliabile eseguire la registrazione nel <xref:System.Web.UI.Control.Init> evento.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata una chiamata di controllo server personalizzato di <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> metodo.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il controllo da registrare è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" /> può essere chiamato solo prima o durante l'evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresPostBack">
      <MemberSignature Language="C#" Value="public void RegisterRequiresPostBack (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresPostBack(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresPostBack(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Controllo da registrare.</param>
        <summary>Registra un controllo in modo che richieda la gestione del postback quando viene eseguito il postback della pagina nel server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il controllo da registrare deve implementare il <xref:System.Web.UI.IPostBackDataHandler> interfaccia o un <xref:System.Web.HttpException> viene generato. Quando viene implementato da un controllo, il <xref:System.Web.UI.IPostBackDataHandler> consente di interfaccia, la gestione dei dati di postback e generazione di post di eseguire il backup degli eventi di dati modificati. Per ulteriori informazioni sul modello di eventi di controllo server, vedere [del modello di eventi controllo ASP.NET Web Forms Server](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
 Registrare i controlli con la pagina in corrispondenza o prima di `Page_PreRender` eventi del ciclo di vita della pagina.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Web.UI.Page.RegisterRequiresPostBack%2A> metodo per richiedere un controllo casella di testo, `myTextBox`, postback prima di poter eseguire qualsiasi codice associato alla casella di testo. <xref:System.Web.UI.WebControls.TextBox> i controlli implementano la <xref:System.Web.UI.IPostBackDataHandler> interfaccia.  
  
> [!IMPORTANT]
>  L'esempio include una casella di testo che accetta l'input dell'utente e rappresenta quindi una potenziale minaccia alla sicurezza. Per impostazione predefinita, le pagine Web ASP.NET verificano che l'input dell'utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterRequiresPostBack#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/CS/page_registerrequirespostback.cs.aspx#1)]
 [!code-vb[Page_RegisterRequiresPostBack#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/VB/page_registerrequirespostback.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Il controllo da registrare non implementa l'interfaccia <see cref="T:System.Web.UI.IPostBackDataHandler" />.</exception>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresRaiseEvent">
      <MemberSignature Language="C#" Value="public virtual void RegisterRequiresRaiseEvent (System.Web.UI.IPostBackEventHandler control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterRequiresRaiseEvent(class System.Web.UI.IPostBackEventHandler control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresRaiseEvent(System.Web.UI.IPostBackEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterRequiresRaiseEvent (control As IPostBackEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterRequiresRaiseEvent(System::Web::UI::IPostBackEventHandler ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.IPostBackEventHandler" />
      </Parameters>
      <Docs>
        <param name="control">Controllo da registrare.</param>
        <summary>Registra un controllo server ASP.NET in modo che richieda la generazione di un evento quando viene elaborato nell'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controllo di un solo server può essere registrato per ogni richiesta di pagina. Il <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> deve essere utilizzato quando il controllo include l'ID nel formato inviare i dati di controllo. Inoltre, è necessario implementare il controllo registrato il <xref:System.Web.UI.IPostBackEventHandler> interfaccia.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> metodo per registrare un <xref:System.Web.UI.WebControls.Button> Web controllo server che richiedono un evento da generare. Dopo avere registrato il primo <xref:System.Web.UI.WebControls.Button> (controllo), è possibile che il secondo <xref:System.Web.UI.WebControls.Button> controllo dichiarato nel codice per registrare i risultati del primo pulsante click (evento) alla pagina.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresViewStateEncryption">
      <MemberSignature Language="C#" Value="public void RegisterRequiresViewStateEncryption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresViewStateEncryption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterRequiresViewStateEncryption ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresViewStateEncryption();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Registra un controllo con la pagina in modo che richieda la crittografia dello stato di visualizzazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si sviluppa un controllo personalizzato che gestisce informazioni potenzialmente riservate, chiamare il <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A> per registrare il controllo con la pagina e verificare lo stato di visualizzazione per il controllo è crittografato.  
  
 Lo stato dell'intera pagina verrà crittografato se il <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> è impostato su <xref:System.Web.UI.ViewStateEncryptionMode.Auto> o <xref:System.Web.UI.ViewStateEncryptionMode.Always>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'impostazione della modalità di crittografia dello stato di visualizzazione per un <xref:System.Web.UI.Page> oggetto e la richiesta di crittografia dello stato di visualizzazione tramite <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>. In questo esempio, lo stato di visualizzazione verrà crittografato quando vengono recuperate informazioni di cliente da un database.  
  
 [!code-aspx-csharp[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/CS/encryptViewState.cs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/VB/encryptViewState.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" /> deve essere chiamato prima o durante la fase <see langword="PreRender" /> della pagina del ciclo di vita della pagina.</exception>
        <altmember cref="P:System.Web.UI.Page.ViewStateEncryptionMode" />
        <altmember cref="T:System.Web.UI.WebControls.GridView" />
        <altmember cref="T:System.Web.UI.WebControls.DetailsView" />
        <altmember cref="T:System.Web.UI.WebControls.FormView" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public virtual void RegisterStartupScript (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterStartupScript(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterStartupScript (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterStartupScript(System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterStartupScript(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave univoca che identifica un blocco di script.</param>
        <param name="script">Contenuto dello script che verrà inviato al client.</param>
        <summary>Crea un blocco di script del lato client nella risposta della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Simile al <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> (metodo), il <xref:System.Web.UI.Page.RegisterStartupScript%2A> metodo genera lo script immediatamente prima del tag di chiusura del <xref:System.Web.UI.Page> dell'oggetto `<form runat= server>` elemento. Assicurarsi di comprendere l'apertura e chiusura `<script>` elementi per lo script di blocco specificato nella stringa di `script` parametro.  
  
 Poiché questo metodo utilizza una chiave per identificare il blocco di script, il blocco di script non deve essere generato ogni volta che viene richiesto da un'istanza del controllo server diverso per il flusso di output  
  
 I blocchi con lo stesso di script `key` i valori dei parametri vengono considerati duplicati.  
  
> [!NOTE]
>  Ricordarsi di includere i tag di commento HTML lo script in modo che non vengono visualizzato se il browser richiedente non supporta gli script.  
  
 Il metodo <xref:System.Web.UI.Page.RegisterStartupScript%2A> è stato deprecato. Utilizzare in alternativa il metodo <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> nella classe <xref:System.Web.UI.ClientScriptManager>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.Page.RegisterStartupScript%2A> metodo in combinazione con il <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> metodo. Se il codice ECMAScript scritto nel blocco di dichiarazione del codice non è già stato registrato, come determinato dal <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> (metodo), quindi un <xref:System.Web.UI.Page.RegisterStartupScript%2A> chiamata.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterViewStateHandler">
      <MemberSignature Language="C#" Value="public void RegisterViewStateHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterViewStateHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterViewStateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterViewStateHandler ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterViewStateHandler();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causa la persistenza dello stato di visualizzazione, se chiamato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.RegisterViewStateHandler%2A> metodo viene chiamato automaticamente tramite il <xref:System.Web.UI.HtmlControls.HtmlForm> controllo server. Se non viene richiamato questo metodo, non sarà persistente lo stato di visualizzazione della pagina.  
  
> [!NOTE]
>  In genere, solo il <xref:System.Web.UI.HtmlControls.HtmlForm> server di controllo per la pagina chiama questo metodo.  
  
   
  
## Examples  
 [!code-csharp[Page_RegisterViewStateHandler#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterViewStateHandler/CS/page_registerviewstatehandler.cs#1)]
 [!code-vb[Page_RegisterViewStateHandler#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterViewStateHandler/VB/page_registerviewstatehandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Web.UI.HtmlTextWriter" /> che riceve il contenuto della pagina.</param>
        <summary>Inizializza l'oggetto <see cref="T:System.Web.UI.HtmlTextWriter" /> e chiama i controlli figlio dell'oggetto <see cref="T:System.Web.UI.Page" /> di cui eseguire il rendering.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.Render%2A> metodo è responsabile della creazione del testo e markup viene inviato al browser client. Il valore predefinito <xref:System.Web.UI.Page.Render%2A> chiamate al metodo <xref:System.Web.UI.Control.RenderChildren%2A> per scrivere il testo e markup per i controlli contenuti nella pagina.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.HttpRequest" /> per la pagina richiesta.</summary>
        <value>L'oggetto <see cref="T:System.Web.HttpRequest" /> corrente associato alla pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto <xref:System.Web.HttpRequest> contiene informazioni sulla richiesta HTTP corrente.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere il <xref:System.Web.HttpRequest.Headers%2A> raccolta dal <xref:System.Web.HttpRequest> dell'oggetto e li scrive in una pagina ASP.NET.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Viene generata quando l'oggetto <see cref="T:System.Web.HttpRequest" /> non è disponibile.</exception>
        <altmember cref="T:System.Web.HttpException" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequiresControlState">
      <MemberSignature Language="C#" Value="public bool RequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Oggetto <see cref="T:System.Web.UI.Control" /> per cui si desidera verificare se è richiesto lo stato del controllo.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Web.UI.Control" /> specificato è stato registrato in modo da essere coinvolto nella gestione dello stato del controllo.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Web.UI.Control" /> specificato richiede lo stato del controllo, altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo stato del controllo è un oggetto costituito da dati dello stato di visualizzazione critici che i controlli server Web devono funzionare; è contenuto in un oggetto separato dallo stato di visualizzazione normale.  
  
 Controlli personalizzati usando lo stato del controllo devono chiamare il <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> metodo prima di salvare lo stato del controllo. Utilizzare il <xref:System.Web.UI.Page.RequiresControlState%2A> metodo per determinare i controlli che sono registrati con la pagina che richiedono lo stato del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.PageStatePersister.ControlState" />
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.HttpResponse" /> associato all'oggetto <see cref="T:System.Web.UI.Page" />. Questo oggetto consente di inviare dati di risposta HTTP a un client e contiene informazioni su tale risposta.</summary>
        <value>L'oggetto <see cref="T:System.Web.HttpResponse" /> corrente associato alla pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente illustra la creazione di un cookie e aggiungerlo alla finestra di output HTTP della pagina utilizzando la <xref:System.Web.HttpResponse> oggetto.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'oggetto <see cref="T:System.Web.HttpResponse" /> non è disponibile.</exception>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="ResponseEncoding">
      <MemberSignature Language="C#" Value="public string ResponseEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResponseEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ResponseEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ResponseEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta il linguaggio di codifica per l'oggetto <see cref="T:System.Web.HttpResponse" /> corrente.</summary>
        <value>Una stringa che contiene il linguaggio di codifica per l'oggetto <see cref="T:System.Web.HttpResponse" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare il `ResponseEncoding` attributo sul valore desiderato utilizzando la direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta la proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData RouteData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteData RouteData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.RouteData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RouteData As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteData ^ RouteData { System::Web::Routing::RouteData ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore <see cref="P:System.Web.Routing.RequestContext.RouteData" /> dell'istanza di <see cref="T:System.Web.Routing.RequestContext" /> corrente.</summary>
        <value>Valore <see cref="P:System.Web.Routing.RequestContext.RouteData" /> dell'istanza di <see cref="T:System.Web.Routing.RequestContext" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se una pagina viene eseguito in risposta a una richiesta effettuata tramite il routing ASP.NET, questa proprietà fornisce l'accesso ai valori di parametro URL che vengono passati come dati della route. Se la pagina viene eseguito in risposta a un URL fisico anziché un URL di route, questa proprietà è `null`. Nell'esempio seguente viene illustrato come estrarre il valore di un parametro URL denominato `year`.  
  
```vb  
Dim year As Integer = Convert.ToInt32(Page.RouteData.Values("year"))  
```  
  
```csharp  
int year = Convert.ToInt32(Page.RouteData.Values["year"])  
```  
  
 Se la route è definita tramite il modello di URL `{locale}/{year}` per il dominio `contoso.com`, e se l'URL richiesto è `contoso.com/US/2010`, `year` conterrà il valore "2010" quando si esegue questo codice.  
  
 Per ulteriori informazioni sul routing di ASP.NET, vedere [Routing ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Routing.RequestContext.RouteData" />
      </Docs>
    </Member>
    <Member MemberName="SavePageStateToPersistenceMedium">
      <MemberSignature Language="C#" Value="protected internal virtual void SavePageStateToPersistenceMedium (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub SavePageStateToPersistenceMedium (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void SavePageStateToPersistenceMedium(System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Oggetto <see cref="T:System.Object" /> in cui archiviare le informazioni relative allo stato di visualizzazione.</param>
        <summary>Salva tutte le informazioni sullo stato di visualizzazione e sullo stato del controllo della pagina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> metodo utilizza il <xref:System.Web.UI.PageStatePersister.Save%2A> metodo il <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> oggetto a cui fa riferimento il <xref:System.Web.UI.Page.PageStatePersister%2A> proprietà per archiviare le informazioni sullo stato di visualizzazione e dello stato di controllo per la pagina.  
  
 ASP.NET include due discendenti del <xref:System.Web.UI.PageStatePersister> (classe), il <xref:System.Web.UI.HiddenFieldPageStatePersister> classe che consente di salvare le informazioni sullo stato in un campo nascosto incluso nella pagina ASP.NET, e <xref:System.Web.UI.SessionPageStatePersister> classe che consente di salvare lo stato nel <xref:System.Web.UI.Page.Session%2A> associato il richiesta. Si noti che quando si utilizza la <xref:System.Web.UI.SessionPageStatePersister> classe campo VIEWSTATE nascosto viene comunque eseguito il rendering come viene utilizzato per determinare il postback.  
  
 Per salvare lo stato nella posizione di propria scelta, è necessario creare un nuovo discendente della <xref:System.Web.UI.PageStatePersister> classe che salva e carica lo stato sul supporto di persistenza di propria scelta. Per un esempio di creazione di un nuovo <xref:System.Web.UI.PageStatePersister> , vedere la <xref:System.Web.UI.PageStatePersister> classe.  
  
 Se si utilizza .NET Framework versione 1.0 o 1.1, eseguire l'override di questo metodo se si desidera salvare il <xref:System.Web.UI.Page> stato qualcosa di diverso da un campo nascosto. Se si sceglie di eseguire questa operazione, è inoltre necessario sostituire il <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="SaveStateComplete">
      <MemberSignature Language="C#" Value="public event EventHandler SaveStateComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SaveStateComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.SaveStateComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SaveStateComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SaveStateComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica al termine del salvataggio di tutte le informazioni sullo stato di visualizzazione e sullo stato del controllo per la pagina e i relativi controlli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le informazioni sullo stato per i controlli della pagina Web sono state salvate dopo il <xref:System.Web.UI.Page.PreRenderComplete> evento. Il <xref:System.Web.UI.Page.SaveStateComplete> evento viene generato dopo il stato di visualizzazione e lo stato di controllo della pagina e controlli della pagina vengono salvati sul supporto di persistenza.  
  
 Si tratta dell'ultimo evento generato prima del rendering della pagina al browser.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see langword="Server" />, che è un'istanza della classe <see cref="T:System.Web.HttpServerUtility" />.</summary>
        <value>L'oggetto <see langword="Server" /> corrente associato alla pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà fornisce l'accesso a utilizzati di frequente <xref:System.Web.HttpServerUtility.HtmlEncode%2A> e <xref:System.Web.HttpServerUtility.MapPath%2A> tra gli altri metodi.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come accedere a informazioni sull'errore dal server tramite il `Server` oggetto. In particolare, nell'esempio viene ottenuto l'URL richiesto dal `Request` oggetto, l'errore più recente del `Server` oggetto (usando il <xref:System.Web.HttpServerUtility.GetLastError%2A> metodo) e li converte entrambi in stringhe che possono essere visualizzate dal client. Una volta il `message` scrittura variabile al client, l'errore viene eliminato usando il <xref:System.Web.HttpServerUtility.ClearError%2A> metodo.  
  
 [!code-csharp[System.Web.UI.Page_Error method#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Error method/CS/sourcecs.aspx#1)]
 [!code-vb[System.Web.UI.Page_Error method#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Error method/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpServerUtility" />
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Session" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see langword="Session" /> corrente fornito da ASP.NET.</summary>
        <value>I dati di stato sessione correnti.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà fornisce informazioni sulla sessione della richiesta corrente. Oggetto `Session` oggetto viene mantenuto per ogni utente che richiede una pagina o un documento da un'applicazione ASP.NET. Le variabili archiviate nel `Session` oggetto non vengono eliminate quando l'utente passa da una pagina nell'applicazione; in alternativa, queste variabili vengono mantenute fino a quando l'utente accede a pagine dell'applicazione. Per ulteriori informazioni sullo stato di sessione, vedere [panoramica dello stato della sessione di ASP.NET](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 L'esempio di codice seguente crea un `GetStyle` funzione che recupera una chiave archiviata nello stato della sessione della pagina Web Form e la converte in una stringa.  
  
 [!code-csharp[Page.Session_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Session_Samples1/CS/sessioncs.aspx#1)]
 [!code-vb[Page.Session_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Session_Samples1/VB/sessionvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Viene generata quando le informazioni di sessione sono impostate sul valore <see langword="null" />.</exception>
        <altmember cref="T:System.Web.HttpException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta lo stato attivo del browser sul controllo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">ID del controllo sul quale si desidera impostare lo stato attivo.</param>
        <summary>Imposta lo stato attivo del browser sul controllo con l'identificatore specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Web.UI.Page.SetFocus%2A> metodo per rendere il controllo con l'ID specificato stringa il controllo attivo nella pagina Web visualizzata nel browser. Il <xref:System.Web.UI.Page.SetFocus%2A> metodo deve essere chiamato prima della preparazione della pagina per il rendering al client il <xref:System.Web.UI.Control.PreRender> evento.  
  
> [!NOTE]
>  Il <xref:System.Web.UI.Page.SetFocus%2A> metodo funzionerà solo nel browser che supportano ECMAScript versione 1.3 o versione successiva.  
  
   
  
## Examples  
 Esempio di codice seguente imposta lo stato attivo nella seconda casella di testo in una pagina Web.  
  
> [!IMPORTANT]
>  L'esempio include una casella di testo che accetta l'input dell'utente e rappresenta quindi una potenziale minaccia alla sicurezza. Per impostazione predefinita, le pagine Web ASP.NET verificano che l'input dell'utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbyidcs.aspx#1)]
 [!code-aspx-vb[PageSetFocus#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbyidvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="clientID" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> viene chiamato quando il controllo non fa parte di una pagina Web Form.  \- oppure - Viene chiamato <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> dopo l'evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Controllo che riceverà lo stato attivo.</param>
        <summary>Imposta lo stato attivo del browser sul controllo specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Web.UI.Page.SetFocus%2A> metodo controllo attivo nella pagina Web visualizzata nel browser per il controllo specificato. Il <xref:System.Web.UI.Page.SetFocus%2A> metodo deve essere chiamato prima della preparazione della pagina per il rendering al client il <xref:System.Web.UI.Control.PreRender> evento.  
  
> [!NOTE]
>  Il <xref:System.Web.UI.Page.SetFocus%2A> metodo funzionerà solo nel browser che supportano ECMAScript versione 1.3 o versione successiva.  
  
   
  
## Examples  
 Esempio di codice seguente imposta lo stato attivo nella seconda casella di testo in una pagina Web.  
  
> [!IMPORTANT]
>  L'esempio include una casella di testo che accetta l'input dell'utente e rappresenta quindi una potenziale minaccia alla sicurezza. Per impostazione predefinita, le pagine Web ASP.NET verificano che l'input dell'utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#2](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbycontrolcs.aspx#2)]
 [!code-aspx-vb[PageSetFocus#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbycontrolvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> viene chiamato quando il controllo non fa parte di una pagina Web Form.  \- oppure - Viene chiamato <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> dopo l'evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipFormActionValidation">
      <MemberSignature Language="C#" Value="public bool SkipFormActionValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipFormActionValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SkipFormActionValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipFormActionValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipFormActionValidation { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il valore della stringa di query è abilitato.</summary>
        <value>
          <see langword="true" /> se la convalida della stringa di query deve essere ignorata (la stringa di query non deve essere convalidata); in caso contrario, <see langword="false" /> se la convalida della stringa di query deve essere eseguita normalmente. Il valore predefinito è <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SmartNavigation">
      <MemberSignature Language="C#" Value="public bool SmartNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SmartNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SmartNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Property SmartNavigation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SmartNavigation { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is Page.SetFocus and Page.MaintainScrollPositionOnPostBack. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se è abilitata la "smart navigation". Questa proprietà è deprecata.</summary>
        <value>
          <see langword="true" /> se la smart navigation è abilitata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare il `SmartNavigation` attributo `true` nella direttiva nel file con estensione aspx. Quando la pagina viene richiesta, questa proprietà è impostata la classe generata in modo dinamico.  
  
> [!NOTE]
>  In ASP.NET versione 2.0, il <xref:System.Web.UI.Page.SmartNavigation%2A> proprietà è deprecata. Utilizzare il <xref:System.Web.UI.Page.SetFocus%2A> (metodo) e <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> proprietà invece.  
  
 Quando viene richiesta una pagina dal browser Microsoft Internet Explorer 5.5 o versione successiva, navigazione migliora l'esperienza dell'utente della pagina eseguendo le operazioni seguenti:  
  
-   Eliminazione del lampeggiamento causato dallo spostamento.  
  
-   Salvare in modo permanente la posizione di scorrimento quando si sposta da una pagina.  
  
-   Mantenimento dello stato attivo di un elemento tra le navigazioni.  
  
-   Mantenendo solo l'ultimo stato di pagina nella cronologia del browser.  
  
 Navigazione viene utilizzato meglio con pagine ASP.NET che richiedono postback frequenti ma con contenuto visivo che non cambia in modo significativo in fase di restituzione. Valutare attentamente questo aspetto quando si decide se impostare questa proprietà su `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.Page.SetFocus" />
        <altmember cref="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      </Docs>
    </Member>
    <Member MemberName="StyleSheetTheme">
      <MemberSignature Language="C#" Value="public virtual string StyleSheetTheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StyleSheetTheme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.StyleSheetTheme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property StyleSheetTheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StyleSheetTheme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del tema che viene inizialmente applicato alla pagina nel ciclo di vita della pagina.</summary>
        <value>Il nome del tema che viene inizialmente applicato alla pagina nel ciclo di vita della pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà non fa riferimento direttamente a un foglio di stile (CSS). La proprietà contiene il nome di un tema ASP.NET, che può includere file CSS al suo interno.  
  
 Il <xref:System.Web.UI.Page.StyleSheetTheme%2A> proprietà specifica il nome di un tema che viene applicato a una pagina nel ciclo di vita di pagina, mentre il <xref:System.Web.UI.Page.Theme%2A> proprietà specifica il nome di un tema che viene applicato a una pagina in un secondo momento nel ciclo di vita della pagina. Ciò significa che le impostazioni nella pagina hanno la precedenza sulle impostazioni di tema del foglio di stile. Per ulteriori informazioni, vedere [ASP.NET temi e interfacce](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 È in genere possibile impostare un valore per questa proprietà nella direttiva page o eseguendo l'override della proprietà. Per informazioni, vedere gli argomenti seguenti:  
  
-   [Procedura: applicare temi ASP.NET](http://msdn.microsoft.com/library/f9d72364-4d77-4b73-84be-7630dc63e0fe)  
  
-   [Procedura: applicare temi ASP.NET a livello di codice](http://msdn.microsoft.com/library/02eed7c3-01e8-4e20-8358-df47dbd4f148))  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si è tentato di impostare la proprietà <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> dopo la chiamata al metodo <see cref="M:System.Web.UI.Page.FrameworkInitialize" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> è impostata su un nome di tema non valido. Questa eccezione viene generata quando viene chiamato il metodo <see cref="M:System.Web.UI.Page.FrameworkInitialize" />, non dal metodo di impostazione della proprietà.</exception>
        <altmember cref="P:System.Web.UI.Page.Theme" />
      </Docs>
    </Member>
    <Member MemberName="Theme">
      <MemberSignature Language="C#" Value="public virtual string Theme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Theme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Theme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Theme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Theme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del tema della pagina.</summary>
        <value>Nome del tema della pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.Theme%2A> proprietà imposta il nome del tema utilizzato per la pagina. Se si desidera le impostazioni nella pagina hanno la precedenza sulle impostazioni del tema, utilizzare il <xref:System.Web.UI.Page.StyleSheetTheme%2A> proprietà. Per ulteriori informazioni, vedere [ASP.NET temi e interfacce](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 Il <xref:System.Web.UI.Page.Theme%2A> proprietà deve essere impostata prima del <xref:System.Web.UI.Page.PreInit> eventi; dell'impostazione di <xref:System.Web.UI.Page.Theme%2A> proprietà dopo il <xref:System.Web.UI.Page.PreInit> evento causerà un <xref:System.InvalidOperationException> eccezione.  
  
 Il tema specificato deve esistere come un'applicazione o un tema globale. Se il tema non esiste, un <xref:System.Web.HttpException> viene generata un'eccezione.  
  
   
  
## Examples  
 Nell'esempio di codice viene impostata la <xref:System.Web.UI.Page.Theme%2A> proprietà a un nome passato nella stringa di query.  
  
 [!code-csharp[PageTheme#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageTheme/CS/pagethemecs.aspx#1)]
 [!code-vb[PageTheme#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageTheme/VB/pagethemevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">È stato effettuato un tentativo di impostare la proprietà <see cref="P:System.Web.UI.Page.Theme" /> dopo che si è verificato l'evento <see cref="E:System.Web.UI.Page.PreInit" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Web.UI.Page.Theme" /> è impostata su un nome di tema non valido.</exception>
        <altmember cref="P:System.Web.UI.Page.StyleSheetTheme" />
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta il titolo per la pagina.</summary>
        <value>Titolo della pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Web.UI.Page.Title%2A> proprietà per impostare il titolo della pagina nell'intestazione HTML inviata al browser.  
  
> [!NOTE]
>  La pagina deve contenere un `head` elemento che dispone dell'attributo `runat="server"`, in caso contrario il titolo non eseguirà il rendering.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Web.UI.Page.Title" /> richiede un controllo intestazione sulla pagina.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlTitle" />
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Web.TraceContext" /> relativo alla richiesta Web corrente.</summary>
        <value>I dati forniti dall'oggetto <see cref="T:System.Web.TraceContext" /> per la richiesta Web corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tiene traccia di traccia e visualizza i dettagli di esecuzione relative a una richiesta Web. Per i dati di traccia siano visibili in una pagina visualizzata, è necessario abilitare la traccia a livello di applicazione o pagina.  
  
 Analisi delle pagine sono disabilitata per impostazione predefinita. Per abilitare la traccia per una pagina, utilizzare la direttiva `<% @ Page trace="true" %>`. Per abilitare la traccia per un'intera applicazione, è necessario abilitarla nel file di configurazione dell'applicazione, Web. config, che si trova nella directory radice dell'applicazione. Per ulteriori informazioni, vedere [Cenni preliminari sulla traccia di ASP.NET](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'accesso di <xref:System.Web.TraceContext.IsEnabled%2A?displayProperty=nameWithType> proprietà e <xref:System.Web.TraceContext.Write%2A?displayProperty=nameWithType> metodo tramite il <xref:System.Web.UI.Page.Trace%2A> proprietà. Questo codice chiama il <xref:System.Diagnostics.Trace.Write%2A> metodo solo durante la traccia è abilitato per il <xref:System.Web.UI.Page> oggetto. Se non è abilitato, questo codice non viene eseguito, che consente di ridurre l'overhead per l'applicazione.  
  
 [!code-csharp[System.Web.UI.Page.Trace#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Trace/CS/trace1cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Trace#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Trace/VB/trace1vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceEnabled">
      <MemberSignature Language="C#" Value="public bool TraceEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TraceEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TraceEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta un valore che indica se la tracciatura è abilitata per l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
        <value>
          <see langword="true" /> se la tracciatura è abilitata per la pagina, altrimenti <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare il `Trace` attributo `true` nella direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta la proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceModeValue" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceModeValue">
      <MemberSignature Language="C#" Value="public System.Web.TraceMode TraceModeValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.TraceMode TraceModeValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceModeValue" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceModeValue As TraceMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceMode TraceModeValue { System::Web::TraceMode get(); void set(System::Web::TraceMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta la modalità di visualizzazione nella pagina per le istruzioni di traccia.</summary>
        <value>Uno dei membri dell'enumerazione <see cref="T:System.Web.TraceMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare il `TraceMode` attributo della direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta la proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceEnabled" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TransactionMode">
      <MemberSignature Language="C#" Value="protected int TransactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TransactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TransactionMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property TransactionMode As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int TransactionMode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta il livello del supporto delle transazioni per la pagina.</summary>
        <value>Un intero che rappresenta uno dei membri dell'enumerazione <see cref="T:System.EnterpriseServices.TransactionOption" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella maggior parte dei casi, non impostare questa proprietà nel codice. Impostare il `Transaction` attributo della direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta la proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryUpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiorna l'istanza del modello specificato tramite valori di un provider di valori.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per una serie di esercitazioni sull'uso di associazione di modelli con Web Form, vedere [associazione del modello e Web Form](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Tipo del modello.</typeparam>
        <param name="model">Modello.</param>
        <summary>Aggiorna l'istanza del modello specificata tramite i valori dal controllo associato ai dati.</summary>
        <returns>
          <see langword="true" /> se l'associazione di modelli è corretta; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere chiamato solo da un metodo specificato da un controllo con associazione a dati `UpdateMethod` o `InsertMethod` proprietà.  
  
 Per una serie di esercitazioni sull'uso di associazione di modelli con Web Form, vedere [associazione del modello e Web Form](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Tipo del modello.</typeparam>
        <param name="model">Modello.</param>
        <param name="valueProvider">Provider di valori.</param>
        <summary>Aggiorna l'istanza del modello tramite valori del provider di valori specificato.</summary>
        <returns>
          <see langword="true" /> se l'associazione di modelli è corretta; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per una serie di esercitazioni sull'uso di associazione di modelli con Web Form, vedere [associazione del modello e Web Form](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UICulture">
      <MemberSignature Language="C#" Value="public string UICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UICulture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property UICulture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UICulture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta l'ID dell'interfaccia utente per l'oggetto <see cref="T:System.Threading.Thread" /> associato alla pagina.</summary>
        <value>L'ID dell'interfaccia utente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è una scelta rapida per il <xref:System.Threading.Thread.CurrentThread%2A> proprietà. Le impostazioni cultura sono una proprietà del thread in esecuzione  
  
 Impostare il `UICulture` attributo della direttiva nel file con estensione aspx. Quando la pagina viene richiesta, la classe generata in modo dinamico imposta il valore di questa proprietà. Inoltre, è possibile impostare in modo esplicito il valore della <xref:System.Web.UI.Page.UICulture%2A> proprietà del file Web. config.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
      </Docs>
    </Member>
    <Member MemberName="UniqueFilePathSuffix">
      <MemberSignature Language="C#" Value="protected internal virtual string UniqueFilePathSuffix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueFilePathSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property UniqueFilePathSuffix As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::String ^ UniqueFilePathSuffix { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un suffisso univoco da aggiungere al percorso del file per i browser di cache.</summary>
        <value>Un suffisso univoco aggiunto al percorso del file. Il valore predefinito è "__ufps=" più un numero univoco a 6 cifre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.UniqueFilePathSuffix%2A> proprietà restituisce una stringa che viene aggiunto alla fine di un percorso di file quando richiesto per la memorizzazione nella cache i browser. La stringa viene utilizzata per identificare il percorso di file associato a una richiesta specifica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnobtrusiveValidationMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property UnobtrusiveValidationMode As UnobtrusiveValidationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::UnobtrusiveValidationMode UnobtrusiveValidationMode { System::Web::UI::UnobtrusiveValidationMode get(); void set(System::Web::UI::UnobtrusiveValidationMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.UnobtrusiveValidationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se JavaScript non intrusivo viene utilizzato per la convalida lato client.</summary>
        <value>
          <see langword="true" /> se viene utilizzato JavaScript non intrusivo; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void UnregisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UnregisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Oggetto <see cref="T:System.Web.UI.Control" /> per il quale si desidera interrompere la persistenza dello stato del controllo.</param>
        <summary>Interrompe la persistenza dello stato del controllo per il controllo specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controlli personalizzati di server che utilizzano lo stato del controllo è necessario chiamare il <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> a ogni richiesta durante la prima viene mantenuto lo stato. Registrazione dello stato del controllo non è salvata da una richiesta a richiesta durante un postback. Utilizzare il <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> metodo per assicurarsi che lo stato del controllo non è persistente per i controlli che non devono essere mantenute per il postback.  
  
 Internamente, il <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> metodo viene richiamato quando si utilizza il <xref:System.Web.UI.Control.RemovedControl%2A> metodo per rimuovere un controllo da una raccolta di controlli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'elemento <see cref="T:System.Web.UI.Control" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiorna l'istanza del modello specificato tramite valori di un provider di valori.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per una serie di esercitazioni sull'uso di associazione di modelli con Web Form, vedere [associazione del modello e Web Form](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Tipo del modello.</typeparam>
        <param name="model">Modello.</param>
        <summary>Aggiorna l'istanza del modello specificata tramite i valori dal controllo associato ai dati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere chiamato solo da un metodo specificato da un controllo con associazione a dati `UpdateMethod` o `InsertMethod` proprietà.  
  
 Per una serie di esercitazioni sull'uso di associazione di modelli con Web Form, vedere [associazione del modello e Web Form](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">Tipo del modello.</typeparam>
        <param name="model">Modello.</param>
        <param name="valueProvider">Provider di valori.</param>
        <summary>Aggiorna l'istanza del modello specificato tramite valori del provider di valori specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per una serie di esercitazioni sull'uso di associazione di modelli con Web Form, vedere [associazione del modello e Web Form](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.User" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene informazioni relative all'utente che esegue la richiesta della pagina.</summary>
        <value>Un oggetto <see cref="T:System.Security.Principal.IPrincipal" /> che rappresenta l'utente che esegue la richiesta della pagina.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Security.Principal.IPrincipal> oggetto rappresenta il contesto di sicurezza dell'utente per conto del quale il codice è in esecuzione, inclusi l'identità dell'utente e gli eventuali ruoli a cui appartiene.  
  
 Questa proprietà Usa il <xref:System.Web.HttpContext> dell'oggetto <xref:System.Web.HttpContext.User%2A> proprietà per determinare l'origine della richiesta.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Web.UI.Page.User%2A> proprietà per accedere alle informazioni di autenticazione e identità per l'utente corrente. Se l'utente non è autenticato, viene reindirizzato a una pagina di accesso.  
  
 [!code-csharp[Page_User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_User/CS/page_user.cs.aspx#1)]
 [!code-vb[Page_User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_User/VB/page_user.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Security.Principal.IPrincipal" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica ai controlli di convalida inclusi nella pagina di convalidare le informazioni a essi assegnate.</summary>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica ai controlli di convalida inclusi nella pagina di convalidare le informazioni a essi assegnate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene richiamato quando un utente fa clic su qualsiasi controllo server ASP.NET che ha il `CausesValidation` proprietà impostata su `true`, ovvero l'impostazione predefinita. Queste includono la <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, e <xref:System.Web.UI.WebControls.LinkButton> controlli server Web, il <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, e <xref:System.Web.UI.HtmlControls.HtmlButton> controlli server HTML e controlli che è possono registrare automaticamente al server, ad esempio il <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, e <xref:System.Web.UI.WebControls.BulletedList> controlli.  
  
 Per disabilitare la convalida per qualsiasi controllo pulsante nella pagina, impostare il controllo button `CausesValidation` proprietà `false`.  
  
 Quando questo metodo viene richiamato, scorrere i controlli di convalida contenuti nel <xref:System.Web.UI.ValidatorCollection> oggetto associato di <xref:System.Web.UI.Page.Validators%2A?displayProperty=nameWithType> proprietà e richiama la logica di convalida per ogni controllo di convalida nel gruppo di convalida corrente. Il gruppo di convalida è determinato dal controllo che la pagina al server registrato. Se viene specificato alcun gruppo di convalida, non viene utilizzato alcun gruppo di convalida.  
  
> [!NOTE]
>  È stato modificato il comportamento della convalida della pagina. In [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], controlla la chiamata non è più il <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> metodo; vengono utilizzare il <xref:System.Web.UI.Page.Validate%28System.String%29?displayProperty=nameWithType> metodo invece. Se si utilizza il <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> metodo su un [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] pagina gruppi di convalida vengono ignorati e tutti i controlli vengono convalidati.  
  
   
  
## Examples  
 Nell'esempio di codice viene chiamato il <xref:System.Web.UI.Page.Validate%2A> definito metodo in una pagina in uno scenario con più gruppi di convalida a altra.  
  
> [!IMPORTANT]
>  L'esempio include una casella di testo che accetta l'input dell'utente e rappresenta quindi una potenziale minaccia alla sicurezza. Per impostazione predefinita, le pagine Web ASP.NET verificano che l'input dell'utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Il <see cref="M:System.Web.UI.Page.Validate" /> (metodo) non viene utilizzato da [! INCLUDE[vstecasplong](~/Includes/vstecasplong-MD.MD)]. Quando si utilizza [! INCLUDE[vstecasplong](~/Includes/vstecasplong-MD.MD)], eseguire l'override di <see cref="M:System.Web.UI.Page.Validate(System.String)" /> metodo per modificare il comportamento di convalida di pagina.</para>
        </block>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate (validationGroup As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate(System::String ^ validationGroup);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">Nome del gruppo di convalida dei controlli da convalidare.</param>
        <summary>Indica ai controlli di convalida nel gruppo di convalida specificato di convalidare le informazioni ad essi assegnate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene richiamato quando un utente fa clic su qualsiasi controllo server ASP.NET che ha il `CausesValidation` proprietà impostata su `true`, ovvero l'impostazione predefinita. Queste includono la <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, e <xref:System.Web.UI.WebControls.LinkButton> controlli server Web, il <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, e <xref:System.Web.UI.HtmlControls.HtmlButton> controlli server HTML e controlli che è possono registrare automaticamente al server, ad esempio il <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, e <xref:System.Web.UI.WebControls.BulletedList> controlli.  
  
 Per disabilitare la convalida per qualsiasi controllo pulsante nella pagina, impostare il controllo button `CausesValidation` proprietà `false`.  
  
 Il <xref:System.Web.UI.Page.Validate%2A> metodo convalida il gruppo di convalida specificato. Dopo la chiamata di <xref:System.Web.UI.Page.Validate%2A> metodo su un gruppo di convalida, il <xref:System.Web.UI.Page.IsValid%2A> metodo restituirà `true` solo se il gruppo di convalida specificato sia il gruppo di convalida del controllo che ha causato la pagina per essere inviati al server sono validi.  
  
   
  
## Examples  
 Nell'esempio di codice viene chiamato il <xref:System.Web.UI.Page.Validate%2A> definito metodo in una pagina in uno scenario con più gruppi di convalida a altra.  
  
> [!IMPORTANT]
>  L'esempio include una casella di testo che accetta l'input dell'utente e rappresenta quindi una potenziale minaccia alla sicurezza. Per impostazione predefinita, le pagine Web ASP.NET verificano che l'input dell'utente non includa script o elementi HTML. Per altre informazioni, vedere [Cenni preliminari sugli attacchi tramite script](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la pagina verifica la presenza di valori potenzialmente pericolosi nell'input proveniente dal browser.</summary>
        <value>Valore che indica se la pagina verifica l'input del client. Il valore predefinito è <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore <xref:System.Web.UI.ValidateRequestMode.Inherit> non viene utilizzato nel <xref:System.Web.UI.Page> classe perché nessun elemento da cui ereditare.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Validators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection Validators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ValidatorCollection Validators" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Validators" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Validators As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ValidatorCollection ^ Validators { System::Web::UI::ValidatorCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un insieme di tutti i controlli di convalida contenuti nella pagina richiesta.</summary>
        <value>L'insieme dei controlli di convalida.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare questa proprietà per modificare i metodi e le proprietà di <xref:System.Web.UI.ValidatorCollection> oggetto associato all'oggetto corrente <xref:System.Web.UI.Page> istanza. Questa raccolta contiene tutti i controlli server di convalida contenuti in una pagina.  
  
 La chiamata di <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> metodo determina la logica di convalida da eseguire per ogni controllo del server di convalida nel gruppo di convalida corrente. Se non si passano uno di questi controlli, la <xref:System.Web.UI.Page.IsValid%2A?displayProperty=nameWithType> restituisce proprietà `false`.  
  
 Per ulteriori informazioni sui controlli di convalida, vedere [controlli di convalida ASP.NET](http://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
      </Docs>
    </Member>
    <Member MemberName="VerifyRenderingInServerForm">
      <MemberSignature Language="C#" Value="public virtual void VerifyRenderingInServerForm (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyRenderingInServerForm(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.VerifyRenderingInServerForm(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void VerifyRenderingInServerForm(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Controllo server ASP.NET richiesto nel controllo <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</param>
        <summary>Conferma che in fase di esecuzione viene eseguito il rendering di un controllo <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> per il controllo server ASP.NET specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I controlli che devono essere racchiusi tra `<form runat=server>` tag possono chiamare questo metodo prima del rendering in modo che un messaggio di errore viene visualizzato se vengono inseriti all'esterno dei tag. I controlli che eseguono il postback o dipendono da blocchi di script registrati devono chiamare questo metodo in un override del <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metodo. Pagine che presentano un modo diverso per il rendering dell'elemento di modulo server possono eseguire l'override di questo metodo per generare un'eccezione in condizioni diverse.  
  
 I controlli server che eseguono il postback o utilizzano script sul lato client non funzionerà se non sono racchiusi tra il <xref:System.Web.UI.HtmlControls.HtmlForm> controllo server (<`form runat="server">`) tag. Questi controlli possono chiamare questo metodo quando si esegue il rendering per fornire un messaggio di errore quando non sono racchiusi tra il <xref:System.Web.UI.HtmlControls.HtmlForm> controllo.  
  
 Quando si sviluppa un controllo server personalizzato, è raro chiamare questo metodo quando esegue l'override di `Render` metodo per qualsiasi tipo di tag di input. Ciò è particolarmente importante se il controllo di input chiama <xref:System.Web.UI.Page.GetPostBackEventReference%2A>, o se genera lo script client. Per effettuare la chiamata non è necessario un controllo server composito.  
  
   
  
## Examples  
 Nell'esempio di codice viene eseguito l'override di <xref:System.Web.UI.Page.Render%2A?displayProperty=nameWithType> metodo di un controllo server personalizzato. Quando il controllo scrive il contenuto a una pagina, viene utilizzato il <xref:System.Web.UI.Page.VerifyRenderingInServerForm%2A> per verificare che il controllo viene visualizzato tra i tag di apertura e chiusura di un <xref:System.Web.UI.HtmlControls.HtmlForm> controllo.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#3)]
 [!code-vb[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/vb/testlinkbutton.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">In fase di esecuzione, il controllo server specificato non è racchiuso tra i tag di apertura e di chiusura del controllo server <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il controllo da verificare è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateEncryptionMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateEncryptionMode As ViewStateEncryptionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ViewStateEncryptionMode ViewStateEncryptionMode { System::Web::UI::ViewStateEncryptionMode get(); void set(System::Web::UI::ViewStateEncryptionMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la modalità di crittografia dello stato di visualizzazione.</summary>
        <value>Uno dei valori di <see cref="T:System.Web.UI.ViewStateEncryptionMode" />. Il valore predefinito è <see cref="F:System.Web.UI.ViewStateEncryptionMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> non può essere impostata nel codice. Può essere impostato solo nella direttiva o nel < elemento del file di configurazione. I valori impostati nella direttiva esegue l'override di tutti i valori impostati nel file di configurazione.  
  
 La sintassi per l'impostazione di questa proprietà nella direttiva è come segue:  
  
```vb  
<%@ Page Language="VB" ViewStateEncryptionMode="Always" %>  
```  
  
```csharp  
<%@ Page Language="C#" ViewStateEncryptionMode="Always" %>  
```  
  
 La sintassi per l'impostazione di questa proprietà nel file di configurazione è come segue:  
  
```vb  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
```csharp  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
 Sviluppatori di controlli personalizzato potrebbero essere necessario controllare il valore di questa proprietà nel codice prima di salvare i dati potenzialmente riservati per visualizzare lo stato dei relativi controlli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore impostato non è un membro dell'enumerazione <see cref="T:System.Web.UI.ViewStateEncryptionMode" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Web.UI.Page.ViewStateEncryptionMode" /> può essere impostata solo durante o prima della fase <see langword="PreRender" /> della pagina del ciclo di vita della pagina.</exception>
        <altmember cref="T:System.Web.UI.ViewStateEncryptionMode" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateUserKey">
      <MemberSignature Language="C#" Value="public string ViewStateUserKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ViewStateUserKey" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateUserKey" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateUserKey As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ViewStateUserKey { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Assegna un identificatore a un singolo utente nella variabile dello stato di visualizzazione associata alla pagina corrente.</summary>
        <value>L'identificatore per il singolo utente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'impostazione di <xref:System.Web.UI.Page.ViewStateUserKey%2A> proprietà consente di evitare gli attacchi all'applicazione da utenti malintenzionati. Ciò avviene in quanto consente di assegnare un identificatore per la variabile di stato di visualizzazione per i singoli utenti, in modo che questi non è possibile utilizzare la variabile per generare un attacco. Per ulteriori informazioni sugli attacchi Web e sulle operazioni eseguibili per prevenirli, vedere [richiedere vantaggio di ASP.NET funzionalità incorporate per Fend attacchi Web](http://go.microsoft.com/fwlink/?LinkId=163557).  
  
 È possibile impostare questa proprietà su qualsiasi valore stringa, ad esempio nome autenticato dell'utente o il <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> valore.  
  
> [!NOTE]
>  È necessario impostare questa proprietà durante il `Page_Init` fase dell'elaborazione della pagina. Impostazione di questa proprietà durante il `Page_Load` fase genera un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'accesso alla proprietà <see cref="P:System.Web.UI.Page.ViewStateUserKey" /> durante l'elaborazione della pagina è stato effettuato troppo tardi.</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se è stato eseguito il rendering dell'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
        <value>
          <see langword="true" /> se deve essere eseguito il rendering della <see cref="T:System.Web.UI.Page" />, altrimenti <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente imposta il <xref:System.Web.UI.Page.Visible%2A> proprietà `false` per nascondere il contenuto viene eseguito il rendering di una pagina. Alla prima richiesta questa pagina, un'origine dati viene popolata e visualizzata nella pagina. Quando un utente fa clic sul pulsante, il `HideButton_Click` gestore nasconde l'intero renderizzato del contenuto della pagina.  
  
 [!code-csharp[Page_Visible#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_Visible/CS/page_visible.cs.aspx#1)]
 [!code-vb[Page_Visible#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_Visible/VB/page_visible.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.UI.TemplateControl" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
  </Members>
</Type>