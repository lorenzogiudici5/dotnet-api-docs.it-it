<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="230ccdaa372490a255772449e9c71e08f0f2b63e" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52207550" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definisce i metodi per la gestione di script client nelle applicazioni Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.ClientScriptManager> classe viene utilizzata per gestire gli script client e aggiungerle alle applicazioni Web. È possibile ottenere un riferimento al <xref:System.Web.UI.ClientScriptManager> classe la <xref:System.Web.UI.Page.ClientScript%2A> proprietà del <xref:System.Web.UI.Page> oggetto.  
  
 È possibile aggiungere uno script client a una pagina Web in modo dichiarativo, includendo lo script nel markup HTML della pagina. Tuttavia, esistono situazioni è necessario aggiungere lo script client in modo dinamico. Per aggiungere uno script in modo dinamico, usare il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metodo, il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metodo, il <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodo, o il <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metodo, a seconda di come e quando si desidera aggiungere lo script. Per altre informazioni, vedere [procedura: aggiungere Client uno Script in modo dinamico da ASP.NET Web Pages](https://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666).  
  
 Il <xref:System.Web.UI.ClientScriptManager> classe identifica in modo univoco gli script da una chiave <xref:System.String> e un <xref:System.Type>. Gli script con la stessa chiave e tipo vengono considerati duplicati. Utilizzando il tipo di script consente di evitare confusione script simili da diversi controlli utente che potrebbero essere in uso nella pagina.  
  
 Il <xref:System.Web.UI.ClientScriptManager> classe può essere usata per richiamare i callback del client in situazioni quando è preferibile eseguire il codice lato server dal client senza eseguendo un postback. Ciò è detto eseguendo un callback di out-of-band al server. In un callback del client, una funzione di script client invia una richiesta asincrona a una pagina Web ASP.NET. La pagina Web viene eseguita una versione modificata del normale ciclo di vita per elaborare il callback. Usare il <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodo per ottenere un riferimento a una funzione client che, quando richiamata, avvia un callback del client a un evento del server. Per altre informazioni, vedere [implementazione di callback Client senza i postback](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Gli script di callback non funzionerà nei browser meno recenti che non supportano il modello DOM (Document Object), e richiedono che ECMAScript sia abilitato nel client. Per verificare se il browser supporta i callback, usare il <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> proprietà, che è accessibile tramite il <xref:System.Web.HttpRequest.Browser%2A> proprietà intrinseca di ASP.NET <xref:System.Web.HttpContext.Request%2A> oggetto.  
  
 Usare la <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo e il <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> metodo per definire un evento di postback del client. Questi metodi consentono alle funzioni di script client, quando richiamata, per il server eseguire il postback della pagina. Un evento di postback del client è diverso da un callback del client in un normale ciclo di vita per elaborare l'evento di postback del client al completamento della pagina Web.  
  
> [!NOTE]
>  Se si usa un <xref:System.Web.UI.WebControls.Button> controllo e il <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> è impostata su `false`, è quindi possibile usare i <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo per restituire il client di postback evento per il <xref:System.Web.UI.WebControls.Button> controllo.  
  
 Il <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> proprietà del <xref:System.Web.UI.WebControls.Button> (controllo), <xref:System.Web.UI.WebControls.ImageButton> controllo e <xref:System.Web.UI.WebControls.LinkButton> controllo può essere usato per eseguire lo script client.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo dei <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metodo del <xref:System.Web.UI.ClientScriptManager> classe. Nella pagina vengono definiti due script client: `PopupScript`, che visualizza un messaggio di avviso quando la pagina viene caricata, e `ButtonClickScript`, che definisce un gestore del client per un pulsante HTML `onClick` evento.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">Script client nelle pagine Web ASP.NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Callback del client senza i postback nelle pagine ASP.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un riferimento a una funzione client che, quando richiamata, avvia un callback client a un evento server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Server <see cref="T:System.Web.UI.Control" /> che gestisce il callback client. Il controllo deve implementare l'interfaccia <see cref="T:System.Web.UI.ICallbackEventHandler" /> e fornire un metodo <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argomento passato al server dallo script client. 
 Metodo<see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> .</param>
        <param name="clientCallback">Nome del gestore eventi client che riceve il risultato dell'evento server riuscito.</param>
        <param name="context">Script client che viene valutato sul client prima di avviare il callback. Il risultato dello script viene restituito al gestore eventi client.</param>
        <summary>Ottiene un riferimento a una funzione client che, quando richiamata, avvia un callback client a un evento server. La funzione client per questo metodo di overload include un controllo, un argomento, uno script client e un contesto specificati.</summary>
        <returns>Nome di una funzione client che richiama il callback client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> metodo esegue un callback di out-of-band al server che è una versione modificata del normale ciclo di vita della pagina. Per altre informazioni, vedere [implementazione di callback Client senza i postback](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Quando il browser Microsoft Internet Explorer (versione 5.0 o versioni successive), il meccanismo di callback di script viene implementato tramite l'oggetto COM Microsoft. XMLHTTP e richiede che il browser da impostare per l'esecuzione dei controlli ActiveX. Per altri browser, viene usato un evento XMLHttpRequest locale del modello DOM del browser (Document Object) utilizzando. Per verificare se un browser supporta i callback del client, usare il <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> proprietà. Per verificare se un browser supporta XML tramite HTTP, usare il <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> proprietà. Entrambe le proprietà sono accessibili tramite il <xref:System.Web.HttpRequest.Browser%2A> proprietà di intrinseche ASP.NET <xref:System.Web.HttpContext.Request%2A> oggetto.  
  
 Il <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> eseguire l'overload del <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodo esegue un callback in modo sincrono tramite XML tramite HTTP. Quando si inviano dati in modo sincrono in uno scenario di callback, callback sincrono a restituire immediatamente e non bloccare il browser. Nessuna due callback sincroni possono eseguire contemporaneamente nel browser. Se viene generato un callback sincrono secondo mentre è in corso, il callback sincrono secondo Annulla il primo e verrà restituito solo il callback di secondo.  
  
 Per inviare i dati in modo asincrono, usare uno degli overload che accetta il `useAsync` parametro, ovvero un valore booleano valore che controlla questo comportamento. Nello scenario asincrono è possibile avere più callback in sospeso. Tuttavia, l'ordine in cui vengono restituiti è necessariamente corrispondere all'ordine in cui vengono avviate.  
  
 Inoltre, questo overload del metodo il <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodo non specifica alcuna funzione client per gestire il caso di una condizione di errore generato dal <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> (metodo). Per specificare un gestore di callback di errore di client, usare uno degli overload che accetta il `clientErrorCallback` parametro.  
  
 Il <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> metodo accetta una stringa facoltativa `argument` parametro e restituisce una stringa. Per passare o per la ricezione di più valori, concatenare i valori nell'input o restituiscono string, rispettivamente.  
  
> [!NOTE]
>  Evitare di usare lo stato di visualizzazione nell'implementazione di pagina o controllo proprietà che devono essere aggiornati durante le operazioni di callback di script. Se le proprietà sono in caso di richieste di pagine, è possibile usare lo stato della sessione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare i due overload del <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodo in uno scenario di callback client che viene incrementato di numeri interi.  
  
 Vengono visualizzati due meccanismi di callback; la differenza tra di essi è l'uso del `context` parametro. Oggetto `ReceiveServerData1` funzione di callback client viene fornito tramite il `context` parametro. Al contrario, il `ReceiveServerData2` funzione di callback client è definita un `<script>` blocco nella pagina. Oggetto <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metodo è il gestore del server che viene incrementato il valore passato ad esso e <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> metodo viene restituito il valore incrementato sotto forma di stringa. Se il <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metodo restituisce un errore, il `ProcessCallBackError` viene chiamata la funzione di client.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’oggetto <see cref="T:System.Web.UI.Control" /> specificato è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Web.UI.Control" /> specificato non implementa l'interfaccia <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Callback del client senza i postback nelle pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Server <see cref="T:System.Web.UI.Control" /> che gestisce il callback client. Il controllo deve implementare l'interfaccia <see cref="T:System.Web.UI.ICallbackEventHandler" /> e fornire un metodo <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argomento passato al server dallo script client. 
 Metodo<see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> .</param>
        <param name="clientCallback">Nome del gestore eventi client che riceve il risultato dell'evento server riuscito.</param>
        <param name="context">Script client che viene valutato sul client prima di avviare il callback. Il risultato dello script viene restituito al gestore eventi client.</param>
        <param name="useAsync">
          <see langword="true" /> per eseguire il callback in modo asincrono; <see langword="false" /> per eseguire il callback in modo sincrono.</param>
        <summary>Ottiene un riferimento a una funzione client che, quando richiamata, avvia un callback client agli eventi server. La funzione client per questo metodo di overload include un controllo, un argomento, uno script client, un contesto e un valore Boolean specificati.</summary>
        <returns>Nome di una funzione client che richiama il callback client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo di <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodo richiede un `useAsync` parametro, che consente di eseguire in modo asincrono il callback client impostando il valore su `true`. Le versioni di overload del metodo che non richiedono la `useAsync` parametro è impostato il valore su `false` per impostazione predefinita.  
  
 Per altre informazioni su questo metodo, vedere la sezione Osservazioni per eseguire l'overload <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’oggetto <see cref="T:System.Web.UI.Control" /> specificato è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Web.UI.Control" /> specificato non implementa l'interfaccia <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Callback del client senza i postback nelle pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Nome di un server <see cref="T:System.Web.UI.Control" /> che gestisce il callback client. Il controllo deve implementare l'interfaccia <see cref="T:System.Web.UI.ICallbackEventHandler" /> e fornire un metodo <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argomento passato al server dallo script client. 
 Metodo<see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> .</param>
        <param name="clientCallback">Nome del gestore eventi client che riceve il risultato dell'evento server riuscito.</param>
        <param name="context">Script client che viene valutato sul client prima di avviare il callback. Il risultato dello script viene restituito al gestore eventi client.</param>
        <param name="clientErrorCallback">Nome del gestore eventi client che riceve il risultato quando si verifica un errore nel gestore eventi server.</param>
        <param name="useAsync">
          <see langword="true" /> per eseguire il callback in modo asincrono; <see langword="false" /> per eseguire il callback in modo sincrono.</param>
        <summary>Ottiene un riferimento a una funzione client che, quando richiamata, avvia un callback client agli eventi server. La funzione client per questo metodo di overload include una destinazione, un argomento, uno script client, un contesto, un gestore errori e un valore Boolean specificati.</summary>
        <returns>Nome di una funzione client che richiama il callback client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo il <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodo accetta un `target` stringa parametro anziché un <xref:System.Web.UI.Control> parametro. Utilizzare questo overload quando si desidera che il callback per tornare a un valore diverso da una stringa contenente il <xref:System.Web.UI.Control.UniqueID%2A> del controllo.  
  
 Inoltre, questo overload del metodo di <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodo richiede un `useAsync` e un `clientErrorCallback` parametro. Il `useAsync` parametro consente di eseguire in modo asincrono il callback client impostando il valore su `true`. Le versioni di overload del metodo che non richiedono la `useAsync` parametro è impostato il valore su `false` per impostazione predefinita. Il `clientErrorCallback` parametro consente di definire il nome della funzione client che viene chiamato se il gestore del server, il <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> (metodo), restituisce un errore. Le versioni di overload del metodo che non richiedono il `clientErrorCallback` parametro impostato il valore su null.  
  
 Per altre informazioni su questo metodo, vedere la sezione Osservazioni per eseguire l'overload <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare i due overload del <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodo in uno scenario di callback client che viene incrementato di numeri interi.  
  
 Vengono visualizzati due meccanismi di callback; la differenza tra di essi è l'uso del `context` parametro. Oggetto `ReceiveServerData1` funzione di callback client viene fornito tramite il `context` parametro. Al contrario, il `ReceiveServerData2` funzione di callback client è definita un `<script>` blocco nella pagina. Oggetto <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metodo è il gestore del server che viene incrementato il valore passato ad esso e <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> metodo viene restituito il valore incrementato sotto forma di stringa. Se il <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> metodo restituisce un errore, quindi la funzione client `ProcessCallBackError` viene chiamato.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Callback del client senza i postback nelle pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Server <see cref="T:System.Web.UI.Control" /> che gestisce il callback client. Il controllo deve implementare l'interfaccia <see cref="T:System.Web.UI.ICallbackEventHandler" /> e fornire un metodo <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Argomento passato dallo script client al metodo <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> del server.</param>
        <param name="clientCallback">Nome del gestore eventi client che riceve il risultato dell'evento server riuscito.</param>
        <param name="context">Script client che viene valutato sul client prima di avviare il callback. Il risultato dello script viene restituito al gestore eventi client.</param>
        <param name="clientErrorCallback">Nome del gestore eventi client che riceve il risultato quando si verifica un errore nel gestore eventi server.</param>
        <param name="useAsync">
          <see langword="true" /> per eseguire il callback in modo asincrono; <see langword="false" /> per eseguire il callback in modo sincrono.</param>
        <summary>Ottiene un riferimento a una funzione client che, quando richiamata, avvia un callback client agli eventi server. La funzione client per questo metodo di overload include un controllo, un argomento, uno script client, un contesto, un gestore errori e un valore Boolean specificati.</summary>
        <returns>Nome di una funzione client che richiama il callback client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo di <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> metodo richiede un `useAsync` e un `clientErrorCallback` parametro. Il `useAsync` parametro consente di eseguire in modo asincrono il callback client impostando il valore su `true`. Le versioni di overload del metodo che non richiedono la `useAsync` parametro è impostato il valore su `false` per impostazione predefinita. Il `clientErrorCallback` parametro consente di definire il nome della funzione client che viene chiamato se il gestore del server (il <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> (metodo)) restituisce un errore. Le versioni di overload del metodo che non richiedono il `clientErrorCallback` parametro impostato il valore su null.  
  
 Per altre informazioni su questo metodo, vedere la sezione Osservazioni per eseguire l'overload <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’oggetto <see cref="T:System.Web.UI.Control" /> specificato è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Web.UI.Control" /> specificato non implementa l'interfaccia <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Callback del client senza i postback nelle pagine ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un riferimento, all'inizio del quale viene aggiunto <see langword="javascript:" />, utilizzabile in un evento client per eseguire il postback nel server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Controllo server per l'elaborazione del postback.</param>
        <param name="argument">Parametro passato al controllo server.</param>
        <summary>Ottiene un riferimento, all'inizio del quale viene aggiunto <see langword="javascript:" />, utilizzabile in un evento client per eseguire il postback nel server per il controllo specificato e con gli argomenti dell'evento specificati.</summary>
        <returns>Una stringa che rappresenta una chiamata JavaScript alla funzione di postback contenente l'ID del controllo di destinazione e gli argomenti dell'evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo richiede il controllo che gestisce il postback per implementare il <xref:System.Web.UI.IPostBackEventHandler> interfaccia. Per implementare il <xref:System.Web.UI.IPostBackEventHandler> interfaccia di amministrazione di un <xref:System.Web.UI.Page>, utilizzare la direttiva.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> (metodo). Il controllo personalizzato, `MyControl`, implementa la <xref:System.Web.UI.IPostBackEventHandler> interfaccia. Quando viene selezionato l'elemento di ancoraggio HTML nella pagina, il <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> metodo del controllo personalizzato viene richiamato.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Esempio di codice seguente ha la stessa funzionalità dell'esempio precedente, tranne il fatto che invece di un controllo personalizzato, il <xref:System.Web.UI.Page> classe implementa il <xref:System.Web.UI.IPostBackEventHandler> interfaccia.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Controllo server per l'elaborazione del postback.</param>
        <param name="argument">Parametro passato al controllo server.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> per registrare l'evento di postback per la convalida; <see langword="false" /> per non registrare l'evento di postback per la convalida.</param>
        <summary>Ottiene un riferimento, all'inizio del quale viene aggiunto <see langword="javascript:" />, utilizzabile in un evento client per eseguire il postback nel server per il controllo specificato con gli argomenti dell'evento specificati e un valore booleano che indica se registrare o meno il postback per la convalida dell'evento.</summary>
        <returns>Una stringa che rappresenta una chiamata JavaScript alla funzione di postback contenente l'ID del controllo di destinazione e gli argomenti dell'evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo richiede il controllo che gestisce il postback per implementare il <xref:System.Web.UI.IPostBackEventHandler> interfaccia. Per implementare il <xref:System.Web.UI.IPostBackEventHandler> interfaccia di amministrazione di un <xref:System.Web.UI.Page>, utilizzare la direttiva.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una stringa utilizzabile in un evento client per causare il postback nel server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Classe <see cref="T:System.Web.UI.PostBackOptions" /> che definisce il postback.</param>
        <summary>Restituisce una stringa utilizzabile in un evento client per causare il postback nel server. La stringa del riferimento è definita dall'istanza <see cref="T:System.Web.UI.PostBackOptions" /> specificata.</summary>
        <returns>Stringa che, quando viene trattata come script sul client, avvia il postback client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per implementare il <xref:System.Web.UI.IPostBackEventHandler> interfaccia di amministrazione di un <xref:System.Web.UI.Page>, utilizzare la direttiva.  
  
 Il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo può essere utilizzato con il <xref:System.Web.UI.WebControls.Button> controllare quando il <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> è di proprietà `false`. In questo scenario, il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo restituisce il postback client evento per il <xref:System.Web.UI.WebControls.Button> controllo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <see cref="T:System.Web.UI.PostBackOptions" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Callback del client senza i postback nelle pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Classe <see cref="T:System.Web.UI.Control" /> del server che elabora il postback sul server.</param>
        <param name="argument">Stringa di argomenti facoltativi da passare al controllo che elabora il postback.</param>
        <summary>Restituisce una stringa utilizzabile in un evento client per causare il postback nel server. La stringa del riferimento è definita dal controllo specificato che gestisce il postback e da un argomento stringa contenente informazioni aggiuntive sull'evento.</summary>
        <returns>Stringa che, quando viene trattata come script nel client, avvia il postback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per implementare il <xref:System.Web.UI.IPostBackEventHandler> interfaccia di amministrazione di un <xref:System.Web.UI.Page>, utilizzare la direttiva.  
  
 Il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo può essere utilizzato con il <xref:System.Web.UI.WebControls.Button> controllare quando il <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> è di proprietà `false`. In questo scenario, il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo restituisce il postback client evento per il <xref:System.Web.UI.WebControls.Button> controllo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> (metodo). Il controllo personalizzato, `MyControl`, implementa la <xref:System.Web.UI.IPostBackEventHandler> interfaccia. Quando si fa clic sul pulsante nella pagina, il <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> metodo del controllo personalizzato viene richiamato.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Esempio di codice seguente ha la stessa funzionalità dell'esempio precedente, tranne il fatto che invece di un controllo personalizzato, il <xref:System.Web.UI.Page> classe implementa il <xref:System.Web.UI.IPostBackEventHandler> interfaccia.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore specificato per il parametro <see cref="T:System.Web.UI.Control" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Callback del client senza i postback nelle pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">Classe <see cref="T:System.Web.UI.PostBackOptions" /> che definisce il postback.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> per registrare un riferimento all'evento per la convalida; in caso contrario <see langword="false" />.</param>
        <summary>Restituisce una stringa utilizzabile in un evento client per causare il postback nel server. La stringa di riferimento è definita dall'oggetto <see cref="T:System.Web.UI.PostBackOptions" /> specificato. Facoltativamente, registra un riferimento all'evento per la convalida.</summary>
        <returns>Stringa che, quando viene trattata come script sul client, avvia il postback client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per implementare il <xref:System.Web.UI.IPostBackEventHandler> interfaccia di amministrazione di un <xref:System.Web.UI.Page> oggetto, usare la direttiva.  
  
 Il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo può essere utilizzato con il <xref:System.Web.UI.WebControls.Button> controllare quando il <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> è di proprietà `false`. In questo scenario, il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo restituisce il postback client evento per il <xref:System.Web.UI.WebControls.Button> controllo.  
  
 Se `registerForEventValidation` viene `true`, il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> chiamate al metodo il <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> metodo per registrare il riferimento dell'evento per la convalida con un ID di controllo univoco che rappresenta il controllo client che sta generando l'evento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'elemento <see cref="T:System.Web.UI.PostBackOptions" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Callback del client senza i postback nelle pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Classe <see cref="T:System.Web.UI.Control" /> del server che elabora il postback sul server.</param>
        <param name="argument">Stringa di argomenti facoltativi da passare a <paramref name="control" />.</param>
        <param name="registerForEventValidation">
          <see langword="true" /> per registrare un riferimento all'evento per la convalida; in caso contrario <see langword="false" />.</param>
        <summary>Restituisce una stringa utilizzabile in un evento client per causare il postback nel server. La stringa del riferimento è definita dal controllo specificato che gestisce il postback e da un argomento stringa contenente informazioni aggiuntive sull'evento. Facoltativamente, registra un riferimento all'evento per la convalida.</summary>
        <returns>Stringa che, quando viene trattata come script nel client, avvia il postback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per implementare il <xref:System.Web.UI.IPostBackEventHandler> interfaccia di amministrazione di un <xref:System.Web.UI.Page>, utilizzare la direttiva.  
  
 Il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo può essere utilizzato con il <xref:System.Web.UI.WebControls.Button> controllare quando il <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> è di proprietà `false`. In questo scenario, il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> metodo restituisce il postback client evento per il <xref:System.Web.UI.WebControls.Button> controllo.  
  
 Se `registerForEventValidation` è true, il <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> chiamate al metodo il <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> metodo per registrare il riferimento dell'evento per la convalida con un ID di controllo univoco che rappresenta il controllo client che sta generando l'evento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore specificato per il parametro <see cref="T:System.Web.UI.Control" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Callback del client senza i postback nelle pagine ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di risorsa.</param>
        <param name="resourceName">Nome completo della risorsa nell'assembly.</param>
        <summary>Ottiene un riferimento URL a una risorsa in un assembly.</summary>
        <returns>Riferimento URL alla risorsa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> metodo restituisce un riferimento URL a una risorsa incorporata in un assembly. Il riferimento restituito non è codificato in URL. Risorse possono essere file di script, immagini o qualsiasi file statici. Specificare il tipo di base per l'oggetto che dovranno accedere alla risorsa.  
  
 Una risorsa Web registrata con la pagina viene identificata in base al tipo e nome. Solo una risorsa con una coppia di nome e il tipo specificato può essere registrata con la pagina. Tentativo di registrare una risorsa che è già registrata non crea un duplicato della risorsa registrata.  
  
 Il <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> metodo viene utilizzato in combinazione con il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> metodo per accedere alle risorse incorporati negli assembly. Per altre informazioni sull'utilizzo delle risorse nelle applicazioni, vedere [ASP.NET Web Page Resources Overview](https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> (metodo). Il *tipo* parametro in questo esempio è impostato per il tipo di classe nell'assembly che contiene la risorsa. Il `resourceName` parametro è specificato con il percorso completo della risorsa, che include lo spazio dei nomi predefinito.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 Esempio di codice seguente viene illustrato come applicare a livello di codice il <xref:System.Web.UI.WebResourceAttribute> attributo dei metadati per contrassegnare l'assembly per le risorse che verranno servite. Compilare la classe seguente in una libreria di classi con uno spazio dei nomi predefinito impostato su `Samples.AspNet.CS.Controls` o `Samples.AspNet.VB.Controls`, a seconda del linguaggio in uso.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Questo esempio richiede un file JavaScript denominato `Script_include.js`. Il file con estensione js è una risorsa incorporata nell'assembly che contiene il `ClientScriptResourceLabel` oggetto. Se si usa Visual Studio, nella finestra proprietà di progetto libreria di classi, impostare **Build Action** al **risorsa incorporata** quando viene selezionato il file di script. Se si sta compilando la libreria nella riga di comando, utilizzare l'opzione per incorporare la risorsa.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il nome della risorsa Web è <see langword="null" />.  
  
\- oppure - 
La lunghezza del nome della risorsa Web è pari a zero.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">ASP.NET Web Page Resources Overview</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/Resource (incorporamento di un file di risorse nel File di Output) (c# Compiler Options)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se il blocco di script client è registrato con l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave del blocco di script client da cercare.</param>
        <summary>Determina se il blocco di script client è stato registrato con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando la chiave specificata.</summary>
        <returns>
          <see langword="true" /> se il blocco di script client è registrato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metodo per evitare la registrazione degli script duplicati. Ciò è particolarmente importante se lo script richiede una grande quantità di risorse server da creare.  
  
 Uno script client è identificato dalla relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati.  
  
 Questo overload del metodo di <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metodo chiama l'overload che accetta sia un `key` e una `type` parametro con il tipo è impostato come un <xref:System.Web.UI.Page> oggetto  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di blocco di script client da cercare.</param>
        <param name="key">Chiave del blocco di script client da cercare.</param>
        <summary>Determina se il blocco di script client è stato registrato con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando una chiave e un tipo.</summary>
        <returns>
          <see langword="true" /> se il blocco di script client è registrato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metodo per evitare la registrazione degli script duplicati. Ciò è particolarmente importante se lo script richiede una grande quantità di risorse server da creare.  
  
 Uno script client è identificato dalla relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati. Specificare il tipo di base per l'oggetto che dovranno accedere alla risorsa. Ad esempio, quando si usa un' `Page` istanza per accedere alla risorsa, si specifica il `Page` tipo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> (metodo). Si noti che, se la logica per cercare il blocco di script client esistenti sono state rimosse, potrebbe non esistere due script client duplicati nel codice sorgente HTML della pagina sottoposta a rendering perché il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metodo verifica la presenza di duplicati. Il vantaggio di controllo consiste nel ridurre il calcolo non necessario.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il tipo di script client è <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se l'inclusione di script client è registrata con l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'inclusione di script client da cercare.</param>
        <summary>Determina se l'inclusione di script client è stata registrata con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando la chiave specificata.</summary>
        <returns>
          <see langword="true" /> se l'inclusione di script client è registrata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metodo per evitare la registrazione degli script duplicati. Ciò è particolarmente importante se lo script richiede una grande quantità di risorse server da creare.  
  
 Includere uno script client è identificata da relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati.  
  
 Questo overload del metodo di <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metodo chiama l'overload che accetta sia un `key` e una `type` parametro con il tipo è impostato come un <xref:System.Web.UI.Page> oggetto.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di inclusione di script client da cercare.</param>
        <param name="key">Chiave dell'inclusione di script client da cercare.</param>
        <summary>Determina se l'inclusione di script client è stata registrata con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando una chiave e un tipo.</summary>
        <returns>
          <see langword="true" /> se l'inclusione di script client è registrata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> include metodo per evitare la registrazione dello script client duplicati. Ciò è particolarmente importante se lo script richiede una grande quantità di risorse server da creare.  
  
 Includere uno script client è identificata da relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati. Specificare il tipo di base per l'oggetto che dovranno accedere alla risorsa. Ad esempio, quando si utilizza un'istanza di pagina per accedere alla risorsa, specificare il `Page` tipo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> (metodo). Si noti che, se sono stati rimossi la logica controlla la presenza include lo script client esistente, potrebbe non esistere due script client duplicati nel codice sorgente HTML della pagina sottoposta a rendering perché il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metodo verifica la presenza di duplicati. Il vantaggio di controllo consiste nel ridurre il calcolo non necessario.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Questo esempio richiede un file JavaScript denominato `Script_include.js`, con il contenuto seguente:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il tipo dell'inclusione di script client è <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se l'istruzione OnSubmit è registrata con l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'istruzione OnSubmit da cercare.</param>
        <summary>Determina se l'istruzione OnSubmit è stata registrata con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando la chiave specificata.</summary>
        <returns>
          <see langword="true" /> se l'istruzione OnSubmit è registrata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare il <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metodo per evitare la registrazione duplicata OnSubmit istruzioni. Ciò è particolarmente importante se l'istruzione richiede una grande quantità di risorse server da creare.  
  
 Un'istruzione viene identificata in modo univoco la chiave e il relativo tipo. Istruzioni con la stessa chiave e tipo vengono considerate duplicati.  
  
 Questo overload del metodo di <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metodo chiama l'overload che accetta sia un `key` e una `type` parametro con il tipo è impostato come un <xref:System.Web.UI.Page> oggetto  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di istruzione OnSubmit da cercare.</param>
        <param name="key">Chiave dell'istruzione OnSubmit da cercare.</param>
        <summary>Determina se l'istruzione OnSubmit è stata registrata con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando la chiave e il tipo specificati.</summary>
        <returns>
          <see langword="true" /> se l'istruzione OnSubmit è registrata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare il <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metodo per evitare la registrazione di istruzioni duplicate. Ciò è particolarmente importante se l'istruzione richiede una grande quantità di risorse server da creare.  
  
 Un'istruzione viene identificata in modo univoco la chiave e il relativo tipo. Istruzioni con la stessa chiave e tipo vengono considerate duplicati. Specificare il tipo di base per l'oggetto che dovranno accedere alla risorsa. Ad esempio, quando si usa un' `Page` istanza per accedere alla risorsa, si specifica il `Page` tipo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> (metodo). Uno script denominato `OnSubmitScript` viene registrato con il <xref:System.Web.UI.Page> in modo che quando viene inviato form della pagina viene richiamato lo script.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il tipo di istruzione OnSubmit è <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se lo script di avvio è registrato con l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dello script di avvio da cercare.</param>
        <summary>Determina se lo script di avvio è stato registrato con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando la chiave specificata.</summary>
        <returns>
          <see langword="true" /> se lo script di avvio è stato registrato, altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare il <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodo per evitare la registrazione degli script duplicati. Ciò è particolarmente importante se lo script richiede una grande quantità di risorse server da creare.  
  
 Uno script di avvio viene identificato dalla relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati.  
  
 Questo overload del metodo di <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metodo chiama l'overload che accetta una stringa di entrambe `key` e una `type` parametro con il tipo è impostato come un <xref:System.Web.UI.Page> oggetto  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di script di avvio da cercare.</param>
        <param name="key">Chiave dello script di avvio da cercare.</param>
        <summary>Determina se lo script di avvio è stato registrato con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando la chiave e il tipo specificati.</summary>
        <returns>
          <see langword="true" /> se lo script di avvio è stato registrato, altrimenti <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima di chiamare il <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodo per evitare la registrazione degli script duplicati. Ciò è particolarmente importante se lo script richiede una grande quantità di risorse server da creare.  
  
 Uno script di avvio client viene identificato dalla relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> (metodo). Si noti che, se la logica per cercare il blocco di script di avvio esistenti sono state rimosse, potrebbe non esistere due script di avvio duplicato nel codice sorgente HTML della pagina sottoposta a rendering perché il <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodo verifica la presenza di duplicati. Il vantaggio di controllo consiste nel ridurre il calcolo non necessario.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il tipo di script di avvio è <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Nome di matrice da registrare.</param>
        <param name="arrayValue">Valore o valori della matrice da registrare.</param>
        <summary>Registra una dichiarazione di matrice JavaScript con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando un nome e un valore di matrice.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> controlli per verificare l'esistenza di una matrice registrata con lo stesso nome come il nome specificato nella `arrayName` parametro e, in questo caso, aggiunge i valori specificati nel `arrayValue` parametro. Poiché il meccanismo di archiviazione sottostante si basa su un <xref:System.Collections.ArrayList>, i duplicati sono consentiti. Se una matrice registrata con lo stesso nome di `arrayName` parametro non esiste, viene creato e i valori nella `arrayValue` parametro aggiunto a esso.  
  
 Se si desidera che i valori letterali stringa nella matrice JavaScript risultante, includere le virgolette singole (') o virgolette doppie di escape (\\") nel `arrayValue` parametro. Il valore della `arrayValue` parametro deve essere un singolo elemento. Se più di un valore deve essere aggiunto alla matrice, eseguire più chiamate tramite il <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo dei <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> e <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metodi. L'esempio registra una matrice e un valore nascosto e definisce la `OnClick` eventi di un `<input>` pulsante per la quale calcolare la somma dei due valori della matrice e del valore nascosto.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayName" /> è <see langword="null" />.</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra lo script client con l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di script client da registrare.</param>
        <param name="key">Chiave dello script client da registrare.</param>
        <param name="script">Valore letterale dello script client da registrare.</param>
        <summary>Registra lo script client con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando un tipo, una chiave e un valore letterale di script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno script client è identificato dalla relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati. Un solo script con un tipo specificato e una coppia di chiavi può essere registrato con la pagina. Tentativo di registrare uno script che è già registrato non crea un duplicato di script.  
  
 Chiamare il <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metodo per determinare se uno script client con una coppia di chiave e il tipo specificato è già registrato ed evitare inutilmente il tentativo di aggiungere lo script.  
  
 In questo overload del metodo il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metodo, è necessario assicurarsi che lo script fornito nel `script` parametro viene eseguito il wrapping un `<script>` blocco di elementi.  
  
 Il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metodo aggiunge un blocco di script nella parte superiore della pagina sottoposta a rendering. I blocchi di script non vengono necessariamente restituiti nell'ordine in che cui sono registrati. Se l'ordine dei blocchi di script è importante, utilizzare un <xref:System.Text.StringBuilder> dell'oggetto per raggruppare gli script in una singola stringa e li registra quindi tutto in un blocco di script client singolo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> (metodo).  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di script client da registrare.</param>
        <param name="key">Chiave dello script client da registrare.</param>
        <param name="script">Valore letterale dello script client da registrare.</param>
        <param name="addScriptTags">Valore Boolean che indica se aggiungere tag script.</param>
        <summary>Registra lo script client con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando un tipo, una chiave, un valore letterale di script e un valore Boolean che indica se aggiungere tag script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno script client è identificato dalla relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati. Un solo script con un tipo specificato e una coppia di chiavi può essere registrato con la pagina. Tentativo di registrare uno script che è già registrato non crea un duplicato di script.  
  
 Chiamare il <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> metodo per determinare se uno script client con una coppia di chiave e il tipo specificato è già registrato. Ciò consente di evitare inutilmente il tentativo di aggiungere lo script.  
  
 In questo overload del <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metodo, è possibile indicare se lo script fornito nel `script` parametro viene eseguito il wrapping con un `<script>` blocco di elementi usando il `addScriptTags` parametro. L'impostazione `addScriptTags` a `true` indica che il tag di script verranno aggiunto automaticamente.  
  
 Il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> metodo aggiunge un blocco di script nella parte superiore della pagina sottoposta a rendering. I blocchi di script non vengono necessariamente restituiti nell'ordine in che cui sono registrati. Se l'ordine dei blocchi di script è importante, utilizzare un <xref:System.Text.StringBuilder> dell'oggetto per raggruppare gli script in una singola stringa e li registra quindi tutto in un blocco di script client singolo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> (metodo). Si noti che il `addScriptTags` parametro è impostato su `true` in modo che non sono inclusi con l'inizio e la chiusura di tag di script di `script` parametro.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il tipo di blocco di script client è <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra l'inclusione di script client con l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chiave dell'inclusione di script client da registrare.</param>
        <param name="url">URL dell'inclusione di script client da registrare.</param>
        <summary>Registra lo script client con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando una chiave e un URL che consente allo script di essere chiamato dal client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Includere uno script client è identificata da relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati. Un solo script con un tipo specificato e una coppia di chiavi può essere registrato con la pagina. Tentativo di registrare uno script che è già registrato non crea un duplicato di script.  
  
 Chiamare il <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> metodo per determinare se includere uno script client con una chiave specificata e la coppia di tipo è già registrata ed evitare inutilmente il tentativo di aggiungere lo script.  
  
> [!NOTE]
>  Per risolvere l'URL del client, usare il <xref:System.Web.UI.Control.ResolveClientUrl%2A> (metodo). Questo metodo Usa il contesto dell'URL in cui viene chiamato per risolvere il percorso.  
  
 Questo overload del metodo di <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metodo chiama l'overload che accetta una `key`, un `URL`e un `type` parametro.  
  
 Il metodo aggiunge un blocco di script nella parte superiore della pagina sottoposta a rendering.  
  
   
  
## Examples  
 Per informazioni correlate, tra cui sintassi, utilizzo e un esempio, vedere <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di inclusione di script client da registrare.</param>
        <param name="key">Chiave dell'inclusione di script client da registrare.</param>
        <param name="url">URL dell'inclusione di script client da registrare.</param>
        <summary>Registra l'inclusione di script client con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando un tipo, una chiave e un URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metodo accetta *chiave* e *url* parametri per identificare lo script, nonché un `type` includono parametro per specificare l'identificazione dello script client. Specificare il tipo di base per l'oggetto che dovranno accedere alla risorsa. Ad esempio, quando si usa un' `Page` istanza per accedere alla risorsa, si specifica il `Page` tipo.  
  
> [!NOTE]
>  Per risolvere l'URL del client, usare il <xref:System.Web.UI.Control.ResolveClientUrl%2A> (metodo). Questo metodo Usa il contesto dell'URL in cui viene chiamato per risolvere il percorso.  
  
 Questo metodo aggiunge un blocco di script nella parte superiore della pagina sottoposta a rendering.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> (metodo). Si noti che se la logica controlla la presenza include lo script client esistenti sono state rimosse, esiste comunque non sarebbe script client duplicato nella pagina sottoposta a rendering perché il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> metodo verifica la presenza di duplicati. Il vantaggio di controllo consiste nel ridurre il calcolo non necessario.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 In questo esempio richiede un file JavaScript denominato file Script_include con il contenuto seguente:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il tipo dell'inclusione di script client è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'URL è <see langword="null" />.  
  
\- oppure - 
URL vuoto.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di risorsa di script client da registrare.</param>
        <param name="resourceName">Nome di risorsa di script client da registrare.</param>
        <summary>Registra la risorsa di script client con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando un tipo e un nome di risorsa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> metodo viene usato per accedere a risorse compilate dagli assembly tramite il gestore HTTP WebResource. axd. Il <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> metodo registra lo script con il <xref:System.Web.UI.Page> dell'oggetto e impedisce a script duplicati. Questo metodo include il contenuto dell'URL della risorsa con un `<script>` blocco di elementi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> (metodo).  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 Esempio di codice seguente viene illustrato come applicare a livello di codice il <xref:System.Web.UI.WebResourceAttribute> attributo dei metadati per contrassegnare l'assembly per le risorse che verranno servite.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Questo esempio richiede un file JavaScript denominato `Script_include.js`, con il contenuto seguente:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Compilare il `Script_include.js` file come risorsa nel `Samples.AspNet.CS.Controls` assembly che contiene il `ClientScriptResourceLabel` classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il nome della risorsa client è <see langword="null" />.  
  
\- oppure - 
La lunghezza del nome della risorsa client è pari a zero.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra una coppia nome/valore come attributo personalizzato (expando) del controllo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">Controllo <see cref="T:System.Web.UI.Control" /> nella pagina contenente l'attributo personalizzato.</param>
        <param name="attributeName">Nome dell'attributo personalizzato da registrare.</param>
        <param name="attributeValue">Valore dell'attributo personalizzato.</param>
        <summary>Registra una coppia nome/valore come attributo personalizzato (expando) del controllo specificato, dati un ID di controllo, un nome attributo e un valore di attributo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> metodo registra una coppia nome/valore come attributo personalizzato (expando) sull'oggetto specificato <xref:System.Web.UI.Control>. L'attributo expando è impostato in modo dinamico da JavaScript per mantenere la compatibilità XHTML per il rendering del markup del controllo. Le virgolette e barre rovesciate in valori dell'attributo personalizzato (expando) vengono sottoposti a escape. Se non si desidera eseguire l'escape di virgolette e barre rovesciate, chiamare il <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> overload di metodo e impostare il `encode` parametro per `false`.  
  
 Se l'attributo expando non viene trovato o non viene trovato il controllo a cui aggiungere l'attributo expando, lo script client viene comunque creato, ma non avrà alcun effetto del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">Controllo <see cref="T:System.Web.UI.Control" /> nella pagina contenente l'attributo personalizzato.</param>
        <param name="attributeName">Nome dell'attributo personalizzato da registrare.</param>
        <param name="attributeValue">Valore dell'attributo personalizzato.</param>
        <param name="encode">Valore Boolean che indica se codificare l'attributo personalizzato da registrare.</param>
        <summary>Registra una coppia nome/valore come attributo personalizzato (expando) del controllo specificato, dati un ID di controllo, un nome di attributo, un valore di attributo e un valore Boolean che indica se codificare il valore dell'attributo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> metodo registra una coppia nome/valore come attributo personalizzato (expando) sull'oggetto specificato <xref:System.Web.UI.Control>. L'attributo expando è impostato in modo dinamico da JavaScript per mantenere la compatibilità XHTML per il rendering del markup del controllo. Impostare il `encode` parametro per `true` se è necessario eseguire l'escape di virgolette e barre rovesciate nel valore dell'attributo expando.  
  
 Se l'attributo expando non viene trovato o non viene trovato il controllo a cui aggiungere l'attributo expando, lo script client viene comunque creato, ma non avrà alcun effetto del controllo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> metodo del <xref:System.Web.UI.ClientScriptManager> classe. Lo script client nella pagina sottoposta a rendering imposta il `title` attributo di un `<span>` elemento.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra un riferimento a un evento per la convalida.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">ID univoco che rappresenta il controllo client che genera l'evento.</param>
        <summary>Registra un riferimento a un evento per la convalida con un ID di controllo univoco che rappresenta il controllo client che genera l'evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni ed esempi, vedere il <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metodo e il <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> metodo per registrare un callback per la convalida e come convalidare che il callback ha avuto origine dalla pagina.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Oggetto <see cref="T:System.Web.UI.PostBackOptions" /> che specifica come viene generato uno script JavaScript client per avviare un evento di postback.</param>
        <summary>Registra un riferimento a un evento per la convalida con <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni ed esempi, vedere il <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">ID univoco che rappresenta il controllo client che genera l'evento.</param>
        <param name="argument">Argomenti di evento passati con l'evento client.</param>
        <summary>Registra un riferimento a un evento per la convalida con un ID di controllo univoco e argomenti di evento che rappresentano il controllo client che genera l'evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metodo e il <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> metodo per registrare un callback per la convalida e per convalidare che il callback ha avuto origine dalla pagina. Per migliorare la convalida illustrata nell'esempio, è possibile modificare la convalida `argument` parametro per contenere le informazioni specifiche dell'utente, ad esempio un'identità o un ruolo  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 Esempio di codice seguente illustra l'uso di <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metodo per registrare un callback per la convalida.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo viene chiamato prima del metodo <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">Callback di client con l'esempio di implementazione di convalida</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Nome del campo nascosto da registrare.</param>
        <param name="hiddenFieldInitialValue">Valore iniziale del campo da registrare.</param>
        <summary>Registra un valore nascosto con l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metodo crea un nascosto `<input>` elemento nella pagina HTML di cui è stato eseguito rendering.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo dei <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> e <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> metodi. L'esempio registra una matrice e un valore nascosto e definisce la `OnClick` eventi di un `<input>` pulsante per la quale calcolare la somma dei due valori della matrice e del valore nascosto.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hiddenFieldName" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo di istruzione OnSubmit da registrare.</param>
        <param name="key">Chiave dell'istruzione OnSubmit da registrare.</param>
        <param name="script">Valore letterale dell'istruzione OnSubmit da registrare.</param>
        <summary>Registra un'istruzione OnSubmit con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando un tipo, una chiave e un valore letterale di script. L'istruzione viene eseguita quando viene inviato il controllo <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istruzione OnSubmit è identificata in modo univoco la chiave e il relativo tipo. Istruzioni con la stessa chiave e tipo vengono considerate duplicati. Un'unica istruzione con un tipo specificato e una coppia di chiavi può essere registrata con la pagina. Tentativo di registrare un'istruzione che è già registrata non creerà un duplicato dell'istruzione.  
  
 Chiamare il <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> metodo per determinare se un'istruzione OnSubmit è già registrata con una coppia di chiave e il tipo specificata ed evitare inutilmente il tentativo di aggiungere lo script.  
  
 Il `script` parametro il <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> metodo può contenere più comandi script, purché siano correttamente delimitati da punto e virgola (;).  
  
 Il <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> aggiunge uno script che viene eseguito prima che la pagina viene inviata e ti offre la possibilità di annullare l'invio.  
  
 Per altre informazioni sui moduli HTML e il `OnSubmit` dell'attributo, vedere la [sito Web World Wide Web Consortium (W3C)](https://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> (metodo).  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra lo script di avvio con l'oggetto <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Tipo dello script di avvio da registrare.</param>
        <param name="key">Chiave dello script di avvio da registrare.</param>
        <param name="script">Valore letterale dello script di avvio da registrare.</param>
        <summary>Registra lo script di avvio con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando un tipo, una chiave e un valore letterale di script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno script client è identificato dalla relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati. Un solo script con un tipo specificato e una coppia di chiavi può essere registrato con la pagina. Tentativo di registrare uno script che è già registrato non crea un duplicato di script.  
  
 Chiamare il <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metodo per determinare se uno script di avvio con una coppia di chiave e il tipo specificato è già registrato ed evitare inutilmente il tentativo di aggiungere lo script.  
  
 In questo overload del metodo il <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodo, è necessario assicurarsi che lo script fornito nel `script` parametro viene eseguito il wrapping con un `<script>` blocco di elementi.  
  
 Il blocco di script aggiunto per il <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodo viene eseguito al termine del caricamento della pagina ma prima della pagina <xref:System.Web.UI.Control.OnLoad%2A> viene generato l'evento. I blocchi di script non vengono necessariamente restituiti nell'ordine in che cui sono registrati. Se l'ordine dei blocchi di script è importante, utilizzare un <xref:System.Text.StringBuilder> dell'oggetto per raggruppare gli script in una singola stringa e li registra quindi tutto in un blocco di script client singolo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> (metodo). Si noti che sono inclusi l'inizio e alla chiusura di tag di script all'interno di `script` parametro. Affinché lo script di tag aggiunti in base all'impostazione parametro aggiuntivo, vedere il <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> (metodo).  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Tipo dello script di avvio da registrare.</param>
        <param name="key">Chiave dello script di avvio da registrare.</param>
        <param name="script">Valore letterale dello script di avvio da registrare.</param>
        <param name="addScriptTags">Valore Boolean che indica se aggiungere tag script.</param>
        <summary>Registra lo script di avvio con l'oggetto <see cref="T:System.Web.UI.Page" /> utilizzando un tipo, una chiave, un valore letterale di script e un valore Boolean che indica se aggiungere tag script.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno script di avvio viene identificato dalla relativa chiave e il relativo tipo. Gli script con la stessa chiave e tipo vengono considerati duplicati. Un solo script con un tipo specificato e una coppia di chiavi può essere registrato con la pagina. Tentativo di registrare uno script che è già registrato non crea un duplicato di script.  
  
 Chiamare il <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> metodo per determinare se uno script di avvio con una coppia di chiave e il tipo specificato è già registrato ed evitare inutilmente il tentativo di aggiungere lo script.  
  
 In questo overload del <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodo, è possibile indicare se lo script fornito nel `script` parametro viene eseguito il wrapping con un `<script>` blocco di elementi usando il `addScriptTags` parametro. L'impostazione `addScriptTags` a `true` indica che il tag di script verranno aggiunto automaticamente.  
  
 Il blocco di script aggiunto per il <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> metodo viene eseguito al termine del caricamento della pagina ma prima della pagina <xref:System.Web.UI.Control.OnLoad%2A> viene generato l'evento. I blocchi di script non vengono necessariamente restituiti nell'ordine in che cui sono registrati. Se l'ordine dei blocchi di script è importante, utilizzare un <xref:System.Text.StringBuilder> dell'oggetto per raggruppare gli script in una singola stringa e li registra quindi tutto in un blocco di script client singolo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> (metodo). Si noti che il `addScriptTags` parametro è impostato su `false` in modo che sono inclusi con l'inizio e la chiusura di tag di script di `script` parametro.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convalida un evento client.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">ID univoco che rappresenta il controllo client che genera l'evento.</param>
        <summary>Convalida un evento client registrato per la convalida degli eventi utilizzando il metodo <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">ID univoco che rappresenta il controllo client che genera l'evento.</param>
        <param name="argument">Argomenti di evento passati con l'evento client.</param>
        <summary>Convalida un evento client registrato per la convalida degli eventi utilizzando il metodo <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> metodo e il <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> metodo per registrare un callback per la convalida e per convalidare che il callback ha avuto origine dalla pagina. Per migliorare la convalida illustrata qui, è possibile modificare la convalida `argument` parametro per contenere le informazioni specifiche dell'utente, ad esempio un'identità o un ruolo  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uniqueId" /> è <see langword="null" /> o è una stringa vuota ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>