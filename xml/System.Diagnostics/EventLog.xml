<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cddf1c04c07302ffae82270967f7c9c372cd50df" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49158512" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gestisce l'interazione con i registri eventi di Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> Consente di accedere o personalizzare i registri eventi di Windows, che registrano informazioni sugli eventi importanti del software o hardware. Usando <xref:System.Diagnostics.EventLog>, è possibile leggere i log esistenti, scrivere voci di log, creare o eliminare le origini evento, eliminare i log e rispondere per le voci di log. È anche possibile creare nuovi log durante la creazione di un'origine evento.  
  
> [!IMPORTANT]
>  Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare il tipo direttamente, chiamare relativi <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 Oltre a fornire accesso ai singoli registri eventi e le relative voci di <xref:System.Diagnostics.EventLog> classe consente di accedere alla raccolta di tutti i registri eventi. È possibile usare la `static` i membri di <xref:System.Diagnostics.EventLog> per eliminare i log, ottenere elenchi di log, creare o eliminare un'origine o determinare se un computer contiene già una determinata origine.  
  
 Sono disponibili tre log eventi predefiniti: applicazione, sistema e sicurezza. Un log di sicurezza è di sola lettura. Altre applicazioni e servizi di installare, ad esempio Active Directory, potrebbero essere altri registri eventi.  
  
 Esistono considerazioni sulla sicurezza quando si usa il <xref:System.Diagnostics.EventLog> classe. <xref:System.Diagnostics.EventLog> richiede <xref:System.Diagnostics.EventLogPermission> le autorizzazioni per azioni specifiche in .NET Framework 2.0 e versioni successive o con attendibilità totale in .NET Framework 1.0 e 1.1. È consigliabile che <xref:System.Diagnostics.EventLogPermission> non concessa a codice parzialmente attendibile.  Non si dovrebbe mai passare qualsiasi oggetto di registro eventi, inclusi <xref:System.Diagnostics.EventLogEntryCollection> e <xref:System.Diagnostics.EventLogEntry> degli oggetti a codice parzialmente attendibile. Ad esempio, la creazione di un' <xref:System.Diagnostics.EventLog> oggetto, si scrive una voce e quindi passando il <xref:System.Diagnostics.EventLog> oggetto da codice parzialmente attendibile può creare un problema di sicurezza, perché la possibilità di leggere e scrivere nel registro eventi consente al codice eseguire azioni quali il rilascio messaggi del registro eventi il nome di un'altra applicazione.  
  
 A partire da Windows Vista, controllo Account utente (UAC) determina le credenziali di un utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Per eseguire il codice che accede al Registro di protezione, è innanzitutto necessario elevare le proprie credenziali di utente standard all'amministratore. È possibile farlo quando si avvia un'applicazione, aprire il menu di scelta rapida per l'applicazione (se si usa un mouse, fare doppio clic sull'icona dell'applicazione) e che indica che si desidera eseguire come amministratore.  
  
 È possibile usare <xref:System.Diagnostics.EventLog> per creare i log di eventi personalizzati che è possibile visualizzare tramite il server del Visualizzatore eventi. Usare il <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> metodo per visualizzare il nome localizzato per il log eventi nel Visualizzatore eventi. Usare il <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> metodo per configurare il comportamento del log eventi quando raggiunge la dimensione massima del log.  
  
 Per leggere da un log eventi, specificare il nome del log (<xref:System.Diagnostics.EventLog.Log%2A> proprietà) e il nome del computer server (<xref:System.Diagnostics.EventLog.MachineName%2A> proprietà per il log eventi. Se non si specifica il nome del computer server, il computer locale, ".", verrà utilizzato. Non è necessario specificare l'origine dell'evento (<xref:System.Diagnostics.EventLog.Source%2A> proprietà), in quanto è necessaria solo per la scrittura nei log di un'origine. Il <xref:System.Diagnostics.EventLog.Entries%2A> proprietà viene popolata automaticamente con l'elenco delle voci del log eventi.  
  
 Per scrivere un log eventi, specificare o creare un'origine evento (<xref:System.Diagnostics.EventLog.Source%2A> proprietà). È necessario disporre delle credenziali amministrative nel computer per creare una nuova origine evento. L'origine eventi registra l'applicazione con il registro eventi come origine valida delle voci. È possibile utilizzare l'origine eventi per scrivere log solo una alla volta. Il <xref:System.Diagnostics.EventLog.Source%2A> proprietà può essere qualsiasi stringa casuale, ma il nome deve essere diverso da altre origini nel computer. L'origine evento è in genere il nome dell'applicazione o un'altra stringa di identificazione. Tentativo di creare un duplicato <xref:System.Diagnostics.EventLog.Source%2A> valore genera un'eccezione. Tuttavia, un singolo registro eventi può essere associato a più origini.  
  
 Se l'origine evento per il log eventi associato il <xref:System.Diagnostics.EventLog> istanza non esiste, viene creata una nuova origine evento. Per creare un'origine evento in Windows Vista e versioni successive o Windows Server 2003, è necessario disporre delle credenziali amministrative.  
  
 Questo requisito è perché tutti i registri eventi, inclusi i log di sicurezza, occorre eseguire una ricerca per determinare se l'origine evento è univoca. A partire da Windows Vista, gli utenti non è autorizzato ad accedere Registro di sicurezza. Pertanto, un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
> [!IMPORTANT]
>  Creazione o eliminazione di un'origine eventi richiede la sincronizzazione del codice sottostante usando un mutex denominato. Se un'applicazione con privilegiata elevati consente di bloccare il mutex denominato, il tentativo di creare o eliminare un'origine evento, l'applicazione di rispondere fino a quando il blocco viene rilasciato. Per evitare questo problema, non concedere mai <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> dell'autorizzazione per codice non attendibile. Inoltre, <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> autorizzazione potenzialmente consente altre autorizzazioni è stata ignorata e deve essere concesso solo a codice completamente attendibile.  
  
 Servizi e applicazioni devono scrivere nel registro applicazioni o in un log personalizzato. I driver di dispositivo devono scrivere nel Registro di sistema. Se non si imposta in modo esplicito il <xref:System.Diagnostics.EventLog.Log%2A> proprietà, per impostazione predefinita il registro eventi nel registro applicazioni.  
  
> [!NOTE]
>  Non sono necessarie per proteggere un'applicazione dalla scrittura come qualsiasi origine registrata.  Se un'applicazione viene concesso <xref:System.Diagnostics.EventLogPermissionAccess.Write> autorizzazione, è possibile scrivere gli eventi per qualsiasi origine valida è registrata nel computer.  
  
 Usare la <xref:System.Diagnostics.EventLog.WriteEvent%2A> e <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodi per scrivere eventi in un log eventi. È necessario specificare un'origine eventi per scrivere eventi; è necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine.  
  
 Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è stato aggiornato l'elenco di origini evento e si prova a scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller> oggetto o il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre delle credenziali amministrative nel computer per creare una nuova origine evento.  
  
 Ogni origine può scrivere solo un registro eventi alla volta. Tuttavia, l'applicazione può utilizzare più origini in cui per scrivere più registri eventi. Ad esempio, l'applicazione potrebbe richiedere più origini configurate per diversi log eventi o file di risorse diversi. Per modificare i dettagli di configurazione di un'origine esistente, è necessario eliminare l'origine e quindi crearlo nuovamente con la nuova configurazione. Se altre applicazioni o componenti usano l'origine esistente, creare una nuova origine con la configurazione aggiornata invece di eliminare l'origine esistente.  
  
 È possibile registrare l'origine evento con le risorse localizzate per le stringhe di categoria e il messaggio di evento. L'applicazione può scrivere voci nel registro eventi utilizzando gli identificatori di risorsa invece di specificare i valori di stringa effettivo. Vedere le <xref:System.Diagnostics.EventLogInstaller> e <xref:System.Diagnostics.EventSourceCreationData> classi per altre informazioni sulla configurazione dell'origine dei file di risorse.  
  
 Se l'applicazione scrive i valori stringa direttamente nel registro eventi, non è necessario impostare le proprietà di file per l'origine della risorsa. L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
 Quando si scrivono gli eventi, è necessario specificare almeno una stringa di messaggio o l'identificatore di risorsa per una stringa di messaggio. Altre proprietà evento sono facoltativi. Esempi di impostazioni facoltativo dell'evento includono quanto segue:  
  
-   È possibile impostare il <xref:System.Diagnostics.EventLogEntryType> per specificare l'icona che consente di visualizzare nel Visualizzatore eventi per la voce.  
  
-   È possibile specificare un identificatore di categoria per l'evento, se l'applicazione usa categorie per filtrare gli eventi.  
  
-   Se si desidera associare informazioni aggiuntive con un determinato evento, è possibile collegare dati binari per la voce dell'evento.  
  
> [!IMPORTANT]
>  La registrazione degli eventi utilizza lo spazio su disco, il tempo del processore e altre risorse di sistema. È importante registrare solo le informazioni essenziali. Si consiglia di inserire chiamate di log di eventi in un percorso di errore, anziché nel percorso di codice principale, in modo non influire negativamente sulle prestazioni.  
  
 Per un elenco di valori di proprietà iniziali per un'istanza di <xref:System.Diagnostics.EventLog>, vedere il <xref:System.Diagnostics.EventLog.%23ctor%2A> costruttore.  
  
   
  
## Examples  
 L'esempio seguente crea l'origine dell'evento `MySource` se non esiste già e viene scritta una voce nel registro eventi `MyNewLog`.  
  
> [!NOTE]
>  A partire da Windows Vista, è necessario eseguire questa applicazione come amministratore.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.EventLog" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.EventLog" />. Non associa l'istanza ad alcun log.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima di chiamare <xref:System.Diagnostics.EventLog.WriteEntry%2A>, specificare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà del <xref:System.Diagnostics.EventLog> istanza. Se si sta solo leggendo <xref:System.Diagnostics.EventLog.Entries%2A> dal log, è possibile specificare solo le <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> proprietà.  
  
> [!NOTE]
>  Se non si specifica un <xref:System.Diagnostics.EventLog.MachineName%2A>, il computer locale (".") verrà utilizzato.  
  
 La tabella seguente illustra i valori iniziali delle proprietà per un'istanza di <xref:System.Diagnostics.EventLog>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Stringa vuota ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Stringa vuota ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Il computer locale (".").|  
  
   
  
## Examples  
 L'esempio seguente crea l'origine `MySource` se non esiste già e viene scritta una voce nel registro eventi `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nome del log nel computer locale.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.EventLog" />. Associa l'istanza a un log nel computer locale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Imposta questo overload di <xref:System.Diagnostics.EventLog.Log%2A> proprietà per il `logName` parametro. Prima di chiamare <xref:System.Diagnostics.EventLog.WriteEntry%2A>, specificare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà del <xref:System.Diagnostics.EventLog> istanza. Se si sta solo leggendo <xref:System.Diagnostics.EventLog.Entries%2A> dal log, è possibile specificare solo le <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> proprietà.  
  
> [!NOTE]
>  Se non si specifica un <xref:System.Diagnostics.EventLog.MachineName%2A>, il computer locale (".") verrà utilizzato. Questo overload del costruttore specifica la <xref:System.Diagnostics.EventLog.Log%2A> proprietà, ma è possibile modificare prima di leggere il <xref:System.Diagnostics.EventLog.Entries%2A> proprietà.  
  
 Se l'origine specifica nel <xref:System.Diagnostics.EventLog.Source%2A> la proprietà è univoca da altre origini nel computer, una chiamata successiva a <xref:System.Diagnostics.EventLog.WriteEntry%2A> crea un registro con il nome specificato, se non esiste già.  
  
 La tabella seguente illustra i valori iniziali delle proprietà per un'istanza di <xref:System.Diagnostics.EventLog>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Stringa vuota ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Parametro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Il computer locale (".").|  
  
   
  
## Examples  
 Nell'esempio seguente legge le voci nel registro eventi, "myNewLog", nel computer locale.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il nome del log è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il nome del log non è valido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nome del log nel computer specificato.</param>
        <param name="machineName">Computer in cui si trova il log.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.EventLog" />. Associa l'istanza a un log nel computer specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Imposta questo overload il <xref:System.Diagnostics.EventLog.Log%2A> proprietà per il `logName` parametro e il <xref:System.Diagnostics.EventLog.MachineName%2A> proprietà per il `machineName` parametro. Prima di chiamare <xref:System.Diagnostics.EventLog.WriteEntry%2A>, specificare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà del <xref:System.Diagnostics.EventLog>. Se si sta solo leggendo <xref:System.Diagnostics.EventLog.Entries%2A> dal log, è possibile specificare solo le <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> proprietà.  
  
> [!NOTE]
>  Questo overload del costruttore specifica la <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> delle proprietà, ma è possibile modificare entrambe prima di leggere il <xref:System.Diagnostics.EventLog.Entries%2A> proprietà.  
  
 La tabella seguente illustra i valori iniziali delle proprietà per un'istanza di <xref:System.Diagnostics.EventLog>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Stringa vuota ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Parametro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Parametro `machineName`.|  
  
   
  
## Examples  
 Nell'esempio seguente legge le voci nel registro eventi, "myNewLog", nel computer "myServer".  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il nome del log è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il nome del log non è valido.  
  
oppure 
Il nome del computer non è valido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nome del log nel computer specificato.</param>
        <param name="machineName">Computer in cui si trova il log.</param>
        <param name="source">Origine delle voci del registro eventi.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.EventLog" />. Associa l'istanza con un log nel computer specificato e crea o assegna l'origine specificata all'oggetto <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore imposta la <xref:System.Diagnostics.EventLog.Log%2A> proprietà per il `logName` parametro, il <xref:System.Diagnostics.EventLog.MachineName%2A> proprietà per il `machineName` parametro e il <xref:System.Diagnostics.EventLog.Source%2A> proprietà per il `source` parametro. Il <xref:System.Diagnostics.EventLog.Source%2A> proprietà è obbligatoria quando si scrive in un log eventi. Tuttavia, se prevede di leggere solo da un log eventi, solo il <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> le proprietà sono obbligatorie (purché il registro eventi sul server è già associato a un'origine). Se prevede di leggere solo dal log eventi, potrebbe essere sufficiente un altro overload del costruttore.  
  
 La tabella seguente illustra i valori iniziali delle proprietà per un'istanza di <xref:System.Diagnostics.EventLog>.  
  
|Proprietà|Valore iniziale|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Parametro `source`.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Parametro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Parametro `machineName`.|  
  
   
  
## Examples  
 Nell'esempio seguente scrive una voce in un log eventi, "MyNewLog", nel computer locale, usando l'origine "MySource".  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il nome del log è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il nome del log non è valido.  
  
oppure 
Il nome del computer non è valido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia l'inizializzazione di un oggetto <see cref="T:System.Diagnostics.EventLog" /> usato in un form o da un altro componente. L'inizializzazione avviene in fase di esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Progettazione ambiente Usa questo metodo per avviare l'inizializzazione di un componente usato in un form o da un altro componente. Il <xref:System.Diagnostics.EventLog.EndInit%2A> metodo termina l'inizializzazione. Usando il <xref:System.Diagnostics.EventLog.BeginInit%2A> e <xref:System.Diagnostics.EventLog.EndInit%2A> impedisce che il controllo utilizzato prima che il completamento dell'inizializzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Diagnostics.EventLog" /> è già inizializzato.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutte le voci dal registro eventi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I registri eventi vengono impostati con una dimensione massima che determina il numero di voci possono contenere. Quando un log eventi è pieno, arresta la registrazione delle nuove informazioni di evento o inizia a sovrascrivere le voci precedenti. Se si arresta la registrazione degli eventi, è possibile utilizzare questo metodo per cancellare il log delle voci esistenti e consentono di avviare nuovamente la registrazione eventi. È necessario disporre delle autorizzazioni di amministratore nel computer in cui si trova il log per la cancellazione di voci del registro eventi.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> Chiude il log eventi, rilascia l'handle di evento, recupera i nuovi leggere e scrittura gli handle e riapre il registro eventi. Gli eventi ricevuti dopo la chiamata al metodo non vengono cancellati insieme a eventi esistenti.  
  
   
  
## Examples  
 Nell'esempio seguente consente di cancellare un log eventi.  
  
> [!CAUTION]
>  Poiché l'applicazione, sistema, sicurezza e altri log personalizzati non possono contenere informazioni cruciali; Assicurarsi di specificare un log personalizzato prima di eseguire questo esempio di codice. Questo esempio viene eliminato il log personalizzato `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">La cancellazione del log eventi non è stata eseguita correttamente.  
  
oppure 
È impossibile aprire il log. Non è disponibile un codice di errore di Windows.</exception>
        <exception cref="T:System.ArgumentException">Non è specificato un valore per la proprietà <see cref="P:System.Diagnostics.EventLog.Log" />. Verificare che il nome del log non corrisponda a una stringa vuota.</exception>
        <exception cref="T:System.InvalidOperationException">Il log non è presente.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude il registro eventi e rende disponibili gli handle di lettura e scrittura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.EventLog.Close%2A> viene chiamato il metodo da protetto <xref:System.ComponentModel.Component.Dispose%2A> (metodo). Non è necessario richiamare <xref:System.Diagnostics.EventLog.Close%2A> prima di chiamare <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">L'handle di lettura o di scrittura del log eventi non è stato rilasciato correttamente.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stabilisce che un'applicazione è in grado di scrivere le informazioni relative agli eventi in un registro specifico del sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">Proprietà di configurazione per l'origine eventi e il registro eventi di destinazione.</param>
        <summary>Stabilisce una origine eventi valida per la scrittura di messaggi di evento localizzati, usando le proprietà di configurazione specificate per l'origine eventi e il registro eventi corrispondente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per configurare una nuova origine per la scrittura di voci in un log eventi nel computer locale o un computer remoto. Non è necessario utilizzare questo metodo per leggere da un log eventi.  
  
 Il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> metodo utilizza l'input `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> e <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> proprietà per creare i valori del Registro di sistema nel computer di destinazione per la nuova origine e il log eventi associato. Un nuovo nome di origine non può corrispondere a un nome di origine esistente o un nome registro eventi esistenti nel computer di destinazione. Se il <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> proprietà non è impostata, l'origine sia registrata per il log eventi dell'applicazione. Se il <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> non è impostato, l'origine è registrata nel computer locale.  
  
> [!NOTE]
>  Per creare un'origine evento in Windows Vista e versioni successive o Windows Server 2003, è necessario disporre dei privilegi amministrativi.  
>   
>  Il motivo per questo requisito è che è necessario eseguire ricerche in tutti i registri eventi, tra cui sicurezza, per determinare se l'origine evento è univoca. A partire da Windows Vista, gli utenti non è autorizzato ad accedere Registro di sicurezza. Pertanto, un <xref:System.Security.SecurityException> viene generata un'eccezione.  
>   
>  A partire da Windows Vista, controllo Account utente (UAC) determina i privilegi dell'utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Per eseguire il codice che accede al Registro di protezione, è innanzitutto necessario elevare i privilegi da utente standard all'amministratore. È possibile farlo quando si avvia un'applicazione facendo clic con il pulsante destro del mouse sull'icona dell'applicazione e indicando l'opzione di esecuzione come amministratore.  
  
 Uso <xref:System.Diagnostics.EventLog.WriteEvent%2A> e <xref:System.Diagnostics.EventLog.WriteEntry%2A> per scrivere eventi in un log eventi. È necessario specificare un'origine eventi per scrivere eventi; è necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine.  
  
 Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 È possibile creare un'origine evento per un log eventi esistente o un nuovo registro eventi. Quando si crea una nuova origine per un nuovo registro eventi, il sistema registra l'origine di tale log, ma non viene creato il registro fino a quando non viene scritta la prima voce a esso.  
  
 Il sistema operativo archivia i registri eventi come file. Quando si usa <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> per creare un nuovo registro eventi, il file associato viene archiviato nella directory %SystemRoot%\System32\Config nel computer specificato. Il nome del file è impostato aggiungendo i primi 8 caratteri del <xref:System.Diagnostics.EventLog.Log%2A> proprietà con l'estensione "estensione evt".  
  
 Ogni origine può scrivere solo in un solo evento di log alla volta. Tuttavia, l'applicazione può utilizzare più origini in cui per scrivere più registri eventi. Ad esempio, l'applicazione potrebbe richiedere più origini configurate per diversi log eventi o file di risorse diversi.  
  
 È possibile registrare l'origine evento con i file di risorse localizzate per le stringhe di categoria e il messaggio di evento. L'applicazione potrà scrivere voci del registro eventi utilizzando gli identificatori di risorsa, anziché specificare la stringa effettiva. Il Visualizzatore eventi Usa l'identificatore di risorsa per trovare e visualizzare la stringa corrispondente dal file di risorse localizzate in base alle impostazioni della lingua corrente. È possibile registrare un file separato per le categorie di eventi, messaggi e le stringhe di inserimento di parametro o è possibile registrare lo stesso file di risorse per tutti i tre tipi di stringhe. Usare la <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, e <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> proprietà per configurare l'origine per scrivere voci localizzate nel registro eventi. Se l'applicazione scrive i valori di stringhe direttamente al registro eventi, non devi impostare queste proprietà.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
 Per modificare i dettagli di configurazione di un'origine esistente, è necessario eliminare l'origine e quindi crearlo nuovamente con la nuova configurazione. Se altre applicazioni o componenti usano l'origine esistente, creare una nuova origine con la configurazione aggiornata, piuttosto che l'eliminazione dell'origine esistente.  
  
> [!NOTE]
>  Se è configurata un'origine per un log eventi e riconfigurarlo per un altro log eventi, è necessario riavviare il computer rendere effettive le modifiche.  
  
   
  
## Examples  
 L'esempio seguente determina se l'origine dell'evento denominato `SampleApplicationSource` è registrata nel computer locale. Se l'origine evento non esiste, l'esempio imposta il file di risorse di messaggio per l'origine e crea la nuova origine evento. Infine, l'esempio imposta il nome visualizzato localizzato per il log eventi, usando il valore di identificatore di risorsa in `DisplayNameMsgId` e il percorso del file di risorse in `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 L'esempio Usa il file di testo di messaggio seguente, generato nella libreria di risorse EventLogMsgs. Un file di testo del messaggio è l'origine da cui viene creato il file di risorse del messaggio. Il file di testo del messaggio definisce gli identificatori di risorsa e il testo per la categoria, messaggio di evento e le stringhe di inserimento di parametro. In particolare, l'identificatore della risorsa 5001 è definito per il nome localizzato del log eventi.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome del computer specificato in <paramref name="sourceData" /> non è valido.  
  
\- oppure - 
Il nome di origine file specificato in <paramref name="sourceData" /> è <see langword="null" />.  
  
\- oppure - 
Il nome del log specificato in <paramref name="sourceData" /> non è valido. I nomi dei log eventi devono essere composti da caratteri stampabili e non possono contenere i caratteri "*", "?" o "\\".  
  
\- oppure - 
Il nome del log specificato in <paramref name="sourceData" /> non è valido per la creazione di log utente. I nomi del log eventi AppEvent, SysEvent e SecEvent sono di uso riservato da parte del sistema.  
  
\- oppure - 
Il nome del log corrisponde a un nome di origine eventi esistente.  
  
\- oppure - 
A causa del nome origine specificato in <paramref name="sourceData" /> il percorso di una chiave del Registro di sistema risulta più lungo di 254 caratteri.  
  
\- oppure - 
I primi 8 caratteri del nome del log specificato in <paramref name="sourceData" /> non sono univoci.  
  
\- oppure - 
Il nome origine specificato in <paramref name="sourceData" /> è già registrato.  
  
\- oppure - 
Il nome origine specificato in <paramref name="sourceData" /> corrisponde a un nome di log eventi esistente.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nome dell'origine con cui l'applicazione è registrata nel computer locale.</param>
        <param name="logName">Nome del log in cui le voci dell'origine vengono scritte. I valori possibili sono Applicazione, Sistema o un registro eventi personalizzato.</param>
        <summary>Determina che il nome di origine specificato è un nome di eventi valido per la scrittura di voci in un log del computer locale. Questo metodo consente inoltre di creare un nuovo log personalizzato nel computer locale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare un registro personalizzato o per creare e registrare un <xref:System.Diagnostics.EventLog.Source%2A> in un registro esistente nel computer locale.  
  
 Se `logName` viene `null` o una stringa vuota ("") quando si chiama <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, per impostazione predefinita il registro nel registro applicazioni. Se il log non esiste nel computer locale, il sistema crea un log personalizzato e registra l'applicazione come un <xref:System.Diagnostics.EventLog.Source%2A> di tale log.  
  
> [!NOTE]
>  Per creare un'origine evento in Windows Vista e versioni successive o Windows Server 2003, è necessario disporre dei privilegi amministrativi.  
>   
>  Il motivo per questo requisito è che è necessario eseguire ricerche in tutti i registri eventi, tra cui sicurezza, per determinare se l'origine evento è univoca. A partire da Windows Vista, gli utenti non è autorizzato ad accedere Registro di sicurezza. Pertanto, un <xref:System.Security.SecurityException> viene generata un'eccezione.  
>   
>  In Windows Vista e versioni successive i privilegi di un utente sono determinati dalla funzionalità Controllo dell'account utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Per eseguire il codice che accede al Registro di protezione, è innanzitutto necessario elevare i privilegi da utente standard all'amministratore. È possibile farlo quando si avvia un'applicazione facendo clic con il pulsante destro del mouse sull'icona dell'applicazione e indicando l'opzione di esecuzione come amministratore.  
  
 Devi solo creare un'origine evento, se si scrive nel registro eventi. Prima di scrivere una voce in un log eventi, è necessario registrare l'origine evento con il registro eventi come origine valida degli eventi. Quando si scrive una voce di log, il sistema utilizza il <xref:System.Diagnostics.EventLog.Source%2A> per trovare il log appropriato in cui inserire la voce. Se si sta leggendo il registro eventi, è possibile specificare il <xref:System.Diagnostics.EventLog.Source%2A>, o un <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Non è necessario specificare il <xref:System.Diagnostics.EventLog.MachineName%2A> se ci si connette a un log nel computer locale. Se non si specifica il <xref:System.Diagnostics.EventLog.MachineName%2A> durante la lettura da un registro, il computer locale (".") verrà utilizzato.  
  
 Uso <xref:System.Diagnostics.EventLog.WriteEvent%2A> e <xref:System.Diagnostics.EventLog.WriteEntry%2A> per scrivere eventi in un log eventi. È necessario specificare un'origine eventi per scrivere eventi; è necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine.  
  
 Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 È possibile creare un'origine evento per un log eventi esistente o un nuovo registro eventi. Quando si crea una nuova origine per un nuovo registro eventi, il sistema registra l'origine di tale log, ma non viene creato il registro fino a quando non viene scritta la prima voce a esso.  
  
 Il sistema operativo archivia i registri eventi come file. Quando si usa <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> per creare un nuovo registro eventi, il file associato viene archiviato nella directory %SystemRoot%\System32\Config nel computer specificato. Il nome del file è impostato aggiungendo i primi 8 caratteri del <xref:System.Diagnostics.EventLog.Log%2A> proprietà con l'estensione "estensione evt".  
  
 L'origine deve essere univoco nel computer locale. un nuovo nome di origine non può corrispondere a un nome di origine esistente o un nome di log eventi esistente. Ogni origine può scrivere solo un registro eventi alla volta. Tuttavia, l'applicazione può utilizzare più origini in cui per scrivere più registri eventi. Ad esempio, l'applicazione potrebbe richiedere più origini configurate per diversi log eventi o file di risorse diversi.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
 Per modificare i dettagli di configurazione di un'origine esistente, è necessario eliminare l'origine e quindi crearlo nuovamente con la nuova configurazione. Se altre applicazioni o componenti usano l'origine esistente, creare una nuova origine con la configurazione aggiornata, piuttosto che l'eliminazione dell'origine esistente.  
  
> [!NOTE]
>  Se un'origine è già stata mappata a un log e si riesegue il mapping di un nuovo registro, è necessario riavviare il computer rendere effettive le modifiche.  
  
   
  
## Examples  
 L'esempio seguente crea l'origine `MySource` se non esiste già e viene scritta una voce nel registro eventi `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> è una stringa ("") o <see langword="null" />.  
  
\- oppure - 
 <paramref name="logName" /> non è un nome di log eventi valido. I nomi dei log eventi devono essere composti da caratteri stampabili e non possono contenere i caratteri "*", "?" o "\\".  
  
\- oppure - 
 <paramref name="logName" /> non è valido per la creazione di log utente. L'utilizzo dei nomi dei log eventi AppEvent, SysEvent e SecEvent è riservato al sistema.  
  
\- oppure - 
Il nome del log corrisponde a un nome di origine eventi esistente.  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.  
  
\- oppure - 
I primi 8 caratteri di <paramref name="logName" /> corrispondono ai primi 8 caratteri di un nome di log eventi esistente.  
  
\- oppure - 
Non è possibile registrare l'origine poiché esiste già nel computer locale.  
  
\- oppure - 
Il nome origine corrisponde a un nome di log eventi esistente.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi sul computer locale.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Origine con cui l'applicazione è registrata nel computer specificato.</param>
        <param name="logName">Nome del log in cui le voci dell'origine vengono scritte. I valori possibili sono Applicazione, Sistema o un registro eventi personalizzato. Se non si specifica alcun valore, il parametro <c>logName</c> userà il log predefinito Applicazione.</param>
        <param name="machineName">Nome del computer con cui registrare l'origine evento oppure "." per il computer locale.</param>
        <summary>Determina che il nome di origine specificato è un nome di eventi valido per la scrittura di voci in un log del computer specificato. Questo metodo può essere usato anche per creare un nuovo log personalizzato nel computer specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare un registro personalizzato o per creare e registrare un <xref:System.Diagnostics.EventLog.Source%2A> in un registro esistente sul computer specificato.  
  
 Se `logName` viene `null` o una stringa vuota ("") quando si chiama <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, per impostazione predefinita il registro nel registro applicazioni. Se il log non esiste nel computer specificato, il sistema crea un log personalizzato e registra l'applicazione come un <xref:System.Diagnostics.EventLog.Source%2A> di tale log.  
  
 Devi solo creare un'origine evento, se si scrive nel registro eventi. Prima di scrivere una voce in un log eventi, è necessario registrare l'origine evento con il registro eventi come origine valida degli eventi. Quando si scrive una voce di log, il sistema utilizza il <xref:System.Diagnostics.EventLog.Source%2A> per trovare il log appropriato in cui inserire la voce. Se si sta leggendo il registro eventi, è possibile specificare il <xref:System.Diagnostics.EventLog.Source%2A>, o un <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Per creare un'origine evento in Windows Vista e versioni successive o Windows Server 2003, è necessario disporre dei privilegi amministrativi.  
>   
>  Il motivo per questo requisito è che è necessario eseguire ricerche in tutti i registri eventi, tra cui sicurezza, per determinare se l'origine evento è univoca. In Windows Vista e versioni successive, gli utenti non si dispongano dell'autorizzazione per accedere al Registro di sicurezza; Pertanto, un <xref:System.Security.SecurityException> viene generata un'eccezione.  
>   
>  In Windows Vista e versioni successive i privilegi di un utente sono determinati dalla funzionalità Controllo dell'account utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Per eseguire il codice che accede al Registro di protezione, è innanzitutto necessario elevare i privilegi da utente standard all'amministratore. È possibile farlo quando si avvia un'applicazione facendo clic con il pulsante destro del mouse sull'icona dell'applicazione e indicando l'opzione di esecuzione come amministratore.  
  
 Uso <xref:System.Diagnostics.EventLog.WriteEvent%2A> e <xref:System.Diagnostics.EventLog.WriteEntry%2A> per scrivere eventi in un log eventi. È necessario specificare un'origine eventi per scrivere eventi; è necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine.  
  
 Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 È possibile creare un'origine evento per un log eventi esistente o un nuovo registro eventi. Quando si crea una nuova origine per un nuovo registro eventi, il sistema registra l'origine di tale log, ma non viene creato il registro fino a quando non viene scritta la prima voce a esso.  
  
 Il sistema operativo archivia i registri eventi come file. Quando si usa <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> per creare un nuovo registro eventi, il file associato viene archiviato nella directory %SystemRoot%\System32\Config nel computer specificato. Il nome del file è impostato aggiungendo i primi 8 caratteri del <xref:System.Diagnostics.EventLog.Log%2A> proprietà con l'estensione "estensione evt".  
  
 L'origine deve essere univoco nel computer locale. un nuovo nome di origine non può corrispondere a un nome di origine esistente o un nome di log eventi esistente. Ogni origine può scrivere solo un registro eventi alla volta. Tuttavia, l'applicazione può utilizzare più origini in cui per scrivere più registri eventi. Ad esempio, l'applicazione potrebbe richiedere più origini configurate per diversi log eventi o file di risorse diversi.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
 Per modificare i dettagli di configurazione di un'origine esistente, è necessario eliminare l'origine e quindi crearlo nuovamente con la nuova configurazione. Se altre applicazioni o componenti usano l'origine esistente, creare una nuova origine con la configurazione aggiornata, piuttosto che l'eliminazione dell'origine esistente.  
  
> [!NOTE]
>  Se un'origine è già stata mappata a un log e si riesegue il mapping di un nuovo registro, è necessario riavviare il computer rendere effettive le modifiche.  
  
   
  
## Examples  
 L'esempio seguente crea l'origine `MySource` nel computer `MyServer`e viene scritta una voce nel registro eventi `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> non è un nome del computer valido.  
  
\- oppure - 
 <paramref name="source" /> è una stringa ("") o <see langword="null" />.  
  
\- oppure - 
 <paramref name="logName" /> non è un nome di log eventi valido. I nomi dei log eventi devono essere composti da caratteri stampabili e non possono contenere i caratteri "*", "?" o "\\".  
  
\- oppure - 
 <paramref name="logName" /> non è valido per la creazione di log utente. L'utilizzo dei nomi dei log eventi AppEvent, SysEvent e SecEvent è riservato al sistema.  
  
\- oppure - 
Il nome del log corrisponde a un nome di origine eventi esistente.  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.  
  
\- oppure - 
I primi 8 caratteri di <paramref name="logName" /> corrispondono ai primi 8 caratteri di un nome di log eventi esistente.  
  
\- oppure - 
Non è possibile registrare l'origine poiché esiste già nel computer specificato.  
  
\- oppure - 
Il nome dell'origine corrisponde a un nome di origine eventi esistente.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi sul computer specificato.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rimuove una risorsa di log.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nome del registro da eliminare. I valori possibili sono Applicazione, Sicurezza, Sistema e qualsiasi registro eventi personalizzato del computer.</param>
        <summary>Rimuove un registro eventi dal computer locale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo quando il log che si desidera eliminare è nel computer locale. È possibile eliminare tutti i log nel computer, purché tu abbia le autorizzazioni del Registro di sistema appropriate.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Rimuove il log specificato da `logName` dal computer locale. Se si vuole eliminare solo l'origine è registrato in un log, chiamare <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Se si desidera solo eliminare le voci di log, chiamare <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sono `static` metodi, in modo che possono essere chiamati nella classe stessa. Non è necessario creare una nuova istanza della <xref:System.Diagnostics.EventLog> per chiamare uno dei due metodi.  
  
 Il <xref:System.Diagnostics.EventLog.Delete%2A> metodo prima elimina il file che contiene il contenuto del log. Accede al Registro di sistema e quindi rimuove tutte le origini eventi relative al log. Se si ricreano i log in un secondo momento, è consigliabile registrare le origini evento anche in questo caso, se sono da riutilizzare. Se non si registrano le origini evento e ad altri utenti di scrittura a un'origine evento senza specificare un nome di log, verrà creata l'origine dell'evento nel registro eventi dell'applicazione. Di conseguenza, le applicazioni che in precedenza erano in grado di scrivere voci nel log è stata eliminata e ricreata verranno scritto nel registro applicazioni di invece perché ora contiene l'origine dell'evento.  
  
> [!NOTE]
>  Ricreazione di un registro eventi può essere un processo difficile. Evitare l'eliminazione di alcuni dei registri eventi creato dal sistema, ad esempio il registro applicazioni.  
  
 Eliminazione di un log mediante una chiamata a <xref:System.Diagnostics.EventLog.Delete%2A> Elimina automaticamente origini registrate nel log. In questo modo altre applicazioni che utilizzano tale registro non funzionanti.  
  
   
  
## Examples  
 L'esempio seguente elimina un registro dal computer locale. Nell'esempio viene determinato il log dalla relativa origine.  
  
> [!NOTE]
>  Più di un'origine potrebbe scrivere in un log eventi. Prima di eliminare un log personalizzato, assicurarsi che non sono presenti altri origini la scrittura in tale registro.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> è una stringa ("") o <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi sul computer locale.  
  
\- oppure - 
Il log non è presente sul computer locale.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">La cancellazione del log eventi non è stata eseguita correttamente.  
  
oppure 
È impossibile aprire il log. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nome del registro da eliminare. I valori possibili sono Applicazione, Sicurezza, Sistema e qualsiasi registro eventi personalizzato del computer specificato.</param>
        <param name="machineName">Nome del computer da cui eliminare il log oppure "." per il computer locale.</param>
        <summary>Rimuove un registro eventi dal computer specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo quando il log che si desidera eliminare è in un computer remoto. È possibile eliminare tutti i log nel computer, purché tu abbia le autorizzazioni del Registro di sistema appropriate.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Rimuove il log specificato da `logName` dal computer specificato dal `machineName`. Se si vuole eliminare solo l'origine è registrato in un log, chiamare <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Se si desidera solo eliminare le voci di log, chiamare <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sono `static` metodi, in modo che possono essere chiamati nella classe stessa. Non è necessario creare un'istanza di <xref:System.Diagnostics.EventLog> chiamare uno dei due metodi.  
  
 Questo metodo prima elimina il file che contiene il contenuto del log. Accede al Registro di sistema e quindi rimuove tutte le origini eventi relative al log. Se si ricreano i log in un secondo momento, è consigliabile registrare le origini evento anche in questo caso, se sono da riutilizzare. Se non si registrano le origini evento e ad altri utenti di scrittura a un'origine evento senza specificare un nome di log, verrà creata l'origine dell'evento nel registro eventi dell'applicazione. Di conseguenza, le applicazioni che in precedenza erano in grado di scrivere voci nel log è stata eliminata e ricreata verranno scritto nel registro applicazioni di invece perché ora contiene l'origine dell'evento.  
  
> [!NOTE]
>  Ricreazione di un registro eventi può essere un processo difficile. Evitare l'eliminazione di alcuni dei registri eventi creato dal sistema, ad esempio il registro applicazioni.  
  
 Eliminazione di un log mediante una chiamata a <xref:System.Diagnostics.EventLog.Delete%2A> Elimina automaticamente origini registrate nel log. In questo modo altre applicazioni che utilizzano tale registro non funzionanti.  
  
   
  
## Examples  
 L'esempio seguente elimina un registro dal computer specificato. Nell'esempio viene determinato il log dalla relativa origine.  
  
> [!NOTE]
>  Più di un'origine potrebbe scrivere in un log eventi. Prima di eliminare un log personalizzato, assicurarsi che non sono presenti altri origini la scrittura in tale registro.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> è una stringa ("") o <see langword="null" />.  
  
\- oppure - 
 <paramref name="machineName" /> non è un nome di computer valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi sul computer specificato.  
  
\- oppure - 
Il log non è presente sul computer specificato.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">La cancellazione del log eventi non è stata eseguita correttamente.  
  
oppure 
È impossibile aprire il log. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rimuove la registrazione dell'origine eventi di un'applicazione dal registro eventi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nome con cui l'applicazione è registrata nel sistema di registro eventi.</param>
        <summary>Rimuove la registrazione dell'origine eventi dal registro eventi del computer locale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per rimuovere la registrazione di un <xref:System.Diagnostics.EventLog.Source%2A> dal computer locale. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> accede al Registro di sistema nel computer locale e rimuove la registrazione dell'applicazione come origine valida degli eventi.  
  
 Se non è più necessario per scrivere voci nel log, è possibile rimuovere il componente come origine valida degli eventi. Ad esempio, si potrebbe eseguire questa operazione se è necessario modificare il componente da un log a un altro. Poiché un'origine può essere registrata solo in un log alla volta, la modifica del log è necessario rimuovere la registrazione corrente.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Rimuove solo l'origine registrata in un log. Se si desidera rimuovere il log stesso, chiamare <xref:System.Diagnostics.EventLog.Delete%2A>. Se si desidera solo eliminare le voci di log, chiamare <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sono `static` metodi, in modo che possono essere chiamati nella classe stessa. Non è necessario creare un'istanza di <xref:System.Diagnostics.EventLog> chiamare uno dei due metodi.  
  
 Eliminazione di un log mediante una chiamata a <xref:System.Diagnostics.EventLog.Delete%2A> Elimina automaticamente origini registrate nel log. In questo modo altre applicazioni che utilizzano tale registro non funzionanti.  
  
> [!NOTE]
>  Se un'origine è già stata mappata a un log e si riesegue il mapping di un nuovo registro, è necessario riavviare il computer rendere effettive le modifiche.  
  
   
  
## Examples  
 L'esempio seguente elimina un'origine dal computer locale. L'esempio determina il log dalla relativa origine e quindi Elimina il log.  
  
> [!NOTE]
>  Più di un'origine potrebbe scrivere in un log eventi. Prima di eliminare un log personalizzato, assicurarsi che non sono presenti altri origini la scrittura in tale registro.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="source" /> non esiste nel Registro di sistema del computer locale.  
  
\- oppure - 
Non si dispone dell'accesso in scrittura per il log eventi nella chiave del Registro di sistema.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nome con cui l'applicazione è registrata nel sistema di registro eventi.</param>
        <param name="machineName">Nome del computer da cui rimuovere la registrazione oppure "." per il computer locale.</param>
        <summary>Rimuove la registrazione dell'origine eventi di un'applicazione dal computer specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per rimuovere la registrazione di un <xref:System.Diagnostics.EventLog.Source%2A> da un computer remoto. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> accede al Registro di sistema sul computer specificato dal `machineName` e rimuove la registrazione dell'applicazione come origine valida degli eventi.  
  
 Se non è più necessario per scrivere voci nel log, è possibile rimuovere il componente come origine valida degli eventi. Ad esempio, si potrebbe eseguire questa operazione se è necessario modificare il componente da un log a un altro. Poiché un'origine può essere registrata solo in un log alla volta, la modifica del log è necessario rimuovere la registrazione corrente.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Rimuove solo l'origine registrata in un log. Se si desidera rimuovere il log stesso, chiamare <xref:System.Diagnostics.EventLog.Delete%2A>. Se si desidera solo eliminare le voci di log, chiamare <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> e <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sono `static` metodi, in modo che possono essere chiamati nella classe stessa. Non è necessario creare un'istanza di <xref:System.Diagnostics.EventLog> chiamare uno dei due metodi.  
  
 Eliminazione di un log mediante una chiamata a <xref:System.Diagnostics.EventLog.Delete%2A> Elimina automaticamente origini registrate nel log. In questo modo altre applicazioni che utilizzano tale registro non funzionanti.  
  
> [!NOTE]
>  Se un'origine è già stata mappata a un log e si riesegue il mapping di un nuovo registro, è necessario riavviare il computer rendere effettive le modifiche.  
  
   
  
## Examples  
 L'esempio seguente elimina un'origine dal computer specificato. L'esempio determina il log dalla relativa origine e quindi Elimina il log.  
  
> [!NOTE]
>  Più di un'origine potrebbe scrivere in un log eventi. Prima di eliminare un log personalizzato, assicurarsi che non sono presenti altri origini la scrittura in tale registro.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="machineName" /> non è valido.  
  
\- oppure - 
Il parametro <paramref name="source" /> non esiste nel Registro di sistema del computer specificato.  
  
\- oppure - 
Non si dispone dell'accesso in scrittura per il log eventi nella chiave del Registro di sistema.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> non può essere eliminato perché nel Registro di sistema la chiave padre per <paramref name="source" /> non contiene una sottochiave con lo stesso nome.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia le risorse non gestite usate dall'oggetto <see cref="T:System.Diagnostics.EventLog" /> e, facoltativamente, le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato da parte del pubblico `Dispose()` metodo e <xref:System.Object.Finalize%2A> (metodo). `Dispose()` richiama il metodo protetto `Dispose(Boolean)` metodo con il `disposing` parametro impostato su `true`. <xref:System.Object.Finalize%2A> richiama `Dispose` con `disposing` impostato su `false`.  
  
 Quando la `disposing` parametro è true, questo metodo rilascia tutte le risorse utilizzate da qualsiasi oggetto gestito da questo <xref:System.Diagnostics.EventLog> riferimenti. Il metodo richiama il metodo `Dispose()` di ciascun oggetto cui viene fatto riferimento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Il metodo 
            <see langword="Dispose" /> può essere chiamato più volte da altri oggetti. Quando si esegue l'override <see langword="Dispose(Boolean)" /> prestare attenzione a non fare riferimento agli oggetti che sono stati eliminati in una precedente chiamata a <see langword="Dispose" />. Per altre informazioni su come implementare <see langword="Dispose(Boolean)" />, vedere [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Per altre informazioni sulle <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se <see cref="T:System.Diagnostics.EventLog" /> riceve notifiche dell'evento <see cref="E:System.Diagnostics.EventLog.EntryWritten" />.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Diagnostics.EventLog" /> riceve notifica quando una voce viene inserita nel log; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> proprietà determina se il <xref:System.Diagnostics.EventLog> genera eventi quando le voci vengono scritte nel log. Quando la proprietà è `true`, i componenti che ricevono il <xref:System.Diagnostics.EventLog.EntryWritten> evento riceverà una notifica ogni volta che viene scritta una voce nel log specificato nel <xref:System.Diagnostics.EventLog.Log%2A> proprietà. Se <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> è `false`, viene generato alcun evento.  
  
> [!NOTE]
>  È possibile ricevere le notifiche degli eventi solo quando le voci vengono scritte nel computer locale. Non è possibile ricevere le notifiche per le voci scritte nei computer remoti.  
  
   
  
## Examples  
 L'esempio seguente viene gestito un <xref:System.Diagnostics.EventLog.EntryWritten> evento.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il registro eventi si trova su un computer remoto.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina l'inizializzazione di un oggetto <see cref="T:System.Diagnostics.EventLog" /> usato in un form o da un altro componente. L'inizializzazione avviene in fase di esecuzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Progettazione ambiente utilizza questo metodo per terminare l'inizializzazione di un componente usato in un form o da un altro componente. Il <xref:System.Diagnostics.EventLog.BeginInit%2A> metodo avvia l'inizializzazione. Usando il <xref:System.Diagnostics.EventLog.BeginInit%2A> e <xref:System.Diagnostics.EventLog.EndInit%2A> metodi impedisce l'utilizzo prima che il completamento dell'inizializzazione del controllo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il contenuto del registro eventi.</summary>
        <value>Oggetto <see cref="T:System.Diagnostics.EventLogEntryCollection" /> che contiene le voci del registro eventi. Ogni voce è associata a un'istanza della classe <see cref="T:System.Diagnostics.EventLogEntry" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Diagnostics.EventLog.Entries%2A> membro durante la lettura dal registro eventi.  
  
 Poiché la proprietà è di sola lettura, è possibile modificare una voce o scrivere nel log utilizzando <xref:System.Diagnostics.EventLog.Entries%2A>. Specificare invece un <xref:System.Diagnostics.EventLog.Source%2A> e chiamare <xref:System.Diagnostics.EventLog.WriteEntry%2A> per scrivere una nuova voce di log. È possibile usare <xref:System.Diagnostics.EventLog.Entries%2A> per contare il numero di voci nel registro eventi e visualizzare ogni <xref:System.Diagnostics.EventLogEntry> nella raccolta. Usare indicizzata <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> membro per recuperare informazioni su una voce specifica, ad esempio <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, o <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 Non è necessario specificare un <xref:System.Diagnostics.EventLog.Source%2A> durante la lettura solo da un log. È possibile specificare solo il <xref:System.Diagnostics.EventLog.Log%2A> nome e <xref:System.Diagnostics.EventLog.MachineName%2A> delle proprietà (nome del computer server) per il <xref:System.Diagnostics.EventLog> istanza. In entrambi i casi il <xref:System.Diagnostics.EventLog.Entries%2A> membro viene popolato automaticamente con l'elenco delle voci del log eventi. È possibile selezionare l'indice appropriato per un elemento in questo elenco per leggere le singole voci.  
  
 Una differenza importante tra lettura e scrittura di voci di log è che non è necessario chiamare in modo esplicito un metodo di lettura. Dopo il <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A> vengono specificati, il <xref:System.Diagnostics.EventLog.Entries%2A> proprietà viene popolata automaticamente. Se si modifica il valore della <xref:System.Diagnostics.EventLog.Log%2A> oppure <xref:System.Diagnostics.EventLog.MachineName%2A> proprietà, il <xref:System.Diagnostics.EventLog.Entries%2A> proprietà ricompilata alla successiva viene letta.  
  
> [!NOTE]
>  Non è necessario specificare il <xref:System.Diagnostics.EventLog.MachineName%2A> se ci si connette a un log. Se non si specifica il <xref:System.Diagnostics.EventLog.MachineName%2A>, sul computer locale ".", verrà utilizzato.  
  
   
  
## Examples  
 Nell'esempio seguente legge le voci nel registro eventi, "MyNewLog", nel computer locale.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene scritta una voce in un registro eventi del computer locale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere le notifiche degli eventi, è necessario impostare <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> a `true`. È possibile ricevere le notifiche degli eventi solo quando le voci vengono scritte nel computer locale. Non è possibile ricevere le notifiche per le voci scritte nei computer remoti.  
  
 Quando si crea un delegato di <xref:System.Diagnostics.EventLog.EntryWritten>, si identifica il metodo con cui gestire l'evento. Per associare l'evento al gestore eventi in uso, aggiungere all'evento un'istanza del delegato. Il gestore eventi viene chiamato ogni volta che si verifica l'evento, fino a quando non viene rimosso il delegato. Per altre informazioni sulla gestione degli eventi con i delegati, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 Il sistema risponde a <xref:System.Diagnostics.EventLog.WriteEntry%2A> solo se l'ultimo evento di scrittura si è verificato almeno sei secondi. Ciò implica si riceverà solo uno <xref:System.Diagnostics.EventLog.EntryWritten> notifica degli eventi all'interno di un intervallo di sei secondi, anche se cambia l'accesso più di un evento si verifica. Se si inserisce un intervallo di inattività sufficientemente lungo (circa 10 secondi) tra le chiamate a <xref:System.Diagnostics.EventLog.WriteEntry%2A>, riduce la probabilità di perdita di un evento. Tuttavia, se gli eventi di scrittura si verificano più spesso, si potrebbe non ricevere la notifica degli eventi fino all'intervallo successivo. In genere, le notifiche degli eventi mancanti non vengono persi, ma ritardati.  
  
   
  
## Examples  
 L'esempio seguente gestisce un'evento scritto della voce.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se il log specificato esiste.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nome del log di cui eseguire la ricerca. I valori possibili sono Applicazione, Sicurezza, Sistema, gli altri log specifici per l'applicazione, come ad esempio quelli associati ad Active Directory, o qualsiasi log personalizzato nel computer.</param>
        <summary>Determina se il log esiste nel computer locale.</summary>
        <returns>
          <see langword="true" /> se il log esiste nel computer locale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per determinare se un log esiste nel computer locale. Se si desidera determinare la presenza di un'origine nel computer locale, usare <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Poiché questo metodo accede al Registro di sistema, è necessario disporre le autorizzazioni del Registro di sistema appropriate nel computer locale. in caso contrario, la query restituisce `false`.  
  
 Poiché è possibile attribuire un nuovo registro il nome di un registro esistente nello stesso computer, usare questo metodo prima di creare un nuovo log per determinare se l'oggetto specificato `logName` esiste già nel computer locale. Il `logName` parametro non viene fatta distinzione tra maiuscole e minuscole.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> è un `static` metodo, pertanto può essere chiamato sulla classe stessa. Non è necessario creare un'istanza di <xref:System.Diagnostics.EventLog> chiamare <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro logName è <see langword="null" /> o il valore è vuoto.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Log da ricercare. I valori possibili sono Applicazione, Sicurezza, Sistema, gli altri log specifici per l'applicazione, come ad esempio quelli associati ad Active Directory, o qualsiasi log personalizzato nel computer.</param>
        <param name="machineName">Nome del computer in cui cercare il log oppure "." per il computer locale.</param>
        <summary>Determina se il log esiste nel computer specificato.</summary>
        <returns>
          <see langword="true" /> se il log esiste nel computer specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per determinare l'esistenza di un log in un computer remoto. Se si desidera determinare la presenza di un'origine in un computer remoto, usare <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Poiché questo metodo accede al Registro di sistema, è necessario disporre di autorizzazioni adeguate sul computer specificato; in caso contrario, la query restituisce `false`.  
  
 Poiché non è possibile attribuire a un nuovo registro il nome di un registro esistente nello stesso computer, usare questo metodo prima di creare un nuovo log per determinare se uno con l'oggetto specificato `logName` esiste già nel server specificato da di `machineName` parametro. Il `logName` e `machineName` parametri non sono tra maiuscole e minuscole.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> è un `static` metodo, pertanto può essere chiamato sulla classe stessa. Non è necessario creare una nuova istanza della <xref:System.Diagnostics.EventLog> chiamare <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="machineName" /> è di un formato non valido. Verificare di avere utilizzato la sintassi corretta per il computer in cui viene eseguita la ricerca.  
  
oppure 
Il parametro <paramref name="logName" /> è <see langword="null" /> o il valore è vuoto.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una matrice dei registri eventi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esegue una ricerca di tutti i registri eventi nel computer locale e crea una matrice di oggetti <see cref="T:System.Diagnostics.EventLog" /> che contengono l'elenco.</summary>
        <returns>Matrice di tipo <see cref="T:System.Diagnostics.EventLog" /> che rappresenta i log nel computer locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Matrice di <xref:System.Diagnostics.EventLog> oggetti è uno snapshot di tutti i registri eventi nel computer locale quando la chiamata a <xref:System.Diagnostics.EventLog.GetEventLogs%2A> viene eseguita. Ciò non è una raccolta dinamica, in modo da non riflette l'eliminazione o la creazione di log in tempo reale. È necessario verificare che un registro nella matrice sia presente prima di leggere o scrivere in esso. Matrice in genere include almeno tre log: applicazione, sistema e sicurezza. Se si creano log personalizzato nel computer locale, verranno visualizzati anche della matrice.  
  
 Per recuperare l'elenco dei registri eventi, è necessario disporre di autorizzazioni adeguate. Queste autorizzazioni sono identiche a quelli necessari per chiamare <xref:System.Diagnostics.EventLog.Exists%2A> e <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente enumera il log eventi definiti nel computer locale e vengono visualizzati i dettagli di configurazione per ogni log eventi.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Non si dispone dell'accesso in lettura al Registro di sistema.  
  
oppure 
Non esiste alcun servizio di log eventi nel computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Computer in cui eseguire la ricerca dei registri eventi.</param>
        <summary>Esegue una ricerca di tutti i registri eventi in un dato computer e crea una matrice di oggetti <see cref="T:System.Diagnostics.EventLog" /> che contengono l'elenco.</summary>
        <returns>Matrice di tipo <see cref="T:System.Diagnostics.EventLog" /> che rappresenta i log in un dato computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Matrice di <xref:System.Diagnostics.EventLog> oggetti è uno snapshot di tutti i registri eventi nel computer specificato per il `machineName` parametro quando la chiamata a <xref:System.Diagnostics.EventLog.GetEventLogs%2A> viene effettuata. Ciò non è una raccolta dinamica, in modo da non riflette l'eliminazione o la creazione di log in tempo reale. È necessario verificare che un registro nella matrice sia presente prima di leggere o scrivere in esso. Matrice in genere include almeno tre log: applicazione, sistema e sicurezza. Se si creano log personalizzato nel computer specificato, verranno visualizzati anche della matrice.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> è un `static` metodo, in modo che può essere chiamata sul <xref:System.Diagnostics.EventLog> classe stessa. Non è necessario creare un'istanza di un <xref:System.Diagnostics.EventLog> oggetto effettuare una chiamata al metodo.  
  
 Per recuperare l'elenco dei registri eventi, è necessario disporre di autorizzazioni adeguate. Queste autorizzazioni sono identiche a quelli necessari per chiamare <xref:System.Diagnostics.EventLog.Exists%2A> e <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene un elenco di log nel computer "myServer". Restituisce quindi il nome di ogni log.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="machineName" /> è un nome di computer non valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non si dispone dell'accesso in lettura al Registro di sistema.  
  
oppure 
Non esiste alcun servizio di log eventi nel computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del log da cui leggere o in cui scrivere.</summary>
        <value>Nome del log. Può trattarsi di un nome di log personalizzato o dei log Applicazione, Sistema o Sicurezza. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sono presenti tre file di log per impostazione predefinita nel server: applicazione, sistema e sicurezza. Servizi e applicazioni di utilizzano il file di log dell'applicazione. I driver di dispositivo usano il file di registro di sistema. Il sistema genera gli eventi di controllo e non riuscite nel log di sicurezza quando il controllo è attivato. Se si dispone di altre applicazioni installate, come Active Directory nei server Windows, potrebbero esserci altri file di log predefinito. Inoltre, è possibile creare file di log personalizzati in un computer locale o remoto. I log personalizzati consentono di organizzare i dati immessi in modo più dettagliato rispetto alla scrittura di eventi nel registro dell'applicazione predefinito dei componenti.  
  
> [!NOTE]
>  I nomi dei log sono limitate a otto caratteri. In base al sistema, MyLogSample1 e MyLogSample2 rappresentano lo stesso log.  
  
 Se si scrive in un log eventi, non è sufficiente specificare il <xref:System.Diagnostics.EventLog.Log%2A> proprietà. È necessario associare un <xref:System.Diagnostics.EventLog.Source%2A> proprietà alla risorsa del registro eventi per connetterla a un registro specifico. Non è necessario specificare un <xref:System.Diagnostics.EventLog.Source%2A> quando leggere solo da un log, ma un'origine evento deve essere associata alla risorsa di log eventi nel Registro di sistema del server. È possibile specificare solo il <xref:System.Diagnostics.EventLog.Log%2A> name e <xref:System.Diagnostics.EventLog.MachineName%2A> (nome del computer server) per leggere da essa.  
  
> [!NOTE]
>  Non è necessario specificare il <xref:System.Diagnostics.EventLog.MachineName%2A> se ci si connette a un log. Se non si specifica il <xref:System.Diagnostics.EventLog.MachineName%2A>, il computer locale (".") verrà utilizzato.  
  
 Se il <xref:System.Diagnostics.EventLog.Source%2A> proprietà non è stata specificata, una chiamata a <xref:System.Diagnostics.EventLog.Log%2A> restituisce una stringa vuota se <xref:System.Diagnostics.EventLog.Log%2A> non è stato impostato in modo esplicito (impostando il <xref:System.Diagnostics.EventLog.Log%2A> proprietà o tramite il costruttore). Se il <xref:System.Diagnostics.EventLog.Source%2A> è stata specificata, <xref:System.Diagnostics.EventLog.Log%2A> restituisce il nome del log in cui è stata registrata tale origine.  
  
 Un'origine può essere registrata solo in un log alla volta. Se il <xref:System.Diagnostics.EventLog.Source%2A> proprietà è stata impostata per un'istanza di <xref:System.Diagnostics.EventLog>, non è possibile modificare le <xref:System.Diagnostics.EventLog.Log%2A> proprietà per tale <xref:System.Diagnostics.EventLog> senza modificare il valore di <xref:System.Diagnostics.EventLog.Source%2A> o la chiamata <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> prima. Se si modifica il <xref:System.Diagnostics.EventLog.Log%2A> proprietà dopo il <xref:System.Diagnostics.EventLog.Source%2A> proprietà è stata impostata, la scrittura di una voce di log genera un'eccezione.  
  
 Il sistema operativo archivia i registri eventi come file. Quando si usa <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> per creare un nuovo registro eventi, il file associato viene archiviato nella directory %SystemRoot%\System32\Config nel computer specificato. Il nome del file è impostato aggiungendo i primi 8 caratteri del <xref:System.Diagnostics.EventLog.Log%2A> proprietà con l'estensione "estensione evt".  
  
 Non è possibile creare un nuovo log usando il <xref:System.Diagnostics.EventLog.Log%2A> proprietà autonomo (senza specificare un'origine per il log). È possibile chiamare <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, passando un nuovo nome di log come parametro e quindi chiamare <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Tuttavia, lo scopo è in genere per creare (e la scrittura di voci per) nuovi log specifici dell'applicazione, o da cui leggere i log esistenti.  
  
 Se il <xref:System.Diagnostics.EventLog.Log%2A> le modifiche dei valori, il registro eventi viene chiusa e vengono rilasciati tutti gli handle di evento.  
  
> [!CAUTION]
>  Se si imposta la <xref:System.Diagnostics.EventLog.Log%2A> proprietà sul nome di un log che non esiste, il sistema associa il <xref:System.Diagnostics.EventLog> nel registro applicazioni, ma non avvisa l'utente che viene usato un log diverso da quello specificato.  
  
   
  
## Examples  
 Nell'esempio seguente legge le voci nel registro eventi, "NewEventLog", nel computer locale.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome descrittivo del registro eventi.</summary>
        <value>Nome che rappresenta il registro eventi nel Visualizzatore eventi del sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  In Windows Vista e versioni successive, gli utenti non si dispone dell'autorizzazione per accedere al Registro di sicurezza. Se si sta eseguendo Windows Vista o in un secondo momento come un utente, si otterrà un <xref:System.Security.SecurityException> quando si tenta di accedere al nome visualizzato per un evento nel Registro di sicurezza.  
>   
>  In Windows Vista e versioni successive i privilegi di un utente sono determinati dalla funzionalità Controllo dell'account utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Per eseguire il codice che accede al Registro di protezione, è innanzitutto necessario elevare i privilegi da utente standard all'amministratore. È possibile farlo quando si avvia un'applicazione facendo clic con il pulsante destro del mouse sull'icona dell'applicazione e indicando l'opzione di esecuzione come amministratore.  
  
   
  
## Examples  
 Nell'esempio seguente enumera il log eventi definiti nel computer locale e visualizza il <xref:System.Diagnostics.EventLog.LogDisplayName%2A> per ogni log eventi.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Diagnostics.EventLog.Log" /> specificata non esiste nel Registro di sistema del computer.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">la possibilità di leggere la chiave del Registro di sistema. Enumerazione associata: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la possibilità di accedere al se chiave del Registro di sistema è una chiave remota. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nome dell'origine evento.</param>
        <param name="machineName">Nome del computer in cui cercare oppure "." per il computer locale.</param>
        <summary>Restituisce il nome del registro in cui l'origine specificata è stata registrata.</summary>
        <returns>Nome del log associato all'origine specificata nel Registro di sistema.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'origine dell'evento indica ciò che registra l'evento. È spesso il nome dell'applicazione o il nome del sottocomponente dell'applicazione, se l'applicazione è di grandi dimensioni. Le applicazioni e servizi devono scrivere nel registro dell'applicazione o un log personalizzato. I driver di dispositivo devono scrivere nel Registro di sistema.  
  
 Quando si crea una nuova origine, che può scrivere solo in un log alla volta, il sistema registra l'applicazione con il registro eventi come origine valida delle voci. Il <xref:System.Diagnostics.EventLog.Source%2A> proprietà può essere qualsiasi stringa, ma il nome non può essere usato da altre origini nel computer. Tentativo di creare un duplicato <xref:System.Diagnostics.EventLog.Source%2A> valore genera un'eccezione. Tuttavia, un singolo registro eventi può avere molte origini diverse di scrivere in esso.  
  
   
  
## Examples  
 L'esempio seguente elimina un'origine dal computer locale. L'esempio determina il log dalla relativa origine e quindi Elimina il log.  
  
> [!NOTE]
>  Più di un'origine potrebbe scrivere in un log eventi. Prima di eliminare un log personalizzato, assicurarsi che non sono presenti altri origini la scrittura in tale registro.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del computer in cui leggere o scrivere eventi.</summary>
        <value>Nome del server in cui risiede il registro eventi. Il valore predefinito è il computer locale (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si scrive in un log eventi, è necessario associare un <xref:System.Diagnostics.EventLog.Source%2A> con l'oggetto registro eventi per connetterla a un registro specifico. Non è necessario specificare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà durante la lettura solo da un log. È possibile specificare solo il <xref:System.Diagnostics.EventLog.Log%2A> name e <xref:System.Diagnostics.EventLog.MachineName%2A> (nome del computer server).  
  
> [!NOTE]
>  Non è necessario specificare il <xref:System.Diagnostics.EventLog.MachineName%2A> se ci si connette a un log. Se non si specifica il <xref:System.Diagnostics.EventLog.MachineName%2A>, il computer locale (".") verrà utilizzato.  
  
 Un'origine può essere registrata solo in un log alla volta. Se il <xref:System.Diagnostics.EventLog.Source%2A> proprietà è stata impostata per un'istanza di <xref:System.Diagnostics.EventLog>, non è possibile modificare le <xref:System.Diagnostics.EventLog.MachineName%2A> proprietà per tale <xref:System.Diagnostics.EventLog> senza modificare il valore di <xref:System.Diagnostics.EventLog.Source%2A> o la chiamata <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> prima. Se si modifica il <xref:System.Diagnostics.EventLog.MachineName%2A> proprietà, il <xref:System.Diagnostics.EventLog> chiude tutti gli handle e ricollegare quest'ultimo per il log e l'origine nel nuovo computer.  
  
 Il <xref:System.Diagnostics.EventLog.MachineName%2A> valore non può essere una stringa vuota. Se non è esplicitamente impostata, per impostazione predefinita nel computer locale (".").  
  
   
  
## Examples  
 Nell'esempio seguente legge le voci nel registro eventi, "NewEventLog", in un computer specifico.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il nome del computer non è valido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione massima del registro eventi in KB.</summary>
        <value>Dimensione massima del registro eventi in KB. Il valore predefinito è 512, che indica una dimensione file massima di 512 KB.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> proprietà rappresenta il limite delle dimensioni del file di log eventi. Quando il registro eventi raggiunge il limite di dimensioni, l'applicazione configurato <xref:System.Diagnostics.EventLog.OverflowAction%2A> valore determina se ignorare le nuove voci o se le nuove voci sovrascrivono le voci precedenti.  
  
> [!NOTE]
>  Questa proprietà rappresenta un'impostazione di configurazione per il log eventi rappresentato da questa istanza. Quando il registro eventi raggiunge la dimensione massima, questa proprietà specifica la modalità di gestione delle nuove voci scritte da tutte le origini di eventi registrate per il log eventi del sistema operativo.  
  
   
  
## Examples  
 Nell'esempio seguente enumera il log eventi definiti nel computer locale e vengono visualizzati i dettagli di configurazione per ogni log eventi.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore specificato è minore di 64, maggiore di 4194240 oppure non è un multiplo pari di 64.</exception>
        <exception cref="T:System.InvalidOperationException">Il valore <see cref="P:System.Diagnostics.EventLog.Log" /> non è un nome di log valido.  
  
\- oppure - 
Non è possibile aprire la chiave del Registro di sistema per il log eventi sul computer di destinazione.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di giorni per cui mantenere le voci nel registro eventi.</summary>
        <value>Numero di giorni per cui le voci vengono mantenute nel registro eventi. Il valore predefinito è 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> proprietà per esaminare l'impostazione corrente per un log eventi. Usare <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> per modificare il numero minimo di giorni che deve essere mantenute ogni voce nel registro eventi.  
  
 Il <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valore dipende dal comportamento configurato overflow del log eventi. Se il <xref:System.Diagnostics.OverflowAction> per un log eventi viene impostata su <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, quindi il <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valore è 0. Se il <xref:System.Diagnostics.OverflowAction> per un log eventi viene impostata su <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, quindi il <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valore è -1. Se il <xref:System.Diagnostics.OverflowAction> per un log eventi viene impostata su <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, quindi il <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valore è maggiore di zero e rappresenta il numero di giorni di conservazione delle voci del registro eventi quando il registro eventi è pieno.  
  
 Il comportamento di overflow si verifica solo quando un registro eventi raggiunge la dimensione massima. Quando un <xref:System.Diagnostics.EventLog> ha relativi <xref:System.Diagnostics.EventLog.OverflowAction%2A> impostata su <xref:System.Diagnostics.OverflowAction.OverwriteOlder>e nel registro eventi raggiunge la dimensione massima, le nuove voci vengono scritte solo se possono sostituire le voci di cui età è superiore di <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> periodo. Mantenendo le voci di evento per un periodo minimo è appropriato quando viene archiviato regolarmente il registro eventi. In caso contrario, si rischia di perdere le nuove voci quando il registro eventi raggiunge il limite. Per evitare la perdita di informazioni sul nuovo evento, impostare i giorni di conservazione minimo per gli eventi in base alla pianificazione dell'archiviazione per un determinato registro eventi.  
  
   
  
## Examples  
 Nell'esempio seguente enumera il log eventi definiti nel computer locale e vengono visualizzati i dettagli di configurazione per ogni log eventi.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">Comportamento di overflow per la scrittura di nuove voci nel registro eventi.</param>
        <param name="retentionDays">Numero minimo di giorni per cui ogni voce del registro eventi viene mantenuta. Questo parametro viene usato solo se <c>action</c> è impostato su <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Modifica il comportamento configurato per la scrittura delle nuove voci quando il registro eventi raggiunge la dimensione massima.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento di overflow del log eventi specifica che cosa avviene quando le nuove voci vengono scritti in un log che ha raggiunto le dimensioni massime del file.  
  
> [!NOTE]
>  Il comportamento di overflow ha effetto solo quando un registro eventi raggiunge la dimensione file massima. Il comportamento di overflow non influenza la scrittura di una nuova voce in un log che può contenere voci registro eventi aggiuntivo.  
  
 Il <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> metodo configura il comportamento di overflow di un log eventi. <xref:System.Diagnostics.EventLog> istanza. Dopo aver chiamato questo metodo per il log eventi specificato dal <xref:System.Diagnostics.EventLog.Log%2A> proprietà, il <xref:System.Diagnostics.EventLog.OverflowAction%2A> e <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> i valori delle proprietà riflettono il comportamento di overflow appena configurata.  
  
> [!NOTE]
>  Questa proprietà rappresenta un'impostazione di configurazione per il log eventi rappresentato da questa istanza. Quando il registro eventi raggiunge la dimensione massima, questa proprietà specifica la modalità di gestione delle nuove voci scritte da tutte le origini di eventi registrate per il log eventi del sistema operativo.  
  
 Impostare il `action` parametro per <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> per indicare che una voce nuova sovrascrive quella meno recente quando la <xref:System.Diagnostics.EventLog> raggiunge la dimensione massima. Se il `action` parametro è impostato su <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, il `retentionDays` valore del parametro viene ignorato.  
  
 Impostare il `action` parametro per <xref:System.Diagnostics.OverflowAction.OverwriteOlder> per indicare che ogni voce nuova sovrascrive le voci meno recenti quando il <xref:System.Diagnostics.EventLog> raggiunge la dimensione massima. Specificare il numero di giorni durante i quali eventi devono essere mantenuti nel log utilizzando il `retentionDays` parametro. Gli eventi scritti all'interno dell'intervallo di conservazione non vengono sovrascritte dalle nuove voci.  
  
 Impostare il `action` parametro per <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> per ignorare i nuovi eventi quando viene raggiunta la dimensione massima del log. Se il `action` parametro è impostato su <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, il `retentionDays` valore del parametro viene ignorato.  
  
> [!CAUTION]
>  Impostazione dei criteri di overflow <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> specifica che le nuove voci vengono rimossi quando il registro eventi è pieno. Se si usa questa impostazione, verificare che il registro eventi regolarmente viene archiviato ed eliminato per evitare di raggiungere il limite di dimensioni massime.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza i criteri di overflow configurato per un registro eventi specificato e consente all'utente di selezionare una nuova impostazione di criteri di overflow per il log eventi.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> non è un valore valido di <see cref="P:System.Diagnostics.EventLog.OverflowAction" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> è minore di uno o maggiore di 365.</exception>
        <exception cref="T:System.InvalidOperationException">Il valore <see cref="P:System.Diagnostics.EventLog.Log" /> non è un nome di log valido.  
  
\- oppure - 
Non è possibile aprire la chiave del Registro di sistema per il log eventi sul computer di destinazione.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il comportamento configurato per l'archiviazione delle nuove voci quando il file di log raggiunge la dimensione massima.</summary>
        <value>Valore di <see cref="T:System.Diagnostics.OverflowAction" /> che specifica il comportamento configurato per l'archiviazione delle nuove voci quando il registro eventi raggiunge la dimensione massima. Il valore predefinito è <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Registri eventi di aumento delle dimensioni come vengono scritti nuovi eventi. Ogni log eventi ha un limite di dimensioni massime configurate; il <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> proprietà definisce il numero massimo di KB consentiti per le dimensioni del file registro eventi.  
  
 Usare il <xref:System.Diagnostics.EventLog.OverflowAction%2A> valore della proprietà per esaminare il comportamento di overflow configurato per un log eventi quando la dimensione massima. Usare il <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> metodo per modificare il comportamento di overflow del log eventi.  
  
> [!NOTE]
>  Il comportamento di overflow ha effetto solo quando un registro eventi raggiunge la dimensione file massima. Il comportamento di overflow non influenza la scrittura di una nuova voce in un log che può contenere voci registro eventi aggiuntivo.  
  
   
  
## Examples  
 Nell'esempio seguente enumera il log eventi definiti nel computer locale e vengono visualizzati i dettagli di configurazione per ogni log eventi.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Percorso completo di un file di risorse localizzato.</param>
        <param name="resourceId">Identificatore di risorsa che indicizza una stringa localizzata all'interno del file di risorse.</param>
        <summary>Specifica il nome localizzato del registro eventi, visualizzato nel Visualizzatore eventi del server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> per registrare e un nome localizzato visualizzato nel Visualizzatore eventi per i log eventi personalizzati.  
  
 L'identificatore di risorsa specificato deve corrispondere a una stringa localizzata definita nel file di risorse. Nel Visualizzatore eventi consente di visualizzare il nome di un log eventi personalizzato usando la stringa localizzata e le impostazioni cultura correnti. Ad esempio, è possibile definire più nomi di registro eventi localizzati per impostazioni cultura diverse nel file di risorse. Il Visualizzatore eventi consente di visualizzare la stringa localizzata corrispondente alle impostazioni cultura dell'utente corrente.  
  
 Se il Visualizzatore eventi non è possibile caricare la stringa localizzata dal file di risorse o se è stato registrato alcun nome visualizzato per il log eventi, il Visualizzatore eventi visualizza il nome del registro eventi definito in <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  Non devi registrare un nome visualizzato per i registri eventi predefiniti. Il sistema operativo registra i nomi visualizzati localizzata per i registri eventi dell'applicazione, sistema e sicurezza.  
  
   
  
## Examples  
 L'esempio seguente determina se l'origine dell'evento denominato `SampleApplicationSource` è registrata nel computer locale. Se l'origine evento non esiste, l'esempio imposta il file di risorse di messaggio per l'origine e crea la nuova origine evento. Infine, l'esempio imposta il nome visualizzato localizzato per il log eventi, usando il valore di identificatore di risorsa in `DisplayNameMsgId` e il percorso del file di risorse in `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 L'esempio Usa il file di testo di messaggio seguente, generato nella libreria di risorse EventLogMsgs. Un file di testo del messaggio è l'origine da cui viene creato il file di risorse del messaggio. Il file di testo del messaggio definisce gli identificatori di risorsa e il testo per la categoria, messaggio di evento e le stringhe di inserimento di parametro. In particolare, l'identificatore della risorsa 5001 è definito per il nome localizzato del log eventi.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il valore <see cref="P:System.Diagnostics.EventLog.Log" /> non è un nome di log valido.  
  
\- oppure - 
Non è possibile aprire la chiave del Registro di sistema per il log eventi sul computer di destinazione.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per l'amministrazione di informazioni del registro eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome dell'origine da registrare e usare quando si scrive nel registro eventi.</summary>
        <value>Nome registrato con il registro eventi come origine delle voci. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'origine dell'evento indica ciò che registra l'evento. È spesso il nome dell'applicazione o il nome del sottocomponente dell'applicazione, se l'applicazione è di grandi dimensioni. Le applicazioni e servizi devono scrivere nel registro dell'applicazione o un log personalizzato. I driver di dispositivo devono scrivere nel Registro di sistema.  
  
 È sufficiente specificare un'origine evento, se si scrive in un log eventi. Prima di scrivere una voce in un log eventi, è necessario registrare l'origine evento con il registro eventi come origine valida degli eventi. Quando si scrive una voce di log, il sistema utilizza il <xref:System.Diagnostics.EventLog.Source%2A> proprietà di cui trovare il log appropriato in cui inserire la voce. Se si sta leggendo il registro eventi, è possibile specificare il <xref:System.Diagnostics.EventLog.Source%2A>, o un <xref:System.Diagnostics.EventLog.Log%2A> e <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Non è necessario specificare il <xref:System.Diagnostics.EventLog.MachineName%2A> se ci si connette a un log nel computer locale. Se non si specifica il <xref:System.Diagnostics.EventLog.MachineName%2A>, il computer locale (".") verrà utilizzato.  
  
 Uso <xref:System.Diagnostics.EventLog.WriteEvent%2A> e <xref:System.Diagnostics.EventLog.WriteEntry%2A> per scrivere eventi in un log eventi. È necessario specificare un'origine eventi per scrivere eventi; è necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine.  
  
 Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 È possibile creare un'origine evento per un log eventi esistente o un nuovo registro eventi. Quando si crea una nuova origine per un nuovo registro eventi, il sistema registra l'origine di tale log, ma non viene creato il registro fino a quando non viene scritta la prima voce a esso.  
  
 L'origine deve essere univoco nel computer locale. un nuovo nome di origine non può corrispondere a un nome di origine esistente o un nome di log eventi esistente. Ogni origine può scrivere solo un registro eventi alla volta. Tuttavia, l'applicazione può utilizzare più origini in cui per scrivere più registri eventi. Ad esempio, l'applicazione potrebbe richiedere più origini configurate per diversi log eventi o file di risorse diversi.  
  
 Se si modifica il <xref:System.Diagnostics.EventLog.Source%2A> valore, il <xref:System.Diagnostics.EventLog> a cui è registrato viene chiusa e vengono rilasciati tutti gli handle di evento.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
 Per modificare i dettagli di configurazione di un'origine esistente, è necessario eliminare l'origine e quindi crearlo nuovamente con la nuova configurazione. Se altre applicazioni o componenti usano l'origine esistente, creare una nuova origine con la configurazione aggiornata, piuttosto che l'eliminazione dell'origine esistente.  
  
> [!NOTE]
>  Se un'origine è già stata mappata a un log e si riesegue il mapping di un nuovo registro, è necessario riavviare il computer rendere effettive le modifiche.  
  
   
  
## Examples  
 L'esempio seguente crea l'origine `MySource` se non esiste già e viene scritta una voce nel registro eventi `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue la ricerca di una determinata origine eventi nel Registro di sistema di un computer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nome dell'origine evento.</param>
        <summary>Determina se un'origine eventi è registrata nel computer locale.</summary>
        <returns>
          <see langword="true" /> se l'origine eventi è registrata nel computer locale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per determinare la presenza di un'origine eventi nel computer locale. Se si desidera determinare la presenza di un log nel computer locale, usare <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Poiché questo metodo accede al Registro di sistema, è necessario disporre le autorizzazioni del Registro di sistema appropriate nel computer locale. in caso contrario, un <xref:System.Security.SecurityException> verrà generata.  
  
> [!NOTE]
>  Per cercare un'origine evento in Windows Vista e versioni successive o Windows Server 2003, è necessario disporre dei privilegi amministrativi.  
>   
>  Il motivo per questo requisito è che è necessario eseguire ricerche in tutti i registri eventi, tra cui sicurezza, per determinare se l'origine evento è univoca. A partire da Windows Vista, gli utenti non è autorizzato ad accedere Registro di sicurezza. Pertanto, un <xref:System.Security.SecurityException> viene generata un'eccezione.  
>   
>  A partire da Windows Vista, controllo Account utente (UAC) determina i privilegi dell'utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Per eseguire il codice che accede ai contatori delle prestazioni, è innanzitutto necessario elevare i privilegi da utente standard all'amministratore. È possibile farlo quando si avvia un'applicazione facendo clic con il pulsante destro del mouse sull'icona dell'applicazione e indicando l'opzione di esecuzione come amministratore.  
  
> [!NOTE]
>  Un servizio che viene eseguito sotto il <xref:System.ServiceProcess.ServiceAccount.LocalSystem> account non dispone dei privilegi necessari per eseguire questo metodo. La soluzione consiste nel verificare l'esistenza dell'origine evento nel <xref:System.ServiceProcess.ServiceInstaller>, e se non esiste, per creare l'origine del programma di installazione.  
  
 Poiché non è possibile attribuire a una nuova origine il nome di un'origine esistente nello stesso computer, utilizzare questo metodo prima di chiamare <xref:System.Diagnostics.EventLog.CreateEventSource%2A> per garantire che un'origine con il nome specificato dal `source` non esiste già nel computer locale. Il `source` parametro non distinzione maiuscole/minuscole.  
  
   
  
## Examples  
 L'esempio seguente crea l'origine `MySource` se non esiste già e viene scritta una voce nel registro eventi `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il parametro <paramref name="source" /> non è stato trovato ma non è stato possibile cercare alcuni o tutti i log eventi.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nome dell'origine evento.</param>
        <param name="machineName">Nome del computer in cui cercare oppure "." per il computer locale.</param>
        <summary>Determina se un'origine eventi è registrata nel computer specificato.</summary>
        <returns>
          <see langword="true" /> se l'origine eventi è registrata nel computer indicato; in caso contrario, &lt;<see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per determinare la presenza di un'origine eventi nel computer specificato per il `machineName` parametro. Se si desidera determinare la presenza di un log nel computer specificato, usare <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Poiché questo metodo accede al Registro di sistema, è necessario disporre di autorizzazioni adeguate sul server specificato. in caso contrario, un <xref:System.Security.SecurityException> verrà generata.  
  
> [!NOTE]
>  Per cercare un'origine evento in Windows Vista e versioni successive o Windows Server 2003, è necessario disporre dei privilegi amministrativi.  
>   
>  Il motivo per questo requisito è che è necessario eseguire ricerche in tutti i registri eventi, tra cui sicurezza, per determinare se l'origine evento è univoca. A partire da Windows Vista, gli utenti non è autorizzato ad accedere Registro di sicurezza. Pertanto, un <xref:System.Security.SecurityException> viene generata un'eccezione.  
>   
>  A partire da Windows Vista, controllo Account utente (UAC) determina i privilegi dell'utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Per eseguire il codice che accede ai contatori delle prestazioni, è innanzitutto necessario elevare i privilegi da utente standard all'amministratore. È possibile farlo quando si avvia un'applicazione facendo clic con il pulsante destro del mouse sull'icona dell'applicazione e indicando l'opzione di esecuzione come amministratore.  
  
> [!NOTE]
>  Un servizio che viene eseguito sotto il <xref:System.ServiceProcess.ServiceAccount.LocalSystem> account non dispone dei privilegi necessari per eseguire questo metodo. La soluzione consiste nel verificare l'esistenza dell'origine evento nel <xref:System.ServiceProcess.ServiceInstaller>, e se non esiste, per creare l'origine del programma di installazione.  
  
 Poiché non è possibile attribuire a una nuova origine il nome di un'origine esistente nello stesso computer, utilizzare questo metodo prima di chiamare <xref:System.Diagnostics.EventLog.CreateEventSource%2A> per garantire che un'origine con il nome specificato dal `source` non esiste già nel computer. Il `source` e `machineName` parametri non sono tra maiuscole e minuscole.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> è un `static` metodo, pertanto può essere chiamato sulla classe stessa. Non è necessario creare un'istanza di <xref:System.Diagnostics.EventLog> chiamare <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 L'esempio seguente crea l'origine `MySource` nel computer `MyServer`e viene scritta una voce nel registro eventi `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> è un nome di computer non valido.</exception>
        <exception cref="T:System.Security.SecurityException">Il parametro <paramref name="source" /> non è stato trovato ma non è stato possibile cercare alcuni o tutti i log eventi.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto usato per effettuare il marshalling delle chiamate del gestore eventi generate in seguito a un evento scritto della voce <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <value>Oggetto <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> usato per eseguire il marshalling delle chiamate del gestore eventi generate in seguito a un evento <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> nel registro eventi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> viene `null`, metodi che gestiscono il <xref:System.Diagnostics.EventLog.EntryWritten> eventi vengono chiamati su un thread dal pool di thread di sistema. Per altre informazioni sui pool di thread di sistema, vedere <xref:System.Threading.ThreadPool>.  
  
 Quando il <xref:System.Diagnostics.EventLog.EntryWritten> evento è gestito da un form Windows visual componente, ad esempio un pulsante, l'accesso al componente tramite il pool di thread di sistema potrebbe non funzionare o potrebbe causare un'eccezione. Evitare questo problema impostando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> a un componente di Windows Form, in modo che i metodi che gestiscono il <xref:System.Diagnostics.EventLog.EntryWritten> eventi da chiamare sullo stesso thread in cui è stato creato il componente.  
  
 Se il <xref:System.Diagnostics.EventLog> viene usata all'interno [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in una finestra di progettazione Windows Form <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> viene impostata automaticamente per il controllo che contiene il <xref:System.Diagnostics.EventLog>. Ad esempio, se si inserisce un' <xref:System.Diagnostics.EventLog> in una finestra di progettazione Form1 (che eredita da <xref:System.Windows.Forms.Form>) la <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> proprietà della <xref:System.Diagnostics.EventLog> è impostato per l'istanza di Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive una voce nel registro eventi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Stringa da scrivere nel registro eventi.</param>
        <summary>Scrive una voce di tipo informativo con il testo del messaggio specificato nel registro eventi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce di informazioni nel log eventi associato a questo <xref:System.Diagnostics.EventLog> istanza. Se si desidera specificare qualsiasi altra <xref:System.Diagnostics.EventLogEntryType>, usare un overload diverso del <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  Il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
 È necessario impostare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà di <xref:System.Diagnostics.EventLog> componente prima di poter scrivere voci nel log. È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine.  
  
 Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 Se l'origine specificata nel <xref:System.Diagnostics.EventLog.Source%2A> proprietà di questo <xref:System.Diagnostics.EventLog> istanza non è registrata nel computer in cui il componente sta scrivendo <xref:System.Diagnostics.EventLog.WriteEntry%2A> chiamate <xref:System.Diagnostics.EventLog.CreateEventSource%2A> e registra l'origine.  
  
> [!NOTE]
>  Se non si specifica un <xref:System.Diagnostics.EventLog.MachineName%2A> per il <xref:System.Diagnostics.EventLog> istanza prima di chiamare <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, il computer locale (".") si presuppone che.  
  
 Se il sistema deve registrare il <xref:System.Diagnostics.EventLog.Source%2A> tramite una chiamata a <xref:System.Diagnostics.EventLog.WriteEntry%2A> e il <xref:System.Diagnostics.EventLog.Log%2A> proprietà non è stata impostata sul <xref:System.Diagnostics.EventLog> per impostazione predefinita il log di istanza, nel registro applicazioni.  
  
> [!NOTE]
>  Molte eccezioni elencate in precedenza vengono generati da errori generati durante il processo di registrazione di <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo scrive la stringa specificata direttamente nel registro eventi di; non usa un file di risorse localizzabili di messaggio. Usare il <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere eventi utilizzando un file di risorse messaggio localizzato.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se si scrive una voce in un computer remoto, il valore del messaggio (stringa di testo) potrebbe non essere quelli previsti se il computer remoto non è in esecuzione in .NET Framework.  
  
> [!NOTE]
>  Se il `message` parametro contiene un carattere null, il messaggio nel registro eventi viene terminato in corrispondenza del carattere null.  
  
   
  
## Examples  
 L'esempio seguente crea l'origine `MySource` se non esiste già e viene scritta una voce nel registro eventi `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Diagnostics.EventLog.Source" /> dell'oggetto <see cref="T:System.Diagnostics.EventLog" /> non è stata impostata.  
  
oppure 
Il metodo ha tentato di registrare una nuova origine eventi, ma il nome del computer in <see cref="P:System.Diagnostics.EventLog.MachineName" /> non è valido.  
  
\- oppure - 
L'origine è già registrata con un log eventi diverso.  
  
\- oppure - 
La stringa del messaggio è maggiore di 31.839 byte (32.766 byte nei sistemi operativi Windows prima di Windows Vista).  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Stringa da scrivere nel registro eventi.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Scrive nel registro eventi una voce relativa a errori, avvisi, informazioni, controlli riusciti o non riusciti, insieme al testo di un determinato messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce di una determinata <xref:System.Diagnostics.EventLogEntryType> nel registro eventi. Il `type` è indicato dall'icona e il testo nella colonna di tipo nel Visualizzatore eventi per un log.  
  
> [!NOTE]
>  Il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
 È necessario impostare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà di <xref:System.Diagnostics.EventLog> componente prima di poter scrivere voci nel log. È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine.  
  
 Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 Se l'origine specificata nel <xref:System.Diagnostics.EventLog.Source%2A> proprietà di questo <xref:System.Diagnostics.EventLog> istanza non è registrata nel computer in cui il componente sta scrivendo <xref:System.Diagnostics.EventLog.WriteEntry%2A> chiamate <xref:System.Diagnostics.EventLog.CreateEventSource%2A> e registra l'origine.  
  
> [!NOTE]
>  Se non si specifica un <xref:System.Diagnostics.EventLog.MachineName%2A> per il <xref:System.Diagnostics.EventLog> istanza prima di chiamare <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, il computer locale (".") si presuppone che.  
  
 Se il sistema deve registrare il <xref:System.Diagnostics.EventLog.Source%2A> tramite una chiamata a <xref:System.Diagnostics.EventLog.WriteEntry%2A> e il <xref:System.Diagnostics.EventLog.Log%2A> proprietà non è stata impostata sul <xref:System.Diagnostics.EventLog> per impostazione predefinita il log di istanza, nel registro applicazioni.  
  
> [!NOTE]
>  Molte eccezioni elencate in precedenza vengono generate da errori generati durante il processo di registrazione di <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo scrive la stringa specificata direttamente nel registro eventi di; non usa un file di risorse localizzabili di messaggio. Usare il <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere eventi utilizzando un file di risorse messaggio localizzato.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se si scrive una voce in un computer remoto, il valore del messaggio (stringa di testo) potrebbe non essere quelli previsti se il computer remoto non è in esecuzione in .NET Framework.  
  
> [!NOTE]
>  Se il `message` parametro contiene un carattere null, il messaggio nel registro eventi viene terminato in corrispondenza del carattere null.  
  
   
  
## Examples  
 L'esempio seguente scrive una voce di avviso in un log eventi, "MyNewLog", nel computer locale.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Diagnostics.EventLog.Source" /> dell'oggetto <see cref="T:System.Diagnostics.EventLog" /> non è stata impostata.  
  
oppure 
Il metodo ha tentato di registrare una nuova origine eventi, ma il nome del computer in <see cref="P:System.Diagnostics.EventLog.MachineName" /> non è valido.  
  
\- oppure - 
L'origine è già registrata con un log eventi diverso.  
  
\- oppure - 
La stringa del messaggio è maggiore di 31.839 byte (32.766 byte nei sistemi operativi Windows prima di Windows Vista).  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> non è un oggetto <see cref="T:System.Diagnostics.EventLogEntryType" /> valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Origine con cui l'applicazione è registrata nel computer specificato.</param>
        <param name="message">Stringa da scrivere nel registro eventi.</param>
        <summary>Scrive una voce di tipo informativo con il testo del messaggio specificato nel registro eventi, usando l'origine eventi registrata specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce di informazioni nel registro eventi, utilizzare un'origine che è già registrata come un'origine evento per il log appropriato. Se si desidera specificare qualsiasi altra <xref:System.Diagnostics.EventLogEntryType>, usare un overload diverso del <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine. Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo scrive la stringa specificata direttamente nel registro eventi di; non usa un file di risorse localizzabili di messaggio. Usare il <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere eventi utilizzando un file di risorse messaggio localizzato.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se il `message` parametro contiene un carattere null, il messaggio nel registro eventi viene terminato in corrispondenza del carattere null.  
>   
>  Il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
   
  
## Examples  
 L'esempio seguente crea l'origine `MySource` se non esiste già e viene scritta una voce nel registro eventi `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore <paramref name="source" /> è una stringa vuota ("").  
  
\- oppure - 
Il valore di <paramref name="source" /> è <see langword="null" />.  
  
\- oppure - 
La stringa del messaggio è maggiore di 31.839 byte (32.766 byte nei sistemi operativi Windows prima di Windows Vista).  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Stringa da scrivere nel registro eventi.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificatore specifico dell'applicazione per l'evento.</param>
        <summary>Scrive nel registro eventi una voce con il testo del messaggio indicato e con un identificatore eventi definito dall'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce con un parametro definito dall'applicazione `eventID` nel registro eventi. Il `eventID` con l'origine identificano in modo univoco un evento. Ogni applicazione può definire i propri eventi numerati e le stringhe di descrizione alle quali vengono mappati. I visualizzatori eventi visualizzati questi valori stringa per consentire all'utente di comprendere la causa dell'errore e suggerire le azioni da intraprendere.  
  
> [!NOTE]
>  Il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
 Oltre l'identificatore dell'evento, è possibile specificare un <xref:System.Diagnostics.EventLogEntryType> per l'evento da scrivere nel registro eventi. Il `type` è indicato dall'icona e il testo nella colonna di tipo nel Visualizzatore eventi per un log. Questo parametro indica se il tipo di evento è errore, avviso, informazioni, operazioni riuscite o controllo con esito negativo.  
  
 È necessario impostare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà di <xref:System.Diagnostics.EventLog> componente prima di poter scrivere voci nel log. È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine.  
  
 Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 Se l'origine specificata nel <xref:System.Diagnostics.EventLog.Source%2A> proprietà di questo <xref:System.Diagnostics.EventLog> istanza non è registrata nel computer in cui il componente sta scrivendo <xref:System.Diagnostics.EventLog.WriteEntry%2A> chiamate <xref:System.Diagnostics.EventLog.CreateEventSource%2A> e registra l'origine.  
  
> [!NOTE]
>  Se non si specifica un <xref:System.Diagnostics.EventLog.MachineName%2A> per il <xref:System.Diagnostics.EventLog> istanza prima di chiamare <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, il computer locale (".") si presuppone che.  
  
 Se il sistema deve registrare il <xref:System.Diagnostics.EventLog.Source%2A> tramite una chiamata a <xref:System.Diagnostics.EventLog.WriteEntry%2A> e il <xref:System.Diagnostics.EventLog.Log%2A> proprietà non è stata impostata sul <xref:System.Diagnostics.EventLog> per impostazione predefinita il log di istanza, nel registro applicazioni.  
  
> [!NOTE]
>  Molte eccezioni elencate in precedenza vengono generate da errori generati durante il processo di registrazione di <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo scrive la stringa specificata direttamente nel registro eventi di; non usa un file di risorse localizzabili di messaggio. Usare il <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere eventi utilizzando un file di risorse messaggio localizzato.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se si scrive una voce in un computer remoto, il valore del messaggio (stringa di testo) potrebbe non essere quelli previsti se il computer remoto non è in esecuzione in .NET Framework.  
  
> [!NOTE]
>  Se il `message` parametro contiene un carattere null, il messaggio nel registro eventi viene terminato in corrispondenza del carattere null.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Diagnostics.EventLog.Source" /> dell'oggetto <see cref="T:System.Diagnostics.EventLog" /> non è stata impostata.  
  
oppure 
Il metodo ha tentato di registrare una nuova origine eventi, ma il nome del computer in <see cref="P:System.Diagnostics.EventLog.MachineName" /> non è valido.  
  
\- oppure - 
L'origine è già registrata con un log eventi diverso.  
  
\- oppure - 
 <paramref name="eventID" /> è minore di zero o maggiore di <see cref="F:System.UInt16.MaxValue" />.  
  
\- oppure - 
La stringa del messaggio è maggiore di 31.839 byte (32.766 byte nei sistemi operativi Windows prima di Windows Vista).  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> non è un oggetto <see cref="T:System.Diagnostics.EventLogEntryType" /> valido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Origine con cui l'applicazione è registrata nel computer specificato.</param>
        <param name="message">Stringa da scrivere nel registro eventi.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Scrive nel registro eventi una voce relativa a errori, errori, avvisi, informazioni, controlli riusciti o controlli non riusciti, insieme al testo di un determinato messaggio, usando l'origine eventi registrata specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce di una determinata <xref:System.Diagnostics.EventLogEntryType> nel registro eventi, utilizzare un'origine già registrato come un'origine evento per il log appropriato. Il `type` è indicato dall'icona e il testo nella colonna di tipo nel Visualizzatore eventi per un log.  
  
> [!NOTE]
>  Il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
 È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine. Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo scrive la stringa specificata direttamente nel registro eventi di; non usa un file di risorse localizzabili di messaggio. Usare il <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere eventi utilizzando un file di risorse messaggio localizzato.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se il `message` parametro contiene un carattere null, il messaggio nel registro eventi viene terminato in corrispondenza del carattere null.  
  
   
  
## Examples  
 L'esempio seguente scrive una voce di avviso in un log eventi, "MyNewLog", nel computer locale.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore <paramref name="source" /> è una stringa vuota ("").  
  
\- oppure - 
Il valore di <paramref name="source" /> è <see langword="null" />.  
  
\- oppure - 
La stringa del messaggio è maggiore di 31.839 byte (32.766 byte nei sistemi operativi Windows prima di Windows Vista).  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> non è un oggetto <see cref="T:System.Diagnostics.EventLogEntryType" /> valido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Stringa da scrivere nel registro eventi.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificatore specifico dell'applicazione per l'evento.</param>
        <param name="category">Sottocategoria specifica per l'applicazione associata al messaggio.</param>
        <summary>Scrive nel registro eventi una voce con il testo del messaggio indicato, insieme a un identificatore eventi definito dall'applicazione e a una categoria definita dall'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce con un parametro definito dall'applicazione `category` nel registro eventi. Il Visualizzatore eventi utilizza la categoria per filtrare gli eventi scritti da un'origine evento. Il Visualizzatore eventi consente di visualizzare la categoria come valore numerico oppure è possibile usare la categoria come identificatore di risorsa per visualizzare una stringa di categoria localizzata.  
  
> [!NOTE]
>  Il `category` parametro deve essere un valore positivo. I valori di categoria negativi vengono visualizzati come un numero positivo complemento nell'evento visualizzatore. – 10, ad esempio, viene visualizzato come 65,526, – 1 come 65.535.  
  
> [!NOTE]
>  Il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
 Per visualizzare le stringhe di categoria localizzata nel Visualizzatore eventi, è necessario usare un'origine evento configurato con un file di risorse di categoria e impostare il `category` a un identificatore di risorsa nel file di risorse della categoria. Se l'origine evento non dispone di un file di risorse di categoria configurati o specificato `category` indicizza una stringa nel file di risorse di categoria, nel Visualizzatore eventi viene visualizzato il valore della categoria numerica per la voce. Configurare il file di risorse di categoria, oltre al numero di stringhe di categoria nel file di risorse, usando il <xref:System.Diagnostics.EventLogInstaller> o il <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Oltre a categoria, è possibile specificare un identificatore di evento per l'evento da scrivere nel registro eventi. Identificatori di eventi, insieme all'origine evento, identificano in modo univoco un evento. Ogni applicazione può definire i propri eventi numerati e le stringhe di descrizione alle quali vengono mappati. I visualizzatori eventi visualizzati questi valori stringa per consentire all'utente di comprendere la causa dell'errore e suggerire le azioni da intraprendere.  
  
 Infine, è possibile specificare un <xref:System.Diagnostics.EventLogEntryType> per l'evento da scrivere nel registro eventi. Il `type` è indicato dall'icona e il testo nella colonna di tipo nel Visualizzatore eventi per un log. Questo parametro indica se il tipo di evento è errore, avviso, informazioni, operazioni riuscite o controllo con esito negativo.  
  
 È necessario impostare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà di <xref:System.Diagnostics.EventLog> componente prima di poter scrivere voci nel log. È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine.  
  
 Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 Se l'origine specificata nel <xref:System.Diagnostics.EventLog.Source%2A> proprietà di questo <xref:System.Diagnostics.EventLog> istanza non è registrata nel computer in cui il componente sta scrivendo <xref:System.Diagnostics.EventLog.WriteEntry%2A> chiamate <xref:System.Diagnostics.EventLog.CreateEventSource%2A> e registra l'origine.  
  
> [!NOTE]
>  Se non si specifica un <xref:System.Diagnostics.EventLog.MachineName%2A> per il <xref:System.Diagnostics.EventLog> istanza prima di chiamare <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, il computer locale (".") si presuppone che.  
  
 Se il sistema deve registrare il <xref:System.Diagnostics.EventLog.Source%2A> tramite una chiamata a <xref:System.Diagnostics.EventLog.WriteEntry%2A> e il <xref:System.Diagnostics.EventLog.Log%2A> proprietà non è stata impostata sul <xref:System.Diagnostics.EventLog> per impostazione predefinita il log di istanza, nel registro applicazioni.  
  
> [!NOTE]
>  Molte eccezioni elencate in precedenza vengono generate da errori generati durante il processo di registrazione di <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo scrive la stringa specificata direttamente nel registro eventi di; non usa un file di risorse localizzabili di messaggio. Usare il <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere eventi utilizzando un file di risorse messaggio localizzato.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se si scrive una voce in un computer remoto, il valore del messaggio (stringa di testo) potrebbe non essere quelli previsti se il computer remoto non è in esecuzione in .NET Framework.  
  
> [!NOTE]
>  Se il `message` parametro contiene un carattere null, il messaggio nel registro eventi viene terminato in corrispondenza del carattere null.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Diagnostics.EventLog.Source" /> dell'oggetto <see cref="T:System.Diagnostics.EventLog" /> non è stata impostata.  
  
oppure 
Il metodo ha tentato di registrare una nuova origine eventi, ma il nome del computer in <see cref="P:System.Diagnostics.EventLog.MachineName" /> non è valido.  
  
\- oppure - 
L'origine è già registrata con un log eventi diverso.  
  
\- oppure - 
 <paramref name="eventID" /> è minore di zero o maggiore di <see cref="F:System.UInt16.MaxValue" />.  
  
\- oppure - 
La stringa del messaggio è maggiore di 31.839 byte (32.766 byte nei sistemi operativi Windows prima di Windows Vista).  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> non è un oggetto <see cref="T:System.Diagnostics.EventLogEntryType" /> valido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Origine con cui l'applicazione è registrata nel computer specificato.</param>
        <param name="message">Stringa da scrivere nel registro eventi.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificatore specifico dell'applicazione per l'evento.</param>
        <summary>Scrive nel registro eventi una voce con il testo del messaggio indicato e con un identificatore eventi definito dall'applicazione, usando l'origine eventi registrata specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce con un parametro definito dall'applicazione `eventID` nel registro eventi, utilizzare un'origine già registrato come un'origine evento per il log appropriato. Il `eventID`, insieme a origine, identificare in modo univoco un evento. Ogni applicazione può definire i propri eventi numerati e le stringhe di descrizione alle quali vengono mappati. I visualizzatori eventi presentano queste stringhe all'utente per consentire all'utente di comprendere la causa dell'errore e suggerire le azioni da intraprendere.  
  
> [!NOTE]
>  Il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
 Oltre all'identificatore dell'evento, questo overload del metodo <xref:System.Diagnostics.EventLog.WriteEntry%2A> consente di specificare un <xref:System.Diagnostics.EventLogEntryType> per l'evento da scrivere nel registro eventi. Il `type` è indicato dall'icona e il testo nella colonna di tipo nel Visualizzatore eventi per un log. Questo parametro indica se il tipo di evento è errore, avviso, informazioni, operazioni riuscite o controllo con esito negativo.  
  
 È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine. Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo scrive la stringa specificata direttamente nel registro eventi di; non usa un file di risorse localizzabili di messaggio. Usare il <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere eventi utilizzando un file di risorse messaggio localizzato.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se il `message` parametro contiene un carattere null, il messaggio nel registro eventi viene terminato in corrispondenza del carattere null.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore <paramref name="source" /> è una stringa vuota ("").  
  
\- oppure - 
Il valore di <paramref name="source" /> è <see langword="null" />.  
  
\- oppure - 
 <paramref name="eventID" /> è minore di zero o maggiore di <see cref="F:System.UInt16.MaxValue" />.  
  
\- oppure - 
La stringa del messaggio è maggiore di 31.839 byte (32.766 byte nei sistemi operativi Windows prima di Windows Vista).  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> non è un oggetto <see cref="T:System.Diagnostics.EventLogEntryType" /> valido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Stringa da scrivere nel registro eventi.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificatore specifico dell'applicazione per l'evento.</param>
        <param name="category">Sottocategoria specifica per l'applicazione associata al messaggio.</param>
        <param name="rawData">Matrice di byte contenente i dati binari associati alla voce.</param>
        <summary>Scrive nel registro eventi una voce con il testo del messaggio indicato, insieme a un identificatore eventi definito dall'applicazione e a una categoria definita dall'applicazione, e allega dati binari al messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per scrivere i dati specifici degli eventi definiti dall'applicazione nel registro eventi. Il Visualizzatore eventi non interpreta i dati; Visualizza i dati non elaborati solo in un formato esadecimale e testo combinato. Usare i dati specifici degli eventi con parsimonia, includerlo solo se si è certi che possa risultare utile a un utente di debug del problema. È anche possibile usare i dati specifici degli eventi per archiviare le informazioni che dell'applicazione può elaborare indipendentemente da Visualizzatore eventi. Ad esempio, si potrebbe scrivere un visualizzatore in modo specifico per gli eventi o scrivere un programma che cerca il file di log e crea report che includono informazioni dai dati specifici degli eventi.  
  
 Oltre ai dati binari, è possibile specificare una categoria definita dall'applicazione e un identificatore eventi definito dall'applicazione. Il Visualizzatore eventi utilizza la categoria per filtrare gli eventi scritti da un'origine evento. Il Visualizzatore eventi consente di visualizzare la categoria come valore numerico oppure è possibile usare la categoria come identificatore di risorsa per visualizzare una stringa di categoria localizzata.  
  
> [!NOTE]
>  Il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
> [!NOTE]
>  Il `category` parametro deve essere un valore positivo. I valori di categoria negativi vengono visualizzati come un numero positivo complemento nell'evento visualizzatore. – 10, ad esempio, viene visualizzato come 65,526, – 1 come 65.535.  
  
 Per visualizzare le stringhe di categoria localizzata nel Visualizzatore eventi, è necessario usare un'origine evento configurato con un file di risorse di categoria e impostare il `category` a un identificatore di risorsa nel file di risorse della categoria. Se l'origine evento non dispone di un file di risorse di categoria configurati o specificato `category` indicizza una stringa nel file di risorse di categoria, nel Visualizzatore eventi viene visualizzato il valore della categoria numerica per la voce. Configurare il file di risorse di categoria, oltre al numero di stringhe di categoria nel file di risorse, usando il <xref:System.Diagnostics.EventLogInstaller> o il <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Identificatori di eventi, insieme all'origine evento, identificano in modo univoco un evento. Ogni applicazione può definire i propri eventi numerati e le stringhe di descrizione alle quali vengono mappati. I visualizzatori eventi visualizzati questi valori stringa per consentire all'utente di comprendere la causa dell'errore e suggerire le azioni da intraprendere.  
  
 Infine, è possibile specificare un <xref:System.Diagnostics.EventLogEntryType> per l'evento da scrivere nel registro eventi. Il `type` è indicato dall'icona e il testo nella colonna di tipo nel Visualizzatore eventi per un log. Questo parametro indica se il tipo di evento è errore, avviso, informazioni, operazioni riuscite o controllo con esito negativo.  
  
 È necessario impostare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà di <xref:System.Diagnostics.EventLog> componente prima di poter scrivere voci nel log. È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine.  
  
 Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 Se l'origine specificata nel <xref:System.Diagnostics.EventLog.Source%2A> proprietà di questo <xref:System.Diagnostics.EventLog> istanza non è registrata nel computer in cui il componente sta scrivendo <xref:System.Diagnostics.EventLog.WriteEntry%2A> chiamate <xref:System.Diagnostics.EventLog.CreateEventSource%2A> e registra l'origine.  
  
> [!NOTE]
>  Se non si specifica un <xref:System.Diagnostics.EventLog.MachineName%2A> per il <xref:System.Diagnostics.EventLog> istanza prima di chiamare <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, il computer locale (".") si presuppone che.  
  
 Se il sistema deve registrare il <xref:System.Diagnostics.EventLog.Source%2A> tramite una chiamata a <xref:System.Diagnostics.EventLog.WriteEntry%2A> e il <xref:System.Diagnostics.EventLog.Log%2A> proprietà non è stata impostata sul <xref:System.Diagnostics.EventLog> per impostazione predefinita il log di istanza, nel registro applicazioni.  
  
> [!NOTE]
>  Molte eccezioni elencate in precedenza vengono generate da errori generati durante il processo di registrazione di <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo scrive la stringa specificata direttamente nel registro eventi di; non usa un file di risorse localizzabili di messaggio. Usare il <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere eventi utilizzando un file di risorse messaggio localizzato.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se si scrive una voce in un computer remoto, il valore del messaggio (stringa di testo) potrebbe non essere quelli previsti se il computer remoto non è in esecuzione in .NET Framework.  
  
> [!NOTE]
>  Se il `message` parametro contiene un carattere null, il messaggio nel registro eventi viene terminato in corrispondenza del carattere null.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Diagnostics.EventLog.Source" /> dell'oggetto <see cref="T:System.Diagnostics.EventLog" /> non è stata impostata.  
  
oppure 
Il metodo ha tentato di registrare una nuova origine eventi, ma il nome del computer in <see cref="P:System.Diagnostics.EventLog.MachineName" /> non è valido.  
  
\- oppure - 
L'origine è già registrata con un log eventi diverso.  
  
\- oppure - 
 <paramref name="eventID" /> è minore di zero o maggiore di <see cref="F:System.UInt16.MaxValue" />.  
  
\- oppure - 
La stringa del messaggio è maggiore di 31.839 byte (32.766 byte nei sistemi operativi Windows prima di Windows Vista).  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> non è un oggetto <see cref="T:System.Diagnostics.EventLogEntryType" /> valido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Origine con cui l'applicazione è registrata nel computer specificato.</param>
        <param name="message">Stringa da scrivere nel registro eventi.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificatore specifico dell'applicazione per l'evento.</param>
        <param name="category">Sottocategoria specifica per l'applicazione associata al messaggio.</param>
        <summary>Scrive nel registro eventi una voce con il testo del messaggio indicato, insieme a un identificatore eventi definito dall'applicazione e a una categoria definita dall'applicazione, usando l'origine eventi registrata specificata. Il parametro <paramref name="category" /> può essere usato dal Visualizzatore eventi per filtrare gli eventi nel registro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce con un parametro definito dall'applicazione `category` nel registro eventi, utilizzare un'origine che è già registrata come un'origine evento per il log appropriato. Il Visualizzatore eventi utilizza la categoria per filtrare gli eventi scritti da un'origine evento. Il Visualizzatore eventi consente di visualizzare la categoria come valore numerico oppure è possibile usare la categoria come identificatore di risorsa per visualizzare una stringa di categoria localizzata.  
  
> [!NOTE]
>  Il `category` parametro deve essere un valore positivo. I valori di categoria negativi vengono visualizzati come un numero positivo complemento nell'evento visualizzatore. – 10, ad esempio, viene visualizzato come 65,526, – 1 come 65.535.  
  
 Per visualizzare le stringhe di categoria localizzata nel Visualizzatore eventi, è necessario usare un'origine evento configurato con un file di risorse di categoria e impostare il `category` a un identificatore di risorsa nel file di risorse della categoria. Se l'origine evento non dispone di un file di risorse di categoria configurati o specificato `category` indicizza una stringa nel file di risorse di categoria, nel Visualizzatore eventi viene visualizzato il valore della categoria numerica per la voce. Configurare il file di risorse di categoria, oltre al numero di stringhe di categoria nel file di risorse, usando il <xref:System.Diagnostics.EventLogInstaller> o il <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Oltre a categoria, è possibile specificare un identificatore di evento per l'evento da scrivere nel registro eventi. Identificatori di eventi, insieme all'origine evento, identificano in modo univoco un evento. Ogni applicazione può definire i propri eventi numerati e le stringhe di descrizione alle quali vengono mappati. I visualizzatori eventi visualizzati questi valori stringa per consentire all'utente di comprendere la causa dell'errore e suggerire le azioni da intraprendere.  
  
 Infine, è possibile specificare un <xref:System.Diagnostics.EventLogEntryType> per l'evento da scrivere nel registro eventi. Il `type` è indicato dall'icona e il testo nella colonna di tipo nel Visualizzatore eventi per un log. Questo parametro indica se il tipo di evento è errore, avviso, informazioni, operazioni riuscite o controllo con esito negativo.  
  
 È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine. Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo scrive la stringa specificata direttamente nel registro eventi di; non usa un file di risorse localizzabili di messaggio. Usare il <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere eventi utilizzando un file di risorse messaggio localizzato.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se il `message` parametro contiene un carattere null, il messaggio nel registro eventi viene terminato in corrispondenza del carattere null.  
>   
>  Il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore <paramref name="source" /> è una stringa vuota ("").  
  
\- oppure - 
Il valore di <paramref name="source" /> è <see langword="null" />.  
  
\- oppure - 
 <paramref name="eventID" /> è minore di zero o maggiore di <see cref="F:System.UInt16.MaxValue" />.  
  
\- oppure - 
La stringa del messaggio è maggiore di 31.839 byte (32.766 byte nei sistemi operativi Windows prima di Windows Vista).  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> non è un oggetto <see cref="T:System.Diagnostics.EventLogEntryType" /> valido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Origine con cui l'applicazione è registrata nel computer specificato.</param>
        <param name="message">Stringa da scrivere nel registro eventi.</param>
        <param name="type">Uno dei valori di <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificatore specifico dell'applicazione per l'evento.</param>
        <param name="category">Sottocategoria specifica per l'applicazione associata al messaggio.</param>
        <param name="rawData">Matrice di byte contenente i dati binari associati alla voce.</param>
        <summary>Scrive nel registro eventi una voce con il testo del messaggio indicato, insieme a un identificatore eventi definito dall'applicazione e a una categoria definita dall'applicazione, usando l'origine eventi registrata specificata, e allega dati binari al messaggio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere dati specifici degli eventi definiti dall'applicazione nel registro eventi, utilizzare un'origine già registrata come un'origine evento per il log appropriato. Il Visualizzatore eventi non interpreta i dati; Visualizza i dati non elaborati solo in un formato esadecimale e testo combinato. Usare i dati specifici degli eventi sporadicamente; incluso solo se si è certi che possa risultare utile. È anche possibile usare i dati specifici degli eventi per archiviare le informazioni che dell'applicazione può elaborare indipendentemente da Visualizzatore eventi. Ad esempio, si potrebbe scrivere un visualizzatore in modo specifico per gli eventi o scrivere un programma che cerca il file di log e crea report che includono informazioni dai dati specifici degli eventi.  
  
 Oltre ai dati binari, è possibile specificare una categoria definita dall'applicazione e un identificatore eventi definito dall'applicazione. Il Visualizzatore eventi utilizza la categoria per filtrare gli eventi scritti da un'origine evento. Il Visualizzatore eventi consente di visualizzare la categoria come valore numerico oppure è possibile usare la categoria come identificatore di risorsa per visualizzare una stringa di categoria localizzata.  
  
> [!NOTE]
>  Il `category` parametro deve essere un valore positivo. I valori di categoria negativi vengono visualizzati come un numero positivo complemento nell'evento visualizzatore. – 10, ad esempio, verrà visualizzato come 65,526, – 1 come 65.535.  
  
 Per visualizzare le stringhe di categoria localizzata nel Visualizzatore eventi, è necessario usare un'origine evento configurato con un file di risorse di categoria e impostare il `category` a un identificatore di risorsa nel file di risorse della categoria. Se l'origine evento non dispone di un file di risorse di categoria configurati o specificato `category` indicizza una stringa nel file di risorse di categoria, nel Visualizzatore eventi viene visualizzato il valore della categoria numerica per la voce. Configurare il file di risorse di categoria, oltre al numero di stringhe di categoria nel file di risorse, usando il <xref:System.Diagnostics.EventLogInstaller> o il <xref:System.Diagnostics.EventSourceCreationData> classe.  
  
 Gli identificatori di evento, con l'origine evento, identificano in modo univoco un evento. Ogni applicazione può definire i propri eventi numerati e le stringhe di descrizione alle quali vengono mappati. I visualizzatori eventi visualizzati questi valori stringa per consentire all'utente di comprendere la causa dell'errore e suggerire le azioni da intraprendere.  
  
 Infine, è possibile specificare un <xref:System.Diagnostics.EventLogEntryType> per l'evento da scrivere nel registro eventi. Il `type` è indicato dall'icona e il testo nella colonna di tipo nel Visualizzatore eventi per un log. Questo parametro indica se il tipo di evento è errore, avviso, informazioni, operazioni riuscite o controllo con esito negativo.  
  
 È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine. Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo scrive la stringa specificata direttamente nel registro eventi di; non usa un file di risorse localizzabili di messaggio. Usare il <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere eventi utilizzando un file di risorse messaggio localizzato.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se il `message` parametro contiene un carattere null, il messaggio nel registro eventi viene terminato in corrispondenza del carattere null.  
>   
>  Il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore <paramref name="source" /> è una stringa vuota ("").  
  
\- oppure - 
Il valore di <paramref name="source" /> è <see langword="null" />.  
  
\- oppure - 
 <paramref name="eventID" /> è minore di zero o maggiore di <see cref="F:System.UInt16.MaxValue" />.  
  
\- oppure - 
La stringa del messaggio è maggiore di 31.839 byte (32.766 byte nei sistemi operativi Windows prima di Windows Vista).  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> non è un oggetto <see cref="T:System.Diagnostics.EventLogEntryType" /> valido.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive una voce di evento localizzata nel registro eventi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Istanza <see cref="T:System.Diagnostics.EventInstance" /> che rappresenta una voce del registro eventi localizzata.</param>
        <param name="values">Matrice di stringhe per il merge della voce del registro eventi nel testo del messaggio.</param>
        <summary>Scrive una voce localizzata nel registro eventi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce localizzata nel registro eventi. Specificare le proprietà dell'evento con identificatori di risorsa, anziché i valori stringa. Il Visualizzatore eventi Usa gli identificatori di risorsa per visualizzare le stringhe corrispondenti dal file di risorse localizzate per le <xref:System.Diagnostics.EventLog.Source%2A>. Prima di scrivere eventi usando gli identificatori di risorsa, è necessario registrare l'origine con il corrispondente file di risorse.  
  
 L'input `instance` istanza specifica il messaggio di evento e le proprietà. Impostare il <xref:System.Diagnostics.EventInstance.InstanceId%2A> del `instance` di input per il messaggio definito nel file di risorse del messaggio di origine. È anche possibile impostare il <xref:System.Diagnostics.EventInstance.CategoryId%2A> e <xref:System.Diagnostics.EventInstance.EntryType%2A> del `instance` input per definire il tipo di categoria ed evento della voce di evento. È anche possibile specificare una matrice di stringhe indipendenti dal linguaggio da inserire nel testo del messaggio. Impostare `values` a `null` se il messaggio di evento non contiene segnaposto di formattazione per le stringhe di sostituzione.  
  
 È necessario impostare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà di <xref:System.Diagnostics.EventLog> componente prima di usare <xref:System.Diagnostics.EventLog.WriteEvent%2A>. L'origine specificata deve essere configurato per la scrittura di voci localizzate per il log. l'origine deve avere almeno un file di risorse di messaggio definito.  
  
 È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine. Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Usare il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo, se l'applicazione scrive i valori stringa direttamente il registro eventi.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se si scrive una voce per un computer remoto, il valore della `message` stringa potrebbe non essere quelli previsti se il computer remoto non è in esecuzione in .NET Framework. Inoltre, il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
   
  
## Examples  
 L'esempio seguente scrive due voci nel registro eventi di controllo `myNewLog`. L'esempio crea una nuova origine evento e un nuovo registro eventi se non esistono nel computer locale. Il testo del messaggio di evento è specificato utilizzando un identificatore di risorsa in un file di risorse.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 L'esempio Usa il file di testo di messaggio seguente, generato nella libreria di risorse EventLogMsgs. Un file di testo del messaggio è l'origine da cui viene creato il file di risorse del messaggio. Il file di testo del messaggio definisce gli identificatori di risorsa e il testo per la categoria, messaggio di evento e le stringhe di inserimento di parametro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Diagnostics.EventLog.Source" /> dell'oggetto <see cref="T:System.Diagnostics.EventLog" /> non è stata impostata.  
  
oppure 
Il metodo ha tentato di registrare una nuova origine eventi, ma il nome del computer in <see cref="P:System.Diagnostics.EventLog.MachineName" /> non è valido.  
  
\- oppure - 
L'origine è già registrata con un log eventi diverso.  
  
\- oppure - 
 <paramref name="instance.InstanceId" /> è minore di zero o maggiore di <see cref="F:System.UInt16.MaxValue" />.  
  
\- oppure - 
 <paramref name="values" /> presenta più di 256 elementi.  
  
\- oppure - 
Uno degli elementi di <paramref name="values" /> presenta una lunghezza superiore a 32766 byte.  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Istanza <see cref="T:System.Diagnostics.EventInstance" /> che rappresenta una voce del registro eventi localizzata.</param>
        <param name="data">Matrice di byte contenente i dati binari associati alla voce.</param>
        <param name="values">Matrice di stringhe per il merge della voce del registro eventi nel testo del messaggio.</param>
        <summary>Scrive una voce di registro eventi con i dati dell'evento specifici, le stringhe di sostituzione del messaggio e i dati binari associati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce localizzata con dati aggiuntivi specifici degli eventi nel registro eventi. Specificare le proprietà dell'evento con identificatori di risorsa, anziché i valori stringa. Il Visualizzatore eventi Usa gli identificatori di risorsa per visualizzare le stringhe corrispondenti dal file di risorse localizzate per le <xref:System.Diagnostics.EventLog.Source%2A>. Prima di scrivere eventi usando gli identificatori di risorsa, è necessario registrare l'origine con il corrispondente file di risorse.  
  
 L'input `instance` istanza specifica il messaggio di evento e le proprietà. Impostare il <xref:System.Diagnostics.EventInstance.InstanceId%2A> del `instance` di input per il messaggio definito nel file di risorse del messaggio di origine. È anche possibile impostare il <xref:System.Diagnostics.EventInstance.CategoryId%2A> e <xref:System.Diagnostics.EventInstance.EntryType%2A> del `instance` input per definire il tipo di categoria ed evento della voce di evento. È anche possibile specificare una matrice di stringhe indipendenti dal linguaggio da inserire nel testo del messaggio. Impostare `values` a `null` se il messaggio di evento non contiene segnaposto di formattazione per le stringhe di sostituzione.  
  
 Specificare i dati binari con un evento quando è necessario fornire dettagli aggiuntivi per l'evento. Ad esempio, usare il `data` parametro per includere informazioni su un errore specifico. Il Visualizzatore eventi non interpreta i dati dell'evento associato; Visualizza i dati in un formato esadecimale e testo combinato. Usare i dati specifici degli eventi sporadicamente; incluso solo se si è certi che possa risultare utile. È anche possibile usare i dati specifici degli eventi per archiviare le informazioni che dell'applicazione può elaborare indipendentemente da Visualizzatore eventi. Ad esempio, si potrebbe scrivere un visualizzatore in modo specifico per gli eventi o scrivere un programma che cerca nel registro eventi e consente di creare report che includono le informazioni dai dati specifici degli eventi.  
  
 È necessario impostare il <xref:System.Diagnostics.EventLog.Source%2A> proprietà di <xref:System.Diagnostics.EventLog> componente prima del componente prima di usare <xref:System.Diagnostics.EventLog.WriteEvent%2A>. L'origine specificata deve essere configurato per la scrittura di voci localizzate per il log. l'origine deve avere almeno un file di risorse di messaggio definito.  
  
 È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine. Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
> [!NOTE]
>  Se non si specifica un <xref:System.Diagnostics.EventLog.MachineName%2A> per il <xref:System.Diagnostics.EventLog> istanza prima di chiamare <xref:System.Diagnostics.EventLog.WriteEvent%2A>, il computer locale (".") si presuppone che.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Usare il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo, se l'applicazione scrive i valori stringa direttamente il registro eventi.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
> [!NOTE]
>  Se si scrive una voce per un computer remoto, il valore della `message` stringa potrebbe non essere quelli previsti se il computer remoto non è in esecuzione in .NET Framework. Inoltre, il `message` stringa non può contenere %*n*, dove *n* è un valore intero (ad esempio, %1), in quanto lo considera come una stringa di inserimento nel Visualizzatore eventi. Poiché un protocollo Internet versione 6 (IPv6) indirizzo può contenere questa sequenza di caratteri, non è possibile accedere un messaggio di evento che contiene un indirizzo IPv6.  
  
   
  
## Examples  
 L'esempio seguente scrive due voci nel registro eventi di controllo `myNewLog`. L'esempio crea una nuova origine evento e un nuovo registro eventi se non esistono nel computer locale. Il testo del messaggio di evento è specificato utilizzando un identificatore di risorsa in un file di risorse.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 L'esempio Usa il file di testo di messaggio seguente, generato nella libreria di risorse EventLogMsgs. Un file di testo del messaggio è l'origine da cui viene creato il file di risorse del messaggio. Il file di testo del messaggio definisce gli identificatori di risorsa e il testo per la categoria, messaggio di evento e le stringhe di inserimento di parametro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Diagnostics.EventLog.Source" /> dell'oggetto <see cref="T:System.Diagnostics.EventLog" /> non è stata impostata.  
  
oppure 
Il metodo ha tentato di registrare una nuova origine eventi, ma il nome del computer in <see cref="P:System.Diagnostics.EventLog.MachineName" /> non è valido.  
  
\- oppure - 
L'origine è già registrata con un log eventi diverso.  
  
\- oppure - 
 <paramref name="instance.InstanceId" /> è minore di zero o maggiore di <see cref="F:System.UInt16.MaxValue" />.  
  
\- oppure - 
 <paramref name="values" /> presenta più di 256 elementi.  
  
\- oppure - 
Uno degli elementi di <paramref name="values" /> presenta una lunghezza superiore a 32766 byte.  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nome dell'origine eventi registrata per l'applicazione nel computer specificato.</param>
        <param name="instance">Istanza <see cref="T:System.Diagnostics.EventInstance" /> che rappresenta una voce del registro eventi localizzata.</param>
        <param name="values">Matrice di stringhe per il merge della voce del registro eventi nel testo del messaggio.</param>
        <summary>Scrive una voce di registro eventi con i dati dell'evento specifici e le stringhe di sostituzione del messaggio, usando l'origine eventi registrata specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per scrivere una voce localizzata nel registro eventi, utilizzare un'origine già registrata come un'origine evento per il log appropriato. Specificare le proprietà dell'evento con identificatori di risorsa, anziché i valori stringa. Il Visualizzatore eventi Usa gli identificatori di risorsa per visualizzare le stringhe corrispondenti dal file di risorse localizzate per l'origine. Prima di scrivere eventi usando gli identificatori di risorsa, è necessario registrare l'origine con il corrispondente file di risorse.  
  
 L'input `instance` istanza specifica il messaggio di evento e le proprietà. Impostare il <xref:System.Diagnostics.EventInstance.InstanceId%2A> del `instance` di input per il messaggio definito nel file di risorse del messaggio di origine. È anche possibile impostare il <xref:System.Diagnostics.EventInstance.CategoryId%2A> e <xref:System.Diagnostics.EventInstance.EntryType%2A> del `instance` input per definire il tipo di categoria ed evento della voce di evento. È anche possibile specificare una matrice di stringhe indipendenti dal linguaggio da inserire nel testo del messaggio. Impostare `values` a `null` se il messaggio di evento non contiene segnaposto di formattazione per le stringhe di sostituzione.  
  
 L'origine specificata deve essere registrato per un log eventi prima di usare <xref:System.Diagnostics.EventLog.WriteEvent%2A>. L'origine specificata deve essere configurato per la scrittura di voci localizzate per il log. l'origine deve avere almeno un file di risorse di messaggio definito.  
  
 È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine. Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Usare il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo, se l'applicazione scrive i valori stringa direttamente il registro eventi.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
   
  
## Examples  
 L'esempio seguente scrive una voce di evento di tipo informativo e una voce di evento di avviso in un log eventi esistente. Il testo del messaggio di evento è specificato utilizzando un identificatore di risorsa in un file di risorse. Nell'esempio si presuppone che il corrispondente file di risorse è stato registrato per l'origine.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 L'esempio Usa il file di testo di messaggio seguente, generato nella libreria di risorse EventLogMsgs. Un file di testo del messaggio è l'origine da cui viene creato il file di risorse del messaggio. Il file di testo del messaggio definisce gli identificatori di risorsa e il testo per la categoria, messaggio di evento e le stringhe di inserimento di parametro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore <paramref name="source" /> è una stringa vuota ("").  
  
\- oppure - 
Il valore di <paramref name="source" /> è <see langword="null" />.  
  
\- oppure - 
 <paramref name="instance.InstanceId" /> è minore di zero o maggiore di <see cref="F:System.UInt16.MaxValue" />.  
  
\- oppure - 
 <paramref name="values" /> presenta più di 256 elementi.  
  
\- oppure - 
Uno degli elementi di <paramref name="values" /> presenta una lunghezza superiore a 32766 byte.  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nome dell'origine eventi registrata per l'applicazione nel computer specificato.</param>
        <param name="instance">Istanza <see cref="T:System.Diagnostics.EventInstance" /> che rappresenta una voce del registro eventi localizzata.</param>
        <param name="data">Matrice di byte contenente i dati binari associati alla voce.</param>
        <param name="values">Matrice di stringhe per il merge della voce del registro eventi nel testo del messaggio.</param>
        <summary>Scrive una voce di registro eventi con i dati dell'evento specifici, le stringhe di sostituzione del messaggio e i dati binari associati, usando l'origine eventi registrata specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per scrivere una voce localizzata con dati aggiuntivi specifici degli eventi nel registro eventi, utilizzare un'origine già registrata come un'origine evento per il log appropriato. Specificare le proprietà dell'evento con identificatori di risorsa, anziché i valori stringa. Il Visualizzatore eventi Usa gli identificatori di risorsa per visualizzare le stringhe corrispondenti dal file di risorse localizzate per l'origine. Prima di scrivere eventi usando gli identificatori di risorsa, è necessario registrare l'origine con il corrispondente file di risorse.  
  
 L'input `instance` istanza specifica il messaggio di evento e le proprietà. Impostare il <xref:System.Diagnostics.EventInstance.InstanceId%2A> del `instance` di input per il messaggio definito nel file di risorse del messaggio di origine. È anche possibile impostare il <xref:System.Diagnostics.EventInstance.CategoryId%2A> e <xref:System.Diagnostics.EventInstance.EntryType%2A> del `instance` input per definire il tipo di categoria ed evento della voce di evento. È anche possibile specificare una matrice di stringhe indipendenti dal linguaggio da inserire nel testo del messaggio. Impostare `values` a `null` se il messaggio di evento non contiene segnaposto di formattazione per le stringhe di sostituzione.  
  
 Specificare i dati binari con un evento quando è necessario fornire dettagli aggiuntivi per l'evento. Ad esempio, usare il `data` parametro per includere informazioni su un errore specifico. Il Visualizzatore eventi non interpreta i dati dell'evento associato; Visualizza i dati in un formato esadecimale e testo combinato. Usare i dati specifici degli eventi sporadicamente; incluso solo se si è certi che possa risultare utile. È anche possibile usare i dati specifici degli eventi per archiviare le informazioni che dell'applicazione può elaborare indipendentemente da Visualizzatore eventi. Ad esempio, si potrebbe scrivere un visualizzatore in modo specifico per gli eventi o scrivere un programma che cerca nel registro eventi e consente di creare report che includono le informazioni dai dati specifici degli eventi.  
  
 L'origine specificata deve essere registrato per un log eventi prima di usare <xref:System.Diagnostics.EventLog.WriteEvent%2A>. L'origine specificata deve essere configurato per la scrittura di voci localizzate per il log. l'origine deve avere almeno un file di risorse di messaggio definito.  
  
 È necessario creare e configurare l'origine evento prima di scrivere la prima voce con l'origine. Creare la nuova origine evento durante l'installazione dell'applicazione. In questo modo ora il sistema operativo aggiornare l'elenco delle origini degli eventi registrati e la relativa configurazione. Se il sistema operativo non è aggiornato l'elenco di origini evento e si tenta di scrivere un evento con la nuova origine, che l'operazione di scrittura avrà esito negativo. È possibile configurare una nuova origine usando un <xref:System.Diagnostics.EventLogInstaller>, o tramite il <xref:System.Diagnostics.EventLog.CreateEventSource%2A> (metodo). È necessario disporre dei diritti amministrativi nel computer per creare una nuova origine evento.  
  
 L'origine deve essere configurato per la scrittura di voci localizzate o per la scrittura di stringhe dirette. Usare il <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo, se l'applicazione scrive i valori stringa direttamente il registro eventi.  
  
 Se l'applicazione scrive le voci con identificatori di risorsa e i valori stringa, è necessario registrare due origini dati separate. Ad esempio, configurare un'origine dei file di risorse e quindi usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEvent%2A> metodo per scrivere voci usando gli identificatori di risorsa nel registro eventi. Quindi creare un'origine diversa senza i file di risorse e usare tale origine nel <xref:System.Diagnostics.EventLog.WriteEntry%2A> metodo per scrivere le stringhe direttamente il registro eventi usando tale origine.  
  
   
  
## Examples  
 L'esempio seguente scrive una voce di evento di tipo informativo e una voce di evento di avviso in un log eventi esistente. Il testo del messaggio di evento è specificato utilizzando un identificatore di risorsa in un file di risorse. Nell'esempio si presuppone che il corrispondente file di risorse è stato registrato per l'origine.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 L'esempio Usa il file di testo di messaggio seguente, generato nella libreria di risorse EventLogMsgs. Un file di testo del messaggio è l'origine da cui viene creato il file di risorse del messaggio. Il file di testo del messaggio definisce gli identificatori di risorsa e il testo per la categoria, messaggio di evento e le stringhe di inserimento di parametro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore <paramref name="source" /> è una stringa vuota ("").  
  
\- oppure - 
Il valore di <paramref name="source" /> è <see langword="null" />.  
  
\- oppure - 
 <paramref name="instance.InstanceId" /> è minore di zero o maggiore di <see cref="F:System.UInt16.MaxValue" />.  
  
\- oppure - 
 <paramref name="values" /> presenta più di 256 elementi.  
  
\- oppure - 
Uno degli elementi di <paramref name="values" /> presenta una lunghezza superiore a 32766 byte.  
  
\- oppure - 
A causa del nome origine una chiave del Registro di sistema risulta più lunga di 254 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile aprire la chiave del Registro di sistema per il log eventi.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">È stato riscontrato un errore durante la scrittura della voce di evento nel log eventi. Non è disponibile un codice di errore di Windows.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">per la scrittura di informazioni del log eventi nel computer. Enumerazione associata: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>