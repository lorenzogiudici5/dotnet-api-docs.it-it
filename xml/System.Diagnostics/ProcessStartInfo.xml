<Type Name="ProcessStartInfo" FullName="System.Diagnostics.ProcessStartInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c8f1ccd8bea734c57d532d5c8554d083d648c4f1" />
    <Meta Name="ms.sourcegitcommit" Value="22c9818dc4a11ae279d13a36bc98a3c6852e9316" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/20/2018" />
    <Meta Name="ms.locfileid" Value="39169330" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ProcessStartInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ProcessStartInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessStartInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ProcessStartInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessStartInfo sealed" />
  <TypeSignature Language="F#" Value="type ProcessStartInfo = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Specifica un insieme di valori usati all'avvio di un processo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessStartInfo> viene usata in combinazione con il <xref:System.Diagnostics.Process> componente. Quando si avvia un processo usando la <xref:System.Diagnostics.Process> (classe), si ha accesso a elaborare le informazioni oltre a quelle disponibili quando si collega a un processo in esecuzione.  
  
 È possibile usare il <xref:System.Diagnostics.ProcessStartInfo> classe per controllare meglio il processo si avvia. È necessario disporre almeno di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà, ad esempio manualmente o usando il costruttore. Il nome del file è qualsiasi applicazione o un documento. In questo caso un documento viene definito da qualsiasi tipo di file che ha aperto o associato azione predefinita. È possibile visualizzare i tipi di file registrati e le relative applicazioni associate per il computer locale usando il **Opzioni cartella** nella finestra di dialogo è disponibile tramite il sistema operativo. Il **avanzate** pulsante conduce a una finestra di dialogo che indica se è presente un'azione di apertura associata a un tipo specifico di file registrata.  
  
 Inoltre, è possibile impostare altre proprietà che definiscono le azioni da intraprendere con tale file. È possibile specificare un valore specifico per il tipo dei <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà per il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> proprietà. Ad esempio, è possibile specificare "print" per un tipo di documento. Inoltre, è possibile specificare <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> valori di proprietà argomenti della riga di comando da passare alla procedura di apertura del file. Ad esempio, se si specifica un'applicazione di editor di testo nel <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà, è possibile usare il <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> proprietà per specificare un file di testo per aprire l'editor.  
  
 L'input standard viene in genere la tastiera e output ed errore standard sono in genere lo schermo. Tuttavia, è possibile usare la <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, e <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> proprietà per fare in modo il processo ottenere l'input dall'o restituire l'output a un file o un altro dispositivo. Se si usa la <xref:System.Diagnostics.Process.StandardInput%2A>, <xref:System.Diagnostics.Process.StandardOutput%2A>, o <xref:System.Diagnostics.Process.StandardError%2A> delle proprietà nel <xref:System.Diagnostics.Process> componente, è necessario innanzitutto impostare il valore corrispondente nel <xref:System.Diagnostics.ProcessStartInfo> proprietà. In caso contrario, il sistema genera un'eccezione durante la lettura o scrittura nel flusso.  
  
 Impostare il <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> proprietà per specificare se si desidera avviare il processo usando la shell del sistema operativo. Se <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> è impostata su `false`, il nuovo processo eredita l'input standard, di output standard, e l'elaborano di flussi di errore standard del chiamante, a meno che non le <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, o <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> , rispettivamente, sono impostate su `true`. 
  
 È possibile modificare il valore di qualsiasi <xref:System.Diagnostics.ProcessStartInfo> proprietà fino al momento dell'avvio del processo. Dopo avere avviato il processo, la modifica di questi valori non ha alcun effetto.  
  
> [!NOTE]
>  Questa classe contiene una richiesta di collegamento a livello di classe che si applica a tutti i membri. Oggetto <xref:System.Security.SecurityException> viene generata quando il chiamante immediato non dispone dell'autorizzazione di attendibilità. Per informazioni dettagliate sui requisiti di sicurezza, vedere [richieste di collegamento](~/docs/framework/misc/link-demands.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Diagnostics.ProcessStartInfo> classe avviare Internet Explorer, fornendo gli URL di destinazione come <xref:System.Diagnostics.ProcessStartInfo> argomenti.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare i membri di <see cref="T:System.Diagnostics.ProcessStartInfo" />. Valore richiesta: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; [NIB: set di autorizzazioni denominati](http://msdn.microsoft.com/library/08250d67-c99d-4ab0-8d2b-b0e12019f6e3): <see langword="FullTrust" />.</permission>
    <altmember cref="T:System.Diagnostics.Process" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.ProcessStartInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.ProcessStartInfo" /> senza specificare un nome file con il quale avviare il processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario impostare almeno le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà prima di iniziare il processo. Il nome del file è qualsiasi applicazione o un documento. In questo caso, un documento viene definito da qualsiasi tipo di file che ha aperto o associato azione predefinita. È possibile visualizzare i tipi di file registrati e le relative applicazioni associate per il computer locale usando il **Opzioni cartella** nella finestra di dialogo è disponibile tramite il sistema operativo. Il **avanzate** pulsante conduce a una finestra di dialogo che indica se è presente un'azione di apertura associata a un tipo specifico di file registrata.  
  
 Facoltativamente, è possibile anche impostare altre proprietà prima di iniziare il processo. Il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> proprietà fornisce le azioni da intraprendere, ad esempio "print", con il file indicato nel <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà. Il <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> proprietà fornisce un modo per passare gli argomenti della riga di comando per il file quando viene aperto il sistema.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.ProcessStartInfo : string -&gt; System.Diagnostics.ProcessStartInfo" Usage="new System.Diagnostics.ProcessStartInfo fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Un'applicazione o un documento con il quale avviare un processo.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.ProcessStartInfo" /> e specifica un nome file, ad esempio un'applicazione o un documento, con il quale avviare il processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il nome del file è qualsiasi applicazione o un documento. In questo caso, un documento viene definito da qualsiasi tipo di file che ha aperto o associato azione predefinita. È possibile visualizzare i tipi di file registrati e le relative applicazioni associate per il computer locale usando il **Opzioni cartella** nella finestra di dialogo è disponibile tramite il sistema operativo. Il **avanzate** pulsante conduce a una finestra di dialogo che indica se è presente un'azione di apertura associata a un tipo specifico di file registrata.  
  
 È possibile modificare il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà dopo aver chiamato questo costruttore, fino al momento dell'avvio del processo. Dopo avere avviato il processo, la modifica di questi valori non ha alcun effetto.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, arguments As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.ProcessStartInfo : string * string -&gt; System.Diagnostics.ProcessStartInfo" Usage="new System.Diagnostics.ProcessStartInfo (fileName, arguments)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Un'applicazione con la quale avviare un processo.</param>
        <param name="arguments">Argomenti della riga di comando da passare all'applicazione all'avvio del processo.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.ProcessStartInfo" />, specifica il nome file di un'applicazione con cui avviare il processo e determina un insieme di argomenti della riga di comando da passare all'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il nome del file è qualsiasi applicazione o un documento. In questo caso, un documento viene definito da qualsiasi tipo di file che ha aperto o associato azione predefinita. È possibile visualizzare i tipi di file registrati e le relative applicazioni associate per il computer locale usando il **Opzioni cartella** nella finestra di dialogo è disponibile tramite il sistema operativo. Il **avanzate** pulsante conduce a una finestra di dialogo che indica se è presente un'azione di apertura associata a un tipo specifico di file registrata.  
  
 È possibile modificare il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> o <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> proprietà dopo aver chiamato questo costruttore, fino al momento dell'avvio del processo. Dopo avere avviato il processo, la modifica di questi valori non ha alcun effetto.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per un'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="ArgumentList">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; ArgumentList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; ArgumentList" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ArgumentList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArgumentList As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ ArgumentList { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ArgumentList : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.Diagnostics.ProcessStartInfo.ArgumentList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arguments">
      <MemberSignature Language="C#" Value="public string Arguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Arguments" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Arguments" />
      <MemberSignature Language="VB.NET" Value="Public Property Arguments As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Arguments { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Arguments : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Arguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Command line arguments that will be passed to the application specified by the FileName property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'insieme di argomenti della riga di comando da usare all'avvio dell'applicazione.</summary>
        <value>Una singola stringa contenente gli argomenti da passare all'applicazione di destinazione specificata nella proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />. Il valore predefinito è una stringa vuota (""). In Windows Vista e nelle versioni precedenti del sistema operativo Windows, la lunghezza degli argomenti aggiunta alla lunghezza del percorso completo del processo deve essere minore di 2080. In Windows 7 e versioni successive la lunghezza deve essere minore di 32699.  Gli argomenti vengono analizzati e interpretati dall'applicazione di destinazione, pertanto devono essere allineati con le aspettative dell'applicazione. Per le applicazioni .NET, come illustrato negli esempi seguenti, gli spazi vengono interpretati come un separatore tra più argomenti. Un singolo argomento che include spazi deve essere racchiuso tra virgolette, ma tali virgolette non vengono riportate nell'applicazione di destinazione. Nelle virgolette incluse nell'argomento analizzato finale, aggiungere tre caratteri di escape a ogni virgoletta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il primo esempio riportato di seguito viene creata una piccola applicazione (argsecho.exe) che restituisce gli argomenti nella console. Nel secondo esempio viene creata un'applicazione che richiama argsecho.exe per illustrare diverse varianti per la proprietà di argomenti.  
  
 [!code-cpp[Process.Start_static#3](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#3)]
 [!code-csharp[Process.Start_static#3](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#3)]
 [!code-vb[Process.Start_static#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#3)]  
  
 [!code-cpp[Process.Start_static#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#2)]
 [!code-csharp[Process.Start_static#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#2)]
 [!code-vb[Process.Start_static#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNoWindow">
      <MemberSignature Language="C#" Value="public bool CreateNoWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CreateNoWindow" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.CreateNoWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property CreateNoWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CreateNoWindow { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CreateNoWindow : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.CreateNoWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to start the process without creating a new window to contain it.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se avviare il processo in una nuova finestra.</summary>
        <value>
          <see langword="true" /> se il processo deve essere avviato senza creare una nuova finestra; in caso contrario, <see langword="false" /> . Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se le proprietà <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> è `true` o se le proprietà <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A> non sono `null`, il valore della proprietà <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> viene ignorato e viene creata una nuova finestra.  

 .NET core non supporta la creazione di windows direttamente su piattaforme simili a Unix, tra cui macOS e Linux. Questa proprietà viene ignorata in tali piattaforme.
  
   
  
## Examples  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che identifica il dominio da usare all'avvio del processo. Se questo valore è <see langword="null" />, la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> deve essere specificata in formato UPN.</summary>
        <value>Il dominio di Active Directory da usare all'avvio del processo. Se questo valore è <see langword="null" />, la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> deve essere specificata in formato UPN.</value>
        <remarks>Questa proprietà è principalmente di interesse per gli utenti all'interno di ambienti aziendali che usano Active Directory.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Environment">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; Environment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; Environment" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Environment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Environment As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ Environment { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Environment : System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="System.Diagnostics.ProcessStartInfo.Environment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le variabili di ambiente applicabili al processo e ai processi figlio.</summary>
        <value>Dizionario generico che contiene le variabili di ambiente applicabili al processo e ai processi figlio. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le variabili di ambiente contengono i percorsi di ricerca di file, le directory dei file temporanei, le opzioni specifiche dell'applicazione e altre informazioni simili. Anche se non è possibile impostare direttamente il <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> proprietà, è possibile modificare il dizionario generico restituito dalla proprietà. Ad esempio, il codice seguente aggiunge una variabile di ambiente TempPath: `myProcess.StartInfo.Environment.Add("TempPath", "C:\\Temp")`.  È necessario impostare il <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> proprietà `false` per avviare il processo dopo aver modificato il <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> proprietà. Se <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true`, un <xref:System.InvalidOperationException> generata quando il <xref:System.Diagnostics.Process.Start%2A> viene chiamato il metodo.  
  
 Nelle applicazioni .NET Framework, tramite il <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> proprietà è simile all'utilizzo di <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="EnvironmentVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.StringDictionary EnvironmentVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.StringDictionary EnvironmentVariables" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnvironmentVariables As StringDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::StringDictionary ^ EnvironmentVariables { System::Collections::Specialized::StringDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnvironmentVariables : System.Collections.Specialized.StringDictionary" Usage="System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.StringDictionaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Set of environment variables that apply to this process and child processes.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.StringDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i percorsi di ricerca dei file, le directory dei file temporanei, le opzioni specifiche delle applicazioni e altre informazioni simili.</summary>
        <value>Dizionario di stringhe che fornisce le variabili di ambiente applicabili a questo processo e ai processi figlio. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se non è possibile impostare il <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> proprietà, è possibile modificare il <xref:System.Collections.Specialized.StringDictionary> restituito dalla proprietà. Ad esempio, il codice seguente aggiunge una variabile di ambiente TempPath: `myProcess.StartInfo.EnvironmentVariables.Add("TempPath", "C:\\Temp")`.  È necessario impostare il <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> proprietà `false` per avviare il processo dopo aver modificato il <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> proprietà. Se <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true`, un <xref:System.InvalidOperationException> generata quando il <xref:System.Diagnostics.Process.Start%2A> viene chiamato il metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorDialog">
      <MemberSignature Language="C#" Value="public bool ErrorDialog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ErrorDialog" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ErrorDialog" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorDialog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ErrorDialog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorDialog : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.ErrorDialog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to show an error dialog to the user if there is an error.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se viene visualizzata una finestra di dialogo di errore all'utente quando il processo non può essere avviato.</summary>
        <value>
          <see langword="true" /> per visualizzare una finestra di dialogo di errore sullo schermo quando il processo non può essere avviato; in caso contrario, <see langword="false" /> . Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> deve essere `true` se si impostano <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> a `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorDialogParentHandle">
      <MemberSignature Language="C#" Value="public IntPtr ErrorDialogParentHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ErrorDialogParentHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorDialogParentHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ErrorDialogParentHandle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorDialogParentHandle : nativeint with get, set" Usage="System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'handle della finestra da usare quando viene visualizzata una finestra di dialogo di errore per un processo che non può essere avviato.</summary>
        <value>Puntatore all'handle della finestra di dialogo di errore che risulta da un errore di avvio del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> viene `true`, il <xref:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle%2A> proprietà specifica la finestra padre della finestra di dialogo visualizzata. È utile specificare un elemento padre per mantenere la finestra di dialogo prima dell'applicazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FileName">
      <MemberSignature Language="C#" Value="public string FileName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.FileName" />
      <MemberSignature Language="VB.NET" Value="Public Property FileName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FileName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FileName : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.FileName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.StartFileNameEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the application, document or URL to start.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'applicazione o il documento da avviare.</summary>
        <value>Il nome dell'applicazione da avviare oppure il nome di un documento di un tipo di file associato a un'applicazione con un'azione Open predefinita. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario impostare almeno le <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà prima di iniziare il processo. Il nome del file è qualsiasi applicazione o un documento. Un documento viene definito per essere di qualsiasi tipo di file che ha aperto o associato azione predefinita. È possibile visualizzare i tipi di file registrati e le relative applicazioni associate per il computer locale usando il **Opzioni cartella** nella finestra di dialogo è disponibile tramite il sistema operativo. Il **avanzate** pulsante conduce a una finestra di dialogo che indica se è presente un'azione di apertura associata a un tipo specifico di file registrata.  
  
 Il set di tipi di file disponibili dipende in parte sul valore della <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> proprietà. Se <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true`, è possibile avviare qualsiasi documento ed eseguire operazioni su file, ad esempio la stampa, con la <xref:System.Diagnostics.Process> componente. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `false`, è possibile avviare solo file eseguibili con il <xref:System.Diagnostics.Process> componente.  
  
 È possibile avviare un'applicazione ClickOnce mediante l'impostazione di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà nel percorso (ad esempio, un indirizzo Web) da cui è stato installato l'applicazione. Avviare un'applicazione ClickOnce, specificando il percorso di installazione sul disco rigido.  
  
   
  
## Examples  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUserProfile">
      <MemberSignature Language="C#" Value="public bool LoadUserProfile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadUserProfile" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.LoadUserProfile" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadUserProfile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadUserProfile { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LoadUserProfile : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.LoadUserProfile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se deve essere caricato il profilo utente di Windows dal Registro di sistema.</summary>
        <value>
          <see langword="true" /> se il profilo utente Windows deve essere caricato; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il processo viene avviato utilizzando il nome utente, password e dominio, questa proprietà viene fatto riferimento.  
  
 Se il valore è `true`, il profilo dell'utente nel `HKEY_USERS` è caricare la chiave del Registro di sistema. Il caricamento del profilo può richiedere molto tempo. Pertanto, è consigliabile usare questo valore solo se è necessario accedere alle informazioni nel `HKEY_CURRENT_USER` chiave del Registro di sistema.  
  
 In Windows Server 2003 e Windows 2000, il profilo viene scaricato dopo il nuovo processo è stato terminato, indipendentemente dal fatto che il processo di stati creati processi figlio.  
  
 In Windows XP, il profilo venga scaricato dopo il nuovo processo e tutti i processi figlio che è creato stati terminati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Password">
      <MemberSignature Language="C#" Value="public System.Security.SecureString Password { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.SecureString Password" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Password" />
      <MemberSignature Language="VB.NET" Value="Public Property Password As SecureString" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::SecureString ^ Password { System::Security::SecureString ^ get(); void set(System::Security::SecureString ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Password : System.Security.SecureString with get, set" Usage="System.Diagnostics.ProcessStartInfo.Password" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecureString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una stringa sicura che contiene la password utente da usare all'avvio del processo.</summary>
        <value>La password utente da usare all'avvio del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> deve essere impostata se <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A> forniti. Se la proprietà non è impostata, la directory di lavoro predefinita è % SYSTEMROOT%\system32.  
  
> [!NOTE]
>  Impostando il <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>e il <xref:System.Diagnostics.ProcessStartInfo.Password%2A> delle proprietà in un <xref:System.Diagnostics.ProcessStartInfo> oggetto è la procedura consigliata per l'avvio di un processo con le credenziali dell'utente.  
  
 Oggetto <xref:System.Security.SecureString> oggetto è simile a un <xref:System.String> poiché dispone di un valore di testo dell'oggetto. Tuttavia, il valore di un <xref:System.Security.SecureString> oggetto verrà crittografato automaticamente, può essere modificata finché l'applicazione viene contrassegnato come di sola lettura e che può essere eliminato dalla memoria del computer da un'applicazione o il garbage collector di .NET Framework.  
  
 Per ulteriori informazioni sulle stringhe protette e un esempio di come ottenere una password per impostare questa proprietà, vedere la classe <xref:System.Security.SecureString>.  
  
> [!NOTE]
>  Se si specifica un valore per il <xref:System.Diagnostics.ProcessStartInfo.Password%2A> proprietà, il <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> della proprietà deve essere `false`, o un' <xref:System.InvalidOperationException> viene generata quando il <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> viene chiamato il metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PasswordInClearText">
      <MemberSignature Language="C#" Value="public string PasswordInClearText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PasswordInClearText" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.PasswordInClearText" />
      <MemberSignature Language="VB.NET" Value="Public Property PasswordInClearText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PasswordInClearText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PasswordInClearText : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.PasswordInClearText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la password utente in testo non crittografato da usare all'avvio del processo.</summary>
        <value>La password dell'utente in testo non crittografato.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardError">
      <MemberSignature Language="C#" Value="public bool RedirectStandardError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardError : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process's error output is written to the Process instance's StandardError member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'output di errore di un'applicazione viene scritto nel flusso <see cref="P:System.Diagnostics.Process.StandardError" />.</summary>
        <value>
          <see langword="true" /> se l'output di errore deve essere scritto in <see cref="P:System.Diagnostics.Process.StandardError" />; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un <xref:System.Diagnostics.Process> scrive il testo nel relativo flusso errore standard, che sia in genere visualizzato nella console. Mediante il reindirizzamento di <xref:System.Diagnostics.Process.StandardError%2A> flusso, è possibile modificare o eliminare l'output di errore di un processo. Ad esempio, è possibile filtrare il testo, formattarla in modo diverso o scrivere l'output in un file di registro designato sia la console.  
  
> [!NOTE]
>  È necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> al `false` se si desidera impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> a `true`. In caso contrario, la lettura dal <xref:System.Diagnostics.Process.StandardError%2A> flusso genera un'eccezione.  
  
 Reindirizzato <xref:System.Diagnostics.Process.StandardError%2A> flusso può essere letto in modo sincrono o asincrono. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A> e <xref:System.IO.StreamReader.ReadToEnd%2A> eseguire operazioni di lettura sincrone nel flusso di output di errori del processo. Questi sincrono letti operazioni non vengono completate finché l'oggetto associato <xref:System.Diagnostics.Process> scrive relativo <xref:System.Diagnostics.Process.StandardError%2A> streaming, o chiude il flusso.  
  
 Al contrario, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> operazioni di lettura asincrona viene avviata nel <xref:System.Diagnostics.Process.StandardError%2A> flusso. Questo metodo consente a un gestore eventi designato per l'output del flusso e torna immediatamente al chiamante, che può eseguire altre operazioni mentre il flusso output viene indirizzato al gestore dell'evento.  
  
> [!NOTE]
>  L'applicazione di elaborazione dell'output asincrono deve chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A> metodo per assicurarsi che il buffer di output è stato scaricato.  
  
 Operazioni introducono una dipendenza tra la lettura dal chiamante di lettura sincrona la <xref:System.Diagnostics.Process.StandardError%2A> flusso e il processo figlio la scrittura in tale flusso. Queste dipendenze possono causare condizioni di deadlock. Quando il chiamante legge dal flusso di reindirizzamento di un processo figlio, è dipendente dal figlio. Il chiamante attende l'operazione di lettura fino a quando l'elemento figlio scrive nel flusso o chiude il flusso. Quando il processo figlio scrive dati sufficienti per riempire il relativo flusso reindirizzata, dipende dal padre. Il processo figlio resta in attesa per l'operazione di scrittura successiva fino a quando l'elemento padre legge dal flusso completo o chiude il flusso. La condizione di deadlock quando il chiamante e il processo figlio attendere tra loro completare un'operazione e non può continuare. È possibile evitare i deadlock valutando le dipendenze tra il chiamante e il processo figlio.  
  
 Ad esempio, il codice c# seguente viene illustrato come leggere da un flusso reindirizzato e attendere il chiusura del processo figlio.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare una condizione di deadlock chiamando `p.StandardError.ReadToEnd` prima di `p.WaitForExit`. Una condizione di deadlock può verificarsi se il processo padre chiama `p.WaitForExit` prima di `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente a riempire reindirizzato. Il processo padre verrebbe attendere in modo indefinito la terminazione del processo figlio. Il processo figlio sarebbe indefinitamente in attesa per l'elemento padre da cui leggere l'intero <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 Si verifica un problema simile quando si legge tutto il testo da flussi di errore e output standard. Ad esempio, il codice c# seguente esegue un'operazione di lettura su entrambi i flussi.  
  
```csharp  
// Do not perform a synchronous read to the end of both  
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare la condizione di deadlock mediante l'esecuzione asincrona di operazioni di lettura su di <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Una condizione di deadlock dei risultati, se il processo padre chiama `p.StandardOutput.ReadToEnd` seguita da `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente a riempire il flusso di errore. Il processo padre viene attesa indefinita per il chiusura del processo figlio relativa <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Il processo figlio sarebbe indefinitamente in attesa per l'elemento padre da cui leggere l'intero <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 È possibile usare operazioni di lettura asincrona per evitare queste dipendenze e i deadlock potenziale. In alternativa, è possibile evitare la condizione di deadlock creando due thread e leggere l'output di ogni flusso in un thread separato.  
  
   
  
## Examples  
 L'esempio seguente usa il `net use` comando insieme a un argomento fornito dall'utente per eseguire il mapping di una risorsa di rete. Quindi legge il flusso di errore standard del comando net e lo scrive nella console.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardInput">
      <MemberSignature Language="C#" Value="public bool RedirectStandardInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardInput : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process command input is read from the Process instance's StandardInput member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'input per un'applicazione viene letto dal flusso <see cref="P:System.Diagnostics.Process.StandardInput" />.</summary>
        <value>
          <see langword="true" /> se l'input deve essere letto da <see cref="P:System.Diagnostics.Process.StandardInput" />; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Diagnostics.Process> può leggere il testo di input dal rispettivo flusso di input standard, in genere la tastiera. Mediante il reindirizzamento di <xref:System.Diagnostics.Process.StandardInput%2A> flusso, è possibile specificare a livello di codice l'input di un processo. Invece di usare gli input da tastiera, ad esempio, è possibile fornire il testo dal contenuto di un file specificato o l'output da un'altra applicazione.  
  
> [!NOTE]
>  È necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> al `false` se si desidera impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A> a `true`. In caso contrario, la scrittura di <xref:System.Diagnostics.Process.StandardInput%2A> stream genera un'eccezione.  
  
   
  
## Examples  
 L'esempio seguente illustra come reindirizzare il <xref:System.Diagnostics.Process.StandardInput%2A> flusso di un processo. Il `sort` comando è un'applicazione console che legge e ordina il testo immesso.  
  
 Nell'esempio viene avviato il `sort` con input reindirizzato. Quindi chiede all'utente per il testo e passa il testo per il `sort` elabora tramite reindirizzato <xref:System.Diagnostics.Process.StandardInput%2A> flusso. Il `sort` i risultati vengono visualizzati all'utente della console.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardOutput">
      <MemberSignature Language="C#" Value="public bool RedirectStandardOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardOutput : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process output is written to the Process instance's StandardOutput member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'output testuale di un'applicazione viene scritto nel flusso <see cref="P:System.Diagnostics.Process.StandardOutput" />.</summary>
        <value>
          <see langword="true" /> se l'output deve essere scritto in <see cref="P:System.Diagnostics.Process.StandardOutput" />; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un <xref:System.Diagnostics.Process> scrive il testo nel relativo flusso standard, che sia in genere visualizzato nella console. Impostando <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> al `true` reindirizzare il <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, è possibile modificare o eliminare l'output di un processo. Ad esempio, è possibile filtrare il testo, formattarla in modo diverso o scrivere l'output in un file di registro designato sia la console.  
  
> [!NOTE]
>  È necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> al `false` se si desidera impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> a `true`. In caso contrario, la lettura dal <xref:System.Diagnostics.Process.StandardOutput%2A> flusso genera un'eccezione.  
  
 Reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso può essere letto in modo sincrono o asincrono. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> eseguire operazioni di lettura sincrone nel flusso di output del processo. Questi sincrono letti operazioni non vengono completate finché l'oggetto associato <xref:System.Diagnostics.Process> scrive relativo <xref:System.Diagnostics.Process.StandardOutput%2A> streaming, o chiude il flusso.  
  
 Al contrario, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> operazioni di lettura asincrona viene avviata nel <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Questo metodo consente a un gestore eventi designato (vedere <xref:System.Diagnostics.Process.OutputDataReceived>) per il flusso di output e immediatamente restituisce al chiamante, che può eseguire altre operazioni mentre il flusso output viene indirizzato al gestore dell'evento.  
  
> [!NOTE]
>  L'applicazione di elaborazione dell'output asincrono deve chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A> metodo per assicurarsi che il buffer di output è stato scaricato.  
  
 Operazioni introducono una dipendenza tra la lettura dal chiamante di lettura sincrona la <xref:System.Diagnostics.Process.StandardOutput%2A> flusso e il processo figlio la scrittura in tale flusso. Queste dipendenze possono causare condizioni di deadlock. Quando il chiamante legge dal flusso di reindirizzamento di un processo figlio, è dipendente dal figlio. Il chiamante attende l'operazione di lettura fino a quando l'elemento figlio scrive nel flusso o chiude il flusso. Quando il processo figlio scrive dati sufficienti per riempire il relativo flusso reindirizzata, dipende dal padre. Il processo figlio resta in attesa per l'operazione di scrittura successiva fino a quando l'elemento padre legge dal flusso completo o chiude il flusso. La condizione di deadlock quando il chiamante e il processo figlio attendere tra loro completare un'operazione e non può continuare. È possibile evitare i deadlock valutando le dipendenze tra il chiamante e il processo figlio.  
  
 Ad esempio, il codice c# seguente viene illustrato come leggere da un flusso reindirizzato e attendere il chiusura del processo figlio.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare una condizione di deadlock chiamando `p.StandardOutput.ReadToEnd` prima di `p.WaitForExit`. Una condizione di deadlock può verificarsi se il processo padre chiama `p.WaitForExit` prima di `p.StandardOutput.ReadToEnd` e il processo figlio scrive testo sufficiente a riempire reindirizzato. Il processo padre verrebbe attendere in modo indefinito la terminazione del processo figlio. Il processo figlio sarebbe indefinitamente in attesa per l'elemento padre da cui leggere l'intero <xref:System.Diagnostics.Process.StandardOutput%2A> flusso.  
  
 Si verifica un problema simile quando si legge tutto il testo da flussi di errore e output standard. Ad esempio, il codice c# seguente esegue un'operazione di lettura su entrambi i flussi.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare la condizione di deadlock mediante l'esecuzione asincrona di operazioni di lettura su di <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Una condizione di deadlock dei risultati, se il processo padre chiama `p.StandardOutput.ReadToEnd` seguita da `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente a riempire il flusso di errore. Il processo padre viene attesa indefinita per il chiusura del processo figlio relativa <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Il processo figlio sarebbe indefinitamente in attesa per l'elemento padre da cui leggere l'intero <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 È possibile usare operazioni di lettura asincrona per evitare queste dipendenze e i deadlock potenziale. In alternativa, è possibile evitare la condizione di deadlock creando due thread e leggere l'output di ogni flusso in un thread separato.  
  
   
  
## Examples  
 [!code-cpp[ProcessOneStream#1](~/samples/snippets/cpp/VS_Snippets_CLR/ProcessOneStream/CPP/stdstr.cpp#1)]
 [!code-csharp[ProcessOneStream#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessOneStream/CS/stdstr.cs#1)]
 [!code-vb[ProcessOneStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessOneStream/VB/stdstr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
      </Docs>
    </Member>
    <Member MemberName="StandardErrorEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardErrorEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardErrorEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardErrorEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardErrorEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardErrorEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardErrorEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la codifica preferita per l'output di errore.</summary>
        <value>Oggetto che rappresenta la codifica preferita per l'output di errore. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore della <xref:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding%2A> è di proprietà `null`, il processo Usa la codifica predefinita degli errori standard per l'output di errore. Il <xref:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding%2A> deve essere impostata prima che il processo viene avviato. Impostazione di questa proprietà non garantisce che il processo userà la codifica specificata. il processo userà solo le codifiche supportate. L'applicazione deve essere testata per determinare le codifiche supportate.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardInputEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardInputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardInputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardInputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardInputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardInputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardInputEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardInputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardOutputEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardOutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardOutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardOutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardOutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutputEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardOutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la codifica preferita per l'output standard.</summary>
        <value>Oggetto che rappresenta la codifica preferita per l'output standard. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore della <xref:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding%2A> è di proprietà `null`, il processo Usa la codifica di output standard predefinito per l'output standard. Il <xref:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding%2A> deve essere impostata prima che il processo viene avviato. Impostazione di questa proprietà non garantisce che il processo userà la codifica specificata. L'applicazione deve essere testata per determinare le codifiche supportate dal processo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public string UserName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome utente da usare all'avvio del processo. Se si usa il formato UPN, <paramref name="user" />@<paramref name="DNS_domain_name" />, la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> deve essere <see langword="null" />.</summary>
        <value>Nome utente da usare all'avvio del processo. Se si usa il formato UPN, <paramref name="user" />@<paramref name="DNS_domain_name" />, la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> deve essere <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> deve essere impostata se <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A> forniti. Se la proprietà non è impostata, la directory di lavoro predefinita è % SYSTEMROOT%\system32.  
  
 Se il <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> proprietà non è `null` o una stringa vuota, il <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> proprietà deve essere `false`, o un <xref:System.InvalidOperationException> viene generata quando il <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> viene chiamato il metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseShellExecute">
      <MemberSignature Language="C#" Value="public bool UseShellExecute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseShellExecute" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
      <MemberSignature Language="VB.NET" Value="Public Property UseShellExecute As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseShellExecute { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseShellExecute : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.UseShellExecute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to use the operating system shell to start the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se usare la shell del sistema operativo per avviare il processo.</summary>
        <value>
          <see langword="true" /> se la shell deve essere utilizzata all'avvio del processo; <see langword="false" /> se il processo deve essere creato direttamente dal file eseguibile. Il valore predefinito è <see langword="true" /> nelle app .NET Framework e <see langword="false" /> nelle app .NET Core.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[## Remarks

Impostando questa proprietà su `false` consente di reindirizzare i flussi di input, output e di errore.

> [!NOTE]
> <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> deve essere `false` se il <xref:System.Diagnostics.ProcessStartInfo.UserName> proprietà non è `null` o una stringa vuota, o un' <xref:System.InvalidOperationException> viene generata quando il <xref:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)?displayProperty=nameWithType> viene chiamato il metodo.

Quando si utilizza la shell del sistema operativo per avviare i processi, è possibile avviare un documento qualsiasi (ovvero, qualsiasi tipo di file registrato associato a un eseguibile con azione di apertura predefinita) ed eseguire operazioni sul file come ad esempio la stampa, utilizzando l'oggetto <xref:System.Diagnostics.Process>. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> è `false`, è possibile avviare solo gli eseguibili utilizzando l'oggetto <xref:System.Diagnostics.Process>.

> [!NOTE]
> <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> deve essere `true` se si imposta la <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog> proprietà `true`.

Se si impostano i <xref:System.Diagnostics.ProcessStartInfo.WindowStyle> al <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>, <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> deve essere impostata su `true`.

### <a name="workingdirectory"></a>WorkingDirectory

La proprietà <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory> si comporta in modo diverso a seconda del valore della proprietà <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute>. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> viene `true`, il <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory> proprietà specifica il percorso del file eseguibile. Se <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory*> è una stringa vuota, si presuppone che la directory corrente contenga l'eseguibile.

Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> viene `false`, il <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory> proprietà non viene utilizzata per trovare il file eseguibile. Viene invece utilizzata solo dal processo avviato ed è significativa solo all'interno del contesto del nuovo processo. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> viene `false`, il <xref:System.Diagnostics.ProcessStartInfo.FileName> proprietà può essere un percorso completo del file eseguibile o un semplice nome di eseguibile che il sistema tenterà di trovare all'interno di cartelle specificate dalla variabile di ambiente PATH.

## Examples

[!code-cpp[ProcessOneStream#1](~/samples/snippets/cpp/VS_Snippets_CLR/ProcessOneStream/CPP/stdstr.cpp#1)]
[!code-csharp[ProcessOneStream#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessOneStream/CS/stdstr.cs#1)]
[!code-vb[ProcessOneStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessOneStream/VB/stdstr.vb#1)]]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Si verifica un tentativo di impostare il valore su <see langword="true" /> nelle app UWP (Universal Windows Platform).</exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="Verb">
      <MemberSignature Language="C#" Value="public string Verb { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Verb" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Verb" />
      <MemberSignature Language="VB.NET" Value="Public Property Verb As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Verb { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Verb : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Verb" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.VerbConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The verb to apply to the document specified by the FileName property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il verbo da usare nell'apertura dell'applicazione o del documento specificato dalla proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />.</summary>
        <value>L'azione da intraprendere con il file aperto dal processo. Il valore predefinito è una stringa vuota (""), corrispondente a nessuna azione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni estensione ha un proprio set di verbi, che può essere ottenuto utilizzando il <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> proprietà. Ad esempio, il "`print`" verbo verrà stampato un documento specificato tramite <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Il verbo predefinito può essere specificato usando una stringa vuota (""). Esempi di verbi sono "Modifica", "Open", "OpenAsReadOnly", "Print" e "Printto". È consigliabile usare solo i verbi presenti nell'insieme di verbi restituito dal <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> proprietà.  
  
 Quando si usa la <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> proprietà, è necessario includere l'estensione del nome file quando si imposta il valore della <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà. Il nome del file non è necessario avere un'estensione, se si immette manualmente un valore per il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente avvia un nuovo processo usando il nome e il verbo specificato. Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> proprietà.  
  
 [!code-csharp[ProcessVerbs_Diagnostics#4](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessVerbs_Diagnostics/CS/source.cs#4)]
 [!code-vb[ProcessVerbs_Diagnostics#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessVerbs_Diagnostics/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.Verbs" />
      </Docs>
    </Member>
    <Member MemberName="Verbs">
      <MemberSignature Language="C#" Value="public string[] Verbs { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Verbs" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Verbs" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Verbs As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Verbs { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Verbs : string[]" Usage="System.Diagnostics.ProcessStartInfo.Verbs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i verbi associati al tipo di file specificato dalla proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />.</summary>
        <value>Le azioni che il sistema può applicare al file indicato dalla proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> proprietà consente di determinare i verbi che possono essere utilizzati con il file specificato da di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà. È possibile impostare il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> il valore di qualsiasi verbo nel set di proprietà. Esempi di verbi sono "Modifica", "Open", "OpenAsReadOnly", "Print" e "Printto".  
  
 Quando si usa la <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> proprietà, è necessario includere l'estensione del nome file quando si imposta il valore della <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà. L'estensione del nome file determina il set di possibili verbi.  
  
   
  
## Examples  
 Esempio di codice seguente visualizza i verbi definiti per il nome file scelto. Se l'utente seleziona uno dei verbi definiti, nell'esempio viene avviato un nuovo processo usando il verbo selezionato e il nome di file di input.  
  
 [!code-csharp[ProcessVerbs_Diagnostics#3](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessVerbs_Diagnostics/CS/source.cs#3)]
 [!code-vb[ProcessVerbs_Diagnostics#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessVerbs_Diagnostics/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.Verb" />
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessWindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessWindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As ProcessWindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessWindowStyle WindowStyle { System::Diagnostics::ProcessWindowStyle get(); void set(System::Diagnostics::ProcessWindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Diagnostics.ProcessWindowStyle with get, set" Usage="System.Diagnostics.ProcessStartInfo.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("How the main window should be created when the process starts.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessWindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo stato della finestra da usare una volta avviato il processo.</summary>
        <value>Uno dei valori di enumerazione che indica se il processo viene avviato in una finestra ingrandita, ridotta a icona o normale (né ingrandita né ridotta a icona) oppure non visibile. Il valore predefinito è <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Lo stile della finestra non è uno dei membri dell'enumerazione <see cref="T:System.Diagnostics.ProcessWindowStyle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkingDirectory">
      <MemberSignature Language="C#" Value="public string WorkingDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WorkingDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.WorkingDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkingDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WorkingDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WorkingDirectory : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.WorkingDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.WorkingDirectoryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The initial working directory for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> è <see langword="false" />, ottiene o imposta la directory di lavoro per il processo da avviare. Quando la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> è <see langword="true" />, ottiene o imposta la directory che contiene il processo da avviare.</summary>
        <value>Quando <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> è <see langword="true" />, il nome completo della directory contenente il processo da avviare. Quando la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> è <see langword="false" />, la directory di lavoro per il processo da avviare. Il valore predefinito è una stringa vuota ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> deve essere impostata se <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A> forniti. Se la proprietà non è impostata, la directory di lavoro predefinita è % SYSTEMROOT%\system32.  
  
 Se la directory è già parte della variabile di sistema path, non è necessario ripetere il percorso della directory in questa proprietà.  
  
 Il <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> proprietà ha un comportamento differente quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true` rispetto a quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> è `false`. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `true`, il <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> proprietà specifica il percorso del file eseguibile. Se <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> è una stringa vuota, la directory corrente è un elemento inteso per contenere il file eseguibile.  
  
> [!NOTE]
>  Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> è `true`, la directory di lavoro dell'applicazione che avvia l'eseguibile è anche la cartella di lavoro dell'eseguibile.  
  
 Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> viene `false`, il <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> proprietà non viene utilizzata per trovare il file eseguibile. Il valore di tale proprietà si applica invece al processo avviato ed è significativo solo all'interno del contesto del nuovo processo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>