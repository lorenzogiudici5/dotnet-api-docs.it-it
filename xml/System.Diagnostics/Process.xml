<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0f3b937515accae8f91569e4cac09306f70365d0" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061729" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce l'accesso ai processi locali e remoti e permette di avviare e arrestare i processi locali del sistema.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Diagnostics.Process> componente fornisce l'accesso a un processo in esecuzione in un computer. Un processo, in termini più semplici, è un'applicazione in esecuzione. Un thread è l'unità di base a cui il sistema operativo alloca il tempo del processore. Un thread può eseguire qualsiasi parte del codice del processo, comprese le parti attualmente in esecuzione da un altro thread.  
  
 Il <xref:System.Diagnostics.Process> componente è uno strumento utile per avviare, arrestare, controllare e gestire le app. È possibile utilizzare il <xref:System.Diagnostics.Process> componente, per ottenere un elenco dei processi in esecuzione, oppure è possibile avviare un nuovo processo. Oggetto <xref:System.Diagnostics.Process> componente viene utilizzato per accedere ai processi di sistema. Dopo un <xref:System.Diagnostics.Process> componente è stato inizializzato, può essere utilizzato per ottenere informazioni sul processo in esecuzione. Tali informazioni includono il set di thread, i moduli caricati (file con estensione dll e .exe), e informazioni sulle prestazioni, ad esempio la quantità di memoria, il processo di utilizzo.  
  
 Questo tipo implementa il <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
> [!NOTE]
>  processi a 32 bit non è possibile accedere ai moduli di un processo a 64 bit. Se si tenta di ottenere informazioni su un processo a 64 bit di un processo a 32 bit, si otterrà un <xref:System.ComponentModel.Win32Exception> eccezione. Un processo a 64 bit, d'altra parte, possa accedere i moduli di un processo a 32 bit.  
  
 Il componente del processo di ottenere informazioni su un gruppo di proprietà in una sola volta. Dopo il <xref:System.Diagnostics.Process> componente ha ottenuto informazioni su un membro di alcun gruppo, saranno nella cache i valori per le altre proprietà in tale gruppo e non ottenere nuove informazioni sugli altri membri del gruppo finché non si chiama il <xref:System.Diagnostics.Process.Refresh%2A> metodo. Pertanto, un valore della proprietà non è più recente rispetto all'ultima chiamata al <xref:System.Diagnostics.Process.Refresh%2A> metodo. La suddivisione del gruppo sono dipendenti dal sistema operativo.  
  
 Se si dispone di una variabile di percorso nel sistema utilizzando le virgolette, è necessario qualificare completamente il percorso all'avvio dei processi in tale percorso. In caso contrario, il sistema non troverà il percorso. Ad esempio, se `c:\mypath` non è presente nel percorso, e si aggiunge utilizzando le virgolette: `path = %path%;"c:\mypath"`, è necessario qualificare completamente qualsiasi processo in `c:\mypath` per l'avvio.  
  
 Un processo di sistema viene identificato in modo univoco nel sistema tramite il relativo identificatore di processo. Analogamente a molte risorse di Windows, un processo viene inoltre identificato dal relativo handle, che potrebbe non essere univoco nel computer. Un handle è il termine generico per un identificatore di una risorsa. Il sistema operativo conserva l'handle del processo, è possibile accedere mediante il <xref:System.Diagnostics.Process.Handle%2A> proprietà del <xref:System.Diagnostics.Process> componente, anche quando il processo è terminato. Di conseguenza, è possibile ottenere le informazioni amministrative del processo, ad esempio il <xref:System.Diagnostics.Process.ExitCode%2A> (in genere, zero per esito positivo o un codice di errore diverso da zero) e <xref:System.Diagnostics.Process.ExitTime%2A>. Gli handle sono una risorsa molto utile, in modo da perdita di handle è molto più grave perdita di memoria.  
  
> [!NOTE]
>  Questa classe contiene una richiesta di collegamento e una richiesta di ereditarietà a livello di classe che si applica a tutti i membri. Oggetto <xref:System.Security.SecurityException> viene generata quando il chiamante immediato o la classe derivata non dispone dell'autorizzazione di attendibilità totale. Per informazioni dettagliate sui requisiti di sicurezza, vedere [le richieste di collegamento](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Note  
 In .NET Framework, il <xref:System.Diagnostics.Process> classe per impostazione predefinita Usa <xref:System.Console> codifiche, che sono in genere codice codifiche delle tabelle codici, per i flussi di input, output e di errore. Ad esempio di codice, nei sistemi con le impostazioni cultura inglese (Stati Uniti), la tabella codici 437 è la codifica predefinita per la <xref:System.Console> classe. Tuttavia, [!INCLUDE[net_core](~/includes/net-core-md.md)] può rendere disponibili solo un sottoinsieme limitato di queste codifiche. In questo caso, viene utilizzato <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> come la codifica predefinita.  
  
 Se un <xref:System.Diagnostics.Process> oggetto dipende da codifiche delle tabelle codici codice specifico, è comunque possibile effettuare tali disponibili con le operazioni seguenti *prima* di chiamare qualsiasi <xref:System.Diagnostics.Process> metodi:  
  
1.  Aggiungere un riferimento all'assembly System.Text.Encoding.CodePages.dll al progetto.  
  
2.  Recuperare il <xref:System.Text.EncodingProvider> dall'oggetto di <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> proprietà.  
  
3.  Passare il <xref:System.Text.EncodingProvider> dell'oggetto per il <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> per rendere le codifiche aggiuntive supportate dal provider di codifica disponibili.  
  
 Il <xref:System.Diagnostics.Process> classe quindi automaticamente utilizzerà la codifica predefinita di sistema anziché UTF8, condizione che è stato registrato il provider di codifica prima di chiamare qualsiasi <xref:System.Diagnostics.Process> metodi.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata un'istanza di <xref:System.Diagnostics.Process> classe per avviare un processo.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 L'esempio seguente usa il <xref:System.Diagnostics.Process> classe stesso e un valore statico <xref:System.Diagnostics.Process.Start%2A> metodo per avviare un processo.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 L'esempio c# seguente definisce un `runProc` funzione che avvia un processo, acquisisce tutte le informazioni di output e l'errore e registra il numero di millisecondi che il processo è stato eseguito.  Il `runProc` funzione presenta tre parametri: il nome dell'applicazione da avviare, gli argomenti per fornire all'applicazione e la directory di avvio.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Il codice per il `runProc` funzione è stato scritto dal [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) ed è disponibile sotto il [Microsoft Public License](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Questa classe non può essere utilizzata da codice parzialmente attendibile.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">per l'attendibilità totale per gli eredi. Questa classe non può essere ereditata da codice parzialmente attendibile.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Diagnostics.Process" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non si specifica il <xref:System.Diagnostics.Process.MachineName%2A> proprietà, il valore predefinito è il computer locale (".").  
  
 Sono disponibili due opzioni per l'associazione di un nuovo <xref:System.Diagnostics.Process> componente con un processo nel computer. La prima opzione è utilizzare il costruttore per creare il <xref:System.Diagnostics.Process> componente, impostare i membri appropriati del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e chiamare <xref:System.Diagnostics.Process.Start%2A> per associare il <xref:System.Diagnostics.Process> con un nuovo processo di sistema. La seconda opzione consiste nell'associare il <xref:System.Diagnostics.Process> con un processo di sistema in esecuzione utilizzando <xref:System.Diagnostics.Process.GetProcessById%2A> o uno del <xref:System.Diagnostics.Process.GetProcesses%2A> restituiscono valori.  
  
 Se si utilizza un `static` overload di <xref:System.Diagnostics.Process.Start%2A> crea un nuovo metodo per avviare un nuovo processo di sistema, il metodo <xref:System.Diagnostics.Process> componente e lo associa al processo.  
  
 Quando il <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> proprietà è impostata sul valore predefinito `true`, è possibile avviare le applicazioni e documenti in modo che è simile all'utilizzo di `Run` delle finestre di dialogo `Start` menu. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> è `false`, è possibile avviare solo file eseguibili.  
  
 Qualsiasi file eseguibile che è possibile chiamare dalla riga di comando può essere avviato in uno dei due modi: mediante l'impostazione dei membri appropriati del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata di <xref:System.Diagnostics.Process.Start%2A> metodo senza parametri oppure passando il parametro appropriato per il `static` <xref:System.Diagnostics.Process.Start%2A> membro.  
  
 È possibile creare un <xref:System.Diagnostics.Process> componente utilizzando il costruttore, uno dei statica <xref:System.Diagnostics.Process.Start%2A> overload o uno qualsiasi del <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, o <xref:System.Diagnostics.Process.GetProcessesByName%2A> metodi. Dopo aver eseguito questa operazione, è disponibile una visualizzazione il processo associato. Non si tratta di una visualizzazione dinamica che viene aggiornata automaticamente le proprietà del processo sono stati modificati in memoria. In alternativa, è necessario chiamare <xref:System.Diagnostics.Process.Refresh%2A> per il componente aggiornare il <xref:System.Diagnostics.Process> informazioni sulle proprietà dell'applicazione.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la priorità base del processo associato.</summary>
        <value>Priorità base, calcolata dalla proprietà <see cref="P:System.Diagnostics.Process.PriorityClass" /> del processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.BasePriority%2A> del processo è la priorità iniziale dei thread creati all'interno del processo associato. È possibile visualizzare informazioni sulla priorità base attraverso contatore di Base di priorità del Monitor di sistema.  
  
 In base al tempo trascorsi o degli altri incrementi, il sistema operativo è possono modificare la priorità di base quando un processo deve essere inserito prima degli altri.  
  
 Il <xref:System.Diagnostics.Process.BasePriority%2A> proprietà consente di visualizzare la priorità iniziale assegnata a un processo. Tuttavia, poiché è di sola lettura, è possibile utilizzare il <xref:System.Diagnostics.Process.BasePriority%2A> per impostare la priorità del processo. Per modificare la priorità, utilizzare il <xref:System.Diagnostics.Process.PriorityClass%2A> proprietà. Il <xref:System.Diagnostics.Process.BasePriority%2A> visualizzabile tramite il monitoraggio di sistema, mentre il <xref:System.Diagnostics.Process.PriorityClass%2A> non. Sia il <xref:System.Diagnostics.Process.BasePriority%2A> e <xref:System.Diagnostics.Process.PriorityClass%2A> possono essere visualizzati a livello di codice. Nella tabella seguente viene illustrata la relazione tra <xref:System.Diagnostics.Process.BasePriority%2A> valori e <xref:System.Diagnostics.Process.PriorityClass%2A> valori.  
  
|BasePriority|Classe di priorità|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e viene visualizzato il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo è stato terminato.  
  
 oppure  
  
 Il processo non è avviato, quindi non c'è nessun ID del processo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizia le operazioni di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardError" /> reindirizzato dell'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.StandardError%2A> flusso può essere letto in modo sincrono o asincrono. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> eseguire le operazioni di lettura sincrona nel flusso di output di errore del processo. Questi sincrono letti operazioni non vengono completate fino a quando l'oggetto associato <xref:System.Diagnostics.Process> scrive relativo <xref:System.Diagnostics.Process.StandardError%2A> stream o chiude il flusso.  
  
 Al contrario, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> operazioni di lettura asincrona viene avviato nel <xref:System.Diagnostics.Process.StandardError%2A> flusso. Questo metodo consente al gestore eventi designato per l'output del flusso e viene restituito immediatamente al chiamante, che è possibile eseguire altro lavoro mentre l'output di flusso viene indirizzato al gestore dell'evento.  
  
 Seguire questi passaggi per eseguire operazioni di lettura asincrona in <xref:System.Diagnostics.Process.StandardError%2A> per un <xref:System.Diagnostics.Process> :  
  
1.  Impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> su `false`.  
  
2.  Impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> su `true`.  
  
3.  Aggiungere il gestore eventi per il <xref:System.Diagnostics.Process.ErrorDataReceived> evento. Il gestore eventi deve corrispondere il <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> firma del delegato.  
  
4.  Avviare il <xref:System.Diagnostics.Process>.  
  
5.  Chiamare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> per il <xref:System.Diagnostics.Process>. La chiamata avvia le operazioni di lettura asincrone su <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Quando l'avvio di operazioni di lettura asincrona, il gestore eventi viene chiamato ogni volta associato <xref:System.Diagnostics.Process> scrive una riga di testo relativa <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 È possibile annullare un'operazione di lettura asincrona chiamando <xref:System.Diagnostics.Process.CancelErrorRead%2A>. L'operazione di lettura può essere annullata dal chiamante o dal gestore dell'evento. Dopo l'annullamento, è possibile chiamare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> per riprendere le operazioni di lettura asincrone.  
  
> [!NOTE]
>  È possibile combinare le operazioni di lettura asincrone e sincrone su un flusso reindirizzato. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità. Ad esempio, non seguire <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> con una chiamata a <xref:System.IO.StreamReader.ReadLine%2A> sul <xref:System.Diagnostics.Process.StandardError%2A> flusso, o viceversa. Tuttavia, è possibile leggere due flussi diversi in modalità diverse. Ad esempio, è possibile chiamare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A> per il <xref:System.Diagnostics.Process.StandardOutput%2A> flusso.  
  
   
  
## Examples  
 L'esempio seguente usa il `net view` comando per elencare le risorse di rete disponibile in un computer remoto. L'utente fornisce il nome del computer di destinazione come argomento della riga di comando. L'utente può fornire anche un nome di file per l'output di errore. L'esempio consente di raccogliere l'output del comando net, attende il completamento del processo e quindi scrive l'output risultante nella console. Se l'utente fornisce il file degli errori facoltativo, gli errori vengono scritti nel file.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> è <see langword="false" />.  
  
 \- oppure -  
  
 È già in corso un'operazione di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardError" />.  
  
 \- oppure -  
  
 Il flusso <see cref="P:System.Diagnostics.Process.StandardError" /> è stato usato da un'operazione di lettura sincrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizia le operazioni di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> reindirizzato dell'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.StandardOutput%2A> flusso può essere letto in modo sincrono o asincrono. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> eseguire le operazioni di lettura sincrona nel flusso di output del processo. Questi sincrono letti operazioni non vengono completate fino a quando l'oggetto associato <xref:System.Diagnostics.Process> scrive relativo <xref:System.Diagnostics.Process.StandardOutput%2A> stream o chiude il flusso.  
  
 Al contrario, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> operazioni di lettura asincrona viene avviato nel <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Questo metodo consente a un gestore eventi designato per l'output del flusso e restituisce immediatamente al chiamante, che è possibile eseguire altro lavoro mentre l'output di flusso viene indirizzato al gestore dell'evento.  
  
 Seguire questi passaggi per eseguire operazioni di lettura asincrona in <xref:System.Diagnostics.Process.StandardOutput%2A> per un <xref:System.Diagnostics.Process> :  
  
1.  Impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> su `false`.  
  
2.  Impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> su `true`.  
  
3.  Aggiungere il gestore eventi per il <xref:System.Diagnostics.Process.OutputDataReceived> evento. Il gestore eventi deve corrispondere il <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> firma del delegato.  
  
4.  Avviare il <xref:System.Diagnostics.Process>.  
  
5.  Chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> per il <xref:System.Diagnostics.Process>. La chiamata avvia le operazioni di lettura asincrone su <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Quando l'avvio di operazioni di lettura asincrona, il gestore eventi viene chiamato ogni volta associato <xref:System.Diagnostics.Process> scrive una riga di testo relativa <xref:System.Diagnostics.Process.StandardOutput%2A> flusso.  
  
 È possibile annullare un'operazione di lettura asincrona chiamando <xref:System.Diagnostics.Process.CancelOutputRead%2A>. L'operazione di lettura può essere annullata dal chiamante o dal gestore dell'evento. Dopo l'annullamento, è possibile chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> per riprendere le operazioni di lettura asincrone.  
  
> [!NOTE]
>  È possibile combinare le operazioni di lettura asincrone e sincrone su un flusso reindirizzato. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità. Ad esempio, non seguire <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> con una chiamata a <xref:System.IO.StreamReader.ReadLine%2A> sul <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, o viceversa. Tuttavia, è possibile leggere due flussi diversi in modalità diverse. Ad esempio, è possibile chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A> per il <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come eseguire le operazioni di lettura asincrone sul reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso del `sort` comando. Il `sort` comando è un'applicazione console che legge e ordina il testo immesso.  
  
 Nell'esempio viene creato un delegato per il `SortOutputHandler` gestore dell'evento e la associa il <xref:System.Diagnostics.Process.OutputDataReceived> evento. Il gestore eventi riceve righe di testo da reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, formatta il testo e scrive il testo sullo schermo.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> è <see langword="false" />.  
  
 \- oppure -  
  
 È già in corso un'operazione di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardOutput" />.  
  
 \- oppure -  
  
 Il flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> è stato usato da un'operazione di lettura sincrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annulla l'operazione di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardError" /> reindirizzato di un'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Avvia un'operazione di lettura asincrona nel <xref:System.Diagnostics.Process.StandardError%2A> flusso. <xref:System.Diagnostics.Process.CancelErrorRead%2A> Termina l'operazione di lettura asincrona.  
  
 Dopo l'annullamento, è possibile riprendere l'operazione di lettura asincrona chiamando <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> nuovamente.  
  
 Quando si chiama <xref:System.Diagnostics.Process.CancelErrorRead%2A>tutti in corso operazioni di lettura per <xref:System.Diagnostics.Process.StandardError%2A> vengono completate e viene disabilitato il gestore dell'evento. Ogni ulteriore output reindirizzato a <xref:System.Diagnostics.Process.StandardError%2A> viene salvato in un buffer. Se si riattiva il gestore eventi con una chiamata a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, l'output salvato viene inviato al gestore dell'evento e riprenderanno le operazioni di lettura asincrone. Se si desidera modificare il gestore dell'evento prima di riprendere le operazioni di lettura asincrona, è necessario rimuovere il gestore dell'evento esistente prima di aggiungere il nuovo gestore eventi:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Non è possibile combinare le operazioni di lettura asincrone e sincrone in reindirizzato <xref:System.Diagnostics.Process.StandardError%2A> flusso. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità. Se si annulla un'operazione di lettura asincrona in <xref:System.Diagnostics.Process.StandardError%2A> ed è quindi necessario nuovamente di leggere dal flusso, è necessario utilizzare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> per riprendere le operazioni di lettura asincrone. Non seguire <xref:System.Diagnostics.Process.CancelErrorRead%2A> con una chiamata a sincroni di metodi di lettura <xref:System.Diagnostics.Process.StandardError%2A> , ad esempio <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, o <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviato il `nmake` gli argomenti di comando con l'utente specificati. I flussi di errore e di output vengono letti in modo asincrono; le righe di testo raccolti vengono visualizzate nella console, nonché scritte in un file di log. Se l'output del comando supera un numero di righe specificato, vengono annullate le operazioni di lettura asincrone.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso <see cref="P:System.Diagnostics.Process.StandardError" /> non è abilitato per le operazioni di lettura asincrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annulla l'operazione di lettura asincrona sul flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> reindirizzato di un'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Avvia un'operazione di lettura asincrona nel <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. <xref:System.Diagnostics.Process.CancelOutputRead%2A> Termina l'operazione di lettura asincrona.  
  
 Dopo l'annullamento, è possibile riprendere le operazioni di lettura asincrone chiamando <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> nuovamente.  
  
 Quando si chiama <xref:System.Diagnostics.Process.CancelOutputRead%2A>tutti in corso operazioni di lettura per <xref:System.Diagnostics.Process.StandardOutput%2A> vengono completate e viene disabilitato il gestore dell'evento. Ogni ulteriore output reindirizzato a <xref:System.Diagnostics.Process.StandardOutput%2A> viene salvato in un buffer. Se si riattiva il gestore eventi con una chiamata a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, l'output salvato viene inviato al gestore dell'evento e riprenderanno le operazioni di lettura asincrone. Se si desidera modificare il gestore dell'evento prima di riprendere le operazioni di lettura asincrona, è necessario rimuovere il gestore dell'evento esistente prima di aggiungere il nuovo gestore eventi:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Non è possibile combinare le operazioni di lettura asincrone e sincrone in reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità. Se si annulla un'operazione di lettura asincrona in <xref:System.Diagnostics.Process.StandardOutput%2A> ed è quindi necessario nuovamente di leggere dal flusso, è necessario utilizzare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> per riprendere le operazioni di lettura asincrone. Non seguire <xref:System.Diagnostics.Process.CancelOutputRead%2A> con una chiamata a sincroni di metodi di lettura <xref:System.Diagnostics.Process.StandardOutput%2A> , ad esempio <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, o <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviato il `nmake` gli argomenti di comando con l'utente specificati. I flussi di errore e di output vengono letti in modo asincrono; le righe di testo raccolti vengono visualizzate nella console, nonché scritte in un file di log. Se l'output del comando supera un numero di righe specificato, vengono annullate le operazioni di lettura asincrone.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> non è abilitato per le operazioni di lettura asincrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera tutte le risorse associate a questo componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.Close%2A> metodo causa l'interruzione in attesa di uscita se era in attesa, chiude l'handle del processo e Cancella le proprietà specifiche del processo del processo. <xref:System.Diagnostics.Process.Close%2A> non chiudere i lettori di output, input e di errore standard e i writer nel caso in cui viene fatto riferimento esternamente.  
  
> [!NOTE]
>  Il metodo <xref:System.Diagnostics.Process.Dispose%2A> chiama <xref:System.Diagnostics.Process.Close%2A>. Inserire il <xref:System.Diagnostics.Process> dell'oggetto un `using` blocco Elimina le risorse senza la necessità di chiamare <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'utilizzo di memoria fisica del processo associato viene quindi recuperato a intervalli di 2 secondi per un massimo di 10 secondi. Nell'esempio viene rilevato se il processo viene chiuso prima che siano trascorsi 10 secondi. L'esempio chiude il processo se è ancora in esecuzione dopo 10 secondi.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude un processo che dispone di un'interfaccia utente inviando un messaggio di chiusura alla corrispondente finestra principale.</summary>
        <returns>
          <see langword="true" /> se il messaggio di chiusura è stato inviato correttamente, <see langword="false" /> se il processo associato non dispone di una finestra principale o se la finestra principale è disabilitata (ad esempio, se è attualmente visualizzata una finestra modale).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un processo è in esecuzione, il ciclo di messaggi è in stato di attesa. Il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. La chiamata <xref:System.Diagnostics.Process.CloseMainWindow%2A> invia una richiesta di chiusura della finestra principale, che, in un'applicazione ben formata, chiude le finestre figlio e revoca tutti in esecuzione i cicli di messaggi per l'applicazione. La richiesta di terminazione del processo chiamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> non forza la chiusura dell'applicazione. L'applicazione può richiedere la verifica dell'utente prima di chiudere o rifiutare la chiusura. Per forzare la chiusura dell'applicazione, utilizzare il <xref:System.Diagnostics.Process.Kill%2A> metodo. Il comportamento di <xref:System.Diagnostics.Process.CloseMainWindow%2A> è identico a quello di un utente chiudendo la finestra principale di un'applicazione utilizzando il menu di sistema. Pertanto, la richiesta di terminazione del processo, chiudere la finestra principale non impone la chiusura immediatamente dell'applicazione.  
  
 I dati modificati dal processo o le risorse allocate al processo possono essere perse se si chiama <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> causa una terminazione anomala processo e deve essere utilizzato solo quando necessario. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Abilita una terminazione corretta del processo e chiude tutte le finestre, pertanto è preferibile per le applicazioni con un'interfaccia. Se <xref:System.Diagnostics.Process.CloseMainWindow%2A> ha esito negativo, è possibile utilizzare <xref:System.Diagnostics.Process.Kill%2A> per terminare il processo. <xref:System.Diagnostics.Process.Kill%2A> è l'unico modo per terminare i processi che non dispongono di interfacce grafiche.  
  
 È possibile chiamare <xref:System.Diagnostics.Process.Kill%2A> e <xref:System.Diagnostics.Process.CloseMainWindow%2A> solo per i processi in esecuzione nel computer locale. È Impossibile i processi in computer remoti per uscire dall'installazione. È possibile visualizzare solo le informazioni sui processi in esecuzione in computer remoti.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'utilizzo di memoria fisica del processo associato viene quindi recuperata in intervalli di 2 secondi per un massimo di 10 secondi. Nell'esempio viene rilevato se il processo viene chiuso prima che siano trascorsi 10 secondi. L'esempio chiude il processo se è ancora in esecuzione dopo 10 secondi.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Processo già terminato.  
  
 oppure  
  
 Nessun processo associato all'oggetto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Rilascia tutte le risorse usate dal processo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la generazione dell'evento <see cref="E:System.Diagnostics.Process.Exited" /> quando il processo viene terminato.</summary>
        <value>
          <see langword="true" /> se l'evento <see cref="E:System.Diagnostics.Process.Exited" /> dovrà essere generato quando il processo associato viene terminato (mediante un'uscita o una chiamata al metodo <see cref="M:System.Diagnostics.Process.Kill" />); in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />. Si noti che il <see cref="E:System.Diagnostics.Process.Exited" /> evento viene generato anche se il valore di <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> è <see langword="false" /> quando il processo viene chiuso durante o prima che l'utente esegue un <see cref="P:System.Diagnostics.Process.HasExited" /> controllare.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Il <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà indica se il componente deve ricevere notifica quando un processo di arresto del sistema operativo. Il <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà viene utilizzata nell'elaborazione asincrona per notificare all'applicazione che un processo è terminato. Per forzare l'applicazione per attendere in modo sincrono un evento di uscita (che interrompe l'elaborazione dell'applicazione fino a quando non si è verificato l'evento di uscita), utilizzare il <xref:System.Diagnostics.Process.WaitForExit%2A> metodo.

> [!NOTE]
> Se si usa Visual Studio e fare doppio clic su un <xref:System.Diagnostics.Process> componente nel progetto, un <xref:System.Diagnostics.Process.Exited> delegato dell'evento e il gestore eventi vengono generati automaticamente. Set di codice aggiuntivo il <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà `false`. È necessario modificare questa proprietà su `true` per il gestore eventi da eseguire quando il processo associato viene terminato.

Se il componente <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> valore `true`, o quando <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> è `false` e <xref:System.Diagnostics.Process.HasExited%2A> controllo viene richiamato dal componente, il componente può accedere alle informazioni amministrative per il processo associato, che rimane archiviato dal sistema operativo. Tali informazioni includono il <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.ExitCode%2A>.

Dopo la chiusura del processo associato, la <xref:System.Diagnostics.Process.Handle%2A> del componente non fa più riferimento a una risorsa di processo esistente. In alternativa, può solo essere utilizzato per accedere alle informazioni del sistema operativo sulla risorsa di processo. Il sistema operativo è a conoscenza che sono presenti handle a processi terminati che non sono stati rilasciati dai <xref:System.Diagnostics.Process> componenti, quindi conserva il <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informazioni in memoria.

È un costo associato guardare il video per un processo uscire dall'installazione. Se <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> è `true`, <xref:System.Diagnostics.Process.Exited> evento viene generato quando il processo associato venga terminato. Le procedure per la <xref:System.Diagnostics.Process.Exited> evento eseguito all'ora corrente.

In alcuni casi, l'applicazione avvia un processo, ma non richiede la notifica della chiusura. Ad esempio, l'applicazione può avviare Blocco note per consentire all'utente di eseguire la modifica del testo senza effettuare alcun altro uso dell'applicazione Blocco note. È possibile evitare di notifica quando il processo viene terminato perché non è pertinente per l'operazione continua dell'applicazione. Impostazione <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> a `false` possibile salvare le risorse di sistema.

## Examples  
Esempio di codice seguente crea un processo che stampa un file. Imposta il <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà per fare in modo che il processo generi il <xref:System.Diagnostics.Process.Exited> evento alla chiusura. Il <xref:System.Diagnostics.Process.Exited> gestore eventi visualizza le informazioni sul processo.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta un componente <see cref="T:System.Diagnostics.Process" /> nello stato che gli permette di interagire con i processi del sistema operativo eseguiti in modalità speciale attivando la proprietà nativa <see langword="SeDebugPrivilege" /> sul thread corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni processi del sistema operativo eseguiti in modalità speciale. Il tentativo di leggere le proprietà di o connettersi a questi processi non è possibile a meno che non è stato chiamato <xref:System.Diagnostics.Process.EnterDebugMode%2A> sul componente. Chiamare <xref:System.Diagnostics.Process.LeaveDebugMode%2A> quando non è più necessario l'accesso a questi processi eseguiti in modalità speciale.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un'applicazione scrive nel proprio flusso <see cref="P:System.Diagnostics.Process.StandardError" /> reindirizzato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.ErrorDataReceived> evento indica che il processo associato ha scritto nel proprio flusso <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 L'evento si verifica solo durante le operazioni di lettura asincrona in <xref:System.Diagnostics.Process.StandardError%2A>. Per avviare le operazioni di lettura asincrone, è necessario reindirizzare il <xref:System.Diagnostics.Process.StandardError%2A> flusso di un <xref:System.Diagnostics.Process>, aggiungere il gestore eventi per il <xref:System.Diagnostics.Process.ErrorDataReceived> evento e chiamare <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Successivamente, il <xref:System.Diagnostics.Process.ErrorDataReceived> evento segnala ogni volta che il processo scrive una riga reindirizzato <xref:System.Diagnostics.Process.StandardError%2A> stream, finché il processo viene chiuso o chiama <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  L'applicazione di elaborazione dell'output asincrono deve chiamare il <xref:System.Diagnostics.Process.WaitForExit> metodo per assicurarsi che il buffer di output è stato scaricato. Si noti che se si specifica un timeout utilizzando il <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> overload *non* verificare che il buffer di output è stato scaricato.
  
   
  
## Examples  
 L'esempio seguente usa il `net view` comando per elencare le risorse di rete disponibile in un computer remoto. L'utente fornisce il nome del computer di destinazione come argomento della riga di comando. L'utente può fornire anche un nome di file per l'output di errore. L'esempio consente di raccogliere l'output del comando net, attende il completamento del processo e quindi scrive l'output risultante nella console. Se l'utente fornisce il file degli errori facoltativo, gli errori vengono scritti nel file.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore specificato dal processo associato quando è stato terminato.</summary>
        <value>Codice specificato dal processo associato quando è stato terminato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Diagnostics.Process.ExitCode%2A> per ottenere lo stato restituito il processo di sistema quando è stato terminato. È possibile utilizzare il codice di uscita molto, analogamente a un numero intero restituito da un `main()` stored procedure.  
  
 Il <xref:System.Diagnostics.Process.ExitCode%2A> valore per un processo riflette la specifica convenzione implementata dallo sviluppatore dell'applicazione per tale processo. Se si utilizza il valore del codice di uscita per prendere decisioni nel codice, assicurarsi di conoscere la convenzione di codice di uscita utilizzata dal processo di applicazione.  
  
 Gli sviluppatori in genere indicano l'esito positivo da un <xref:System.Diagnostics.Process.ExitCode%2A> valore pari a zero e definiscono come errori da valori diversi da zero che è possibile utilizzare il metodo chiamante per identificare la causa di una chiusura anomala di processo. Non è necessario seguire queste linee guida, ma sono la convenzione.  
  
 Se si tenta di ottenere il <xref:System.Diagnostics.Process.ExitCode%2A> prima che il processo è terminato, il tentativo genera un'eccezione. Esaminare il <xref:System.Diagnostics.Process.HasExited%2A> proprietà prima di verificare se il processo associato è terminato.  
  
> [!NOTE]
>  Quando l'output standard è stato reindirizzato ai gestori eventi asincroni, è possibile che l'elaborazione di output non deve avere completata quando <xref:System.Diagnostics.Process.HasExited%2A> restituisce `true`. Per garantire che la gestione degli eventi asincroni è stata completata, chiamare il <xref:System.Diagnostics.Process.WaitForExit> overload che non accetta alcun parametro prima dell'archiviazione <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 È possibile utilizzare il <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A> metodo a causa di un processo venga terminato.  
  
 Esistono due modi di ricevere una notifica quando il processo associato viene chiuso: in modo sincrono e asincrono. La notifica sincrona si basa sulla chiamata di <xref:System.Diagnostics.Process.WaitForExit%2A> metodo sospendere l'elaborazione dell'applicazione fino a quando non viene terminato il componente associato. Notifica asincrona si basa sul <xref:System.Diagnostics.Process.Exited> evento. Quando si utilizza la notifica asincrona, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> deve essere impostato su `true` per il <xref:System.Diagnostics.Process> componente per ricevere una notifica che il processo è terminato.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e viene visualizzato il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il processo non è terminato.  
  
 oppure  
  
 Il processo <see cref="P:System.Diagnostics.Process.Handle" /> non è valido.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.ExitCode" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica al termine di un processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.Exited> evento indica che il processo associato è stato terminato. Questa situazione indica che il processo di terminazione (interruzione) o è stato chiuso correttamente. Questo evento può verificarsi solo se il valore di <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà `true`.  
  
 Esistono due modi di ricevere una notifica quando il processo associato viene chiuso: in modo sincrono e asincrono. Notifica sincrona, chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A> metodo per bloccare il thread corrente finché non viene terminato il processo. Notifica asincrona utilizza il <xref:System.Diagnostics.Process.Exited> evento, che consente di continuare l'esecuzione nel frattempo il thread chiamante. Nel secondo caso, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> deve essere impostato su `true` per l'applicazione chiamante di ricevere l'evento Exited.  
  
 Quando il sistema operativo viene arrestato un processo, invia una notifica a tutti gli altri processi che hanno registrato i gestori per l'evento Exited. A questo punto, l'handle del processo di cui è appena stato terminato può essere utilizzato per accedere ad esempio alcune proprietà <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.HasExited%2A> che il sistema operativo gestisce fino a quando non viene rilasciata completamente tale handle.  
  
> [!NOTE]
>  Anche se si dispone di un handle a un processo terminato, non è possibile chiamare <xref:System.Diagnostics.Process.Start%2A> per ristabilire la connessione allo stesso processo. La chiamata <xref:System.Diagnostics.Process.Start%2A> automaticamente rilascia il processo associato e si connette a un processo con lo stesso file, ma un completamente nuova <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Per ulteriori informazioni sull'utilizzo del <xref:System.Diagnostics.Process.Exited> eventi nelle applicazioni Windows Forms, vedere il <xref:System.Diagnostics.Process.SynchronizingObject%2A> proprietà.  
  
   
  
## Examples  
 Esempio di codice seguente crea un processo che stampa un file. Genera il <xref:System.Diagnostics.Process.Exited> evento alla chiusura del processo perché il <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> proprietà è stata impostata quando il processo è stato creato. Il <xref:System.Diagnostics.Process.Exited> gestore eventi visualizza le informazioni sul processo.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'ora in cui il processo associato è stato terminato.</summary>
        <value>Oggetto <see cref="T:System.DateTime" /> che indica il momento in cui il processo associato è stato terminato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non è stato terminato il processo, il tentativo di recuperare il <xref:System.Diagnostics.Process.ExitTime%2A> proprietà genera un'eccezione. Utilizzare <xref:System.Diagnostics.Process.HasExited%2A> prima di ottenere il <xref:System.Diagnostics.Process.ExitTime%2A> proprietà per determinare se il processo associato è terminato.  
  
   
  
## Examples  
 Esempio di codice seguente crea un processo che stampa un file. Il processo genera il <xref:System.Diagnostics.Process.Exited> evento quando viene chiusa e il gestore eventi visualizza le <xref:System.Diagnostics.Process.ExitTime%2A> elaborare le proprietà e altre informazioni.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.ExitTime" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un nuovo componente <see cref="T:System.Diagnostics.Process" /> e lo associa al processo attivo.</summary>
        <returns>Nuovo componente <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo che sta eseguendo l'applicazione chiamante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per creare un nuovo <xref:System.Diagnostics.Process> istanza e associarlo alla risorsa di processo nel computer locale.  
  
 Ad esempio simile <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, e <xref:System.Diagnostics.Process.GetProcesses%2A> metodi, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associa una risorsa esistente a un nuovo <xref:System.Diagnostics.Process> componente.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico del computer locale. Viene quindi recuperato le informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo componente <see cref="T:System.Diagnostics.Process" /> e lo associa alla risorsa di processo esistente specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Identificatore univoco nel sistema di una risorsa di processo.</param>
        <summary>Restituisce un nuovo componente <see cref="T:System.Diagnostics.Process" />, dato l'identificatore di un processo nel computer locale.</summary>
        <returns>Componente <see cref="T:System.Diagnostics.Process" /> associato alla risorsa locale del processo identificata dal parametro <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per creare un nuovo <xref:System.Diagnostics.Process> componente e associarlo a una risorsa di processo nel computer locale. La risorsa di processo deve esistere nel computer, perché <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> non crea una risorsa di sistema, ma piuttosto generati dall'applicazione associa una risorsa <xref:System.Diagnostics.Process> componente. Un processo <xref:System.Diagnostics.Process.Id%2A> può essere recuperato solo per un processo attualmente in esecuzione nel computer. Una volta terminato il processo, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> genera un'eccezione se viene passato un identificatore scaduto.  
  
 Su un particolare computer, l'identificatore di un processo è univoco. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Restituisce al massimo un processo. Se si desidera ottenere tutti i processi in esecuzione un'applicazione specifica, utilizzare <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Se esistono più processi del computer che esegue l'applicazione specificata, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> restituisce una matrice contenente tutti i processi associati. È possibile eseguire una query ognuno di questi processi, a sua volta per il relativo identificatore. L'identificatore di processo può essere visualizzato nel `Processes` riquadro Task Manager di Windows. Il `PID` colonna viene visualizzato l'identificatore di processo che viene assegnato a un processo.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico del computer locale. Viene quindi recuperato le informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il processo specificato dal parametro <paramref name="processId" /> non è in esecuzione. L'identificatore potrebbe essere scaduto.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo non è stato avviato da questo oggetto.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Identificatore univoco nel sistema di una risorsa di processo.</param>
        <param name="machineName">Nome di un computer della rete.</param>
        <summary>Restituisce un nuovo componente <see cref="T:System.Diagnostics.Process" />, dato un identificatore di processo e il nome di un computer sulla rete.</summary>
        <returns>Componente <see cref="T:System.Diagnostics.Process" /> associato a una risorsa di processo remota identificata dal parametro <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per creare un nuovo <xref:System.Diagnostics.Process> componente e associarlo a una risorsa di processo in un computer remoto sulla rete. La risorsa di processo deve esistere nel computer specificato, in quanto <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> non crea una risorsa di sistema, ma piuttosto generati dall'applicazione associa una risorsa <xref:System.Diagnostics.Process> componente. Un processo <xref:System.Diagnostics.Process.Id%2A> può essere recuperato solo per un processo attualmente in esecuzione nel computer. Una volta terminato il processo, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> genera un'eccezione se viene passato un identificatore scaduto.  
  
 Su un particolare computer, l'identificatore di un processo è univoco. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Restituisce al massimo un processo. Se si desidera ottenere tutti i processi in esecuzione un'applicazione specifica, utilizzare <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Se esistono più processi del computer che esegue l'applicazione specificata, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> restituisce una matrice contenente tutti i processi associati. È possibile eseguire una query ognuno di questi processi, a sua volta per il relativo identificatore. L'identificatore di processo può essere visualizzato nel `Processes` riquadro Task Manager di Windows. Il `PID` colonna viene visualizzato l'identificatore di processo che viene assegnato a un processo.  
  
 Se non si specifica un `machineName`, viene usato il computer locale. In alternativa, è possibile specificare il computer locale tramite l'impostazione `machineName` sul valore "." o su una stringa vuota ("").  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico del computer locale. Viene quindi recuperato le informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il processo specificato dal parametro <paramref name="processId" /> non è in esecuzione. L'identificatore potrebbe essere scaduto.  
  
 oppure  
  
 La sintassi del parametro <paramref name="machineName" /> non è valida. Il nome potrebbe avere lunghezza zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="machineName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo non è stato avviato da questo oggetto.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una matrice di nuovi componenti <see cref="T:System.Diagnostics.Process" /> e li associa alle risorse di processo esistenti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuovo componente <see cref="T:System.Diagnostics.Process" /> per ciascuna risorsa di processo del computer locale.</summary>
        <returns>Matrice di tipo <see cref="T:System.Diagnostics.Process" /> che rappresenta tutte le risorse di processo in esecuzione sul computer locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process> componenti e associarli a tutte le risorse di processo nel computer locale. Le risorse di processo devono esistere nel computer locale, perché <xref:System.Diagnostics.Process.GetProcesses%2A> crea risorse di sistema, ma piuttosto associa risorse generati dall'applicazione <xref:System.Diagnostics.Process> componenti. Poiché il sistema operativo è in esecuzione i processi in background, questa matrice non è mai vuota.  
  
 Se non si desidera recuperare tutti i processi in esecuzione nel computer, è possibile limitare il numero utilizzando il <xref:System.Diagnostics.Process.GetProcessById%2A> o <xref:System.Diagnostics.Process.GetProcessesByName%2A> metodo. <xref:System.Diagnostics.Process.GetProcessById%2A> Crea un <xref:System.Diagnostics.Process> componente associato al processo identificato nel sistema dall'identificatore di processo che viene passato al metodo. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Crea una matrice di <xref:System.Diagnostics.Process> componenti con risorse di processo associato che condividono il file eseguibile passare al metodo.  
  
> [!NOTE]
>  Più servizi di Windows possono essere caricati nella stessa istanza del processo Host del servizio (svchost.exe). GetProcesses non identifica i singoli servizi; a tale scopo, vedere <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico del computer locale. Viene quindi recuperato le informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Computer da cui leggere l'elenco di processi.</param>
        <summary>Crea un nuovo componente <see cref="T:System.Diagnostics.Process" /> per ciascuna risorsa di processo nel computer specificato.</summary>
        <returns>Matrice di tipo <see cref="T:System.Diagnostics.Process" /> che rappresenta tutte le risorse di processo in esecuzione sul computer specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process> componenti e associarli a tutte le risorse di processo nel computer specificato (in genere remoto). Le risorse di processo devono esistere nel computer locale, perché <xref:System.Diagnostics.Process.GetProcesses%2A> crea risorse di sistema, ma piuttosto associa risorse generati dall'applicazione <xref:System.Diagnostics.Process> componenti. Poiché il sistema operativo è in esecuzione i processi in background, questa matrice non è mai vuota.  
  
 Se non si desidera recuperare tutti i processi in esecuzione nel computer, è possibile limitare il numero utilizzando il <xref:System.Diagnostics.Process.GetProcessById%2A> o <xref:System.Diagnostics.Process.GetProcessesByName%2A> metodo. <xref:System.Diagnostics.Process.GetProcessById%2A> Crea un <xref:System.Diagnostics.Process> componente associato al processo identificato nel sistema dall'identificatore di processo che viene passato al metodo. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Crea una matrice di <xref:System.Diagnostics.Process> componenti con risorse di processo associato che condividono il file eseguibile passare al metodo.  
  
 Questo overload del metodo di <xref:System.Diagnostics.Process.GetProcesses%2A> metodo viene in genere utilizzato per recuperare l'elenco delle risorse di processo in esecuzione in un computer remoto sulla rete, ma è possibile specificare il computer locale mediante il passaggio ".".  
  
> [!NOTE]
>  Più servizi di Windows possono essere caricati nella stessa istanza del processo Host del servizio (svchost.exe). GetProcesses non identifica i singoli servizi; a tale scopo, vedere <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico del computer locale. Viene quindi recuperato le informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La sintassi del parametro <paramref name="machineName" /> non è valida. Potrebbe avere lunghezza zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="machineName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma del sistema operativo non supporta questa operazione in computer remoti.</exception>
        <exception cref="T:System.InvalidOperationException">Si sono verificati problemi di accesso alle API del contatore di prestazioni usate per ottenere informazioni sul processo. Questa eccezion è specifica di Windows NT, Windows 2000 e Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un problema durante l'accesso a un'API di sistema sottostante.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una matrice di nuovi componenti <see cref="T:System.Diagnostics.Process" /> e li associa alle risorse di processo esistenti che condividono il nome di processo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Nome descrittivo del processo.</param>
        <summary>Crea una matrice di nuovi componenti <see cref="T:System.Diagnostics.Process" /> e li associa a tutte le risorse di processo nel computer locale che condividono il nome di processo specificato.</summary>
        <returns>Una matrice di tipo <see cref="T:System.Diagnostics.Process" /> che rappresenta le risorse di processo che eseguono l'applicazione o il file specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process> componenti e associarli a tutte le risorse di processo che eseguono lo stesso file eseguibile nel computer locale. Le risorse di processo devono esistere nel computer, perché <xref:System.Diagnostics.Process.GetProcessesByName%2A> non crea le risorse di sistema, ma piuttosto li associa generati dall'applicazione <xref:System.Diagnostics.Process> componenti. Oggetto `processName` può essere specificato per un file eseguibile che non è attualmente in esecuzione nel computer locale, pertanto la matrice restituita dal metodo può essere vuota.  
  
 Il nome del processo è un nome descrittivo per il processo, ad esempio Outlook, che non include l'estensione .exe o il percorso. <xref:System.Diagnostics.Process.GetProcessesByName%2A> è utile per ottenere e modificare tutti i processi che sono associati lo stesso file eseguibile. Ad esempio, è possibile passare un nome del file eseguibile come i `processName` parametro, per arrestare tutte le istanze in esecuzione del file eseguibile.  
  
 Anche se un processo <xref:System.Diagnostics.Process.Id%2A> è univoco per una singola risorsa di processo nel sistema, più processi nel computer locale può eseguire l'applicazione specificata dal `processName` parametro. Pertanto, <xref:System.Diagnostics.Process.GetProcessById%2A> restituisce al massimo un processo ma <xref:System.Diagnostics.Process.GetProcessesByName%2A> restituisce una matrice contenente tutti i processi associati. Se è necessario modificare il processo utilizzando le chiamate API standard, è possibile eseguire query ognuno di questi processi, a sua volta per il relativo identificatore. Non è possibile accedere alle risorse di processo tramite il nome del processo da solo, ma, dopo avere recuperato una matrice di <xref:System.Diagnostics.Process> componenti che sono stati associati alle risorse di processo, è possibile avviare, terminare e modificare le risorse di sistema.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico del computer locale. Viene quindi recuperato le informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si sono verificati problemi di accesso alle API del contatore di prestazioni usate per ottenere informazioni sul processo. Questa eccezion è specifica di Windows NT, Windows 2000 e Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Nome descrittivo del processo.</param>
        <param name="machineName">Nome di un computer della rete.</param>
        <summary>Crea una matrice di nuovi componenti <see cref="T:System.Diagnostics.Process" /> e li associa a tutte le risorse di processo in un computer remoto che condividono il nome di processo specificato.</summary>
        <returns>Una matrice di tipo <see cref="T:System.Diagnostics.Process" /> che rappresenta le risorse di processo che eseguono l'applicazione o il file specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per creare una matrice di nuovi <xref:System.Diagnostics.Process> componenti e associarli a tutte le risorse di processo che eseguono lo stesso file eseguibile nel computer specificato. Le risorse di processo devono esistere nel computer, perché <xref:System.Diagnostics.Process.GetProcessesByName%2A> non crea le risorse di sistema, ma piuttosto li associa generati dall'applicazione <xref:System.Diagnostics.Process> componenti. Oggetto `processName` può essere specificato per un file eseguibile che non è attualmente in esecuzione nel computer locale, pertanto la matrice restituita dal metodo può essere vuota.  
  
 Il nome del processo è un nome descrittivo per il processo, ad esempio Outlook, che non include l'estensione .exe o il percorso. <xref:System.Diagnostics.Process.GetProcessesByName%2A> è utile per ottenere e modificare tutti i processi che sono associati lo stesso file eseguibile. Ad esempio, è possibile passare un nome del file eseguibile come i `processName` parametro, per arrestare tutte le istanze in esecuzione del file eseguibile.  
  
 Anche se un processo <xref:System.Diagnostics.Process.Id%2A> è univoco per una singola risorsa di processo nel sistema, più processi nel computer locale può eseguire l'applicazione specificata dal `processName` parametro. Pertanto, <xref:System.Diagnostics.Process.GetProcessById%2A> restituisce al massimo un processo ma <xref:System.Diagnostics.Process.GetProcessesByName%2A> restituisce una matrice contenente tutti i processi associati. Se è necessario modificare il processo utilizzando le chiamate API standard, è possibile eseguire query ognuno di questi processi, a sua volta per il relativo identificatore. Non è possibile accedere alle risorse di processo tramite il nome del processo da solo, ma, dopo avere recuperato una matrice di <xref:System.Diagnostics.Process> componenti che sono stati associati alle risorse di processo, è possibile avviare, terminare e modificare le risorse di sistema.  
  
 È possibile utilizzare questo overload per ottenere i processi nel computer locale e in un computer remoto. Utilizzare "." per specificare il computer locale. Un altro overload esistente che utilizza il computer locale per impostazione predefinita.  
  
 È possibile accedere ai processi nei computer remoto solo per visualizzare informazioni sui processi, ad esempio le statistiche. Non è possibile chiudere, terminare (utilizzando <xref:System.Diagnostics.Process.Kill%2A>), oppure avviare i processi nel computer remoto.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni del processo corrente, i processi in esecuzione nel computer locale, tutte le istanze del blocco note in esecuzione nel computer locale e un processo specifico del computer locale. Viene quindi recuperato le informazioni per gli stessi processi in un computer remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La sintassi del parametro <paramref name="machineName" /> non è valida. Potrebbe avere lunghezza zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="machineName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma del sistema operativo non supporta questa operazione in computer remoti.</exception>
        <exception cref="T:System.InvalidOperationException">Si sono verificati problemi di accesso alle API del contatore di prestazioni usate per ottenere informazioni sul processo. Questa eccezion è specifica di Windows NT, Windows 2000 e Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un problema durante l'accesso a un'API di sistema sottostante.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle nativo del processo associato.</summary>
        <value>Handle che il sistema operativo ha assegnato al processo associato quando è stato avviato. Il sistema usa questo handle per tenere traccia degli attributi del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'applicazione può ottenere un handle a un processo che può essere utilizzato come parametro per molte funzioni di controllo e le informazioni di processo. È possibile utilizzare questo handle per inizializzare un <xref:System.Threading.WaitHandle> o chiamare metodi nativi con platform invoke.  
  
 Questo handle del processo è privato per un'applicazione, in altre parole, non è possibile condividere gli handle di processo. Un processo dispone anche di un processo <xref:System.Diagnostics.Process.Id%2A> che, a differenza di <xref:System.Diagnostics.Process.Handle%2A>, è univoco e, pertanto, valida in tutto il sistema.  
  
 Solo i processi avviati tramite una chiamata a <xref:System.Diagnostics.Process.Start%2A> impostare il <xref:System.Diagnostics.Process.Handle%2A> proprietà dell'oggetto corrispondente <xref:System.Diagnostics.Process> istanze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il processo non è stato avviato o è terminato. Non è possibile leggere la proprietà <see cref="P:System.Diagnostics.Process.Handle" /> perché nessun processo è associato a questa istanza di <see cref="T:System.Diagnostics.Process" />.  
  
 oppure  
  
 L'istanza <see cref="T:System.Diagnostics.Process" /> è stata collegata a un processo in esecuzione ma non si possiedono le autorizzazioni necessarie per ottenere un handle con diritti di accesso completi.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.Handle" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di handle aperti dal processo.</summary>
        <value>Numero di handle del sistema operativo aperti dal processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli handle forniscono un modo per un processo fare riferimento a oggetti. Un processo può ottenere l'handle di file, risorse, le code di messaggi e molti altri oggetti di sistema operativo. Il sistema operativo recupera la memoria associata al processo solo quando il numero di handle è zero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il processo associato è stato terminato.</summary>
        <value>
          <see langword="true" /> se il processo del sistema operativo cui fa riferimento il componente <see cref="T:System.Diagnostics.Process" /> è stato terminato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore `true` per <xref:System.Diagnostics.Process.HasExited%2A> indica che il processo associato è stato terminato normalmente o in modo anomalo. È possibile richiedere o forzare il processo associato venga terminato chiamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Se un handle aperto per il processo, il sistema operativo rilascia la memoria del processo quando il processo è stato chiuso, ma mantiene le informazioni amministrative sul processo, ad esempio l'handle, codice di uscita e il tempo di uscita. Per ottenere queste informazioni, è possibile utilizzare il <xref:System.Diagnostics.Process.ExitCode%2A> e <xref:System.Diagnostics.Process.ExitTime%2A> proprietà. Queste proprietà vengono popolate automaticamente per i processi avviati da questo componente. Le informazioni amministrative vengono rilasciate quando tutti i <xref:System.Diagnostics.Process> componenti che sono associati il processo di sistema vengono eliminati definitivamente e contenere handle non sono più presenti al processo terminato.  
  
 Un processo può terminare indipendentemente dal codice. Se il processo utilizzando questo componente è stato avviato, il sistema aggiorna il valore di <xref:System.Diagnostics.Process.HasExited%2A> automaticamente, anche se il processo associato viene terminato in modo indipendente.  
  
> [!NOTE]
>  Quando l'output standard è stato reindirizzato ai gestori eventi asincroni, è possibile che l'elaborazione di output non sia completata quando questa proprietà restituisce `true`. Per garantire che la gestione degli eventi asincroni è stata completata, chiamare il <xref:System.Diagnostics.Process.WaitForExit> overload che non accetta alcun parametro prima dell'archiviazione <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'utilizzo di memoria fisica del processo associato viene quindi recuperata in intervalli di 2 secondi per un massimo di 10 secondi. Nell'esempio viene rilevato se il processo viene chiuso prima che siano trascorsi 10 secondi. L'esempio chiude il processo se è ancora in esecuzione dopo 10 secondi.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessun processo è associato all'oggetto.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile recuperare il codice di uscita del processo.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l’identificatore univoco per il processo associato.</summary>
        <value>Identificatore univoco generato dal sistema relativo al processo cui questa istanza di <see cref="T:System.Diagnostics.Process" /> fa riferimento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il processo <xref:System.Diagnostics.Process.Id%2A> non è valido se non è in esecuzione il processo associato. Pertanto, è necessario assicurarsi che il processo è in esecuzione prima di tentare di recuperare il <xref:System.Diagnostics.Process.Id%2A> proprietà. Finché non termina il processo, l'identificatore di processo identifica in modo univoco il processo in tutto il sistema.  
  
 È possibile connettersi a un processo è in esecuzione in un computer locale o remoto in un nuovo <xref:System.Diagnostics.Process> istanza passando l'identificatore di processo per il <xref:System.Diagnostics.Process.GetProcessById%2A> metodo. <xref:System.Diagnostics.Process.GetProcessById%2A> è un `static` metodo che crea un nuovo componente e imposta il <xref:System.Diagnostics.Process.Id%2A> proprietà per il nuovo <xref:System.Diagnostics.Process> istanza automaticamente.  
  
 Identificatori di processo possono essere riutilizzati dal sistema. Il <xref:System.Diagnostics.Process.Id%2A> valore della proprietà è univoco solo durante l'esecuzione del processo associato. Dopo il processo è terminato, il sistema è possibile riutilizzare il <xref:System.Diagnostics.Process.Id%2A> valore della proprietà per un processo non correlato.  
  
 Poiché l'identificatore è univoco nel sistema, è possibile passare, altri thread come alternativa a passare un <xref:System.Diagnostics.Process> istanza. Questa azione può risparmiare risorse di sistema e garantire che il processo è stato identificato correttamente.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere il <xref:System.Diagnostics.Process.Id%2A> per tutti istanze di un'applicazione in esecuzione. Il codice crea una nuova istanza del blocco note, Elenca tutte le istanze del blocco note e quindi consente all'utente di immettere il <xref:System.Diagnostics.Process.Id%2A> numero per rimuovere un'istanza specifica.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Diagnostics.Process.Id" /> del processo non è stata impostata.  
  
 oppure  
  
 A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arresta immediatamente il processo associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> impone la terminazione del processo, mentre <xref:System.Diagnostics.Process.CloseMainWindow%2A> solo la richiede. Quando è in esecuzione un processo con un'interfaccia grafica, il ciclo di messaggi è in stato di attesa. Il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. La chiamata <xref:System.Diagnostics.Process.CloseMainWindow%2A> invia una richiesta di chiusura della finestra principale, che, in un'applicazione ben formata, chiude le finestre figlio e revoca tutti in esecuzione i cicli di messaggi per l'applicazione. La richiesta di terminazione del processo chiamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> non forza la chiusura dell'applicazione. L'applicazione può richiedere la verifica dell'utente prima di chiudere o rifiutare la chiusura. Per forzare la chiusura dell'applicazione, utilizzare il <xref:System.Diagnostics.Process.Kill%2A> metodo. Il comportamento di <xref:System.Diagnostics.Process.CloseMainWindow%2A> è identico a quello di un utente chiudendo la finestra principale di un'applicazione utilizzando il menu di sistema. Pertanto, la richiesta di terminazione del processo, chiudere la finestra principale non impone la chiusura immediatamente dell'applicazione.  
  
> [!NOTE]
>  Il <xref:System.Diagnostics.Process.Kill%2A> metodo viene eseguito in modo asincrono. Dopo la chiamata di <xref:System.Diagnostics.Process.Kill%2A> metodo, chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A> metodo per attendere che il processo di uscita o verificare il <xref:System.Diagnostics.Process.HasExited%2A> proprietà per determinare se il processo è terminato.  
  
 I dati modificati dal processo o le risorse allocate al processo possono essere perse se si chiama <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> causa una terminazione anomala processo e deve essere utilizzato solo quando necessario. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Abilita una terminazione corretta del processo e chiude tutte le finestre, pertanto è preferibile per le applicazioni con un'interfaccia. Se <xref:System.Diagnostics.Process.CloseMainWindow%2A> ha esito negativo, è possibile utilizzare <xref:System.Diagnostics.Process.Kill%2A> per terminare il processo. <xref:System.Diagnostics.Process.Kill%2A> è l'unico modo per terminare i processi che non dispongono di interfacce grafiche.  
  
 È possibile chiamare <xref:System.Diagnostics.Process.Kill%2A> e <xref:System.Diagnostics.Process.CloseMainWindow%2A> solo per i processi in esecuzione nel computer locale. È Impossibile i processi in computer remoti per uscire dall'installazione. È possibile visualizzare solo le informazioni sui processi in esecuzione in computer remoti.  
  
> [!NOTE]
>  Se la chiamata al <xref:System.Diagnostics.Process.Kill%2A> (metodo) viene eseguita durante il processo è in fase di chiusura, un <xref:System.ComponentModel.Win32Exception> viene generata per accesso negato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è possibile terminare il processo associato.  
  
 oppure  
  
 Il processo verrà terminato.  
  
 oppure  
  
 Il processo associato è un eseguibile Win16.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando a chiamare <see cref="M:System.Diagnostics.Process.Kill" /> per un processo in esecuzione in un computer remoto. Il metodo è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Processo già terminato.  
  
 oppure  
  
 A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fa uscire un componente <see cref="T:System.Diagnostics.Process" /> dallo stato che permette di interagire con i processi del sistema operativo eseguiti in modalità speciale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni processi del sistema operativo eseguiti in modalità speciale. Il tentativo di leggere le proprietà di o connettersi a questi processi non è possibile a meno che non è stato chiamato <xref:System.Diagnostics.Process.EnterDebugMode%2A> sul componente. Chiamare <xref:System.Diagnostics.Process.LeaveDebugMode%2A> quando non è più necessario l'accesso a questi processi eseguiti in modalità speciale.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del computer sul quale è in esecuzione il processo associato.</summary>
        <value>Nome del computer sul quale è in esecuzione il processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile visualizzare i dati statistici e le informazioni sui processi in esecuzione in computer remoti, ma è possono chiamare <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, o <xref:System.Diagnostics.Process.Kill%2A> in computer remoti.  
  
> [!NOTE]
>  Quando il processo associato è in esecuzione nel computer locale, questa proprietà restituisce un punto (".") per il nome del computer. È consigliabile utilizzare il <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> proprietà per ottenere il nome computer corretto.  
  
   
  
## Examples  
 Per utilizzare l'esempio seguente, è necessario innanzitutto avviare almeno un'istanza del blocco note in un computer remoto. Nell'esempio viene richiesto il nome del computer remoto in cui è in esecuzione, il blocco note e quindi vengono visualizzate le rispettive <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, e <xref:System.Diagnostics.Process.MachineName%2A> proprietà per ogni istanza.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il modulo principale del processo associato.</summary>
        <value>Oggetto <see cref="T:System.Diagnostics.ProcessModule" /> usato per avviare il processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un modulo di processo rappresenta i file DLL o .exe che viene caricato in un determinato processo. Il <xref:System.Diagnostics.Process.MainModule%2A> proprietà consente di visualizzare informazioni relative all'eseguibile utilizzato per avviare il processo, inclusi il nome del modulo, nome file e i dettagli della memoria del modulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.MainModule" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Un processo a 32 bit sta provando ad accedere ai moduli di un processo a 64 bit.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.  
  
 oppure  
  
 Il processo è stato terminato.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle della finestra principale del processo associato.</summary>
        <value>Handle generato dal sistema della finestra principale del processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La finestra principale è la finestra aperta dal processo che ha attualmente lo stato attivo (la <xref:System.Windows.Forms.Form.TopLevel%2A> form). È necessario utilizzare il <xref:System.Diagnostics.Process.Refresh%2A> per aggiornare il <xref:System.Diagnostics.Process> oggetto per cui ottenere l'handle della finestra principale corrente, se è stato modificato. In generale, poiché verrà memorizzati nella cache l'handle di finestra, utilizzare <xref:System.Diagnostics.Process.Refresh%2A> in anticipo per garantire che si recupererà l'handle corrente.  
  
 È possibile ottenere il <xref:System.Diagnostics.Process.MainWindowHandle%2A> proprietà solo per i processi in esecuzione nel computer locale. Il <xref:System.Diagnostics.Process.MainWindowHandle%2A> proprietà è un valore che identifica in modo univoco la finestra che viene associata al processo.  
  
 Un processo ha una finestra principale associata solo se il processo ha un'interfaccia grafica. Se il processo associato non dispone di una finestra principale, il <xref:System.Diagnostics.Process.MainWindowHandle%2A> valore è zero. Anche il valore è zero per i processi che sono stati nascosti, processi, ovvero che non sono visibili nella barra delle applicazioni. Può essere il caso per i processi che vengono visualizzati come icone nell'area di notifica, all'estrema destra della barra delle applicazioni.  
  
 Se è stato appena avviato un processo e si desidera utilizzare il relativo handle della finestra principale, è consigliabile utilizzare il <xref:System.Diagnostics.Process.WaitForInputIdle%2A> metodo per consentire al processo di completare l'avvio, garantendo che è stato creato l'handle di finestra principale. In caso contrario, verrà generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> non è definita, perché il processo è stato terminato.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la didascalia della finestra principale del processo.</summary>
        <value>Titolo della finestra principale del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un processo ha una finestra principale associata solo se il processo ha un'interfaccia grafica. Se il processo associato non dispone di una finestra principale (in modo che <xref:System.Diagnostics.Process.MainWindowHandle%2A> è uguale a zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> è una stringa vuota (""). Se è stato appena avviato un processo e si desidera utilizzare il titolo della finestra principale, è consigliabile utilizzare il <xref:System.Diagnostics.Process.WaitForInputIdle%2A> metodo per consentire al processo di completare l'avvio, garantendo che è stato creato l'handle di finestra principale. In caso contrario, il sistema genererà un'eccezione.  
  
> [!NOTE]
>  La finestra principale è la finestra che ha attualmente lo stato attivo. Si noti che potrebbe non essere la finestra principale per il processo. È necessario utilizzare il <xref:System.Diagnostics.Process.Refresh%2A> per aggiornare il <xref:System.Diagnostics.Process> oggetto per cui ottenere l'handle della finestra principale corrente, se è stato modificato.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note e recupera la didascalia della finestra principale del processo.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> non è definita, perché il processo è stato terminato.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione massima del working set, in byte, consentita per il processo associato.</summary>
        <value>Dimensione massima del working set consentita in memoria per il processo, in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un'applicazione può utilizzare senza generare un errore di pagina.  
  
 Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni di esecuzione dell'applicazione, incluse le pagine nel file con estensione dll e file DLL di sistema. Working set di dimensioni maggiori, aumenta la richiesta di memoria.  
  
 Un processo ha dimensioni dei set di lavoro minimo e massimo. Ogni volta che viene creata una risorsa di processo, il sistema si riserva una quantità di memoria uguale alla minima dimensione del working set per il processo. Virtual memory manager tenta di mantenere almeno la quantità minima di memoria residenti quando il processo è attivo, ma non vengono mai superiore rispetto alla dimensione massima.  
  
 Il sistema imposta il valore predefinito del working set. È possibile modificare queste dimensioni utilizzando il <xref:System.Diagnostics.Process.MaxWorkingSet%2A> e <xref:System.Diagnostics.Process.MinWorkingSet%2A> membri. Tuttavia, l'impostazione di questi valori non garantisce che la memoria sia riservato o residenti.  
  
> [!NOTE]
>  Quando si aumenta la dimensione del working set di un processo, richiedere quantità di memoria fisica il resto del sistema. Assicurarsi di non richiedere una dimensione del set working minimo o massimo che è troppo grande, poiché possono peggiorare le prestazioni del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione minima del working set non è valida. Deve essere maggiore o uguale alla dimensione minima del working set.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile recuperare le informazioni sul working set dalla risorsa di processo associata.  
  
 oppure  
  
 L'identificatore di processo o l'handle di processo è zero perché il processo non è stato avviato.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.  
  
 oppure  
  
 Il processo è stato terminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la dimensione minima del working set, in byte, consentita per il processo associato.</summary>
        <value>Dimensione minima del working set richiesta in memoria per il processo, in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un'applicazione può utilizzare senza generare un errore di pagina.  
  
 Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni di esecuzione dell'applicazione, incluse le pagine nel file con estensione dll e file DLL di sistema. Working set di dimensioni maggiori, aumenta la richiesta di memoria.  
  
 Un processo ha dimensioni dei set di lavoro minimo e massimo. Ogni volta che viene creata una risorsa di processo, il sistema si riserva una quantità di memoria uguale alla minima dimensione del working set per il processo. Virtual memory manager tenta di mantenere almeno la quantità minima di memoria residenti quando il processo è attivo, ma non vengono mai superiore rispetto alla dimensione massima.  
  
 Il sistema imposta il valore predefinito del working set. È possibile modificare queste dimensioni utilizzando il <xref:System.Diagnostics.Process.MaxWorkingSet%2A> e <xref:System.Diagnostics.Process.MinWorkingSet%2A> membri. Tuttavia, l'impostazione di questi valori non garantisce che la memoria sia riservato o residenti.  
  
> [!NOTE]
>  Quando si aumenta la dimensione del working set di un processo, richiedere quantità di memoria fisica il resto del sistema. Assicurarsi di non richiedere una dimensione del set working minimo o massimo che è troppo grande, poiché possono peggiorare le prestazioni del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La dimensione minima del working set non è valida. Deve essere minore di o uguale alla dimensione massima del working set.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile recuperare le informazioni sul working set dalla risorsa di processo associata.  
  
 oppure  
  
 L'identificatore di processo o l'handle di processo è zero perché il processo non è stato avviato.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.  
  
 oppure  
  
 Il processo è stato terminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i moduli che sono stati caricati dal processo associato.</summary>
        <value>Matrice di tipo <see cref="T:System.Diagnostics.ProcessModule" /> che rappresenta i moduli caricati dal processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un modulo di processo rappresenta i file DLL o .exe che viene caricato in un determinato processo. Oggetto <xref:System.Diagnostics.ProcessModule> istanza consente di visualizzare informazioni su un modulo, inclusi il nome del modulo, nome file e i dettagli della memoria del modulo.  
  
 Un processo è possibile caricare più moduli in memoria. Ad esempio, file .exe che caricano altri file DLL dispongono di più moduli.  
  
 Dopo avere avviato il processo, la raccolta è vuota finché non il sistema ha caricato il processo. Se il processo dispone di una finestra principale, è possibile chiamare <xref:System.Diagnostics.Process.WaitForInputIdle%2A> prima di recuperare questa proprietà per assicurarsi che la raccolta è vuota quando si ottiene un elenco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.Modules" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.Modules" /> per il processo di sistema o il processo inattivo. Questi processi non contengono moduli.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di sistema non di paging, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria, in byte, allocata dal sistema per il processo associato che non può essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di sistema non di paging, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria di sistema, in byte, allocata per il processo associato che non può essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria di sistema non di paging usata dal processo, in byte. Memoria di sistema è la memoria fisica utilizzata dal sistema operativo e viene divisa in pool di paging e. Le allocazioni di memoria non paginata rimangono nella memoria di sistema e non vengono inviate al file di paging della memoria virtuale.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte del Pool non di paging** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e visualizza le statistiche di memoria punta e di codice di uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera l'evento <see cref="E:System.Diagnostics.Process.Exited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> il metodo API che genera il <xref:System.Diagnostics.Process.Exited> evento. La chiamata <xref:System.Diagnostics.Process.OnExited%2A> provoca il <xref:System.Diagnostics.Process.Exited> dell'evento ed è l'unico modo per generare l'evento utilizzando il <xref:System.Diagnostics.Process> componente. <xref:System.Diagnostics.Process.OnExited%2A> viene utilizzato principalmente per la derivazione di classi dal componente.  
  
 In alternativa alla <xref:System.Diagnostics.Process.OnExited%2A>, è possibile scrivere un proprio gestore eventi. Creare il propria delegato del gestore eventi e un metodo di gestione degli eventi.  
  
> [!NOTE]
>  Se si utilizza l'ambiente di Visual Studio, un delegato del gestore eventi (AddOnExited) e un metodo di gestione degli eventi (Process1_Exited) vengono creati automaticamente quando si trascina un <xref:System.Diagnostics.Process> componente in un form e fare doppio clic sull'icona. Il codice creato per l'esecuzione quando il <xref:System.Diagnostics.Process.Exited> viene immesso nella routine Process1_Exited si verifica. Non è necessario creare il <xref:System.Diagnostics.Process.OnExited%2A> membro, perché è già stato implementato.  
  
 Quando viene generato un evento, il gestore dell'evento viene richiamato tramite un delegato. Per una panoramica, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Diagnostics.Process.OnExited%2A> metodo in una classe derivata.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un'applicazione scrive nel proprio flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> reindirizzato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.OutputDataReceived> evento indica che l'oggetto associato <xref:System.Diagnostics.Process> ha scritto una riga, terminare con un carattere di nuova riga, nel proprio flusso <xref:System.Diagnostics.Process.StandardOutput%2A> flusso.  
  
 L'evento è abilitato durante operazioni di lettura asincrona in <xref:System.Diagnostics.Process.StandardOutput%2A>. Per avviare le operazioni di lettura asincrone, è necessario reindirizzare il <xref:System.Diagnostics.Process.StandardOutput%2A> flusso di un <xref:System.Diagnostics.Process>, aggiungere il gestore eventi per il <xref:System.Diagnostics.Process.OutputDataReceived> evento e chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Successivamente, il <xref:System.Diagnostics.Process.OutputDataReceived> evento segnala ogni volta che il processo scrive una riga reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> stream, finché il processo viene chiuso o chiama <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  L'applicazione di elaborazione dell'output asincrono deve chiamare il <xref:System.Diagnostics.Process.WaitForExit%2A> metodo per assicurarsi che il buffer di output è stato scaricato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come eseguire le operazioni di lettura asincrone sul reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso del `ipconfig` comando.  
  
 Nell'esempio viene creato un delegato per il `OutputHandler` gestore dell'evento e la associa il <xref:System.Diagnostics.Process.OutputDataReceived> evento. Il gestore eventi riceve righe di testo da reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, formatta il testo che viene salvato in una stringa di output in un secondo momento nella finestra della console dell'esempio.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di paging, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria, in byte, allocata dal processo associato che può essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di paging, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria, in byte, allocata nel file di paging della memoria virtuale per il processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria nel file di paging della memoria virtuale usata dal processo, in byte. Il sistema operativo Usa il file di paging della memoria virtuale in combinazione con memoria fisica per gestire lo spazio di indirizzi virtuali per ogni processo. Quando la memoria paginabile non è in uso, può essere trasferita nel file di paging della memoria virtuale su disco. Per ottenere le dimensioni di memoria utilizzata dal sistema operativo per il processo, utilizzare il <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> proprietà.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte File di paging** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note, quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e visualizza le statistiche di memoria punta e di codice di uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di sistema paginabile, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria, in byte, allocata dal sistema per il processo associato che può essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria di sistema paginabile, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria di sistema, in byte, allocata per il processo associato che può essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria di sistema paginabile utilizzata dal processo, in byte. Memoria di sistema è la memoria fisica utilizzata dal sistema operativo e viene divisa in pool di paging e. Quando la memoria paginabile non è in uso, può essere trasferita nel file di paging della memoria virtuale su disco. Per ottenere le dimensioni della memoria dell'applicazione utilizzata dal processo, utilizzare il <xref:System.Diagnostics.Process.PagedMemorySize64%2A> proprietà.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte del Pool di paging** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e visualizza le statistiche di memoria punta e di codice di uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità massima di memoria, in byte, nel file di paging della memoria virtuale usata dal processo associato.</summary>
        <value>Quantità massima di memoria, in byte, allocata dal processo associato che potrebbe essere scritta nel file di paging della memoria virtuale.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità massima di memoria, in byte, nel file di paging della memoria virtuale usata dal processo associato.</summary>
        <value>Quantità massima di memoria, in byte, allocata nel file di paging della memoria virtuale per il processo associato da quando è stato avviato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione massima di memoria nel file di paging della memoria virtuale usata dal processo dall'avvio, in byte. Il sistema operativo Usa il file di paging della memoria virtuale in combinazione con memoria fisica per gestire lo spazio di indirizzi virtuali per ogni processo. Quando la memoria paginabile non è in uso, può essere trasferita nel file di paging della memoria virtuale su disco.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **Byte massimi File** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e visualizza le statistiche di memoria punta e di codice di uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità massima di memoria virtuale in byte usata dal processo associato.</summary>
        <value>Quantità massima di memoria virtuale, in byte, che il processo associato ha richiesto.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità massima di memoria virtuale in byte usata dal processo associato.</summary>
        <value>Quantità massima di memoria virtuale, in byte, allocata per il processo associato da quando è stato avviato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione massima di memoria virtuale usata dal processo dall'avvio, in byte. Il sistema operativo esegue il mapping di spazio degli indirizzi virtuali per ogni processo alle pagine caricate nella memoria fisica, o per le pagine memorizzate nel file di paging della memoria virtuale su disco.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **massimo valore byte virtuali** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e visualizza le statistiche di memoria punta e di codice di uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le dimensioni di picco del working set per il processo associato in byte.</summary>
        <value>Quantità massima di memoria fisica che il processo associato ha richiesto in una sola volta in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un'applicazione può utilizzare senza generare un errore di pagina.  
  
 Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni eseguite dal processo, inclusi i moduli di processo e le librerie di sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità massima di memoria fisica in byte usata dal processo associato.</summary>
        <value>Quantità massima di memoria fisica, in byte, allocata per il processo associato da quando è stato avviato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione massima del working set di memoria utilizzata dal processo dall'avvio, in byte. Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un'applicazione può utilizzare senza generare un errore di pagina.  
  
 Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni che il processo viene eseguito, incluse le istruzioni da moduli di processo e le librerie di sistema.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **max Working Set** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e visualizza le statistiche di memoria punta e di codice di uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la priorità del processo associato deve essere incrementata temporaneamente dal sistema operativo quando la finestra principale è attiva.</summary>
        <value>
          <see langword="true" /> se va eseguito l'incremento dinamico della priorità del processo uscito dallo stato di attesa; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un thread viene eseguito in un processo per cui la classe di priorità è uno dei valori di enumerazione priorità dinamica (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, o <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), il sistema incrementa temporaneamente la priorità del thread quando viene escluso da uno stato di attesa. Questa azione impedisce ad altri processi di interrompere l'elaborazione del thread corrente. Il <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> impostazione influisce su tutti i thread esistenti e su qualsiasi thread successivamente creato dal processo. Per ripristinare il funzionamento normale, impostare il <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> proprietà `false`.  
  
> [!NOTE]
>  Aumento eccessivo della priorità può sottrarre risorse essenziali del sistema operativo e di rete, causando problemi con le altre attività del sistema operativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile recuperare le informazioni sull'aumento della priorità dalla risorsa di processo associata.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.  
  
 oppure  
  
 L'identificatore di processo o l'handle di processo è zero (il processo non è stato avviato).</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la categoria di priorità globale per il processo associato.</summary>
        <value>Categoria di priorità del processo associato, dalla quale viene calcolata la proprietà <see cref="P:System.Diagnostics.Process.BasePriority" /> del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una classe di priorità del processo include una gamma di livelli di priorità di thread. I thread con priorità diverse che sono in esecuzione nel processo di esecuzione rispetto alla classe di priorità del processo. Win32 utilizza quattro classi di priorità con sette livelli di priorità di base per ogni classe. Queste classi di priorità del processo vengono acquisite nel <xref:System.Diagnostics.ProcessPriorityClass> enumerazione, che consente di imposta la priorità del processo <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, o <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. In base al tempo trascorsi o degli altri incrementi, il livello di priorità di base possono essere modificati dal sistema operativo quando un processo deve essere inseriti prima degli altri per l'accesso al processore. Inoltre, è possibile impostare il <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> per aumentare temporaneamente il livello di priorità di thread che sono stati eseguiti dallo stato di attesa. La priorità viene reimpostata quando il processo ritorna allo stato di attesa.  
  
 Il <xref:System.Diagnostics.Process.BasePriority%2A> proprietà consente di visualizzare la priorità iniziale viene assegnata a un processo. Tuttavia, poiché è di sola lettura, è possibile utilizzare il <xref:System.Diagnostics.Process.BasePriority%2A> proprietà per impostare la priorità di un processo. Per modificare la priorità, utilizzare il <xref:System.Diagnostics.Process.PriorityClass%2A> proprietà, che ottiene o imposta la categoria di priorità globale per il processo.  
  
 La classe di priorità non può essere visualizzata utilizzando Monitor di sistema. Nella tabella seguente viene illustrata la relazione tra il <xref:System.Diagnostics.Process.BasePriority%2A> e <xref:System.Diagnostics.Process.PriorityClass%2A> valori.  
  
|BasePriority|Classe di priorità|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e viene visualizzato il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile impostare o recuperare le informazioni sulla priorità del processo dalla risorsa di processo associata.  
  
 oppure  
  
 L'identificatore di processo o l'handle di processo è zero (il processo non è stato avviato).</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.PriorityClass" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La proprietà <see cref="P:System.Diagnostics.Process.PriorityClass" /> è stata impostata su <see langword="AboveNormal" /> o <see langword="BelowNormal" /> quando si usa Windows 98 o Windows Millennium Edition (Windows Me). Queste piattaforme non supportano tali valori per la classe di priorità.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La classe di priorità non può essere impostata perché non usa un valore valido, come definito nell'enumerazione <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria privata, in byte, allocata per il processo associato.</summary>
        <value>Numero di byte allocati dal processo associato che non possono essere condivisi con altri processi.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria privata, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria, in byte, allocata per il processo associato che non può essere condivisa con altri processi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria utilizzata dal processo, in byte, che non può essere condivisa con altri processi.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte privati** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e visualizza le statistiche di memoria punta e di codice di uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tempo privilegiato del processore per questo processo.</summary>
        <value>Valore <see cref="T:System.TimeSpan" /> che indica la quantità di tempo impiegato dal processore nell'eseguire il codice all'interno del nucleo centrale del sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e viene visualizzato il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del processo.</summary>
        <value>Nome usato dal sistema per identificare il processo rispetto all'utente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.ProcessName%2A> proprietà contiene un nome di file eseguibile, ad esempio Outlook, che non include l'estensione .exe o il percorso. È utile per ottenere e modificare tutti i processi che sono associati con lo stesso file eseguibile.  
  
> [!NOTE]
>  In [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] sistemi operativi, il <xref:System.Diagnostics.Process.ProcessName%2A> proprietà può essere troncata a 15 caratteri se non è possibile ottenere le informazioni sul modulo di processo.  
  
 È possibile chiamare <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passando un nome di file eseguibile, per recuperare una matrice che contiene tutte le istanze in esecuzione nel computer specificato. È possibile utilizzare questa matrice, ad esempio, per arrestare tutte le istanze in esecuzione del file eseguibile.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il processo non ha un identificatore oppure nessun processo è associato a <see cref="T:System.Diagnostics.Process" />.  
  
 oppure  
  
 Il processo associato è stato terminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">Il processo non si trova in questo computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i processori nei quali è pianificata l'esecuzione dei thread di questo processo.</summary>
        <value>Maschera di bit che rappresenta i processori con cui è possibile eseguire i thread del processo associato. Il valore predefinito dipende dal numero di processori presenti nel computer. Il valore predefinito è 2 <sup>n</sup> -1, dove n è il numero di processori.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows 2000 e versioni successive, un thread in un processo può eseguire la migrazione da un processore, con ogni migrazione il ricaricamento di cache del processore. Carichi pesanti sistema, specificando il processore in cui deve essere eseguito un thread specifico può migliorare le prestazioni riducendo il numero di volte in cui che la cache del processore viene ricaricata più volte. L'associazione tra un processore e un thread viene chiamato l'affinità del processore.  
  
 Ogni processore viene rappresentato sotto forma di bit. Bit 0 è il processore uno, il bit 1 è il processore due e così via. Se si imposta un bit sul valore 1, il processore corrispondente viene selezionato per l'assegnazione di thread. Quando si imposta la <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valore su zero, il sistema operativo pianificazione del set di algoritmi affinità del thread. Quando il <xref:System.Diagnostics.Process.ProcessorAffinity%2A> è impostato su qualsiasi valore diverso da zero, il valore viene interpretato come maschera di bit che specifica i processori sono selezionabili.  
  
 La tabella seguente illustra una selezione di <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valori per un sistema con otto processori.  
  
|maschera di bit|Valore binario|Processori idonei|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 e 2|  
|0x0007|00000000 00000111|1, 2 e 3|  
|0x0009|00000000 00001001|1 e 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 e 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          Non è possibile impostare o recuperare le informazioni di <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> dalla risorsa del processo associato.  
  
 oppure  
  
 L'identificatore di processo o l'handle di processo è zero (il processo non è stato avviato).</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo <see cref="P:System.Diagnostics.Process.Id" /> non è disponibile.  
  
 oppure  
  
 Il processo è stato terminato.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina le informazioni relative al processo associato memorizzate nella cache all'interno del componente del processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo aver <xref:System.Diagnostics.Process.Refresh%2A> viene chiamato, la prima richiesta per informazioni su ciascuna proprietà fa sì che il componente del processo ottenere un nuovo valore dal processo associato.  
  
 Quando un <xref:System.Diagnostics.Process> è associato a una risorsa di processo, i valori delle proprietà del componente di <xref:System.Diagnostics.Process> immediatamente vengono popolati in base allo stato del processo associato. Se le informazioni relative al processo associato viene successivamente modificato, tali modifiche non vengono riflesse nel <xref:System.Diagnostics.Process> valori memorizzati nella cache del componente. Il <xref:System.Diagnostics.Process> componente è uno snapshot della risorsa di processo al momento sono associate. Per visualizzare i valori correnti per il processo associato, chiamare il <xref:System.Diagnostics.Process.Refresh%2A> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. L'utilizzo di memoria fisica del processo associato viene quindi recuperata in intervalli di 2 secondi per un massimo di 10 secondi. Nell'esempio viene rilevato se il processo viene chiuso prima che siano trascorsi 10 secondi. L'esempio chiude il processo se è ancora in esecuzione dopo 10 secondi.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'interfaccia utente del processo sta rispondendo.</summary>
        <value>
          <see langword="true" /> se l'interfaccia utente del processo associato sta rispondendo al sistema; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un processo con un'interfaccia utente, il <xref:System.Diagnostics.Process.Responding%2A> proprietà contatta l'interfaccia utente per determinare se il processo risponde all'input dell'utente. Se l'interfaccia non risponde immediatamente, il <xref:System.Diagnostics.Process.Responding%2A> restituisce proprietà `false`. Utilizzare questa proprietà per determinare se l'interfaccia del processo associato ha smesso di rispondere.  
  
 Se il processo non dispone di un <xref:System.Diagnostics.Process.MainWindowHandle%2A>, questa proprietà restituisce `true`.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e viene visualizzato il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.Responding" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'handle nativo di questo processo.</summary>
        <value>Handle nativo di questo processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'handle è disponibile solo se il componente chiamante ha avviato il processo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identificatore della sessione di Servizi terminal per il processo associato.</summary>
        <value>Identificatore della sessione di Servizi terminal per il processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Diagnostics.Process.SessionId%2A> proprietà identifica la sessione in cui è attualmente in esecuzione l'applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">A questo processo non è associata alcuna sessione.</exception>
        <exception cref="T:System.InvalidOperationException">A questo identificatore di sessione non è associato alcun processo.  
  
 oppure  
  
 Il processo associato non si trova in questo computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La proprietà <see cref="P:System.Diagnostics.Process.SessionId" /> non è supportata in Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un flusso usato per leggere l'output di errore dell'applicazione.</summary>
        <value>Oggetto <see cref="T:System.IO.StreamReader" /> che può essere usato per leggere il flusso di errore standard dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un <xref:System.Diagnostics.Process> scrive il testo nel proprio flusso di errore standard, che è in genere visualizzato nella console. Reindirizzando il <xref:System.Diagnostics.Process.StandardError%2A> flusso, è possibile modificare o eliminare l'output di errore di un processo. Ad esempio, è possibile filtrare il testo, formattarlo in modo diverso o scrivere l'output sia nella console e un determinato file di log.  
  
> [!NOTE]
>  Per utilizzare <xref:System.Diagnostics.Process.StandardError%2A>, è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> a `false`, ed è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> a `true`. In caso contrario, leggere la <xref:System.Diagnostics.Process.StandardError%2A> flusso genera un'eccezione.  
  
 Reindirizzato <xref:System.Diagnostics.Process.StandardError%2A> flusso può essere letto in modo sincrono o asincrono. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> eseguire le operazioni di lettura sincrona nel flusso di output di errore del processo. Questi sincrono letti operazioni non vengono completate fino a quando l'oggetto associato <xref:System.Diagnostics.Process> scrive relativo <xref:System.Diagnostics.Process.StandardError%2A> stream o chiude il flusso.  
  
 Al contrario, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> operazioni di lettura asincrona viene avviato nel <xref:System.Diagnostics.Process.StandardError%2A> flusso. Questo metodo consente a un gestore eventi designato per l'output del flusso e restituisce immediatamente al chiamante, che è possibile eseguire altro lavoro mentre l'output di flusso viene indirizzato al gestore dell'evento.  
  
 Operazioni introducono una dipendenza tra la lettura dal chiamante di lettura sincrona di <xref:System.Diagnostics.Process.StandardError%2A> flusso e il processo figlio scrive in tale flusso. Queste dipendenze possono causare condizioni di deadlock. Quando il chiamante legge dal flusso reindirizzato di un processo figlio, è dipendente dal figlio. Il chiamante attende l'operazione di lettura fino a quando l'elemento figlio scrive nel flusso o chiude il flusso. Quando il processo figlio scrive dati sufficienti per riempire il relativo flusso reindirizzato, è dipende dal padre. Il processo figlio attende durante la successiva operazione di scrittura padre legge dal flusso completo o chiude il flusso. La condizione di deadlock si verifica quando il chiamante e il processo figlio di reciproca per completare un'operazione di attesa e non può proseguire. Per evitare deadlock, è possibile valutare le dipendenze tra il chiamante e il processo figlio.  
  
 Il codice c# seguente, ad esempio, viene illustrato come leggere da un flusso reindirizzato e attendere l'uscita del processo figlio.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare una condizione di deadlock chiamando `p.StandardError.ReadToEnd` prima `p.WaitForExit`. Una condizione di deadlock può verificarsi se il processo padre chiama `p.WaitForExit` prima `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente per riempire il flusso reindirizzato. Il processo padre rimarrebbe indefinitamente in attesa per l'uscita del processo figlio. Il processo figlio rimarrebbe indefinitamente in attesa per l'elemento padre da cui leggere la versione completa <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 Si verifica un problema simile durante la lettura di tutto il testo di output standard e flussi di errore standard. Il codice c# seguente, ad esempio, esegue un'operazione di lettura su entrambi i flussi.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare la condizione di deadlock mediante l'esecuzione asincrona di operazioni di lettura di <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Risultati di una condizione di deadlock se il processo padre chiama `p.StandardOutput.ReadToEnd` seguito da `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente per riempire il relativo flusso di errore. Il processo padre rimarrebbe indefinitamente in attesa per il processo figlio chiudere la <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Il processo figlio rimarrebbe indefinitamente in attesa per l'elemento padre da cui leggere la versione completa <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 Per evitare queste dipendenze e i potenziali deadlock, è possibile utilizzare le operazioni di lettura asincrone. In alternativa, è possibile evitare la condizione di deadlock creando due thread e leggendo l'output di ogni flusso in un thread separato.  
  
> [!NOTE]
>  È possibile combinare le operazioni di lettura asincrone e sincrone su un flusso reindirizzato. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità. Ad esempio, non seguire <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> con una chiamata a <xref:System.IO.StreamReader.ReadLine%2A> sul <xref:System.Diagnostics.Process.StandardError%2A> flusso, o viceversa. Tuttavia, è possibile leggere due flussi diversi in modalità diverse. Ad esempio, è possibile chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A> per il <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
   
  
## Examples  
 L'esempio seguente usa il `net use` comando insieme a un utente fornisca gli argomenti per eseguire il mapping di una risorsa di rete. Quindi legge il flusso di errore standard del comando net e lo scrive nella console.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso <see cref="P:System.Diagnostics.Process.StandardError" /> non è stato definito per il reindirizzamento; assicurarsi che <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> sia impostato su <see langword="true" /> e che <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> sia impostato su <see langword="false" />.  
  
 \- oppure -  
  
 Il flusso <see cref="P:System.Diagnostics.Process.StandardError" /> è stato aperto per operazioni di lettura asincrona con <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un flusso usato per scrivere l'input dell'applicazione.</summary>
        <value>Oggetto <see cref="T:System.IO.StreamWriter" /> che può essere usato per scrivere il flusso di input standard dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Diagnostics.Process> può leggere il testo di input dal flusso di input standard, in genere la tastiera. Reindirizzando il <xref:System.Diagnostics.Process.StandardInput%2A> flusso, è possibile specificare a livello di codice l'input. Anziché utilizzare l'input da tastiera, ad esempio, è possibile fornire il testo dal contenuto di un file specificato o output da un'altra applicazione.  
  
> [!NOTE]
>  Per utilizzare <xref:System.Diagnostics.Process.StandardInput%2A>, è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> a `false`, ed è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> a `true`. In caso contrario, la scrittura di <xref:System.Diagnostics.Process.StandardInput%2A> flusso genera un'eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come reindirizzare il <xref:System.Diagnostics.Process.StandardInput%2A> flusso di un processo. Nell'esempio viene avviato il `sort` con input reindirizzato. Quindi richiesto il testo e lo passa al `sort` processo mezzo reindirizzato <xref:System.Diagnostics.Process.StandardInput%2A> flusso. Il `sort` risultati vengono visualizzati all'utente nella console.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso <see cref="P:System.Diagnostics.Process.StandardInput" /> non è stato definito perché la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> è impostata su <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un flusso usato per leggere l'output dell'applicazione.</summary>
        <value>Oggetto <see cref="T:System.IO.StreamReader" /> che può essere usato per leggere il flusso di output standard dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un <xref:System.Diagnostics.Process> scrive il testo nel proprio flusso standard, che è in genere visualizzato nella console. Reindirizzando il <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, è possibile modificare o eliminare l'output di un processo. Ad esempio, è possibile filtrare il testo, formattarlo in modo diverso o scrivere l'output sia nella console e un determinato file di log.  
  
> [!NOTE]
>  Per utilizzare <xref:System.Diagnostics.Process.StandardOutput%2A>, è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> a `false`, ed è necessario impostare <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> a `true`. In caso contrario, leggere la <xref:System.Diagnostics.Process.StandardOutput%2A> flusso genera un'eccezione.  
  
 Reindirizzato <xref:System.Diagnostics.Process.StandardOutput%2A> flusso può essere letto in modo sincrono o asincrono. I metodi come <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> eseguire le operazioni di lettura sincrona nel flusso di output del processo. Questi sincrono letti operazioni non vengono completate fino a quando l'oggetto associato <xref:System.Diagnostics.Process> scrive relativo <xref:System.Diagnostics.Process.StandardOutput%2A> stream o chiude il flusso.  
  
 Al contrario, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> operazioni di lettura asincrona viene avviato nel <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Questo metodo consente a un gestore eventi designato per l'output del flusso e restituisce immediatamente al chiamante, che è possibile eseguire altro lavoro mentre l'output di flusso viene indirizzato al gestore dell'evento.  
  
 Operazioni introducono una dipendenza tra la lettura dal chiamante di lettura sincrona di <xref:System.Diagnostics.Process.StandardOutput%2A> flusso e il processo figlio scrive in tale flusso. Queste dipendenze possono causare condizioni di deadlock. Quando il chiamante legge dal flusso reindirizzato di un processo figlio, è dipendente dal figlio. Il chiamante attende l'operazione di lettura fino a quando l'elemento figlio scrive nel flusso o chiude il flusso. Quando il processo figlio scrive dati sufficienti per riempire il relativo flusso reindirizzato, è dipende dal padre. Il processo figlio attende durante la successiva operazione di scrittura padre legge dal flusso completo o chiude il flusso. La condizione di deadlock si verifica quando il chiamante e il processo figlio di reciproca per completare un'operazione di attesa e non può proseguire. Per evitare deadlock, è possibile valutare le dipendenze tra il chiamante e il processo figlio.  
  
 Il codice c# seguente, ad esempio, viene illustrato come leggere da un flusso reindirizzato e attendere l'uscita del processo figlio.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare una condizione di deadlock chiamando `p.StandardOutput.ReadToEnd` prima `p.WaitForExit`. Una condizione di deadlock può verificarsi se il processo padre chiama `p.WaitForExit` prima `p.StandardOutput.ReadToEnd` e il processo figlio scrive testo sufficiente per riempire il flusso reindirizzato. Il processo padre rimarrebbe indefinitamente in attesa per l'uscita del processo figlio. Il processo figlio rimarrebbe indefinitamente in attesa per l'elemento padre da cui leggere la versione completa <xref:System.Diagnostics.Process.StandardOutput%2A> flusso.  
  
 Si verifica un problema simile durante la lettura di tutto il testo di output standard e flussi di errore standard. Il codice c# seguente, ad esempio, esegue un'operazione di lettura su entrambi i flussi.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 L'esempio di codice consente di evitare la condizione di deadlock mediante l'esecuzione asincrona di operazioni di lettura di <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Risultati di una condizione di deadlock se il processo padre chiama `p.StandardOutput.ReadToEnd` seguito da `p.StandardError.ReadToEnd` e il processo figlio scrive testo sufficiente per riempire il relativo flusso di errore. Il processo padre rimarrebbe indefinitamente in attesa per il processo figlio chiudere la <xref:System.Diagnostics.Process.StandardOutput%2A> flusso. Il processo figlio rimarrebbe indefinitamente in attesa per l'elemento padre da cui leggere la versione completa <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
 Per evitare queste dipendenze e i potenziali deadlock, è possibile utilizzare le operazioni di lettura asincrone. In alternativa, è possibile evitare la condizione di deadlock creando due thread e leggendo l'output di ogni flusso in un thread separato.  
  
> [!NOTE]
>  È possibile combinare le operazioni di lettura asincrone e sincrone su un flusso reindirizzato. Una volta reindirizzato di un' <xref:System.Diagnostics.Process> viene aperto in modalità sincrona o asincrona, tutte le successive lettura operazioni su tale flusso devono essere nella stessa modalità. Ad esempio, non seguire <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> con una chiamata a <xref:System.IO.StreamReader.ReadLine%2A> sul <xref:System.Diagnostics.Process.StandardOutput%2A> flusso, o viceversa. Tuttavia, è possibile leggere due flussi diversi in modalità diverse. Ad esempio, è possibile chiamare <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e quindi chiamare <xref:System.IO.StreamReader.ReadLine%2A> per il <xref:System.Diagnostics.Process.StandardError%2A> flusso.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguito il comando ipconfig.exe e reindirizza l'output standard finestra della console dell'esempio.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> non è stato definito per il reindirizzamento; assicurarsi che <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> sia impostato su <see langword="true" /> e che <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> sia impostato su <see langword="false" />.  
  
 \- oppure -  
  
 Il flusso <see cref="P:System.Diagnostics.Process.StandardOutput" /> è stato aperto per operazioni di lettura asincrona con <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia una risorsa di processo e la associa a un componente <see cref="T:System.Diagnostics.Process" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia (o riutilizza) la risorsa di processo specificata dalla proprietà <see cref="P:System.Diagnostics.Process.StartInfo" /> di questo componente <see cref="T:System.Diagnostics.Process" /> e la associa al componente.</summary>
        <returns>
          <see langword="true" /> se viene avviata una risorsa di processo, <see langword="false" /> se non viene avviata alcuna risorsa di processo nuova (ad esempio, se è stato riutilizzato un processo esistente).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per avviare una risorsa di processo e associarlo all'oggetto corrente <xref:System.Diagnostics.Process> componente. Il valore restituito `true` indica che è stata avviata una nuova risorsa di processo. Se la risorsa di processo specificato per il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà è già in esecuzione nel computer, viene avviata alcuna risorsa di processo aggiuntivo. Risorsa di processo in esecuzione, invece, viene riutilizzato e `false` viene restituito.  
  
 È possibile avviare un'applicazione ClickOnce specificando il percorso da cui è stato installato l'applicazione (ad esempio, un indirizzo Web). Avviare un'applicazione ClickOnce specificandone il percorso di installazione sul disco rigido.  
  
> [!NOTE]
>  Se si utilizza Visual Studio, questo overload del metodo di <xref:System.Diagnostics.Process.Start%2A> metodo è quello che viene inserito il codice dopo avere trascinato un <xref:System.Diagnostics.Process> componente nella finestra di progettazione. Utilizzare il `Properties` finestra per espandere il `StartInfo` categoria e scrivere il valore appropriato nel `FileName` proprietà. Le modifiche verranno visualizzate del modulo `InitializeComponent` stored procedure.  
  
 Questo overload di <xref:System.Diagnostics.Process.Start%2A> non è un `static` metodo. È necessario chiamarlo da un'istanza di <xref:System.Diagnostics.Process> classe. Prima di chiamare <xref:System.Diagnostics.Process.Start%2A>, è necessario innanzitutto specificare <xref:System.Diagnostics.Process.StartInfo%2A> informazioni sulle proprietà per questo <xref:System.Diagnostics.Process> istanza, in quanto tali informazioni vengono utilizzate per determinare la risorsa di processo da avviare.  
  
 Gli altri overload di <xref:System.Diagnostics.Process.Start%2A> metodo `static` membri. Non è necessario creare un'istanza di <xref:System.Diagnostics.Process> componente prima di chiamare l'overload del metodo. In alternativa, è possibile chiamare <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> classe stesso e un nuovo <xref:System.Diagnostics.Process> se è stato avviato il processo di creazione del componente. In alternativa, `null` viene restituito se è stato riutilizzato un processo. Viene automaticamente associata alla nuova risorsa di processo <xref:System.Diagnostics.Process> componente restituito dal <xref:System.Diagnostics.Process.Start%2A> metodo.  
  
 Il <xref:System.Diagnostics.Process.StartInfo%2A> membri possono essere utilizzati per riprodurre la funzionalità del `Run` delle finestre di dialogo `Start` menu. Qualsiasi che possono essere digitati nella riga di comando può essere avviato impostando i valori appropriati <xref:System.Diagnostics.Process.StartInfo%2A> proprietà. L'unico <xref:System.Diagnostics.Process.StartInfo%2A> è di proprietà che è necessario impostare il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà. Il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà non deve essere un file eseguibile. Può trattarsi di qualsiasi tipo di file per cui l'estensione è stata associata a un'applicazione installata nel sistema. Ad esempio, il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà può avere estensione txt se sono stati associati file di testo con un editor, ad esempio Blocco note, oppure può avere un'estensione doc se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word.  
  
 Nella riga di comando, è possibile specificare le azioni da intraprendere per determinati tipi di file. Ad esempio, è possibile stampare documenti o modificare i file di testo. Specificare queste azioni utilizzando il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> appartenente il <xref:System.Diagnostics.Process.StartInfo%2A> proprietà. Per altri tipi di file, è possibile specificare gli argomenti della riga di comando quando si avvia il file di `Run` la finestra di dialogo. Ad esempio, è possibile passare un URL come argomento se si specifica il browser come il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Questi argomenti possono essere specificati nel <xref:System.Diagnostics.Process.StartInfo%2A> della proprietà <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> membro.  
  
 Se si dispone di una variabile di percorso nel sistema utilizzando le virgolette, è necessario qualificare completamente il percorso all'avvio dei processi in tale percorso. In caso contrario, il sistema non troverà il percorso. Ad esempio, se `c:\mypath` non è presente nel percorso, e si aggiunge utilizzando le virgolette: `path = %path%;"c:\mypath"`, è necessario qualificare completamente qualsiasi processo in `c:\mypath` per l'avvio.  
  
> [!NOTE]
>  Codice di controllo di pagina e il server Web ASP.NET viene eseguito nel contesto del processo di lavoro ASP.NET nel server Web.  Se si utilizza il <xref:System.Diagnostics.Process.Start%2A> metodo in una pagina Web ASP.NET o un controllo server, il nuovo processo viene eseguito sul server Web con autorizzazioni limitate. Il processo non viene avviato nello stesso contesto nel browser client e non dispone dell'accesso al desktop dell'utente.  
  
 Quando si utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudere i processi utilizzando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile verificare se un processo è già stato chiuso mediante il relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà.  
  
 Questo caso, è necessaria una nota sugli stati di apartment di thread gestiti. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> è `true` del componente di processo <xref:System.Diagnostics.Process.StartInfo%2A> proprietà, è necessario impostare un modello di threading dell'applicazione impostando l'attributo `[STAThread]` sul `main()` metodo. In caso contrario, un thread gestito può essere un `unknown` stato o inserire nel `MTA` stato, quest ' ultimo che è in conflitto con <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> da `true`. Alcuni metodi richiedono che lo stato dell'apartment non essere `unknown`. Se lo stato non è esplicitamente impostato, quando l'applicazione rileva tale metodo, per impostazione predefinita `MTA`, e una volta impostato, lo stato dell'apartment non può essere modificato. Tuttavia, `MTA` genererà un'eccezione generata quando la shell del sistema operativo gestisce il thread.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata un'istanza di <xref:System.Diagnostics.Process> classe per avviare un processo.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è stato specificato alcun nome file nella proprietà <see cref="P:System.Diagnostics.Process.StartInfo" /> del componente <see cref="T:System.Diagnostics.Process" />.
 -oppure- Il membro <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> della proprietà <see cref="P:System.Diagnostics.Process.StartInfo" /> è <see langword="true" /> mentre <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> o <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> è <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metodo non supportato nei sistemi operativi senza supporto della shell, ad esempio Nano Server (solo .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">Oggetto <see cref="T:System.Diagnostics.ProcessStartInfo" /> che contiene le informazioni usate per avviare il processo, tra cui il nome file e gli eventuali argomenti della riga di comando.</param>
        <summary>Avvia la risorsa di processo specificata dal parametro contenente le informazioni di avvio del processo (ad esempio, il nome file del processo da avviare) e associa la risorsa a un nuovo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuovo <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo o <see langword="null" /> se non viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, l'avvio può restituire un processo non Null con la relativa proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> già impostata su <see langword="true" />. In questo caso, è possibile che il processo avviato abbia attivato un'istanza esistente di se stesso e quindi sia terminato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per avviare una risorsa di processo specificando un <xref:System.Diagnostics.ProcessStartInfo> istanza. L'overload associa la risorsa a un nuovo <xref:System.Diagnostics.Process> oggetto.  
  
> [!NOTE]
>  Se l'indirizzo del file eseguibile da avviare è un URL, il processo non è stato avviato e `null` viene restituito.  
  
 Questo overload consente di avviare un processo senza prima creare un nuovo <xref:System.Diagnostics.Process> istanza. Utilizza questo overload con un <xref:System.Diagnostics.ProcessStartInfo> parametro costituisce un'alternativa alle fasi esplicite di creazione di un nuovo <xref:System.Diagnostics.Process> istanza, l'impostazione relativa <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> istanza.  
  
 Utilizzando un <xref:System.Diagnostics.ProcessStartInfo> istanza come parametro consente di chiamare <xref:System.Diagnostics.Process.Start%2A> con il maggior controllo su ciò che viene passato nella chiamata per avviare il processo. Se è necessario passare solo un nome file o un nome di file e gli argomenti, non è necessario creare un nuovo <xref:System.Diagnostics.ProcessStartInfo> istanza, anche se questa opzione è. L'unico <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> è di proprietà che è necessario impostare il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà. Il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà non ha bisogno rappresentare un file eseguibile. Può trattarsi di qualsiasi tipo di file per cui l'estensione è stata associata a un'applicazione installata nel sistema. Ad esempio, il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà può avere estensione txt se sono stati associati file di testo con un editor, ad esempio Blocco note, oppure può avere un'estensione doc se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word.  
  
 È possibile avviare un'applicazione ClickOnce specificando il percorso da cui è stato installato l'applicazione (ad esempio, un indirizzo Web). Avviare un'applicazione ClickOnce specificandone il percorso di installazione sul disco rigido.  
  
 Se il <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> le proprietà del <xref:System.Diagnostics.Process.StartInfo%2A> istanza vengono impostati, non gestito `CreateProcessWithLogonW` funzione viene chiamata, che avvia il processo di una nuova finestra, anche se il <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> valore della proprietà è `true` o il <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> valore della proprietà è <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Se il <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> proprietà `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> proprietà deve essere nel formato UPN, *utente*@*DNS_domain_name*.   
  
 A differenza di altri overload, il metodo di overload <xref:System.Diagnostics.Process.Start%2A> che non dispone di parametri non è un `static` membro. Utilizzare questo overload quando è già stato creato un <xref:System.Diagnostics.Process> istanza, le informazioni di avvio specificato (incluso il nome di file) e si desidera avviare una risorsa di processo e associarlo a esistente <xref:System.Diagnostics.Process> istanza. Utilizzare uno del `static` overload quando si desidera creare un nuovo <xref:System.Diagnostics.Process> componente piuttosto che avviare un processo per un componente esistente. Questo overload sia l'overload senza parametri consentono di specificare le informazioni di avvio per la risorsa di processo utilizzando un <xref:System.Diagnostics.ProcessStartInfo> istanza.  
  
 Se si dispone di una variabile di percorso nel sistema utilizzando le virgolette, è necessario qualificare completamente il percorso all'avvio dei processi in tale percorso. In caso contrario, il sistema non troverà il percorso. Ad esempio, se `c:\mypath` non è presente nel percorso, e si aggiunge utilizzando le virgolette: `path = %path%;"c:\mypath"`, è necessario qualificare completamente qualsiasi processo in `c:\mypath` per l'avvio.  
  
> [!NOTE]
>  Codice di controllo di pagina e il server Web ASP.NET viene eseguito nel contesto del processo di lavoro ASP.NET nel server Web.  Se si utilizza il <xref:System.Diagnostics.Process.Start%2A> metodo in una pagina Web ASP.NET o un controllo server, il nuovo processo viene eseguito sul server Web con autorizzazioni limitate. Il processo non viene avviato nello stesso contesto nel browser client e non dispone dell'accesso al desktop dell'utente.  
  
 Quando si utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudere i processi utilizzando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile verificare se un processo è già stato chiuso mediante il relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà.  
  
 Questo caso, è necessaria una nota sugli stati di apartment di thread gestiti. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> è `true` sul `startInfo` parametro, è necessario impostare un modello di threading dell'applicazione impostando l'attributo `[STAThread]` sul `main()` metodo. In caso contrario, un thread gestito può essere un `unknown` stato o inserire nel `MTA` stato, quest ' ultimo che è in conflitto con <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> da `true`. Alcuni metodi richiedono che lo stato dell'apartment non essere `unknown`. Se lo stato non è esplicitamente impostato, quando l'applicazione rileva tale metodo, per impostazione predefinita `MTA`, e una volta impostato, lo stato dell'apartment non può essere modificato. Tuttavia, `MTA` genererà un'eccezione generata quando la shell del sistema operativo gestisce il thread.  
  
   
  
## Examples  
 Nell'esempio seguente viene innanzitutto generata un'istanza di Internet Explorer e visualizza il contenuto della cartella Preferiti nel browser. Quindi avvia alcune altre istanze di Internet Explorer e consente di visualizzare alcune pagine specifiche o siti. Infine, viene avviato Internet Explorer con la finestra ridotta a icona durante l'esplorazione di un sito specifico.  
  
 Per ulteriori esempi di altri utilizzi di questo metodo, vedere le singole proprietà di <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è stato specificato alcun nome file nella proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> del parametro <paramref name="startInfo" />.  
  
 oppure  
  
 La proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> del parametro <paramref name="startInfo" /> è <see langword="true" /> e anche la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> o <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> è <see langword="true" />.  
  
 oppure  
  
 La proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> del parametro <paramref name="startInfo" /> è <see langword="true" /> e la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> non è <see langword="null" /> o vuota oppure la proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> non è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="startInfo" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il file specificato nella proprietà <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> del parametro <paramref name="startInfo" /> non è stato trovato.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.  
  
 oppure  
  
 La somma della lunghezza degli argomenti e della lunghezza del percorso completo del processo supera i 2080 caratteri. Il messaggio di errore associato a questa eccezione può essere uno dei seguenti: "L'area dati passata a una chiamata di sistema è troppo piccola." oppure "Accesso negato".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metodo non supportato nei sistemi operativi senza supporto della shell, ad esempio Nano Server (solo .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome di un documento o di un file di applicazione da eseguire nel processo.</param>
        <summary>Avvia una risorsa di processo specificando il nome di un documento o un file di applicazione e associa la risorsa a un nuovo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuovo <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo o <see langword="null" /> se non viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, l'avvio può restituire un processo non Null con la relativa proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> già impostata su <see langword="true" />. In questo caso, è possibile che il processo avviato abbia attivato un'istanza esistente di se stesso e quindi sia terminato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per avviare una risorsa di processo specificando il nome del file. L'overload associa la risorsa a un nuovo <xref:System.Diagnostics.Process> oggetto.  
  
> [!NOTE]
>  Se l'indirizzo del file eseguibile da avviare è un URL, il processo non è stato avviato e `null` viene restituito.  
  
 Questo overload consente di avviare un processo senza prima creare un nuovo <xref:System.Diagnostics.Process> istanza. L'overload costituisce un'alternativa alle fasi esplicite di creazione di un nuovo <xref:System.Diagnostics.Process> istanza, l'impostazione di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> istanza.  
  
 È possibile avviare un'applicazione ClickOnce impostando il `fileName` parametro per il percorso da cui è stato installato l'applicazione (ad esempio, un indirizzo Web). Avviare un'applicazione ClickOnce specificandone il percorso di installazione sul disco rigido.  
  
 Avvio di un processo specificando il nome del file è simile alla digitazione delle informazioni nel `Run` delle finestre di dialogo `Start` menu. Pertanto, non è necessario che il nome del file rappresentano un file eseguibile. Può trattarsi di qualsiasi tipo di file per cui l'estensione è stata associata a un'applicazione installata nel sistema. Ad esempio il nome del file può avere un'estensione. txt se sono stati associati file di testo con un editor, ad esempio Blocco note, oppure può avere un file con estensione doc se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word. Analogamente, nello stesso modo in cui il `Run` la finestra di dialogo può accettare un nome di file eseguibile con o senza l'estensione .exe, l'estensione .exe è facoltativa nel `fileName` parametro. Ad esempio, è possibile impostare il `fileName` parametro "Notepad.exe" o "Notepad".  
  
 Questo overload non consente argomenti della riga di comando per il processo. Se è necessario specificare uno o più argomenti della riga di comando per il processo, utilizzare il <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> o <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> overload.  
  
 A differenza di altri overload, il metodo di overload <xref:System.Diagnostics.Process.Start%2A> che non dispone di parametri non è un `static` membro. Utilizzare questo overload quando è già stato creato un <xref:System.Diagnostics.Process> istanza, le informazioni di avvio specificato (incluso il nome di file) e si desidera avviare una risorsa di processo e associarlo a esistente <xref:System.Diagnostics.Process> istanza. Utilizzare uno del `static` overload quando si desidera creare un nuovo <xref:System.Diagnostics.Process> componente piuttosto che avviare un processo per un componente esistente. Questo overload sia l'overload senza parametri consente di specificare il nome del file di risorsa di processo da avviare.  
  
 Se si dispone di una variabile di percorso nel sistema utilizzando le virgolette, è necessario qualificare completamente il percorso all'avvio dei processi in tale percorso. In caso contrario, il sistema non troverà il percorso. Ad esempio, se `c:\mypath` non è presente nel percorso, e si aggiunge utilizzando le virgolette: `path = %path%;"c:\mypath"`, è necessario qualificare completamente qualsiasi processo in `c:\mypath` per l'avvio.  
  
> [!NOTE]
>  Codice di controllo di pagina e il server Web ASP.NET viene eseguito nel contesto del processo di lavoro ASP.NET nel server Web.  Se si utilizza il <xref:System.Diagnostics.Process.Start%2A> metodo in una pagina Web ASP.NET o un controllo server, il nuovo processo viene eseguito sul server Web con autorizzazioni limitate. Il processo non viene avviato nello stesso contesto nel browser client e non dispone dell'accesso al desktop dell'utente.  
  
 Quando si utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudere i processi utilizzando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile verificare se un processo è già stato chiuso mediante il relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà.  
  
 Questo caso, è necessaria una nota sugli stati di apartment di thread gestiti. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> è `true` del componente di processo <xref:System.Diagnostics.Process.StartInfo%2A> proprietà, è necessario impostare un modello di threading dell'applicazione impostando l'attributo `[STAThread]` sul `main()` metodo. In caso contrario, un thread gestito può essere un `unknown` stato o inserire nel `MTA` stato, quest ' ultimo che è in conflitto con <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> da `true`. Alcuni metodi richiedono che lo stato dell'apartment non essere `unknown`. Se lo stato non è esplicitamente impostato, quando l'applicazione rileva tale metodo, per impostazione predefinita `MTA`, e una volta impostato, lo stato dell'apartment non può essere modificato. Tuttavia, `MTA` genererà un'eccezione generata quando la shell del sistema operativo gestisce il thread.  
  
   
  
## Examples  
 Nell'esempio seguente viene innanzitutto generata un'istanza di Internet Explorer e visualizza il contenuto della cartella Preferiti nel browser. Quindi avvia alcune altre istanze di Internet Explorer e consente di visualizzare alcune pagine specifiche o siti. Infine, viene avviato Internet Explorer con la finestra ridotta a icona durante l'esplorazione di un sito specifico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">La variabile di ambiente PATH include una stringa che contiene virgolette.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome di un file di applicazione da eseguire nel processo.</param>
        <param name="arguments">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <summary>Avvia una risorsa di processo specificando il nome di un'applicazione e un insieme di argomenti della riga di comando e associa la risorsa a un nuovo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuovo <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo o <see langword="null" /> se non viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, l'avvio può restituire un processo non Null con la relativa proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> già impostata su <see langword="true" />. In questo caso, è possibile che il processo avviato abbia attivato un'istanza esistente di se stesso e quindi sia terminato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per avviare una risorsa di processo specificando il nome file e gli argomenti della riga di comando. L'overload associa la risorsa a un nuovo <xref:System.Diagnostics.Process> oggetto.  
  
> [!NOTE]
>  Se l'indirizzo del file eseguibile da avviare è un URL, il processo non è stato avviato e `null` viene restituito.  
  
 Questo overload consente di avviare un processo senza prima creare un nuovo <xref:System.Diagnostics.Process> istanza. L'overload costituisce un'alternativa alle fasi esplicite di creazione di un nuovo <xref:System.Diagnostics.Process> istanza, l'impostazione di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> e <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> i membri del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> istanza.  
  
 Avvio di un processo specificando il nome del file e gli argomenti è simile all'immissione del nome e argomenti della riga di comando di `Run` delle finestre di dialogo `Start` menu. Pertanto, non è necessario che il nome del file rappresentano un file eseguibile. Può trattarsi di qualsiasi tipo di file per cui l'estensione è stata associata a un'applicazione installata nel sistema. Ad esempio il nome del file può avere un'estensione. txt se sono stati associati file di testo con un editor, ad esempio Blocco note, oppure può avere un file con estensione doc se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word. Analogamente, nello stesso modo in cui il `Run` la finestra di dialogo può accettare un nome di file eseguibile con o senza l'estensione .exe, l'estensione .exe è facoltativa nel `fileName` parametro. Ad esempio, è possibile impostare il `fileName` parametro "Notepad.exe" o "Notepad". Se il `fileName` parametro rappresenta un file eseguibile, la `arguments` parametro potrebbe rappresentare un file per eseguire un'azione, ad esempio file di testo in `Notepad.exe myfile.txt`. Se il `fileName` parametro rappresenta un file di comando (cmd), il `arguments` parametro deve includere un "`/c`"o"`/k`" argomento per specificare se la finestra di comando viene chiusa o rimane dopo il completamento.  
  
 A differenza di altri overload, il metodo di overload <xref:System.Diagnostics.Process.Start%2A> che non dispone di parametri non è un `static` membro. Utilizzare questo overload quando è già stato creato un <xref:System.Diagnostics.Process> istanza, le informazioni di avvio specificato (incluso il nome di file) e si desidera avviare una risorsa di processo e associarlo a esistente <xref:System.Diagnostics.Process> istanza. Utilizzare uno del `static` overload quando si desidera creare un nuovo <xref:System.Diagnostics.Process> componente piuttosto che avviare un processo per un componente esistente. Questo overload sia l'overload senza parametri consente di specificare il nome del file della risorsa di processo per avviare e argomenti della riga di comando da passare.  
  
 Se si dispone di una variabile di percorso nel sistema utilizzando le virgolette, è necessario qualificare completamente il percorso all'avvio dei processi in tale percorso. In caso contrario, il sistema non troverà il percorso. Ad esempio, se `c:\mypath` non è presente nel percorso, e si aggiunge utilizzando le virgolette: `path = %path%;"c:\mypath"`, è necessario qualificare completamente qualsiasi processo in `c:\mypath` per l'avvio.  
  
> [!NOTE]
>  Codice di controllo di pagina e il server Web ASP.NET viene eseguito nel contesto del processo di lavoro ASP.NET nel server Web.  Se si utilizza il <xref:System.Diagnostics.Process.Start%2A> metodo in una pagina Web ASP.NET o un controllo server, il nuovo processo viene eseguito sul server Web con autorizzazioni limitate. Il processo non viene avviato nello stesso contesto nel browser client e non dispone dell'accesso al desktop dell'utente.  
  
 Quando si utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudere i processi utilizzando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile verificare se un processo è già stato chiuso mediante il relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà...  
  
 Questo caso, è necessaria una nota sugli stati di apartment di thread gestiti. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> è `true` del componente di processo <xref:System.Diagnostics.Process.StartInfo%2A> proprietà, è necessario impostare un modello di threading dell'applicazione impostando l'attributo `[STAThread]` sul `main()` metodo. In caso contrario, un thread gestito può essere un `unknown` stato o inserire nel `MTA` stato, quest ' ultimo che è in conflitto con <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> da `true`. Alcuni metodi richiedono che lo stato dell'apartment non essere `unknown`. Se lo stato non è esplicitamente impostato, quando l'applicazione rileva tale metodo, per impostazione predefinita `MTA`, e una volta impostato, lo stato dell'apartment non può essere modificato. Tuttavia, `MTA` genererà un'eccezione generata quando la shell del sistema operativo gestisce il thread.  
  
   
  
## Examples  
 Nell'esempio seguente viene innanzitutto generata un'istanza di Internet Explorer e visualizza il contenuto della cartella Preferiti nel browser. Quindi avvia alcune altre istanze di Internet Explorer e consente di visualizzare alcune pagine specifiche o siti. Infine, viene avviato Internet Explorer con la finestra ridotta a icona durante l'esplorazione di un sito specifico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il parametro <paramref name="fileName" /> o il parametro <paramref name="arguments" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.  
  
 oppure  
  
 La somma della lunghezza degli argomenti e della lunghezza del percorso completo del processo supera i 2080 caratteri. Il messaggio di errore associato a questa eccezione può essere uno dei seguenti: "L'area dati passata a una chiamata di sistema è troppo piccola." oppure "Accesso negato".</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">La variabile di ambiente PATH include una stringa che contiene virgolette.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome di un file di applicazione da eseguire nel processo.</param>
        <param name="userName">Nome utente da usare all'avvio del processo.</param>
        <param name="password">Classe <see cref="T:System.Security.SecureString" /> contenente la password da usare all'avvio del processo.</param>
        <param name="domain">Dominio da usare all'avvio del processo.</param>
        <summary>Avvia una risorsa di processo specificando il nome di un'applicazione, un nome utente, una password e un dominio e associa la risorsa a un nuovo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuovo <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo o <see langword="null" /> se non viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, l'avvio può restituire un processo non Null con la relativa proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> già impostata su <see langword="true" />. In questo caso, è possibile che il processo avviato abbia attivato un'istanza esistente di se stesso e quindi sia terminato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare un nuovo processo e il relativo thread primario specificando il nome del file, nome utente, password e dominio. Il nuovo processo viene quindi eseguito il file eseguibile specificato nel contesto di sicurezza delle credenziali specificate (utente, dominio e password).  
  
> [!NOTE]
>  Quando il file eseguibile si trova su un disco remoto, è necessario identificare la condivisione di rete mediante un identificatore uniform resource identifier (URI), non una lettera di unità collegate.  
  
> [!NOTE]
>  Se l'indirizzo del file eseguibile da avviare è un URL, il processo non è stato avviato e `null` viene restituito.  
  
 Questo overload consente di avviare un processo senza prima creare un nuovo <xref:System.Diagnostics.Process> istanza. L'overload costituisce un'alternativa alle fasi esplicite di creazione di un nuovo <xref:System.Diagnostics.Process> istanza, l'impostazione di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> le proprietà del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> istanza.  
  
 Analogamente, nello stesso modo in cui il **eseguire** la finestra di dialogo può accettare un nome di file eseguibile con o senza l'estensione .exe, l'estensione .exe è facoltativa nel `fileName` parametro. Ad esempio, è possibile impostare il `fileName` parametro "Notepad.exe" o "Notepad". Se il `fileName` parametro rappresenta un file eseguibile, la `arguments` parametro potrebbe rappresentare un file per eseguire un'azione, ad esempio file di testo in `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Il nome del file deve rappresentare un file eseguibile nel <xref:System.Diagnostics.Process.Start%2A> gli overload che hanno `userName`, `password`, e `domain` parametri.  
  
 Quando si utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudere i processi utilizzando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile verificare se un processo è già stato chiuso mediante il relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà...  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare questo overload per avviare un file eseguibile e viene inoltre la generazione di un <xref:System.ComponentModel.Win32Exception> quando viene effettuato un tentativo di avviare un'applicazione associata a un file non eseguibile.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessun nome file specificato.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metodo non supportato in Linux o macOS (solo .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nome di un file di applicazione da eseguire nel processo.</param>
        <param name="arguments">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <param name="userName">Nome utente da usare all'avvio del processo.</param>
        <param name="password">Classe <see cref="T:System.Security.SecureString" /> contenente la password da usare all'avvio del processo.</param>
        <param name="domain">Dominio da usare all'avvio del processo.</param>
        <summary>Avvia una risorsa di processo specificando il nome di un'applicazione e un insieme di argomenti della riga di comando, un nome utente, una password e un dominio, e associa la risorsa a un nuovo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuovo <see cref="T:System.Diagnostics.Process" /> associato alla risorsa di processo o <see langword="null" /> se non viene avviata alcuna risorsa di processo. Si noti che un nuovo processo avviato parallelamente a istanze dello stesso processo già in esecuzione sarà indipendente dalle altre. Inoltre, l'avvio può restituire un processo non Null con la relativa proprietà <see cref="P:System.Diagnostics.Process.HasExited" /> già impostata su <see langword="true" />. In questo caso, è possibile che il processo avviato abbia attivato un'istanza esistente di se stesso e quindi sia terminato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload per creare un nuovo processo e il relativo thread primario specificando il nome del file, gli argomenti della riga di comando, nome utente, password e dominio. Il nuovo processo viene quindi eseguito il file eseguibile specificato nel contesto di sicurezza delle credenziali specificate (utente, dominio e password).  
  
> [!NOTE]
>  Quando il file eseguibile si trova su un disco remoto, è necessario identificare la condivisione di rete mediante un identificatore uniform resource identifier (URI), non una lettera di unità collegate.  
  
> [!NOTE]
>  Se l'indirizzo del file eseguibile da avviare è un URL, il processo non è stato avviato e `null` viene restituito.  
  
 Questo overload consente di avviare un processo senza prima creare un nuovo <xref:System.Diagnostics.Process> istanza. L'overload costituisce un'alternativa alle fasi esplicite di creazione di un nuovo <xref:System.Diagnostics.Process> istanza, l'impostazione di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> le proprietà del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà e la chiamata <xref:System.Diagnostics.Process.Start%2A> per il <xref:System.Diagnostics.Process> istanza.  
  
 Analogamente, nello stesso modo in cui il **eseguire** la finestra di dialogo può accettare un nome di file eseguibile con o senza l'estensione .exe, l'estensione .exe è facoltativa nel `fileName` parametro. Ad esempio, è possibile impostare il `fileName` parametro "Notepad.exe" o "Notepad". Se il `fileName` parametro rappresenta un file eseguibile, la `arguments` parametro potrebbe rappresentare un file per eseguire un'azione, ad esempio file di testo in `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Il nome del file deve rappresentare un file eseguibile nel <xref:System.Diagnostics.Process.Start%2A> gli overload che hanno `userName`, `password`, e `domain` parametri.  
  
 Quando si utilizza <xref:System.Diagnostics.Process.Start%2A> per avviare un processo, potrebbe essere necessario chiuderlo o si rischia di perdere le risorse di sistema. Chiudere i processi utilizzando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. È possibile verificare se un processo è già stato chiuso mediante il relativo <xref:System.Diagnostics.Process.HasExited%2A> proprietà...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nessun nome file specificato.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore durante l'apertura del file associato.  
  
 oppure  
  
 La somma della lunghezza degli argomenti e della lunghezza del percorso completo al file associato supera 2080. Il messaggio di errore associato a questa eccezione può essere uno dei seguenti: "L'area dati passata a una chiamata di sistema è troppo piccola." oppure "Accesso negato".</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto del processo è già stato eliminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Metodo non supportato in Linux o macOS (solo .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le proprietà da passare al metodo <see cref="M:System.Diagnostics.Process.Start" /> del componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>Oggetto <see cref="T:System.Diagnostics.ProcessStartInfo" /> che rappresenta i dati con i quali avviare il processo. Tra gli argomenti sono compresi il nome del file eseguibile o il documento usato per avviare il processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> rappresenta il set di parametri da utilizzare per avviare un processo. Quando <xref:System.Diagnostics.Process.Start%2A> viene chiamato, il <xref:System.Diagnostics.Process.StartInfo%2A> viene utilizzata per specificare l'avvio del processo. Necessario solo <xref:System.Diagnostics.Process.StartInfo%2A> membro da impostare è la <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà. Avvio di un processo specificando il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà è simile a digitare le informazioni contenute nel **eseguire** delle finestre di dialogo **avviare** menu. Pertanto, il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà non ha bisogno rappresentare un file eseguibile. Può trattarsi di qualsiasi tipo di file per cui l'estensione è stata associata a un'applicazione installata nel sistema. Ad esempio il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> possono avere estensione txt se sono stati associati file di testo con un editor, ad esempio Blocco note, oppure può avere un file con estensione doc se si dispone di file doc con uno strumento di elaborazione di testi, ad esempio Microsoft Word. Analogamente, nello stesso modo in cui il **eseguire** la finestra di dialogo può accettare un nome di file eseguibile con o senza l'estensione .exe, l'estensione .exe è facoltativa nel <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro. Ad esempio, è possibile impostare il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà su "Notepad.exe" o "Notepad".  
  
 È possibile avviare un'applicazione ClickOnce impostando il <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà per il percorso da cui è stato installato l'applicazione (ad esempio, un indirizzo Web). Avviare un'applicazione ClickOnce specificandone il percorso di installazione sul disco rigido.  
  
 Se il nome del file comporta un file non eseguibile, ad esempio un file con estensione doc, è possibile includere un verbo per specificare l'azione da eseguire sul file. Ad esempio, è possibile impostare il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> a "Print" per un file con estensione doc. Il nome del file specificato nella <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà non è necessario avere un'estensione se si immette manualmente un valore per il <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> proprietà. Tuttavia, se si utilizza il <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> proprietà per determinare i verbi disponibili, è necessario includere l'estensione.  
  
 È possibile modificare i parametri specificati nel <xref:System.Diagnostics.Process.StartInfo%2A> proprietà fino al momento della chiamata di <xref:System.Diagnostics.Process.Start%2A> metodo del processo. Dopo avere avviato il processo, la modifica di <xref:System.Diagnostics.Process.StartInfo%2A> valori non influisce o riavviare il processo associato. Se si chiama il <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> metodo con il <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> set di proprietà, non gestito `CreateProcessWithLogonW` funzione viene chiamata, che avvia il processo di una nuova finestra, anche se il <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> valore della proprietà è `true` o il <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> valore della proprietà è <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Se si utilizza il <xref:System.Diagnostics.Process.Start%2A> metodo per avviare un processo, il <xref:System.Diagnostics.Process.StartInfo%2A> proprietà non riflette i parametri utilizzati per avviare il processo. Ad esempio, se si utilizza <xref:System.Diagnostics.Process.GetProcesses%2A> per ottenere una matrice di processi in esecuzione nel computer, il <xref:System.Diagnostics.Process.StartInfo%2A> proprietà di ogni <xref:System.Diagnostics.Process> non contiene il nome file originale o gli argomenti utilizzati per avviare il processo.  
  
 Quando viene avviato il processo, il nome del file è il file che compila (sola lettura) <xref:System.Diagnostics.Process.MainModule%2A> proprietà. Se si desidera recuperare il file eseguibile che viene associato al processo dopo l'avvio del processo, utilizzare il <xref:System.Diagnostics.Process.MainModule%2A> proprietà. Se si desidera impostare il file eseguibile di un <xref:System.Diagnostics.Process> dell'istanza per cui non è stato avviato un processo associato, utilizzare il <xref:System.Diagnostics.Process.StartInfo%2A> della proprietà <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro. Perché i membri del <xref:System.Diagnostics.Process.StartInfo%2A> proprietà sono argomenti passati al <xref:System.Diagnostics.Process.Start%2A> metodo di un processo, la modifica di <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> proprietà dopo l'avvio del processo associato non verrà reimpostato il <xref:System.Diagnostics.Process.MainModule%2A> proprietà. Queste proprietà vengono utilizzate solo per inizializzare il processo associato.  
  
   
  
## Examples  
 Nell'esempio seguente viene compilato un <xref:System.Diagnostics.Process.StartInfo%2A> con il file da eseguire, l'azione eseguita su di esso e se è necessario Visualizza un'interfaccia utente. Per ulteriori esempi, vedere le pagine di riferimento per le proprietà del <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore che specifica la proprietà <see cref="P:System.Diagnostics.Process.StartInfo" /> è <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'ora in cui è stato avviato il processo associato.</summary>
        <value>Oggetto che indica il momento in cui è stato avviato il processo. Viene generata un eccezione se il processo non è in esecuzione.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.StartTime" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo è stato terminato.  
  
 oppure  
  
 Il processo non è stato avviato.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Si è verificato un errore nella chiamata alla funzione di Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto usato per effettuare il marshalling delle chiamate del gestore dell'evento generate in seguito a un evento di terminazione di un processo.</summary>
        <value>Oggetto <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> usato per effettuare il marshalling delle chiamate del gestore dell'evento generate in seguito a un evento <see cref="E:System.Diagnostics.Process.Exited" /> del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> è `null`, metodi che gestiscono il <xref:System.Diagnostics.Process.Exited> eventi vengono chiamati su un thread dal pool di thread del sistema. Per ulteriori informazioni sui pool di thread del sistema, vedere <xref:System.Threading.ThreadPool>.  
  
 Quando il <xref:System.Diagnostics.Process.Exited> evento è gestito da un componente di Windows Form visivo, ad esempio un <xref:System.Windows.Forms.Button>, accesso al componente tramite il pool di thread di sistema potrebbero non funzionare o generare un'eccezione. Evitare questa situazione impostando <xref:System.Diagnostics.Process.SynchronizingObject%2A> a un componente di Windows Form, che comporta l'esecuzione di metodi che gestiscono il <xref:System.Diagnostics.Process.Exited> sullo stesso thread in cui il componente è stato creato l'evento.  
  
 Se il <xref:System.Diagnostics.Process> viene utilizzata all'interno [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in una finestra di progettazione Windows Form, <xref:System.Diagnostics.Process.SynchronizingObject%2A> viene impostata automaticamente al controllo che contiene il <xref:System.Diagnostics.Process>. Ad esempio, se si inserisce un <xref:System.Diagnostics.Process> in una finestra di progettazione per `Form1` (che eredita da <xref:System.Windows.Forms.Form>) il <xref:System.Diagnostics.Process.SynchronizingObject%2A> proprietà di <xref:System.Diagnostics.Process> è impostato per l'istanza di `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 In genere, questa proprietà è impostata quando il componente si trova all'interno di un controllo o un form, perché tali componenti sono associati a un thread specifico.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il gruppo di thread in esecuzione nel processo associato.</summary>
        <value>Matrice di tipo <see cref="T:System.Diagnostics.ProcessThread" /> che rappresenta i thread del sistema operativo attualmente in esecuzione nel processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread esegue codice in un processo. Ogni processo viene avviato con un singolo thread, il thread principale. Qualsiasi thread può creare thread aggiuntivi. Thread all'interno di un processo di condividere lo spazio degli indirizzi del processo.  
  
 Utilizzare <xref:System.Diagnostics.ProcessThread> per ottenere tutti i thread associati al processo corrente. Il thread principale non necessariamente in corrispondenza dell'indice zero nella matrice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Il processo non ha un oggetto <see cref="P:System.Diagnostics.Process.Id" /> o non sono presenti processi associati all'istanza di <see cref="T:System.Diagnostics.Process" />.  
  
 oppure  
  
 Il processo associato è stato terminato.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me); impostare <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> su <see langword="false" /> per accedere a questa proprietà in Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte il nome del processo in una stringa, combinandola al tipo di componente padre, se disponibile.</summary>
        <returns>Proprietà <see cref="P:System.Diagnostics.Process.ProcessName" />, combinata con il valore restituito <see cref="M:System.Object.ToString" /> del componente base.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e viene visualizzato il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> non è supportato in Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tempo totale del processore per questo processo.</summary>
        <value>Valore <see cref="T:System.TimeSpan" /> che indica la quantità di tempo impiegato dal processo associato nell'utilizzo della CPU. Questo valore è la somma delle proprietà <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> e <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e viene visualizzato il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tempo utente del processore per questo processo.</summary>
        <value>Valore <see cref="T:System.TimeSpan" /> che indica la quantità di tempo impiegato dal processo associato nell'esecuzione del codice all'interno della parte di applicazione del processo (non all'interno del nucleo centrale del sistema operativo).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e viene visualizzato il codice di uscita del processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <exception cref="T:System.NotSupportedException">Si sta provando ad accedere alla proprietà <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> per un processo in esecuzione in un computer remoto. Questa proprietà è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la dimensione in byte della memoria virtuale del processo.</summary>
        <value>Quantità di memoria virtuale, in byte, che il processo associato ha richiesto.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria virtuale, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria virtuale, in byte, allocata per il processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente della memoria virtuale usata dal processo, in byte. Il sistema operativo esegue il mapping di spazio degli indirizzi virtuali per ogni processo alle pagine caricate nella memoria fisica, o per le pagine memorizzate nel file di paging della memoria virtuale su disco.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **byte virtuali** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e visualizza le statistiche di memoria punta e di codice di uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta l'intervallo di tempo in base al quale attendere che il processo associato venga terminato e blocca il thread corrente di esecuzione fino alla scadenza di tale intervallo o al termine del processo. Per evitare di bloccare il thread corrente, usare l'evento <see cref="E:System.Diagnostics.Process.Exited" />.  
  
 Per esempi di codice, vedere le pagine di riferimento alle proprietà <see cref="P:System.Diagnostics.Process.StandardError" /> e <see cref="P:System.Diagnostics.Process.ExitCode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica al componente <see cref="T:System.Diagnostics.Process" /> di attendere in modo indefinito la terminazione del processo associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> Consente di attendere che il processo associato venga terminato il thread corrente.  Deve essere chiamato dopo che tutti gli altri metodi vengono chiamati nel processo. Per evitare di bloccare il thread corrente, usare l'evento <xref:System.Diagnostics.Process.Exited>.  
  
 Questo metodo indica il <xref:System.Diagnostics.Process> componente attenderà un'infinito quantità di tempo per i processo e gestori eventi uscire dall'installazione. In questo modo un'applicazione di rispondere. Ad esempio, se si chiama <xref:System.Diagnostics.Process.CloseMainWindow%2A> per un processo che dispone di un'interfaccia utente, la richiesta al sistema operativo per terminare il processo associato potrebbe non essere gestita se il processo viene scritto su mai immettere il ciclo di messaggi.  
  
> [!NOTE]
>  Nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] e versioni precedenti, il <xref:System.Diagnostics.Process.WaitForExit> overload in attesa per <xref:System.Int32.MaxValue> millisecondi (circa 24 giorni), non per un periodo illimitato. Inoltre, le versioni precedenti non si attende che i gestori eventi per l'uscita se la versione completa <xref:System.Int32.MaxValue> è stata raggiunta l'ora.  
  
 Questo overload assicura che l'elaborazione è stata completata, inclusa la gestione degli eventi asincroni per l'output standard reindirizzato. È necessario utilizzare questo overload dopo una chiamata al <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload quando l'output standard è stato reindirizzato ai gestori eventi asincroni.  
  
 Quando un processo associato viene terminato (ovvero, quando viene chiuso dal sistema operativo mediante terminazione normale o anomala), il sistema memorizza le informazioni amministrative sul processo e restituisce al componente che ha chiamato <xref:System.Diagnostics.Process.WaitForExit>. Il <xref:System.Diagnostics.Process> componente può quindi accedere alle informazioni, che include il <xref:System.Diagnostics.Process.ExitTime%2A>, utilizzando il <xref:System.Diagnostics.Process.Handle%2A> al processo terminato.  
  
 Poiché il processo associato è stato terminato, il <xref:System.Diagnostics.Process.Handle%2A> proprietà del componente non punta a una risorsa di processo esistente. Al contrario, l'handle può essere utilizzato solo per accedere alle informazioni del sistema operativo sulla risorsa di processo. Il sistema è a conoscenza di handle a processi terminati che non sono stati rilasciati da <xref:System.Diagnostics.Process> componenti, quindi conserva il <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informazioni in memoria finché il <xref:System.Diagnostics.Process> componente specificamente libera le risorse. Per questo motivo, ogni chiamata di <xref:System.Diagnostics.Process.Start%2A> per un <xref:System.Diagnostics.Process> dell'istanza, chiamare <xref:System.Diagnostics.Process.Close%2A> quando il processo associato è terminato e non è più necessario le informazioni amministrative su di esso. <xref:System.Diagnostics.Process.Close%2A> libera la memoria allocata al processo terminato.  
  
   
  
## Examples  
 Vedere la sezione Note del <xref:System.Diagnostics.Process.StandardError%2A> pagina di riferimento di proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile accedere all'impostazione di attesa.</exception>
        <exception cref="T:System.SystemException">Non è stato impostato alcun <see cref="P:System.Diagnostics.Process.Id" /> di processo e non è presente alcun <see cref="P:System.Diagnostics.Process.Handle" /> da cui è possibile determinare la proprietà <see cref="P:System.Diagnostics.Process.Id" />.  
  
 oppure  
  
 A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.  
  
 oppure  
  
 Si sta provando a chiamare <see cref="M:System.Diagnostics.Process.WaitForExit" /> per un processo in esecuzione in un computer remoto. Questo metodo è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Quantità di tempo, espressa in millisecondi, in base alla quale viene attesa la terminazione del processo associato. Il valore massimo è il valore integer a 32 bit più alto possibile, che rappresenta l'infinito per il sistema operativo.</param>
        <summary>Indica al componente <see cref="T:System.Diagnostics.Process" /> di attendere per il numero specificato di millisecondi che il processo venga terminato.</summary>
        <returns>
          <see langword="true" /> se il processo associato è stato terminato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> Consente di attendere che il processo associato venga terminato il thread corrente. Deve essere chiamato dopo che tutti gli altri metodi vengono chiamati nel processo. Per evitare di bloccare il thread corrente, usare l'evento <xref:System.Diagnostics.Process.Exited>.  
  
 Questo metodo indica il <xref:System.Diagnostics.Process> componente attenderà una quantità limitata di tempo per la terminazione del processo. Se il processo associato viene terminato entro la fine dell'intervallo perché viene negata la richiesta di terminazione, `false` viene restituito alla routine chiamante. È possibile specificare <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> per `milliseconds`, e <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> si comporterà come il <xref:System.Diagnostics.Process.WaitForExit> rapporto di overload. Se si passa 0 (zero) per il metodo, viene restituito `true` solo se il processo è già stato terminato; in caso contrario, viene immediatamente restituito `false`.  
  
> [!NOTE]
>  Nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] e versioni precedenti, se `milliseconds` è -1, il <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload in attesa per <xref:System.Int32.MaxValue> millisecondi (circa 24 giorni), non per un periodo illimitato.  
  
 Quando l'output standard è stato reindirizzato ai gestori eventi asincroni, è possibile che l'elaborazione di output non sia completata quando questo metodo viene restituito. Per garantire che la gestione degli eventi asincroni è stata completata, chiamare il <xref:System.Diagnostics.Process.WaitForExit> overload che non accetta alcun parametro dopo avere ricevuto un `true` da questo overload. Per garantire che il <xref:System.Diagnostics.Process.Exited> evento viene gestito correttamente nelle applicazioni Windows Form, impostare il <xref:System.Diagnostics.Process.SynchronizingObject%2A> proprietà.  
  
 Quando un processo associato termina (viene chiuso dal sistema operativo mediante terminazione normale o anomala), il sistema memorizza le informazioni amministrative sul processo e restituisce al componente che ha chiamato <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. Il <xref:System.Diagnostics.Process> componente può quindi accedere alle informazioni, che include il <xref:System.Diagnostics.Process.ExitTime%2A>, utilizzando il <xref:System.Diagnostics.Process.Handle%2A> al processo terminato.  
  
 Poiché il processo associato è stato terminato, il <xref:System.Diagnostics.Process.Handle%2A> proprietà del componente non punta a una risorsa di processo esistente. Al contrario, l'handle può essere utilizzato solo per accedere alle informazioni del sistema operativo sulla risorsa di processo. Il sistema è a conoscenza di handle a processi terminati che non sono stati rilasciati da <xref:System.Diagnostics.Process> componenti, quindi conserva il <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informazioni in memoria finché il <xref:System.Diagnostics.Process> componente specificamente libera le risorse. Per questo motivo, ogni chiamata di <xref:System.Diagnostics.Process.Start%2A> per un <xref:System.Diagnostics.Process> dell'istanza, chiamare <xref:System.Diagnostics.Process.Close%2A> quando il processo associato è terminato e non è più necessario le informazioni amministrative su di esso. <xref:System.Diagnostics.Process.Close%2A> libera la memoria allocata al processo terminato.  
  
   
  
## Examples  
 Vedere l'esempio di codice per il <xref:System.Diagnostics.Process.ExitCode%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Non è stato possibile accedere all'impostazione di attesa.</exception>
        <exception cref="T:System.SystemException">Non è stato impostato alcun <see cref="P:System.Diagnostics.Process.Id" /> di processo e non è presente alcun <see cref="P:System.Diagnostics.Process.Handle" /> da cui è possibile determinare la proprietà <see cref="P:System.Diagnostics.Process.Id" />.  
  
 oppure  
  
 A questo oggetto <see cref="T:System.Diagnostics.Process" /> non è associato alcun processo.  
  
 oppure  
  
 Si sta provando a chiamare <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> per un processo in esecuzione in un computer remoto. Questo metodo è disponibile solo per i processi in esecuzione nel computer locale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Il componente <see cref="T:System.Diagnostics.Process" /> attenderà che il processo associato entri in uno stato inattivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Il componente <see cref="T:System.Diagnostics.Process" /> attenderà in modo indefinito che il processo associato entri in uno stato inattivo. Questo overload viene applicato soltanto ai processi dotati di interfaccia utente e, quindi, di un ciclo di messaggi.</summary>
        <returns>
          <see langword="true" /> se il processo associato ha raggiunto uno stato inattivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Diagnostics.Process.WaitForInputIdle> per forzare l'elaborazione dell'applicazione in attesa fino a quando non ha restituito il ciclo di messaggi di stato di inattività. Quando è in esecuzione un processo con un'interfaccia utente, il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. Restituisce quindi il processo del ciclo di messaggi. Un processo è detto in uno stato di inattività quando è in attesa per i messaggi all'interno di un ciclo di messaggi. Questo stato è utile, ad esempio, quando l'applicazione deve attendere che un processo completare la creazione corrispondente finestra principale prima che l'applicazione comunica con tale finestra.  
  
 Se un processo non dispone di un ciclo di messaggi, <xref:System.Diagnostics.Process.WaitForInputIdle> genera un <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Diagnostics.Process.WaitForInputIdle> overload indica il <xref:System.Diagnostics.Process> componente per un'attesa indefinita per il processo diventi inattivo nel ciclo di messaggi. Questa istruzione può causare un'applicazione di rispondere. Ad esempio, se il processo viene scritto per chiudere il ciclo di messaggi immediatamente, come illustrato nel frammento di codice `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il processo non ha un'interfaccia grafica.  
  
 oppure  
  
 Si è verificato un errore sconosciuto. Il processo non è riuscito a passare a uno stato di inattività.  
  
 oppure  
  
 Processo già terminato.  
  
 oppure  
  
 Nessun processo associato all'oggetto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Valore pari a 1 per <see cref="F:System.Int32.MaxValue" /> che specifica la quantità di tempo, espressa in millisecondi, in base alla quale viene atteso che il processo associato diventi inattivo. Un valore pari a 0 specifica una restituzione immediata, mentre un valore pari a -1 specifica un'attesa infinita.</param>
        <summary>Il componente <see cref="T:System.Diagnostics.Process" /> attenderà per un numero specificato di millisecondi che il processo associato entri in uno stato inattivo. Questo overload viene applicato soltanto ai processi dotati di interfaccia utente e, quindi, di un ciclo di messaggi.</summary>
        <returns>
          <see langword="true" /> se il processo associato ha raggiunto uno stato inattivo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> per forzare l'elaborazione dell'applicazione in attesa fino a quando non ha restituito il ciclo di messaggi di stato di inattività. Quando è in esecuzione un processo con un'interfaccia utente, il ciclo di messaggi viene eseguito ogni volta che viene inviato un messaggio di Windows per il processo dal sistema operativo. Restituisce quindi il processo del ciclo di messaggi. Un processo è detto in uno stato di inattività quando è in attesa per i messaggi all'interno di un ciclo di messaggi. Questo stato è utile, ad esempio, quando l'applicazione deve attendere che un processo completare la creazione corrispondente finestra principale prima che l'applicazione comunica con tale finestra.  
  
 Se un processo non dispone di un ciclo di messaggi, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> genera un <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> overload indica il <xref:System.Diagnostics.Process> componente attenderà una quantità limitata di tempo per il processo diventi inattivo nel ciclo di messaggi. Se il processo associato non è diventato inattivo entro la fine dell'intervallo perché il ciclo sta ancora elaborando i messaggi, `false` viene restituito alla routine chiamante.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il processo non ha un'interfaccia grafica.  
  
 oppure  
  
 Si è verificato un errore sconosciuto. Il processo non è riuscito a passare a uno stato di inattività.  
  
 oppure  
  
 Processo già terminato.  
  
 oppure  
  
 Nessun processo associato all'oggetto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'utilizzo di memoria fisica del processo associato, espresso in byte.</summary>
        <value>Quantità totale di memoria fisica usata dal processo associato, in byte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente del working set di memoria utilizzata dal processo, in byte. Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un'applicazione può utilizzare senza generare un errore di pagina.  
  
 Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni eseguite dal processo, inclusi i moduli di processo e le librerie di sistema.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'istanza del blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e viene visualizzato il codice di uscita del processo.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria fisica, in byte, allocata per il processo associato.</summary>
        <value>Quantità di memoria fisica, in byte, allocata per il processo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà rappresenta la dimensione corrente del working set di memoria utilizzata dal processo, in byte. Il working set di un processo è il set di pagine di memoria attualmente visibili per il processo nella memoria RAM fisica. Queste pagine sono residenti e disponibili per un'applicazione può utilizzare senza generare un errore di pagina.  
  
 Il working set include dati sia condivisi e privati. I dati condivisi sono incluse le pagine che contengono tutte le istruzioni che il processo viene eseguito, incluse le istruzioni in moduli di processo e le librerie di sistema.  
  
 Questa proprietà può essere utilizzata per monitorare l'utilizzo di memoria nei computer con processori a 32 bit o 64 bit. Il valore della proprietà è equivalente al **Working Set** contatore delle prestazioni per il processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene avviata un'istanza dell'applicazione Blocco note. Nell'esempio viene quindi recupera e Visualizza proprietà del processo associato. Nell'esempio viene rilevato al termine del processo e visualizza le statistiche di memoria punta e di codice di uscita.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma è Windows 98 o Windows Millennium Edition (Windows Me), che non supporta questa proprietà.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>